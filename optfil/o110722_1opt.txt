nop,maxfn,iprint,nloop,iquad:   938000  20  95   1
stopcr,simp:    20.0000       0.00000    
T0,Tstep:    173.736      0.500000    
Tfreq:   30
nop,maxfn,iprint,nloop,iquad:   938000  20  95   1
stopcr,simp:    20.0000       0.00000    
T0,Tstep:    173.736      0.500000    
Tfreq:   30
 Estimating   30 parameters on   1 communicators
 Progress Report every  20 function evaluations
 EVAL.   FUNC.VALUE.          PARAMETER VALUES
iter,obj,time:      2        579.12         77.44          0.97         38.34          1.50          0.04        118.29
iter,obj,time:      3        595.09         73.43          1.00         38.74          0.81          0.05        114.04
iter,obj,time:      4        542.95         73.35          1.00         38.87          0.76          0.06        114.04
iter,obj,time:      5        577.17         73.78          0.98         38.53          0.79          0.05        114.12
iter,obj,time:      6        579.12         73.28          0.98         38.94          0.55          0.05        113.81
iter,obj,time:      7        615.56         73.24          0.99         38.84          1.11          0.05        114.23
iter,obj,time:      8        543.33         73.49          0.91         38.76          0.55          0.06        113.78
iter,obj,time:      9        511.02         73.49          1.00         38.73          0.81          0.06        114.09
iter,obj,time:     10        579.12         73.29          0.99         38.78          0.92          0.05        114.03
iter,obj,time:     11        585.62         73.09          0.92         38.04          2.04          0.05        114.16
iter,obj,time:     12        584.83         73.38          0.94         38.34          1.62          0.05        114.33
iter,obj,time:     13        582.37         73.29          0.94         38.27          1.49          0.05        114.03
iter,obj,time:     14        590.73         73.43          0.98         38.82          0.79          0.05        114.08
iter,obj,time:     15        902.09         73.54          0.97         38.66          0.91          0.05        114.14
iter,obj,time:     16        672.68         73.79          1.03         38.77          0.18          0.06        113.83
iter,obj,time:     17        586.74         73.57          1.01         38.86          0.48          0.05        113.97
iter,obj,time:     18        572.08         73.71          1.02         38.59          0.58          0.05        113.95
iter,obj,time:     19        605.95         73.96          1.00         38.62          0.42          0.06        114.05
iter,obj,time:     20        578.84         73.89          1.02         38.73          0.40          0.06        114.10
iter,obj,time:     21        578.81         73.68          1.01         38.88          0.27          0.06        113.90
iter,obj,time:     22        579.09         73.53          0.98         38.56          0.92          0.06        114.05
iter,obj,time:     23        568.14         73.58          0.99         38.74          0.93          0.06        114.30
iter,obj,time:     24        579.12         73.68          1.03         38.88          0.32          0.06        113.97
iter,obj,time:     25        439.31         73.51          0.99         38.71          0.69          0.06        113.96
iter,obj,time:     26        616.46         73.46          0.98         38.72          0.71          0.06        113.93
iter,obj,time:     27        734.50         73.57          0.98         38.78          0.58          0.06        113.97
iter,obj,time:     28        582.85         73.53          0.98         38.54          1.20          0.05        114.31
iter,obj,time:     29        574.71         74.09          1.03         38.56          0.36          0.06        114.09
iter,obj,time:     30        572.89         74.19          1.04         38.44          0.44          0.04        114.15
iter,obj,time:     31        578.41         73.68          1.03         38.81          0.54          0.04        114.10
iter,obj,time:     32        572.33         73.45          0.98         38.41          1.10          0.04        113.98

    1    579.12        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

    2    595.09        3.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

    3    542.95        2.284    -0.5271      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

    4    577.17        2.284     -1.527      6.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

    5    579.12        2.284     -1.527      5.272     -99.00     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

    6    615.56        2.284     -1.527      5.272     -100.0      1.991    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

    7    543.33        2.284     -1.527      5.272     -100.0     0.9910    
                      0.4421      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

    8    511.02        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      3.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

    9    579.12        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -99.00      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   10    585.62        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      3.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   11    584.83        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      3.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   12    582.37        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       2.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   13    590.73        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518    -0.7176      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   14    902.09        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      2.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   15    672.68        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.2023E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   16    586.74        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.2023E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   17    572.08        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -3119.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   18    605.95        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.6902E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   19    578.84        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -3.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   20    578.81        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -5.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   21    579.09        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -5.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   22    568.14        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340    -0.4927    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   23    579.12        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -12.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   24    439.31        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                      -1.500     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   25    616.46        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -2.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   26    734.50        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      0.000      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   27    582.85        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      0.000      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   28    574.71        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124    -0.1408E+05  1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   29    572.89        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -9808.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   30    578.41        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                     -0.1382E+05  1.000    -0.6904    -0.2373      10.12    
                       8.459     -3546.      1.000    

   31    572.33        2.284     -1.527      5.272     -100.0     0.9910    
                     -0.5579      2.554     -100.0      2.994      2.000    
                       1.518     -1.718      1.841      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1011E+05 0.1011E+05 -1560.    -0.3451E+05
                      -2.000     -4.229     -6.401     -6.340     -1.493    
                      -13.12     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5000     -1.000      1.764      1.764      0.000    
                       0.000      9.205      9.124     -7039.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -4904.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6912.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -7092.      1.000    
 finished setting up initial simplex
 count number of function evaluations which here is neval=np1          31          31

beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    173.736                61
loop is:        1
neval is:       31


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       61
neval,tstepnext:       31      61

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.228570      -1.47591      -256.419       256.419       579.118       835.537    
   2  0.709707     -0.342904      -59.5745       59.5745       595.090       654.665    
   3  0.151889      -1.88460      -327.422       327.422       542.951       870.373    
   4  0.456170E-01  -3.08747      -536.404       536.404       577.169       1113.57    
   5  0.882557     -0.124932      -21.7051       21.7051       579.118       600.823    
   6  0.711292     -0.340672      -59.1868       59.1868       615.561       674.748    
   7  0.241669      -1.42019      -246.737       246.737       543.326       790.063    
   8  0.682871     -0.381450      -66.2714       66.2714       511.020       577.291    
   9  0.500657     -0.691834      -120.196       120.196       579.118       699.315    
  10  0.494633     -0.703939      -122.299       122.299       585.620       707.919    
  11  0.437126     -0.827535      -143.772       143.772       584.834       728.606    
  12  0.462981     -0.770069      -133.788       133.788       582.368       716.156    
  13  0.988878     -0.111840E-01  -1.94306       1.94306       590.730       592.673    
  14  0.878158     -0.129929      -22.5733       22.5733       902.089       924.663    
  15  0.825605     -0.191638      -33.2944       33.2944       672.680       705.974    
  16  0.966665     -0.339033E-01  -5.89021       5.89021       586.739       592.629    
  17  0.340930      -1.07608      -186.953       186.953       572.083       759.036    
  18  0.288920      -1.24161      -215.711       215.711       605.948       821.659    
  19  0.442843     -0.814539      -141.514       141.514       578.844       720.359    
  20  0.878635     -0.129386      -22.4789       22.4789       578.811       601.290    
  21  0.198777E-01  -3.91816      -680.723       680.723       579.091       1259.81    
  22  0.315829      -1.15255      -200.239       200.239       568.142       768.382    
  23  0.208690      -1.56690      -272.227       272.227       579.118       851.345    
  24  0.849393     -0.163234      -28.3595       28.3595       439.306       467.666    
  25  0.945818     -0.557056E-01  -9.67804       9.67804       616.461       626.139    
  26  0.567839     -0.565917      -98.3199       98.3199       734.498       832.818    
  27  0.718388     -0.330745      -57.4622       57.4622       582.846       640.308    
  28  0.115406      -2.15930      -375.147       375.147       574.710       949.856    
  29  0.659869E-01  -2.71830      -472.265       472.265       572.886       1045.15    
  30  0.171393      -1.76380      -306.434       306.434       578.414       884.848    
  31  0.161953      -1.82045      -316.277       316.277       572.329       888.606    
loop,thermsimp(1:2)        1   256.419       59.5745    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     33        539.25         73.36          0.98         38.38          1.12          0.04        113.88
Just calling func    0   0        113.88


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    539.25
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    173.736                61
loop is:        1
neval is:       32
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        1      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    173.736                61
loop is:        2
neval is:       32


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       61
neval,tstepnext:       32      61

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.352733      -1.04204      -181.040       181.040       439.306       620.346    
   2  0.440787     -0.819193      -142.323       142.323       511.020       653.343    
   3  0.685789     -0.377185      -65.5305       65.5305       586.739       652.269    
   4  0.673104     -0.395856      -68.7743       68.7743       590.730       659.504    
   5  0.655536     -0.422301      -73.3688       73.3688       579.118       652.487    
   6  0.422838     -0.860766      -149.546       149.546       578.811       728.357    
   7  0.300870      -1.20108      -208.670       208.670       616.461       825.130    
   8  0.776987     -0.252331      -43.8389       43.8389       582.846       626.685    
   9  0.170551      -1.76872      -307.289       307.289       595.090       902.380    
  10  0.587497     -0.531884      -92.4072       92.4072       615.561       707.968    
  11  0.250425      -1.38459      -240.553       240.553       579.118       819.672    
  12  0.776362E-01  -2.55572      -444.020       444.020       672.680       1116.70    
  13  0.766647     -0.265729      -46.1666       46.1666       585.620       631.787    
  14  0.480193     -0.733568      -127.447       127.447       582.368       709.815    
  15  0.434643     -0.833231      -144.762       144.762       578.844       723.606    
  16  0.815924E-01  -2.50602      -435.385       435.385       584.834       1020.22    
  17  0.724257E-01  -2.62519      -456.089       456.089       572.083       1028.17    
  18  0.573795     -0.555483      -96.5071       96.5071       568.142       664.649    
  19  0.196096      -1.62915      -283.041       283.041       543.326       826.367    
  20  0.240673      -1.42432      -247.454       247.454       605.948       853.402    
  21  0.194228      -1.63872      -284.704       284.704       734.498       1019.20    
  22  0.236387      -1.44229      -250.576       250.576       579.118       829.695    
  23  0.261662      -1.34070      -232.927       232.927       579.118       812.046    
  24  0.146321      -1.92195      -333.912       333.912       542.951       876.862    
  25  0.169637      -1.77410      -308.224       308.224       578.414       886.637    
  26  0.886717     -0.120229      -20.8881       20.8881       572.329       593.217    
  27  0.253412      -1.37274      -238.494       238.494       902.089       1140.58    
  28  0.470820     -0.753279      -130.871       130.871       574.710       705.581    
  29  0.329871      -1.10905      -192.682       192.682       572.886       765.568    
  30  0.726784     -0.319126      -55.4435       55.4435       577.169       632.612    
  31  0.612351     -0.490450      -85.2087       85.2087       539.254       624.463    
loop,thermsimp(1:2)        2   181.040       142.323    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     34        762.53         73.47          0.99         38.48          1.13          0.04        114.11
Just calling func    0   0        114.11


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     35       1929.92         73.42          1.00         38.37          1.34          0.04        114.17
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    762.53
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    173.736                61
loop is:        2
neval is:       34
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        2      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    173.736                61
loop is:        3
neval is:       34


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       61
neval,tstepnext:       34      61

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.167898      -1.78440      -310.014       310.014       572.329       882.343    
   2  0.274399      -1.29317      -224.670       224.670       439.306       663.976    
   3  0.597410E-01  -2.81774      -489.541       489.541       539.254       1028.80    
   4  0.283115E-01  -3.56449      -619.278       619.278       582.846       1202.12    
   5  0.901069     -0.104174      -18.0987       18.0987       585.620       603.719    
   6  0.717939     -0.331371      -57.5709       57.5709       577.169       634.740    
   7  0.294866      -1.22123      -212.172       212.172       586.739       798.910    
   8  0.935651     -0.665127E-01  -11.5556       11.5556       579.118       590.674    
   9  0.314362      -1.15721      -201.049       201.049       511.020       712.069    
  10  0.807729     -0.213529      -37.0976       37.0976       590.730       627.827    
  11  0.757191     -0.278140      -48.3228       48.3228       568.142       616.465    
  12  0.508654     -0.675987      -117.443       117.443       574.710       692.153    
  13  0.722060     -0.325647      -56.5764       56.5764       615.561       672.137    
  14  0.424032     -0.857947      -149.056       149.056       582.368       731.424    
  15  0.786154     -0.240602      -41.8012       41.8012       578.844       620.645    
  16  0.399894     -0.916557      -159.238       159.238       578.811       738.049    
  17  0.757416     -0.277843      -48.2712       48.2712       572.886       621.157    
  18  0.637270     -0.450563      -78.2787       78.2787       579.118       657.397    
  19  0.586055     -0.534342      -92.8342       92.8342       579.118       671.953    
  20  0.821724     -0.196351      -34.1132       34.1132       616.461       650.574    
  21  0.921558     -0.816897E-01  -14.1924       14.1924       543.326       557.519    
  22  0.985596     -0.145083E-01  -2.52061       2.52061       579.118       581.639    
  23  0.257194      -1.35793      -235.920       235.920       605.948       841.867    
  24  0.921438E-01  -2.38440      -414.256       414.256       542.951       957.207    
  25  0.114653      -2.16584      -376.284       376.284       578.414       954.698    
  26  0.379827     -0.968040      -168.183       168.183       595.090       763.273    
  27  0.541451     -0.613503      -106.587       106.587       734.498       841.086    
  28  0.544274     -0.608302      -105.684       105.684       584.834       690.517    
  29  0.934365     -0.678883E-01  -11.7946       11.7946       572.083       583.878    
  30  0.266419E-01  -3.62527      -629.838       629.838       672.680       1302.52    
  31  0.919572     -0.838466E-01  -14.5671       14.5671       762.529       777.096    
loop,thermsimp(1:2)        3   310.014       224.670    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     36       1113.57         73.67          1.03         38.85          0.61          0.05        114.21
Just calling func    0   0        114.21


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2   1113.57
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    173.736                61
loop is:        3
neval is:       35
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        3      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    173.736                61
loop is:        4
neval is:       35


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       61
neval,tstepnext:       35      61

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.883237     -0.124162      -21.5713       21.5713       543.326       564.898    
   2  0.114178      -2.16999      -377.005       377.005       579.118       956.123    
   3  0.217017      -1.52778      -265.429       265.429       572.083       837.513    
   4  0.138317      -1.97821      -343.685       343.685       579.118       922.803    
   5  0.832728     -0.183048      -31.8019       31.8019       585.620       617.422    
   6  0.390825     -0.939496      -163.224       163.224       568.142       731.366    
   7  0.283633      -1.26007      -218.920       218.920       578.844       797.764    
   8  0.725809     -0.320468      -55.6767       55.6767       572.886       628.563    
   9  0.506121     -0.680979      -118.310       118.310       590.730       709.040    
  10  0.216234      -1.53139      -266.057       266.057       577.169       843.226    
  11  0.637942     -0.449509      -78.0956       78.0956       616.461       694.556    
  12  0.536707     -0.622302      -108.116       108.116       579.118       687.234    
  13  0.231844      -1.46169      -253.948       253.948       439.306       693.254    
  14  0.491379     -0.710540      -123.446       123.446       579.118       702.564    
  15  0.825774     -0.191434      -33.2589       33.2589       615.561       648.820    
  16  0.671593     -0.398102      -69.1645       69.1645       584.834       653.998    
  17  0.549103     -0.599470      -104.149       104.149       574.710       678.859    
  18  0.659287     -0.416597      -72.3777       72.3777       511.020       583.398    
  19  0.205012      -1.58469      -275.316       275.316       582.368       857.684    
  20  0.400541E-02  -5.52011      -959.039       959.039       578.811       1537.85    
  21  0.750831     -0.286575      -49.7882       49.7882       595.090       644.879    
  22  0.619921     -0.478162      -83.0738       83.0738       762.529       845.603    
  23  0.435226     -0.831889      -144.529       144.529       586.739       731.267    
  24  0.460974     -0.774414      -134.543       134.543       734.498       869.042    
  25  0.891582E-01  -2.41734      -419.978       419.978       605.948       1025.93    
  26  0.589618E-01  -2.83087      -491.822       491.822       572.329       1064.15    
  27  0.541391     -0.613613      -106.606       106.606       578.414       685.020    
  28  0.545108E-01  -2.90936      -505.458       505.458       542.951       1048.41    
  29  0.744722     -0.294744      -51.2075       51.2075       539.254       590.462    
  30  0.712477     -0.339008      -58.8977       58.8977       582.846       641.744    
  31  0.563836     -0.572992      -99.5490       99.5490       1113.57       1213.12    
loop,thermsimp(1:2)        4   21.5713       377.005    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     37        509.20         73.52          1.02         38.78          0.74          0.04        114.11
Just calling func    0   0        114.11


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     38        488.67         74.64          1.11         38.24          0.19          0.05        114.22
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    488.67
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    173.736                61
loop is:        4
neval is:       37
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        4      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    173.736                61
loop is:        5
neval is:       37


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       61
neval,tstepnext:       37      61

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.968189     -0.323278E-01  -5.61649       5.61649       543.326       548.943    
   2  0.384676     -0.955353      -165.979       165.979       511.020       676.999    
   3  0.472770     -0.749146      -130.153       130.153       539.254       669.408    
   4  0.131186      -2.03114      -352.880       352.880       585.620       938.501    
   5  0.387497     -0.948046      -164.709       164.709       572.886       737.595    
   6  0.474858     -0.744739      -129.388       129.388       582.846       712.234    
   7  0.654056     -0.424563      -73.7616       73.7616       595.090       668.852    
   8  0.375266     -0.980119      -170.281       170.281       615.561       785.843    
   9  0.605577     -0.501574      -87.1412       87.1412       584.834       671.975    
  10  0.485605     -0.722360      -125.500       125.500       574.710       700.209    
  11  0.503843     -0.685490      -119.094       119.094       578.414       697.508    
  12  0.374521     -0.982108      -170.627       170.627       579.118       749.745    
  13  0.955542E-01  -2.34806      -407.942       407.942       439.306       847.248    
  14  0.902567     -0.102512      -17.8100       17.8100       616.461       634.271    
  15  0.347215      -1.05781      -183.779       183.779       579.118       762.898    
  16  0.893138     -0.113014      -19.6346       19.6346       590.730       610.364    
  17  0.561145     -0.577776      -100.380       100.380       586.739       687.119    
  18  0.667287     -0.404536      -70.2822       70.2822       568.142       638.424    
  19  0.601102     -0.508991      -88.4298       88.4298       578.844       667.274    
  20  0.569928     -0.562245      -97.6819       97.6819       572.083       669.765    
  21  0.655926     -0.421708      -73.2656       73.2656       577.169       650.435    
  22  0.355892      -1.03313      -179.491       179.491       762.529       942.020    
  23  0.208013      -1.57015      -272.791       272.791       582.368       855.159    
  24  0.879772     -0.128093      -22.2543       22.2543       734.498       756.753    
  25  0.114206E-01  -4.47233      -777.003       777.003       579.118       1356.12    
  26  0.950245     -0.510357E-01  -8.86671       8.86671       579.118       587.985    
  27  0.321268      -1.13548      -197.273       197.273       605.948       803.221    
  28  0.379005     -0.970207      -168.559       168.559       542.951       711.510    
  29  0.117960      -2.13741      -371.344       371.344       572.329       943.674    
  30  0.822558     -0.195337      -33.9369       33.9369       1113.57       1147.51    
  31  0.671085     -0.398860      -69.2962       69.2962       488.675       557.971    
loop,thermsimp(1:2)        5   5.61649       165.979    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     39        510.97         73.51          1.02         38.69          0.84          0.04        114.10
Just calling func    0   0        114.10


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     40        493.23         73.93          1.05         38.59          0.55          0.06        114.18
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    493.23
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    173.736                61
loop is:        5
neval is:       39
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        5      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    173.736                61
loop is:        6
neval is:       39


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       61
neval,tstepnext:       39      61

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.806234     -0.215382      -37.4195       37.4195       543.326       580.746    
   2  0.337878      -1.08507      -188.515       188.515       488.675       677.190    
   3  0.930612     -0.719127E-01  -12.4938       12.4938       579.118       591.612    
   4  0.843645     -0.170024      -29.5392       29.5392       590.730       620.269    
   5  0.757799     -0.277337      -48.1832       48.1832       616.461       664.644    
   6  0.627925     -0.465335      -80.8453       80.8453       568.142       648.987    
   7  0.412314     -0.885971      -153.925       153.925       577.169       731.094    
   8  0.282274      -1.26488      -219.754       219.754       578.844       798.598    
   9  0.426609E-01  -3.15447      -548.044       548.044       595.090       1143.13    
  10  0.484876     -0.723862      -125.760       125.760       539.254       665.015    
  11  0.372210     -0.988296      -171.702       171.702       572.083       743.786    
  12  0.740507     -0.300421      -52.1938       52.1938       584.834       637.027    
  13  0.361519      -1.01744      -176.766       176.766       511.020       687.786    
  14  0.421034     -0.865042      -150.289       150.289       586.739       737.027    
  15  0.780595     -0.247699      -43.0342       43.0342       578.414       621.448    
  16  0.758410     -0.276531      -48.0432       48.0432       574.710       622.753    
  17  0.522921E-01  -2.95091      -512.678       512.678       542.951       1055.63    
  18  0.609673     -0.494833      -85.9701       85.9701       582.846       668.816    
  19  0.204029      -1.58949      -276.151       276.151       572.886       849.037    
  20  0.516385     -0.660902      -114.822       114.822       579.118       693.941    
  21  0.323918      -1.12726      -195.846       195.846       734.498       930.344    
  22  0.671820     -0.397765      -69.1060       69.1060       579.118       648.224    
  23  0.850344     -0.162114      -28.1649       28.1649       615.561       643.726    
  24  0.515631     -0.662364      -115.076       115.076       605.948       721.024    
  25  0.919408     -0.840249E-01  -14.5981       14.5981       439.306       453.904    
  26  0.516519     -0.660643      -114.777       114.777       582.368       697.145    
  27  0.986900     -0.131869E-01  -2.29103       2.29103       585.620       587.911    
  28  0.127351      -2.06081      -358.036       358.036       762.529       1120.56    
  29  0.775028E-01  -2.55744      -444.318       444.318       572.329       1016.65    
  30  0.778307     -0.250634      -43.5440       43.5440       1113.57       1157.11    
  31  0.548570     -0.600441      -104.318       104.318       493.234       597.552    
loop,thermsimp(1:2)        6   37.4195       188.515    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     41        626.71         73.63          0.99         38.76          0.86          0.06        114.29
Just calling func    0   0        114.29


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     42        746.76         73.48          1.00         38.86          0.62          0.06        114.01
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

   40    626.71        2.307     -1.504      5.295     -100.3      1.014    
                     -0.5349      2.577     -99.98      3.017      2.023    
                       1.541     -1.695      1.822      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.2006E+05 0.1035E+05 -1596.    -0.3531E+05
                      -2.000     -4.206     -6.690     -6.362     -1.470    
                      -13.09     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.5230     -1.023      1.724      1.724      0.000    
                       0.000      9.205      9.124     -7201.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -5017.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -7071.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3628.      1.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    626.71
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    173.736                61
loop is:        6
neval is:       41
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        6      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    173.736                61
loop is:        7
neval is:       41


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       61
neval,tstepnext:       41      61

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.117714      -2.13949      -371.706       371.706       439.306       811.012    
   2  0.421875     -0.863045      -149.942       149.942       543.326       693.268    
   3  0.700103     -0.356528      -61.9417       61.9417       585.620       647.562    
   4  0.209367      -1.56367      -271.664       271.664       579.118       850.783    
   5  0.117251      -2.14344      -372.391       372.391       493.234       865.625    
   6  0.898330     -0.107218      -18.6275       18.6275       590.730       609.357    
   7  0.209806      -1.56157      -271.301       271.301       578.414       849.714    
   8  0.917155     -0.864790E-01  -15.0245       15.0245       574.710       589.734    
   9  0.120514E-01  -4.41857      -767.663       767.663       584.834       1352.50    
  10  0.189983      -1.66082      -288.544       288.544       615.561       904.105    
  11  0.257131      -1.35817      -235.962       235.962       579.118       815.080    
  12  0.913158E-01  -2.39343      -415.824       415.824       568.142       983.966    
  13  0.336531      -1.08906      -189.209       189.209       616.461       805.670    
  14  0.318351      -1.14460      -198.858       198.858       539.254       738.112    
  15  0.919606     -0.838101E-01  -14.5608       14.5608       582.846       597.407    
  16  0.719771E-01  -2.63141      -457.169       457.169       488.675       945.844    
  17  0.788730E-01  -2.53992      -441.274       441.274       511.020       952.294    
  18  0.905929     -0.987941E-01  -17.1640       17.1640       579.118       596.282    
  19  0.665501     -0.407215      -70.7478       70.7478       582.368       653.116    
  20  0.812159     -0.208059      -36.1473       36.1473       605.948       642.095    
  21  0.412726E-01  -3.18756      -553.792       553.792       577.169       1130.96    
  22  0.256064      -1.36233      -236.685       236.685       586.739       823.423    
  23  0.277519      -1.28187      -222.706       222.706       572.083       794.789    
  24  0.279550      -1.27457      -221.439       221.439       578.844       800.283    
  25  0.857884     -0.153286      -26.6313       26.6313       572.886       599.517    
  26  0.205158      -1.58398      -275.193       275.193       734.498       1009.69    
  27  0.482085     -0.729635      -126.764       126.764       572.329       699.093    
  28  0.494966E-01  -3.00585      -522.223       522.223       542.951       1065.17    
  29  0.338791      -1.08237      -188.047       188.047       762.529       950.576    
  30  0.249491E-01  -3.69092      -641.243       641.243       595.090       1236.33    
  31  0.480710     -0.732491      -127.260       127.260       626.714       753.974    
loop,thermsimp(1:2)        7   371.706       149.942    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     43        499.70         73.35          0.99         39.02          0.70          0.06        114.12
Just calling func    0   0        114.12


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     44        535.27         73.36          1.00         39.10          0.37          0.06        113.89
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    499.70
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    173.736                61
loop is:        7
neval is:       43
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        7      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    173.736                61
loop is:        8
neval is:       43


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       61
neval,tstepnext:       43      61

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.487401     -0.718668      -124.858       124.858       574.710       699.568    
   2  0.568497     -0.564760      -98.1189       98.1189       579.118       677.237    
   3  0.632037E-01  -2.76139      -479.752       479.752       582.846       1062.60    
   4  0.184325      -1.69105      -293.796       293.796       572.886       866.682    
   5  0.949772     -0.515332E-01  -8.95314       8.95314       590.730       599.683    
   6  0.512179     -0.669081      -116.243       116.243       605.948       722.191    
   7  0.573767     -0.555532      -96.5156       96.5156       585.620       682.136    
   8  0.590189     -0.527312      -91.6128       91.6128       582.368       673.981    
   9  0.323917      -1.12727      -195.847       195.847       543.326       739.173    
  10  0.246420E-01  -3.70330      -643.395       643.395       572.329       1215.72    
  11  0.923153E-01  -2.38255      -413.933       413.933       539.254       953.187    
  12  0.236043      -1.44374      -250.829       250.829       626.714       877.543    
  13  0.885388     -0.121730      -21.1487       21.1487       572.083       593.232    
  14  0.617726     -0.481710      -83.6901       83.6901       578.844       662.534    
  15  0.349992      -1.04985      -182.395       182.395       616.461       798.856    
  16  0.892028     -0.114257      -19.8506       19.8506       439.306       459.157    
  17  0.382423     -0.961227      -166.999       166.999       579.118       746.118    
  18  0.850527     -0.161899      -28.1277       28.1277       586.739       614.866    
  19  0.653461     -0.425472      -73.9196       73.9196       578.414       652.333    
  20  0.413959     -0.881988      -153.233       153.233       579.118       732.351    
  21  0.807813     -0.213424      -37.0794       37.0794       493.234       530.313    
  22  0.348045      -1.05542      -183.365       183.365       615.561       798.926    
  23  0.435267     -0.831795      -144.512       144.512       488.675       633.187    
  24  0.434284     -0.834056      -144.905       144.905       762.529       907.434    
  25  0.983564     -0.165728E-01  -2.87929       2.87929       511.020       513.899    
  26  0.545923     -0.605277      -105.158       105.158       568.142       673.300    
  27  0.227140      -1.48219      -257.509       257.509       734.498       992.007    
  28  0.965085     -0.355395E-01  -6.17448       6.17448       542.951       549.125    
  29  0.183882      -1.69346      -294.214       294.214       577.169       871.383    
  30  0.187300E-02  -6.28022      -1091.10       1091.10       595.090       1686.19    
  31  0.428736     -0.846914      -147.139       147.139       499.703       646.842    
loop,thermsimp(1:2)        8   124.858       98.1189    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     45        480.51         73.51          1.02         38.98          0.75          0.06        114.30
Just calling func    0   0        114.30


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    480.51
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    173.736                61
loop is:        8
neval is:       44
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        8      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    173.736                61
loop is:        9
neval is:       44


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       61
neval,tstepnext:       44      61

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.878288E-01  -2.43237      -422.588       422.588       439.306       861.895    
   2  0.192227      -1.64908      -286.504       286.504       511.020       797.524    
   3  0.872733     -0.136126      -23.6499       23.6499       493.234       516.884    
   4  0.444113     -0.811675      -141.017       141.017       542.951       683.968    
   5  0.194382      -1.63793      -284.567       284.567       572.083       856.650    
   6  0.358074      -1.02702      -178.429       178.429       590.730       769.159    
   7  0.461693     -0.772855      -134.272       134.272       586.739       721.011    
   8  0.180202      -1.71368      -297.727       297.727       488.675       786.401    
   9  0.944954     -0.566187E-01  -9.83669       9.83669       499.703       509.539    
  10  0.738770     -0.302769      -52.6017       52.6017       578.414       631.015    
  11  0.822491E-01  -2.49800      -433.992       433.992       578.844       1012.84    
  12  0.313602      -1.15963      -201.469       201.469       568.142       769.611    
  13  0.978185     -0.220567E-01  -3.83203       3.83203       582.368       586.200    
  14  0.540591E-01  -2.91768      -506.904       506.904       579.118       1086.02    
  15  0.872885     -0.135951      -23.6195       23.6195       585.620       609.240    
  16  0.209079      -1.56504      -271.903       271.903       574.710       846.613    
  17  0.789205E-01  -2.53931      -441.169       441.169       605.948       1047.12    
  18  0.746404     -0.292489      -50.8157       50.8157       579.118       629.934    
  19  0.110219      -2.20529      -383.137       383.137       543.326       926.463    
  20  0.656016     -0.421570      -73.2416       73.2416       579.118       652.360    
  21  0.665675     -0.406953      -70.7022       70.7022       616.461       687.163    
  22  0.563292     -0.573957      -99.7166       99.7166       615.561       715.278    
  23  0.615044     -0.486062      -84.4462       84.4462       572.886       657.332    
  24  0.128081      -2.05509      -357.042       357.042       577.169       934.211    
  25  0.459916     -0.776711      -134.942       134.942       626.714       761.656    
  26  0.433297     -0.836332      -145.301       145.301       762.529       907.830    
  27  0.225675      -1.48866      -258.633       258.633       539.254       797.887    
  28  0.808805     -0.212197      -36.8662       36.8662       734.498       771.365    
  29  0.578238     -0.547770      -95.1670       95.1670       582.846       678.013    
  30  0.569572     -0.562871      -97.7906       97.7906       572.329       670.120    
  31  0.291272      -1.23350      -214.302       214.302       480.507       694.809    
loop,thermsimp(1:2)        9   422.588       286.504    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     46        489.23         73.48          0.99         39.09          0.44          0.06        114.06
Just calling func    0   0        114.06


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     47        475.44         74.41          1.08         38.29          0.00          0.05        113.83
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    475.44
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    173.736                61
loop is:        9
neval is:       46
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        9      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    173.736                61
loop is:       10
neval is:       46


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       61
neval,tstepnext:       46      61

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.611807     -0.491339      -85.3631       85.3631       499.703       585.066    
   2  0.877337     -0.130865      -22.7358       22.7358       493.234       515.970    
   3  0.821280     -0.196891      -34.2070       34.2070       582.368       616.575    
   4  0.989636     -0.104181E-01  -1.80999       1.80999       585.620       587.430    
   5  0.492813     -0.707625      -122.940       122.940       579.118       702.058    
   6  0.904083     -0.100835      -17.5186       17.5186       578.414       595.932    
   7  0.490620     -0.712086      -123.715       123.715       579.118       702.833    
   8  0.572439     -0.557850      -96.9183       96.9183       572.886       669.804    
   9  0.588753     -0.529749      -92.0363       92.0363       572.329       664.366    
  10  0.341799      -1.07353      -186.511       186.511       582.846       769.357    
  11  0.449605     -0.799385      -138.882       138.882       542.951       681.832    
  12  0.740720     -0.300132      -52.1436       52.1436       616.461       668.604    
  13  0.173164E-01  -4.05610      -704.689       704.689       480.507       1185.20    
  14  0.828389     -0.188272      -32.7095       32.7095       615.561       648.271    
  15  0.110451      -2.20318      -382.771       382.771       586.739       969.510    
  16  0.646816     -0.435693      -75.6954       75.6954       626.714       702.409    
  17  0.857676     -0.153529      -26.6734       26.6734       590.730       617.403    
  18  0.691202E-02  -4.97449      -864.246       864.246       568.142       1432.39    
  19  0.530885     -0.633210      -110.011       110.011       734.498       844.510    
  20  0.742957     -0.297117      -51.6199       51.6199       488.675       540.295    
  21  0.883526E-01  -2.42642      -421.555       421.555       511.020       932.575    
  22  0.599138     -0.512263      -88.9982       88.9982       539.254       628.253    
  23  0.476407     -0.741482      -128.822       128.822       574.710       703.531    
  24  0.509994E-01  -2.97594      -517.027       517.027       572.083       1089.11    
  25  0.669768     -0.400824      -69.6374       69.6374       439.306       508.944    
  26  0.874430     -0.134183      -23.3123       23.3123       762.529       785.842    
  27  0.830739     -0.185440      -32.2174       32.2174       543.326       575.544    
  28  0.166673      -1.79172      -311.286       311.286       577.169       888.455    
  29  0.578742     -0.546898      -95.0156       95.0156       578.844       673.860    
  30  0.433531     -0.835791      -145.207       145.207       605.948       751.154    
  31  0.979127     -0.210935E-01  -3.66469       3.66469       475.440       479.105    
loop,thermsimp(1:2)       10   85.3631       22.7358    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     48        496.52         73.35          1.01         38.42          1.13          0.05        113.97
Just calling func    0   0        113.97


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     49        484.30         73.35          1.00         38.54          1.16          0.05        114.10
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    484.30
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    173.736                61
loop is:       10
neval is:       48
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       10      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    173.736                61
loop is:       11
neval is:       48


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       61
neval,tstepnext:       48      61

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.356780      -1.03064      -179.058       179.058       475.440       654.499    
   2  0.318207      -1.14505      -198.937       198.937       439.306       638.243    
   3  0.410972E-01  -3.19181      -554.532       554.532       493.234       1047.77    
   4  0.217948      -1.52350      -264.685       264.685       488.675       753.360    
   5  0.460755     -0.774888      -134.626       134.626       543.326       677.952    
   6  0.694214     -0.364975      -63.4091       63.4091       499.703       563.112    
   7  0.237764      -1.43648      -249.567       249.567       585.620       835.187    
   8  0.635477     -0.453379      -78.7680       78.7680       578.414       657.182    
   9  0.882831E-01  -2.42721      -421.692       421.692       582.368       1004.06    
  10  0.889613     -0.116969      -20.3216       20.3216       590.730       611.051    
  11  0.236395      -1.44225      -250.570       250.570       539.254       789.825    
  12  0.785560     -0.241359      -41.9326       41.9326       615.561       657.494    
  13  0.253594      -1.37202      -238.369       238.369       572.329       810.698    
  14  0.767743     -0.264300      -45.9184       45.9184       616.461       662.379    
  15  0.425111     -0.855405      -148.614       148.614       572.886       721.500    
  16  0.334680E-01  -3.39717      -590.208       590.208       578.844       1169.05    
  17  0.737903     -0.303943      -52.8057       52.8057       542.951       595.756    
  18  0.530906     -0.633170      -110.004       110.004       579.118       689.123    
  19  0.811772     -0.208536      -36.2301       36.2301       626.714       662.944    
  20  0.781494     -0.246548      -42.8342       42.8342       579.118       621.953    
  21  0.668871     -0.402164      -69.8702       69.8702       574.710       644.580    
  22  0.609633     -0.494898      -85.9813       85.9813       605.948       691.929    
  23  0.732795E-01  -2.61347      -454.053       454.053       582.846       1036.90    
  24  0.999755     -0.244962E-03 -0.425586E-01  0.425586E-01   762.529       762.572    
  25  0.556911     -0.585350      -101.696       101.696       734.498       836.195    
  26  0.381942     -0.962485      -167.218       167.218       577.169       744.387    
  27  0.230973      -1.46546      -254.602       254.602       511.020       765.622    
  28  0.791084     -0.234351      -40.7152       40.7152       586.739       627.454    
  29  0.122039      -2.10341      -365.438       365.438       572.083       937.521    
  30  0.411383     -0.888231      -154.317       154.317       480.507       634.824    
  31  0.753656     -0.282819      -49.1357       49.1357       484.301       533.436    
loop,thermsimp(1:2)       11   179.058       198.937    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     50        493.46         73.50          1.01         38.73          0.73          0.05        114.02
Just calling func    0   0        114.02


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     51        475.87         73.31          0.99         39.00          0.47          0.06        113.83
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    475.87
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    173.736                61
loop is:       11
neval is:       50
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       11      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    173.736                61
loop is:       12
neval is:       50


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       61
neval,tstepnext:       50      61

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.759790E-01  -2.57730      -447.768       447.768       484.301       932.069    
   2  0.804470     -0.217571      -37.7998       37.7998       499.703       537.503    
   3  0.984017     -0.161120E-01  -2.79923       2.79923       542.951       545.750    
   4  0.587639     -0.531643      -92.3652       92.3652       590.730       683.095    
   5  0.523810     -0.646626      -112.342       112.342       579.118       691.460    
   6  0.930607     -0.719181E-01  -12.4947       12.4947       586.739       599.233    
   7  0.360114E-01  -3.32392      -577.483       577.483       480.507       1057.99    
   8  0.963815     -0.368556E-01  -6.40312       6.40312       439.306       445.709    
   9  0.201264E-01  -3.90572      -678.563       678.563       574.710       1253.27    
  10  0.954897     -0.461522E-01  -8.01828       8.01828       475.440       483.459    
  11  0.374160     -0.983071      -170.794       170.794       578.414       749.208    
  12  0.174967      -1.74316      -302.848       302.848       615.561       918.409    
  13  0.381618     -0.963335      -167.365       167.365       616.461       783.826    
  14  0.191097      -1.65498      -287.528       287.528       626.714       914.242    
  15  0.425287     -0.854991      -148.542       148.542       543.326       691.869    
  16  0.426180     -0.852893      -148.178       148.178       579.118       727.296    
  17  0.615671     -0.485042      -84.2690       84.2690       605.948       690.217    
  18  0.787264     -0.239192      -41.5561       41.5561       572.886       614.442    
  19  0.812636     -0.207472      -36.0453       36.0453       577.169       613.214    
  20  0.917241E-01  -2.38897      -415.049       415.049       488.675       903.724    
  21  0.671310     -0.398525      -69.2379       69.2379       762.529       831.767    
  22  0.548174     -0.601162      -104.443       104.443       511.020       615.463    
  23  0.134851      -2.00359      -348.094       348.094       539.254       887.348    
  24  0.373236     -0.985545      -171.224       171.224       572.329       743.554    
  25  0.578774     -0.546843      -95.0061       95.0061       585.620       680.626    
  26  0.910021     -0.942872E-01  -16.3810       16.3810       734.498       750.879    
  27  0.192323      -1.64858      -286.417       286.417       572.083       858.500    
  28  0.366342      -1.00419      -174.463       174.463       582.368       756.831    
  29  0.686994     -0.375430      -65.2255       65.2255       582.846       648.072    
  30  0.486551     -0.720414      -125.162       125.162       493.234       618.396    
  31  0.256801      -1.35945      -236.185       236.185       475.875       712.060    
loop,thermsimp(1:2)       12   447.768       37.7998    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     52        475.57         73.82          1.05         38.82          0.12          0.06        113.87
Just calling func    0   0        113.87


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     53        384.61         73.62          1.02         38.78          0.10          0.06        113.57
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    384.61
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    173.736                61
loop is:       12
neval is:       52
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       12      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    173.736                61
loop is:       13
neval is:       52


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       61
neval,tstepnext:       52      61

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.872435     -0.136467      -23.7091       23.7091       439.306       463.015    
   2  0.311340      -1.16687      -202.727       202.727       475.440       678.167    
   3  0.293828      -1.22476      -212.784       212.784       499.703       712.487    
   4  0.586668     -0.533296      -92.6525       92.6525       542.951       635.603    
   5  0.360311      -1.02079      -177.347       177.347       586.739       764.086    
   6  0.315643      -1.15314      -200.342       200.342       577.169       777.511    
   7  0.481464     -0.730923      -126.987       126.987       572.886       699.873    
   8  0.720279     -0.328116      -57.0055       57.0055       511.020       568.026    
   9  0.551471     -0.595166      -103.401       103.401       493.234       596.635    
  10  0.524434     -0.645435      -112.135       112.135       582.846       694.981    
  11  0.781600     -0.246412      -42.8105       42.8105       585.620       628.431    
  12  0.353648      -1.03945      -180.590       180.590       590.730       771.320    
  13  0.451044     -0.796190      -138.327       138.327       605.948       744.274    
  14  0.325353      -1.12284      -195.078       195.078       579.118       774.196    
  15  0.312157      -1.16425      -202.271       202.271       543.326       745.597    
  16  0.432418     -0.838362      -145.653       145.653       475.875       621.528    
  17  0.296543      -1.21556      -211.186       211.186       579.118       790.305    
  18  0.705416     -0.348967      -60.6280       60.6280       572.329       632.957    
  19  0.146505      -1.92069      -333.693       333.693       578.414       912.106    
  20  0.471608     -0.751607      -130.581       130.581       734.498       865.079    
  21  0.633095     -0.457134      -79.4205       79.4205       582.368       661.788    
  22  0.754855     -0.281230      -48.8597       48.8597       616.461       665.320    
  23  0.444501E-01  -3.11339      -540.906       540.906       762.529       1303.44    
  24  0.160973      -1.82652      -317.331       317.331       572.083       889.414    
  25  0.943694     -0.579536E-01  -10.0686       10.0686       539.254       549.323    
  26  0.187304      -1.67502      -291.011       291.011       488.675       779.686    
  27  0.840922     -0.173257      -30.1008       30.1008       626.714       656.815    
  28  0.888648     -0.118054      -20.5101       20.5101       615.561       636.071    
  29  0.920614E-01  -2.38530      -414.411       414.411       484.301       898.712    
  30  0.906493     -0.981722E-01  -17.0560       17.0560       480.507       497.563    
  31  0.221761      -1.50616      -261.673       261.673       384.612       646.285    
loop,thermsimp(1:2)       13   23.7091       202.727    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     54        831.50         73.49          0.97         38.93          0.63          0.05        114.08
Just calling func    0   0        114.08


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    831.50
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    173.736                61
loop is:       13
neval is:       53
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       13      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    173.736                61
loop is:       14
neval is:       53


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       61
neval,tstepnext:       53      61

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.344597      -1.06538      -185.094       185.094       439.306       624.400    
   2  0.267720      -1.31781      -228.951       228.951       480.507       709.458    
   3  0.279825      -1.27359      -221.268       221.268       539.254       760.522    
   4  0.281095      -1.26906      -220.481       220.481       511.020       731.501    
   5  0.245867      -1.40297      -243.745       243.745       493.234       736.979    
   6  0.914239     -0.896636E-01  -15.5777       15.5777       475.875       491.452    
   7  0.180116      -1.71415      -297.810       297.810       585.620       883.430    
   8  0.567917     -0.565780      -98.2962       98.2962       572.329       670.625    
   9  0.431941     -0.839465      -145.845       145.845       542.951       688.796    
  10  0.877920     -0.130199      -22.6203       22.6203       615.561       638.181    
  11  0.280355      -1.27170      -220.939       220.939       384.612       605.551    
  12  0.486947     -0.719601      -125.020       125.020       626.714       751.734    
  13  0.216546      -1.52995      -265.807       265.807       582.368       848.175    
  14  0.483718E-02  -5.33142      -926.258       926.258       616.461       1542.72    
  15  0.785152E-03  -7.14963      -1242.15       1242.15       475.440       1717.59    
  16  0.300781      -1.20137      -208.721       208.721       582.846       791.567    
  17  0.869691     -0.139618      -24.2566       24.2566       572.886       597.142    
  18  0.694261E-01  -2.66749      -463.438       463.438       499.703       963.141    
  19  0.635475     -0.453382      -78.7686       78.7686       605.948       684.716    
  20  0.894977     -0.110958      -19.2773       19.2773       543.326       562.603    
  21  0.442267     -0.815841      -141.740       141.740       586.739       728.479    
  22  0.283362      -1.26103      -219.085       219.085       590.730       809.815    
  23  0.518611     -0.656601      -114.075       114.075       579.118       693.193    
  24  0.858122E-01  -2.45559      -426.624       426.624       577.169       1003.79    
  25  0.461153     -0.774026      -134.476       134.476       488.675       623.151    
  26  0.180026      -1.71465      -297.896       297.896       579.118       877.015    
  27  0.446938E-01  -3.10792      -539.956       539.956       734.498       1274.45    
  28  0.152352      -1.88156      -326.894       326.894       572.083       898.977    
  29  0.163937E-01  -4.11086      -714.202       714.202       484.301       1198.50    
  30  0.721347     -0.326635      -56.7481       56.7481       578.414       635.162    
  31  0.813323     -0.206626      -35.8984       35.8984       831.500       867.398    
loop,thermsimp(1:2)       14   185.094       228.951    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     55        632.89         73.62          0.98         38.64          0.91          0.05        114.20
Just calling func    0   0        114.20


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    632.89
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    173.736                61
loop is:       14
neval is:       54
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       14      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    173.736                61
loop is:       15
neval is:       54


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       61
neval,tstepnext:       54      61

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.229949      -1.46990      -255.374       255.374       475.875       731.248    
   2  0.322822      -1.13066      -196.435       196.435       543.326       739.761    
   3  0.327586      -1.11601      -193.890       193.890       572.886       766.776    
   4  0.799078     -0.224296      -38.9682       38.9682       384.612       423.580    
   5  0.698072     -0.359433      -62.4463       62.4463       488.675       551.121    
   6  0.733871     -0.309421      -53.7575       53.7575       439.306       493.064    
   7  0.823872     -0.193740      -33.6596       33.6596       578.414       612.073    
   8  0.800045     -0.223087      -38.7581       38.7581       615.561       654.319    
   9  0.162010      -1.82010      -316.215       316.215       572.329       888.545    
  10  0.113138      -2.17915      -378.595       378.595       605.948       984.543    
  11  0.973966     -0.263784E-01  -4.58286       4.58286       542.951       547.534    
  12  0.998107     -0.189521E-02 -0.329265      0.329265       579.118       579.448    
  13  0.631351     -0.459893      -79.8998       79.8998       480.507       560.406    
  14  0.698229     -0.359208      -62.4073       62.4073       586.739       649.146    
  15  0.359252      -1.02373      -177.858       177.858       511.020       688.878    
  16  0.936266     -0.658562E-01  -11.4416       11.4416       493.234       504.676    
  17  0.843107     -0.170662      -29.6500       29.6500       626.714       656.364    
  18  0.181284      -1.70769      -296.687       296.687       539.254       835.941    
  19  0.354246      -1.03777      -180.297       180.297       582.846       763.143    
  20  0.981540     -0.186324E-01  -3.23711       3.23711       590.730       593.967    
  21  0.582284E-01  -2.84338      -493.997       493.997       582.368       1076.36    
  22  0.935088     -0.671143E-01  -11.6601       11.6601       831.500       843.160    
  23  0.682144     -0.382515      -66.4564       66.4564       579.118       645.575    
  24  0.441439     -0.817715      -142.066       142.066       585.620       727.686    
  25  0.325829      -1.12138      -194.824       194.824       572.083       766.907    
  26  0.956968E-01  -2.34657      -407.683       407.683       499.703       907.385    
  27  0.465124E-01  -3.06804      -533.027       533.027       577.169       1110.20    
  28  0.645503     -0.437726      -76.0486       76.0486       484.301       560.349    
  29  0.184751      -1.68875      -293.395       293.395       734.498       1027.89    
  30  0.676303     -0.391115      -67.9505       67.9505       616.461       684.411    
  31  0.408248     -0.895880      -155.646       155.646       632.888       788.535    
loop,thermsimp(1:2)       15   255.374       196.435    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     56        540.29         73.64          1.00         38.75          0.55          0.05        114.00
Just calling func    0   0        114.00


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    540.29
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    173.736                61
loop is:       15
neval is:       55
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       15      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    173.736                61
loop is:       16
neval is:       55


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       61
neval,tstepnext:       55      61

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.557805     -0.583747      -101.418       101.418       384.612       486.030    
   2  0.850944     -0.161409      -28.0425       28.0425       439.306       467.349    
   3  0.343999      -1.06712      -185.396       185.396       493.234       678.630    
   4  0.481777E-02  -5.33544      -926.956       926.956       542.951       1469.91    
   5  0.146991      -1.91738      -333.117       333.117       488.675       821.792    
   6  0.545677     -0.605728      -105.236       105.236       484.301       589.537    
   7  0.761940     -0.271888      -47.2366       47.2366       480.507       527.743    
   8  0.944477     -0.571238E-01  -9.92443       9.92443       579.118       589.043    
   9  0.965249     -0.353688E-01  -6.14482       6.14482       590.730       596.875    
  10  0.634176     -0.455429      -79.1243       79.1243       578.414       657.538    
  11  0.793205     -0.231673      -40.2499       40.2499       579.118       619.368    
  12  0.743605     -0.296246      -51.4684       51.4684       586.739       638.207    
  13  0.983069E-01  -2.31966      -403.008       403.008       615.561       1018.57    
  14  0.618437     -0.480560      -83.4903       83.4903       626.714       710.204    
  15  0.429182     -0.845875      -146.958       146.958       616.461       763.419    
  16  0.771528     -0.259382      -45.0638       45.0638       511.020       556.084    
  17  0.218286      -1.52195      -264.416       264.416       585.620       850.036    
  18  0.556408     -0.586254      -101.853       101.853       475.875       577.728    
  19  0.526292     -0.641899      -111.521       111.521       543.326       654.847    
  20  0.665532     -0.407169      -70.7397       70.7397       582.846       653.586    
  21  0.261756      -1.34034      -232.865       232.865       572.886       805.751    
  22  0.975508     -0.247971E-01  -4.30814       4.30814       572.083       576.392    
  23  0.257613      -1.35630      -235.637       235.637       632.888       868.525    
  24  0.981555E-01  -2.32120      -403.275       403.275       539.254       942.530    
  25  0.955054     -0.459870E-01  -7.98958       7.98958       831.500       839.490    
  26  0.887906     -0.118890      -20.6554       20.6554       572.329       592.985    
  27  0.407043     -0.898837      -156.160       156.160       499.703       655.863    
  28  0.876870     -0.131396      -22.8282       22.8282       605.948       628.776    
  29  0.957152     -0.437935E-01  -7.60849       7.60849       734.498       742.107    
  30  0.827730     -0.189068      -32.8478       32.8478       582.368       615.216    
  31  0.289027      -1.24124      -215.647       215.647       540.286       755.933    
loop,thermsimp(1:2)       16   101.418       28.0425    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     57        536.64         73.44          1.00         38.83          0.88          0.05        114.20
Just calling func    0   0        114.20


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    536.64
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    173.736                61
loop is:       16
neval is:       56
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       16      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    173.736                61
loop is:       17
neval is:       56


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       61
neval,tstepnext:       56      61

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.739792     -0.301387      -52.3616       52.3616       439.306       491.668    
   2  0.527958     -0.638738      -110.971       110.971       384.612       495.584    
   3  0.326119      -1.12049      -194.669       194.669       480.507       675.176    
   4  0.647061     -0.435314      -75.6295       75.6295       511.020       586.650    
   5  0.419805     -0.867966      -150.797       150.797       572.083       722.880    
   6  0.218417      -1.52135      -264.312       264.312       475.875       740.187    
   7  0.168864      -1.77866      -309.017       309.017       579.118       888.135    
   8  0.761417     -0.272575      -47.3559       47.3559       484.301       531.657    
   9  0.383989     -0.957143      -166.290       166.290       572.329       738.619    
  10  0.104774      -2.25595      -391.939       391.939       590.730       982.669    
  11  0.167912      -1.78432      -309.999       309.999       582.368       892.367    
  12  0.997930     -0.207190E-02 -0.359963      0.359963       579.118       579.478    
  13  0.493294     -0.706650      -122.770       122.770       605.948       728.718    
  14  0.483048     -0.727639      -126.417       126.417       586.739       713.155    
  15  0.715967     -0.334121      -58.0487       58.0487       582.846       640.895    
  16  0.595423E-01  -2.82107      -490.120       490.120       543.326       1033.45    
  17  0.636569     -0.451662      -78.4697       78.4697       499.703       578.172    
  18  0.482980     -0.727779      -126.441       126.441       578.414       704.855    
  19  0.500121     -0.692905      -120.382       120.382       493.234       613.616    
  20  0.426980     -0.851018      -147.852       147.852       626.714       774.566    
  21  0.546576     -0.604082      -104.951       104.951       734.498       839.449    
  22  0.142720      -1.94687      -338.241       338.241       540.286       878.527    
  23  0.473622     -0.747346      -129.841       129.841       616.461       746.301    
  24  0.892718E-01  -2.41607      -419.757       419.757       572.886       992.643    
  25  0.660659     -0.414518      -72.0164       72.0164       488.675       560.691    
  26  0.328755      -1.11244      -193.271       193.271       831.500       1024.77    
  27  0.544150     -0.608530      -105.723       105.723       585.620       691.343    
  28  0.199068      -1.61411      -280.428       280.428       632.888       913.317    
  29  0.685070     -0.378234      -65.7127       65.7127       539.254       604.967    
  30  0.500258     -0.692632      -120.335       120.335       615.561       735.896    
  31  0.130607      -2.03556      -353.650       353.650       536.644       890.294    
loop,thermsimp(1:2)       17   52.3616       110.971    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     58        548.94         74.33          1.07         38.57          0.03          0.05        114.06
Just calling func    0   0        114.06


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     59        559.35         73.88          1.04         38.65          0.39          0.05        114.02
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    548.94
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    173.736                61
loop is:       17
neval is:       58
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       17      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    173.736                61
loop is:       18
neval is:       58


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       61
neval,tstepnext:       58      61

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.382860     -0.960086      -166.801       166.801       439.306       606.107    
   2  0.293468      -1.22599      -212.998       212.998       384.612       597.610    
   3  0.954036     -0.470539E-01  -8.17493       8.17493       484.301       492.476    
   4  0.452934     -0.792010      -137.600       137.600       488.675       626.275    
   5  0.251692      -1.37955      -239.677       239.677       499.703       739.379    
   6  0.881081     -0.126605      -21.9959       21.9959       579.118       601.114    
   7  0.855311     -0.156290      -27.1531       27.1531       511.020       538.173    
   8  0.576474     -0.550824      -95.6977       95.6977       539.254       634.952    
   9  0.433835     -0.835090      -145.085       145.085       493.234       638.319    
  10  0.298626      -1.20856      -209.971       209.971       582.846       792.817    
  11  0.269991      -1.30937      -227.484       227.484       480.507       707.990    
  12  0.884826     -0.122364      -21.2590       21.2590       585.620       606.879    
  13  0.664124     -0.409287      -71.1076       71.1076       578.414       649.521    
  14  0.580836     -0.543287      -94.3883       94.3883       586.739       681.127    
  15  0.285501      -1.25351      -217.779       217.779       572.083       789.862    
  16  0.690757     -0.369967      -64.2765       64.2765       605.948       670.224    
  17  0.578320     -0.547628      -95.1425       95.1425       615.561       710.704    
  18  0.563230     -0.574067      -99.7359       99.7359       572.329       672.065    
  19  0.681565     -0.383363      -66.6038       66.6038       475.875       542.479    
  20  0.453362     -0.791065      -137.436       137.436       616.461       753.897    
  21  0.645457     -0.437797      -76.0609       76.0609       626.714       702.775    
  22  0.982222E-01  -2.32052      -403.157       403.157       734.498       1137.66    
  23  0.843064     -0.170712      -29.6588       29.6588       540.286       569.945    
  24  0.505683     -0.681845      -118.461       118.461       579.118       697.579    
  25  0.350376      -1.04875      -182.205       182.205       536.644       718.850    
  26  0.367167      -1.00194      -174.073       174.073       582.368       756.440    
  27  0.268175      -1.31611      -228.656       228.656       632.888       861.544    
  28  0.989085E-01  -2.31356      -401.948       401.948       590.730       992.677    
  29  0.349392      -1.05156      -182.694       182.694       572.886       755.580    
  30  0.945468     -0.560755E-01  -9.74230       9.74230       831.500       841.242    
  31  0.305400      -1.18613      -206.073       206.073       548.945       755.018    
loop,thermsimp(1:2)       18   166.801       212.998    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     60        476.68         73.45          1.01         38.88          0.67          0.06        114.07
Just calling func    0   0        114.07


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     61        453.72         73.78          1.04         38.84          0.14          0.05        113.84
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

   60    453.72        2.167     -1.402      5.377     -100.9      1.410    
                     -0.4148      2.973     -99.58      3.413      1.847    
                       1.937     -1.299      1.833      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1248E+05 0.1435E+05 -2213.    -0.4896E+05
                      -2.000     -4.673     -7.455     -6.733     -2.052    
                      -12.76     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.9187     -1.419      6.554      1.026      0.000    
                       0.000      9.205      9.124     -4630.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -6957.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -9807.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -5031.      1.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    453.72
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    173.736                61
loop is:       18
neval is:       60
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       18      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    173.736                61
loop is:       19
neval is:       60


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       61
neval,tstepnext:       60      61

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.352992      -1.04131      -180.913       180.913       484.301       665.213    
   2  0.270835E-01  -3.60883      -626.982       626.982       511.020       1138.00    
   3  0.923755     -0.793087E-01  -13.7787       13.7787       475.875       489.653    
   4  0.535520     -0.624517      -108.501       108.501       540.286       648.787    
   5  0.629344     -0.463078      -80.4530       80.4530       384.612       465.065    
   6  0.572648E-01  -2.86007      -496.896       496.896       579.118       1076.01    
   7  0.353113E-01  -3.34355      -580.894       580.894       439.306       1020.20    
   8  0.580838     -0.543283      -94.3875       94.3875       585.620       680.008    
   9  0.370403     -0.993164      -172.548       172.548       488.675       661.222    
  10  0.443010     -0.814162      -141.449       141.449       539.254       680.703    
  11  0.188704      -1.66757      -289.717       289.717       493.234       782.951    
  12  0.177608      -1.72818      -300.246       300.246       578.414       878.660    
  13  0.694998     -0.363847      -63.2131       63.2131       605.948       669.161    
  14  0.160742      -1.82796      -317.581       317.581       572.329       889.910    
  15  0.290050      -1.23770      -215.033       215.033       586.739       801.772    
  16  0.441138E-01  -3.12098      -542.225       542.225       579.118       1121.34    
  17  0.372461     -0.987622      -171.585       171.585       626.714       798.299    
  18  0.652779     -0.426517      -74.1012       74.1012       480.507       554.608    
  19  0.998108     -0.189387E-02 -0.329033      0.329033       615.561       615.890    
  20  0.741140     -0.299566      -52.0453       52.0453       536.644       588.690    
  21  0.623042     -0.473141      -82.2015       82.2015       499.703       581.904    
  22  0.504617     -0.683955      -118.827       118.827       616.461       735.288    
  23  0.872499     -0.136394      -23.6965       23.6965       548.945       572.641    
  24  0.142620      -1.94757      -338.362       338.362       572.886       911.248    
  25  0.580285     -0.544236      -94.5532       94.5532       582.368       676.921    
  26  0.860063E-01  -2.45334      -426.231       426.231       572.083       998.315    
  27  0.401846     -0.911687      -158.392       158.392       582.846       741.238    
  28  0.161242      -1.82485      -317.042       317.042       831.500       1148.54    
  29  0.550753     -0.596469      -103.628       103.628       632.888       736.516    
  30  0.815012     -0.204553      -35.5380       35.5380       590.730       626.268    
  31  0.438663     -0.824024      -143.162       143.162       453.721       596.883    
loop,thermsimp(1:2)       19   180.913       626.982    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     62        704.85         73.64          1.02         38.68          0.69          0.06        114.10
Just calling func    0   0        114.10


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     63       2188.06         73.42          0.99         38.90          0.59          0.06        113.95
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    704.85
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    173.736                61
loop is:       19
neval is:       62
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       19      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    173.736                61
loop is:       20
neval is:       62


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 




neval>tstepnex so lower away!t
---> lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
     new SAtemp,tstepnext are :    86.8678                91

 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       62      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.534746     -0.625963      -54.3760       54.3760       384.612       438.988    
   2  0.288348      -1.24359      -108.028       108.028       475.875       583.902    
   3  0.910112E-01  -2.39677      -208.202       208.202       480.507       688.709    
   4  0.213812      -1.54266      -134.007       134.007       548.945       682.952    
   5  0.575222     -0.552999      -48.0378       48.0378       499.703       547.741    
   6  0.855707     -0.155827      -13.5364       13.5364       536.644       550.181    
   7  0.818692     -0.200047      -17.3777       17.3777       453.721       471.099    
   8  0.309911      -1.17147      -101.763       101.763       615.561       717.324    
   9  0.773438     -0.256910      -22.3172       22.3172       590.730       613.047    
  10  0.440502E-01  -3.12243      -271.238       271.238       540.286       811.524    
  11  0.211655      -1.55280      -134.888       134.888       488.675       623.563    
  12  0.713577     -0.337465      -29.3149       29.3149       484.301       513.616    
  13  0.927405     -0.753650E-01  -6.54679       6.54679       605.948       612.494    
  14  0.360229      -1.02101      -88.6932       88.6932       582.368       671.061    
  15  0.911872     -0.922553E-01  -8.01401       8.01401       585.620       593.634    
  16  0.800691     -0.222280      -19.3090       19.3090       539.254       558.563    
  17  0.169830      -1.77296      -154.013       154.013       616.461       770.474    
  18  0.581014     -0.542980      -47.1675       47.1675       632.888       680.056    
  19  0.869395     -0.139958      -12.1578       12.1578       582.846       595.004    
  20  0.773880     -0.256338      -22.2675       22.2675       493.234       515.501    
  21  0.496085     -0.701008      -60.8950       60.8950       626.714       687.609    
  22  0.530037     -0.634809      -55.1444       55.1444       586.739       641.883    
  23  0.239414      -1.42956      -124.183       124.183       578.414       702.597    
  24  0.595728     -0.517972      -44.9951       44.9951       572.329       617.324    
  25  0.170793      -1.76730      -153.522       153.522       572.886       726.408    
  26  0.983027     -0.171183E-01  -1.48703       1.48703       572.083       573.570    
  27  0.608714     -0.496407      -43.1217       43.1217       439.306       482.428    
  28  0.518727     -0.656378      -57.0181       57.0181       579.118       636.137    
  29  0.887918     -0.118876      -10.3265       10.3265       579.118       589.445    
  30  0.140498      -1.96256      -170.483       170.483       511.020       681.503    
  31  0.256308      -1.36138      -118.260       118.260       704.852       823.111    
loop,thermsimp(1:2)       20   54.3760       108.028    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     64        831.50         73.57          0.99         38.66          0.74          0.05        114.01
Just calling func    0   0        114.01


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    831.50
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    86.8678                91
loop is:       20
neval is:       63
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       20      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    86.8678                91
loop is:       21
neval is:       63


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       63      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.297422      -1.21260      -105.336       105.336       384.612       489.948    
   2  0.663536     -0.410173      -35.6308       35.6308       453.721       489.352    
   3  0.263982      -1.33188      -115.697       115.697       439.306       555.003    
   4  0.792402     -0.232686      -20.2129       20.2129       484.301       504.514    
   5  0.624731     -0.470434      -40.8655       40.8655       493.234       534.100    
   6  0.170977      -1.76622      -153.428       153.428       499.703       653.131    
   7  0.362487      -1.01477      -88.1506       88.1506       536.644       624.795    
   8  0.659245     -0.416659      -36.1943       36.1943       539.254       575.449    
   9  0.746481E-03  -7.20014      -625.460       625.460       572.083       1197.54    
  10  0.690046     -0.370998      -32.2277       32.2277       475.875       508.102    
  11  0.905636     -0.991173E-01  -8.61010       8.61010       579.118       587.728    
  12  0.317643      -1.14683      -99.6224       99.6224       585.620       685.242    
  13  0.321948      -1.13336      -98.4529       98.4529       582.846       681.299    
  14  0.293974      -1.22426      -106.349       106.349       605.948       712.297    
  15  0.679275     -0.386729      -33.5943       33.5943       590.730       624.324    
  16  0.180340      -1.71291      -148.797       148.797       572.329       721.126    
  17  0.539600     -0.616927      -53.5911       53.5911       488.675       542.266    
  18  0.260315      -1.34586      -116.912       116.912       579.118       696.030    
  19  0.256777      -1.35955      -118.101       118.101       586.739       704.839    
  20  0.518851     -0.656138      -56.9973       56.9973       582.368       639.365    
  21  0.485887     -0.721780      -62.6994       62.6994       632.888       695.588    
  22  0.562814     -0.574805      -49.9320       49.9320       511.020       560.952    
  23  0.906369     -0.983082E-01  -8.53982       8.53982       548.945       557.485    
  24  0.332143      -1.10219      -95.7447       95.7447       626.714       722.459    
  25  0.912001E-01  -2.39470      -208.022       208.022       480.507       688.529    
  26  0.302569      -1.19545      -103.846       103.846       578.414       682.259    
  27  0.362040      -1.01600      -88.2577       88.2577       615.561       703.819    
  28  0.630870     -0.460656      -40.0161       40.0161       572.886       612.902    
  29  0.685312     -0.377881      -32.8257       32.8257       616.461       649.286    
  30  0.329910      -1.10894      -96.3309       96.3309       540.286       636.617    
  31  0.906630E-01  -2.40061      -208.535       208.535       831.500       1040.04    
loop,thermsimp(1:2)       21   105.336       35.6308    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     65        501.22         73.52          0.99         38.54          0.89          0.06        114.00
Just calling func    0   0        114.00


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     66        482.55         73.54          0.99         38.38          0.90          0.06        113.86
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    482.55
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    86.8678                91
loop is:       21
neval is:       65
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       21      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    86.8678                91
loop is:       22
neval is:       65


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       65      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.383671     -0.957969      -83.2166       83.2166       453.721       536.938    
   2  0.741480     -0.299107      -25.9827       25.9827       384.612       410.595    
   3  0.138898      -1.97401      -171.478       171.478       484.301       655.779    
   4  0.751974E-01  -2.58764      -224.782       224.782       475.875       700.657    
   5  0.824485     -0.192996      -16.7651       16.7651       493.234       509.999    
   6  0.982900     -0.172482E-01  -1.49831       1.49831       488.675       490.173    
   7  0.693409     -0.366136      -31.8054       31.8054       439.306       471.112    
   8  0.941572     -0.602045E-01  -5.22983       5.22983       548.945       554.175    
   9  0.812713     -0.207378      -18.0144       18.0144       511.020       529.034    
  10  0.879507     -0.128393      -11.1532       11.1532       539.254       550.408    
  11  0.418958     -0.869984      -75.5735       75.5735       579.118       654.692    
  12  0.314952      -1.15533      -100.361       100.361       572.886       673.247    
  13  0.812426     -0.207731      -18.0451       18.0451       590.730       608.775    
  14  0.213788      -1.54277      -134.017       134.017       536.644       670.661    
  15  0.521629     -0.650798      -56.5334       56.5334       540.286       596.819    
  16  0.287143      -1.24777      -108.391       108.391       582.368       690.759    
  17  0.518340     -0.657125      -57.0830       57.0830       616.461       673.544    
  18  0.712802E-02  -4.94372      -429.450       429.450       499.703       929.153    
  19  0.579935     -0.544838      -47.3289       47.3289       582.846       630.175    
  20  0.508101E-02  -5.28224      -458.857       458.857       578.414       1037.27    
  21  0.984466     -0.156557E-01  -1.35998       1.35998       585.620       586.980    
  22  0.394325     -0.930579      -80.8373       80.8373       480.507       561.344    
  23  0.837309     -0.177562      -15.4244       15.4244       632.888       648.313    
  24  0.683519     -0.380501      -33.0533       33.0533       579.118       612.172    
  25  0.892337     -0.113912      -9.89526       9.89526       615.561       625.456    
  26  0.297675      -1.21175      -105.262       105.262       586.739       692.001    
  27  0.566054     -0.569065      -49.4334       49.4334       605.948       655.381    
  28  0.325499E-01  -3.42498      -297.520       297.520       572.329       869.850    
  29  0.721169     -0.326882      -28.3955       28.3955       626.714       655.109    
  30  0.370449     -0.993040      -86.2632       86.2632       831.500       917.763    
  31  0.398952     -0.918913      -79.8239       79.8239       482.549       562.373    
loop,thermsimp(1:2)       22   83.2166       25.9827    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     67        489.34         74.03          1.03         38.61          0.51          0.05        114.23
Just calling func    0   0        114.24


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    489.34
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    86.8678                91
loop is:       22
neval is:       66
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       22      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    86.8678                91
loop is:       23
neval is:       66


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       66      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.327656      -1.11579      -96.9263       96.9263       384.612       481.538    
   2  0.736029     -0.306486      -26.6237       26.6237       439.306       465.930    
   3  0.608436     -0.496864      -43.1615       43.1615       488.675       531.836    
   4  0.584882     -0.536346      -46.5912       46.5912       493.234       539.825    
   5  0.617514     -0.482053      -41.8748       41.8748       511.020       552.895    
   6  0.376473     -0.976909      -84.8619       84.8619       453.721       538.583    
   7  0.535145     -0.625218      -54.3113       54.3113       539.254       593.566    
   8  0.341783      -1.07358      -93.2594       93.2594       548.945       642.204    
   9  0.804208E-01  -2.52048      -218.949       218.949       480.507       699.455    
  10  0.660499     -0.414760      -36.0293       36.0293       482.549       518.578    
  11  0.739860E-01  -2.60388      -226.193       226.193       585.620       811.813    
  12  0.203251      -1.59331      -138.407       138.407       540.286       678.693    
  13  0.637025     -0.450946      -39.1727       39.1727       590.730       629.902    
  14  0.687460     -0.374752      -32.5538       32.5538       579.118       611.672    
  15  0.663581     -0.410105      -35.6249       35.6249       615.561       651.186    
  16  0.579690     -0.545263      -47.3657       47.3657       582.846       630.212    
  17  0.775653     -0.254050      -22.0688       22.0688       632.888       654.957    
  18  0.284124      -1.25834      -109.310       109.310       579.118       688.428    
  19  0.317710      -1.14662      -99.6039       99.6039       626.714       726.318    
  20  0.958871     -0.419990E-01  -3.64836       3.64836       605.948       609.596    
  21  0.582932     -0.539685      -46.8812       46.8812       484.301       531.182    
  22  0.905476     -0.992942E-01  -8.62546       8.62546       536.644       545.270    
  23  0.225214      -1.49070      -129.494       129.494       572.886       702.380    
  24  0.618260     -0.480846      -41.7700       41.7700       616.461       658.231    
  25  0.608706     -0.496420      -43.1229       43.1229       582.368       625.491    
  26  0.651052     -0.429165      -37.2806       37.2806       586.739       624.019    
  27  0.138439E-02  -6.58249      -571.806       571.806       475.875       1047.68    
  28  0.157375      -1.84913      -160.629       160.629       572.329       732.959    
  29  0.168063      -1.78342      -154.921       154.921       831.500       986.422    
  30  0.924354     -0.786598E-01  -6.83300       6.83300       499.703       506.536    
  31  0.985585     -0.145204E-01  -1.26136       1.26136       489.342       490.603    
loop,thermsimp(1:2)       23   96.9263       26.6237    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     68        622.00         73.73          1.00         38.66          0.87          0.05        114.32
Just calling func    0   0        114.32


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    622.00
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    86.8678                91
loop is:       23
neval is:       67
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       23      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    86.8678                91
loop is:       24
neval is:       67


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       67      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.291502      -1.23271      -107.083       107.083       439.306       546.389    
   2  0.991852     -0.818183E-02 -0.710737      0.710737       384.612       385.323    
   3  0.317368      -1.14769      -99.6976       99.6976       489.342       589.040    
   4  0.737330     -0.304720      -26.4703       26.4703       499.703       526.173    
   5  0.834641     -0.180753      -15.7016       15.7016       482.549       498.251    
   6  0.464401     -0.767007      -66.6282       66.6282       484.301       550.929    
   7  0.592116     -0.524053      -45.5233       45.5233       488.675       534.198    
   8  0.464372     -0.767069      -66.6335       66.6335       453.721       520.355    
   9  0.636055E-01  -2.75505      -239.325       239.325       493.234       732.559    
  10  0.712927     -0.338376      -29.3940       29.3940       536.644       566.038    
  11  0.265597      -1.32578      -115.167       115.167       511.020       626.187    
  12  0.152318      -1.88178      -163.466       163.466       539.254       702.721    
  13  0.629580     -0.462703      -40.1940       40.1940       605.948       646.142    
  14  0.849464     -0.163150      -14.1724       14.1724       579.118       593.291    
  15  0.487816     -0.717817      -62.3551       62.3551       586.739       649.094    
  16  0.374667     -0.981718      -85.2797       85.2797       582.368       667.647    
  17  0.657383     -0.419488      -36.4400       36.4400       590.730       627.170    
  18  0.846901     -0.166172      -14.4350       14.4350       582.846       597.281    
  19  0.201185      -1.60353      -139.295       139.295       548.945       688.240    
  20  0.771980     -0.258797      -22.4811       22.4811       615.561       638.042    
  21  0.507739     -0.677788      -58.8779       58.8779       632.888       691.766    
  22  0.280262      -1.27203      -110.499       110.499       616.461       726.959    
  23  0.285359      -1.25401      -108.933       108.933       540.286       649.219    
  24  0.246191      -1.40165      -121.758       121.758       579.118       700.876    
  25  0.559989E-01  -2.88242      -250.390       250.390       480.507       730.896    
  26  0.330462      -1.10726      -96.1855       96.1855       572.886       669.071    
  27  0.899405     -0.106022      -9.20991       9.20991       626.714       635.924    
  28  0.637003     -0.450981      -39.1757       39.1757       572.329       611.505    
  29  0.699726E-01  -2.65965      -231.038       231.038       585.620       816.658    
  30  0.677191     -0.389802      -33.8612       33.8612       831.500       865.361    
  31  0.649507     -0.431542      -37.4871       37.4871       622.004       659.491    
loop,thermsimp(1:2)       24   107.083      0.710737    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     69        661.10         73.70          0.99         38.68          0.57          0.05        114.00
Just calling func    0   0        114.00


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    661.10
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    86.8678                91
loop is:       24
neval is:       68
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       24      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    86.8678                91
loop is:       25
neval is:       68


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       68      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.145902      -1.92482      -167.205       167.205       384.612       551.817    
   2  0.438196     -0.825090      -71.6737       71.6737       482.549       554.223    
   3  0.637359     -0.450422      -39.1272       39.1272       453.721       492.848    
   4  0.122813      -2.09709      -182.170       182.170       499.703       681.872    
   5  0.926899     -0.759107E-01  -6.59419       6.59419       488.675       495.269    
   6  0.456580     -0.783992      -68.1037       68.1037       439.306       507.410    
   7  0.988763     -0.113008E-01 -0.981679      0.981679       484.301       485.282    
   8  0.499609     -0.693930      -60.2801       60.2801       536.644       596.925    
   9  0.432617     -0.837902      -72.7867       72.7867       489.342       562.129    
  10  0.403570     -0.907406      -78.8243       78.8243       579.118       657.943    
  11  0.435824     -0.830517      -72.1452       72.1452       582.846       654.991    
  12  0.504807     -0.683579      -59.3810       59.3810       572.329       631.710    
  13  0.778763     -0.250048      -21.7211       21.7211       511.020       532.741    
  14  0.429140     -0.845972      -73.4877       73.4877       590.730       664.217    
  15  0.597763     -0.514562      -44.6988       44.6988       626.714       671.413    
  16  0.425932     -0.853476      -74.1395       74.1395       615.561       689.701    
  17  0.825778     -0.191430      -16.6291       16.6291       605.948       622.577    
  18  0.448772     -0.801241      -69.6020       69.6020       586.739       656.341    
  19  0.701335     -0.354770      -30.8180       30.8180       540.286       571.104    
  20  0.425857     -0.853651      -74.1548       74.1548       622.004       696.159    
  21  0.800815     -0.222126      -19.2956       19.2956       582.368       601.663    
  22  0.724239     -0.322634      -28.0265       28.0265       572.886       600.912    
  23  0.312194      -1.16413      -101.125       101.125       548.945       650.070    
  24  0.796592     -0.227412      -19.7548       19.7548       632.888       652.643    
  25  0.164146      -1.80700      -156.970       156.970       579.118       736.089    
  26  0.503041     -0.687083      -59.6854       59.6854       539.254       598.940    
  27  0.640838     -0.444978      -38.6543       38.6543       616.461       655.115    
  28  0.327752      -1.11550      -96.9008       96.9008       480.507       577.407    
  29  0.720325     -0.328053      -28.4973       28.4973       493.234       521.731    
  30  0.447570     -0.803922      -69.8349       69.8349       585.620       655.455    
  31  0.377461     -0.974289      -84.6343       84.6343       661.104       745.739    
loop,thermsimp(1:2)       25   167.205       71.6737    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     70        831.50         73.62          1.00         38.82          0.38          0.06        113.87
Just calling func    0   0        113.87


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     71        640.55         73.70          1.02         38.68          0.62          0.05        114.07
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    640.55
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    86.8678                91
loop is:       25
neval is:       70
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       25      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    86.8678                91
loop is:       26
neval is:       70


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       70      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.781042     -0.247126      -21.4673       21.4673       484.301       505.768    
   2  0.928800     -0.738619E-01  -6.41622       6.41622       453.721       460.137    
   3  0.727994     -0.317462      -27.5772       27.5772       488.675       516.252    
   4  0.109723E-01  -4.51238      -391.981       391.981       439.306       831.287    
   5  0.160096      -1.83198      -159.140       159.140       493.234       652.374    
   6  0.497079     -0.699006      -60.7211       60.7211       511.020       571.741    
   7  0.789473     -0.236389      -20.5346       20.5346       384.612       405.147    
   8  0.763780     -0.269476      -23.4087       23.4087       482.549       505.958    
   9  0.217288      -1.52653      -132.606       132.606       489.342       621.948    
  10  0.867642     -0.141976      -12.3332       12.3332       540.286       552.619    
  11  0.740966     -0.299800      -26.0430       26.0430       480.507       506.550    
  12  0.999757     -0.242662E-03 -0.210795E-01  0.210795E-01   536.644       536.666    
  13  0.587476     -0.531920      -46.2067       46.2067       539.254       585.461    
  14  0.703619     -0.351518      -30.5356       30.5356       572.886       603.421    
  15  0.740946     -0.299828      -26.0454       26.0454       582.368       608.413    
  16  0.335927      -1.09086      -94.7606       94.7606       605.948       700.708    
  17  0.736553     -0.305774      -26.5619       26.5619       572.329       598.891    
  18  0.597397     -0.515174      -44.7520       44.7520       548.945       593.697    
  19  0.126601      -2.06672      -179.531       179.531       632.888       812.420    
  20  0.990194     -0.985477E-02 -0.856062      0.856062       582.846       583.702    
  21  0.716453     -0.333443      -28.9655       28.9655       616.461       645.426    
  22  0.279233E-01  -3.57829      -310.838       310.838       585.620       896.458    
  23  0.413932     -0.882054      -76.6221       76.6221       586.739       663.361    
  24  0.109516      -2.21168      -192.124       192.124       579.118       771.242    
  25  0.440749     -0.819279      -71.1689       71.1689       590.730       661.899    
  26  0.412115     -0.886453      -77.0042       77.0042       626.714       703.718    
  27  0.146963      -1.91758      -166.576       166.576       499.703       666.278    
  28  0.345919      -1.06155      -92.2144       92.2144       615.561       707.775    
  29  0.343614      -1.06824      -92.7952       92.7952       622.004       714.799    
  30  0.600334E-01  -2.81285      -244.346       244.346       579.118       823.465    
  31  0.751538     -0.285634      -24.8124       24.8124       640.549       665.361    
loop,thermsimp(1:2)       26   21.4673       6.41622    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     72        504.07         73.57          1.01         38.88          0.66          0.05        114.17
Just calling func    0   0        114.17


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    504.07
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    86.8678                91
loop is:       26
neval is:       71
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       26      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    86.8678                91
loop is:       27
neval is:       71


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       71      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.818509     -0.200271      -17.3971       17.3971       384.612       402.009    
   2  0.309452      -1.17295      -101.892       101.892       453.721       555.613    
   3  0.303638      -1.19192      -103.539       103.539       484.301       587.840    
   4  0.754457     -0.281757      -24.4756       24.4756       482.549       507.025    
   5  0.623133     -0.472996      -41.0881       41.0881       480.507       521.595    
   6  0.989422E-01  -2.31322      -200.944       200.944       488.675       689.619    
   7  0.695126     -0.363662      -31.5905       31.5905       536.644       568.235    
   8  0.832210E-01  -2.48626      -215.975       215.975       540.286       756.261    
   9  0.869521     -0.139813      -12.1453       12.1453       511.020       523.165    
  10  0.488136     -0.717160      -62.2981       62.2981       582.846       645.144    
  11  0.579877     -0.544940      -47.3377       47.3377       539.254       586.592    
  12  0.480435     -0.733064      -63.6796       63.6796       548.945       612.624    
  13  0.792626     -0.232404      -20.1884       20.1884       572.329       592.518    
  14  0.870230     -0.138998      -12.0744       12.0744       572.886       584.960    
  15  0.886361     -0.120631      -10.4789       10.4789       582.368       592.847    
  16  0.358181      -1.02672      -89.1887       89.1887       489.342       578.531    
  17  0.560125     -0.579594      -50.3481       50.3481       616.461       666.809    
  18  0.546151     -0.604859      -52.5427       52.5427       493.234       545.777    
  19  0.732086     -0.311858      -27.0904       27.0904       590.730       617.820    
  20  0.590102     -0.527460      -45.8193       45.8193       586.739       632.558    
  21  0.867355     -0.142307      -12.3619       12.3619       640.549       652.910    
  22  0.749758     -0.288005      -25.0184       25.0184       499.703       524.721    
  23  0.721970     -0.325772      -28.2991       28.2991       605.948       634.247    
  24  0.596865     -0.516065      -44.8294       44.8294       626.714       671.543    
  25  0.878161     -0.129925      -11.2863       11.2863       615.561       626.847    
  26  0.558752E-01  -2.88463      -250.582       250.582       622.004       872.586    
  27  0.555543     -0.587810      -51.0617       51.0617       579.118       630.180    
  28  0.597562     -0.514897      -44.7279       44.7279       632.888       677.616    
  29  0.995329     -0.468202E-02 -0.406717      0.406717       579.118       579.525    
  30  0.206787      -1.57606      -136.909       136.909       439.306       576.215    
  31  0.645457     -0.437797      -38.0305       38.0305       504.066       542.097    
loop,thermsimp(1:2)       27   17.3971       101.892    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     73        471.67         73.68          1.04         38.93          0.12          0.05        113.82
Just calling func    0   0        113.82


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    471.67
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    86.8678                91
loop is:       27
neval is:       72
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       27      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    86.8678                91
loop is:       28
neval is:       72


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       72      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.808657     -0.212380      -18.4490       18.4490       384.612       403.061    
   2  0.162004E-01  -4.12272      -358.132       358.132       482.549       840.681    
   3  0.446841E-01  -3.10814      -269.997       269.997       480.507       750.503    
   4  0.757954     -0.277132      -24.0739       24.0739       511.020       535.094    
   5  0.525315     -0.643757      -55.9218       55.9218       499.703       555.625    
   6  0.229940      -1.46994      -127.690       127.690       504.066       631.756    
   7  0.273310E-01  -3.59973      -312.701       312.701       493.234       805.935    
   8  0.228047      -1.47820      -128.408       128.408       453.721       582.129    
   9  0.963384E-01  -2.33989      -203.261       203.261       536.644       739.905    
  10  0.495504     -0.702179      -60.9967       60.9967       439.306       500.303    
  11  0.930436     -0.721018E-01  -6.26332       6.26332       489.342       495.605    
  12  0.138744      -1.97513      -171.575       171.575       579.118       750.693    
  13  0.676381     -0.390999      -33.9652       33.9652       572.886       606.851    
  14  0.763696     -0.269586      -23.4183       23.4183       539.254       562.673    
  15  0.282468      -1.26419      -109.817       109.817       484.301       594.118    
  16  0.359172      -1.02395      -88.9485       88.9485       572.329       661.278    
  17  0.392258     -0.935834      -81.2938       81.2938       582.368       663.662    
  18  0.524686     -0.644955      -56.0258       56.0258       548.945       604.970    
  19  0.850465     -0.161972      -14.0702       14.0702       590.730       604.800    
  20  0.227056      -1.48256      -128.786       128.786       615.561       744.347    
  21  0.942039     -0.597082E-01  -5.18672       5.18672       579.118       584.305    
  22  0.807336     -0.214016      -18.5911       18.5911       586.739       605.330    
  23  0.345853      -1.06174      -92.2311       92.2311       605.948       698.179    
  24  0.762940     -0.270575      -23.5043       23.5043       582.846       606.350    
  25  0.589959     -0.527702      -45.8403       45.8403       640.549       686.389    
  26  0.563539     -0.573518      -49.8202       49.8202       616.461       666.281    
  27  0.812044     -0.208201      -18.0860       18.0860       626.714       644.800    
  28  0.735850     -0.306729      -26.6449       26.6449       632.888       659.533    
  29  0.396292     -0.925605      -80.4052       80.4052       488.675       569.080    
  30  0.623568     -0.472298      -41.0275       41.0275       540.286       581.313    
  31  0.925937     -0.769486E-01  -6.68435       6.68435       471.666       478.351    
loop,thermsimp(1:2)       28   18.4490       358.132    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     74        853.26         73.62          0.99         38.96          0.51          0.05        114.13
Just calling func    0   0        114.13


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     75        591.43         73.67          1.01         38.77          0.54          0.05        114.05
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    591.43
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    86.8678                91
loop is:       28
neval is:       74
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       28      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    86.8678                91
loop is:       29
neval is:       74


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       74      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.115886      -2.15515      -187.213       187.213       384.612       571.825    
   2  0.685048     -0.378267      -32.8592       32.8592       471.666       504.525    
   3  0.739526     -0.301746      -26.2120       26.2120       489.342       515.554    
   4  0.161448      -1.82357      -158.410       158.410       439.306       597.716    
   5  0.819608     -0.198929      -17.2805       17.2805       511.020       528.301    
   6  0.750679     -0.286777      -24.9117       24.9117       499.703       524.614    
   7  0.797409     -0.226388      -19.6658       19.6658       539.254       558.920    
   8  0.193123      -1.64443      -142.848       142.848       488.675       631.523    
   9  0.189346E-01  -3.96676      -344.584       344.584       540.286       884.870    
  10  0.715264     -0.335103      -29.1097       29.1097       453.721       482.831    
  11  0.384856     -0.954886      -82.9488       82.9488       579.118       662.067    
  12  0.268023      -1.31668      -114.377       114.377       484.301       598.678    
  13  0.777164     -0.252104      -21.8997       21.8997       590.730       612.629    
  14  0.707495E-01  -2.64861      -230.079       230.079       548.945       779.024    
  15  0.233610      -1.45410      -126.315       126.315       586.739       713.053    
  16  0.193057      -1.64477      -142.878       142.878       582.846       725.724    
  17  0.486879     -0.719739      -62.5222       62.5222       572.886       635.408    
  18  0.735370     -0.307381      -26.7015       26.7015       504.066       530.768    
  19  0.147509      -1.91387      -166.253       166.253       626.714       792.967    
  20  0.739111     -0.302308      -26.2608       26.2608       632.888       659.149    
  21  0.886241     -0.120766      -10.4907       10.4907       572.329       582.820    
  22  0.158672      -1.84092      -159.916       159.916       582.368       742.284    
  23  0.143658      -1.94032      -168.551       168.551       616.461       785.012    
  24  0.637431E-02  -5.05548      -439.158       439.158       640.549       1079.71    
  25  0.753372     -0.283196      -24.6006       24.6006       605.948       630.548    
  26  0.555831     -0.587292      -51.0167       51.0167       536.644       587.661    
  27  0.280013      -1.27292      -110.576       110.576       615.561       726.137    
  28  0.811304     -0.209112      -18.1651       18.1651       480.507       498.672    
  29  0.972296E-02  -4.63327      -402.481       402.481       579.118       981.600    
  30  0.713459     -0.337631      -29.3292       29.3292       493.234       522.563    
  31  0.194621      -1.63670      -142.176       142.176       591.432       733.608    
loop,thermsimp(1:2)       29   187.213       32.8592    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     76        488.89         73.62          1.01         38.85          0.24          0.06        113.78
Just calling func    0   0        113.78


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     77        896.98         73.57          0.97         38.78          0.93          0.05        114.30
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    488.89
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    86.8678                91
loop is:       29
neval is:       76
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       29      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    86.8678                91
loop is:       30
neval is:       76


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       76      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.396389E-01  -3.22794      -280.404       280.404       453.721       734.125    
   2  0.712690     -0.338709      -29.4229       29.4229       480.507       509.929    
   3  0.284498      -1.25703      -109.195       109.195       471.666       580.862    
   4  0.132414      -2.02182      -175.631       175.631       489.342       664.973    
   5  0.868558     -0.140920      -12.2414       12.2414       493.234       505.475    
   6  0.695240     -0.363498      -31.5762       31.5762       499.703       531.279    
   7  0.777362     -0.251849      -21.8776       21.8776       511.020       532.898    
   8  0.302494      -1.19569      -103.867       103.867       504.066       607.933    
   9  0.710188     -0.342225      -29.7284       29.7284       539.254       568.983    
  10  0.884530     -0.122698      -10.6585       10.6585       384.612       395.271    
  11  0.146421E-01  -4.22386      -366.917       366.917       572.329       939.246    
  12  0.834801     -0.180562      -15.6850       15.6850       536.644       552.329    
  13  0.414011     -0.881863      -76.6055       76.6055       439.306       515.912    
  14  0.655777     -0.421935      -36.6526       36.6526       484.301       520.953    
  15  0.530106     -0.634679      -55.1332       55.1332       590.730       645.863    
  16  0.325231      -1.12322      -97.5716       97.5716       605.948       703.519    
  17  0.293550      -1.22571      -106.475       106.475       488.675       595.149    
  18  0.194161      -1.63907      -142.382       142.382       572.886       715.268    
  19  0.589029E-01  -2.83186      -245.998       245.998       632.888       878.886    
  20  0.385142     -0.954143      -82.8843       82.8843       579.118       662.003    
  21  0.287461      -1.24667      -108.295       108.295       586.739       695.034    
  22  0.528518     -0.637678      -55.3937       55.3937       582.846       638.240    
  23  0.517042     -0.659630      -57.3006       57.3006       615.561       672.862    
  24  0.453375     -0.791035      -68.7154       68.7154       591.432       660.147    
  25  0.695596     -0.362986      -31.5318       31.5318       582.368       613.900    
  26  0.645178     -0.438228      -38.0679       38.0679       548.945       587.013    
  27  0.696076     -0.362297      -31.4719       31.4719       616.461       647.933    
  28  0.483522     -0.726659      -63.1232       63.1232       626.714       689.837    
  29  0.155396E-01  -4.16436      -361.749       361.749       540.286       902.035    
  30  0.883154     -0.124256      -10.7938       10.7938       579.118       589.912    
  31  0.525944     -0.642561      -55.8179       55.8179       488.891       544.709    
loop,thermsimp(1:2)       30   280.404       29.4229    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     78        464.41         73.80          1.00         38.75          0.84          0.05        114.46
Just calling func    0   0        114.46


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    464.41
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    86.8678                91
loop is:       30
neval is:       77
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       30      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    86.8678                91
loop is:       31
neval is:       77


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       77      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.248581      -1.39199      -120.919       120.919       384.612       505.531    
   2  0.247647      -1.39575      -121.246       121.246       493.234       614.480    
   3  0.396263     -0.925678      -80.4116       80.4116       480.507       560.918    
   4  0.386461     -0.950723      -82.5872       82.5872       439.306       521.893    
   5  0.729285     -0.315691      -27.4233       27.4233       484.301       511.724    
   6  0.665866     -0.406667      -35.3263       35.3263       499.703       535.029    
   7  0.385122     -0.954194      -82.8887       82.8887       511.020       593.909    
   8  0.625701     -0.468883      -40.7308       40.7308       488.891       529.622    
   9  0.392668     -0.934792      -81.2033       81.2033       536.644       617.848    
  10  0.698356     -0.359026      -31.1878       31.1878       539.254       570.442    
  11  0.537534E-01  -2.92335      -253.945       253.945       471.666       725.611    
  12  0.289307      -1.24027      -107.739       107.739       548.945       656.684    
  13  0.138460E-01  -4.27976      -371.773       371.773       579.118       950.892    
  14  0.824110     -0.193451      -16.8046       16.8046       488.675       505.479    
  15  0.560983     -0.578065      -50.2152       50.2152       504.066       554.281    
  16  0.116087E-01  -4.45600      -387.083       387.083       582.368       969.451    
  17  0.218033      -1.52311      -132.309       132.309       582.846       715.155    
  18  0.893705E-01  -2.41497      -209.783       209.783       590.730       800.512    
  19  0.304886      -1.18782      -103.183       103.183       616.461       719.644    
  20  0.179833      -1.71573      -149.042       149.042       591.432       740.473    
  21  0.867378     -0.142281      -12.3596       12.3596       579.118       591.478    
  22  0.243287      -1.41351      -122.789       122.789       489.342       612.131    
  23  0.772489     -0.258138      -22.4238       22.4238       615.561       637.985    
  24  0.321011      -1.13628      -98.7062       98.7062       626.714       725.420    
  25  0.499417     -0.694314      -60.3135       60.3135       586.739       647.052    
  26  0.396806     -0.924307      -80.2925       80.2925       605.948       686.240    
  27  0.580203E-01  -2.84696      -247.309       247.309       572.886       820.195    
  28  0.854206     -0.157583      -13.6889       13.6889       453.721       467.410    
  29  0.914649     -0.892145E-01  -7.74986       7.74986       632.888       640.638    
  30  0.167601      -1.78617      -155.161       155.161       540.286       695.446    
  31  0.350137      -1.04943      -91.1617       91.1617       464.413       555.575    
loop,thermsimp(1:2)       31   120.919       121.246    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     79        471.53         73.93          1.03         38.59          0.27          0.04        113.86
Just calling func    0   0        113.86


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     80        507.92         73.43          1.01         38.80          0.35          0.04        113.63
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    471.53
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    86.8678                91
loop is:       31
neval is:       79
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       31      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    86.8678                91
loop is:       32
neval is:       79


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       79      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.996070     -0.393760E-02 -0.342050      0.342050       453.721       454.063    
   2  0.758684E-02  -4.88134      -424.031       424.031       488.675       912.706    
   3  0.404439     -0.905254      -78.6374       78.6374       384.612       463.249    
   4  0.947917E-01  -2.35607      -204.667       204.667       484.301       688.968    
   5  0.834417     -0.181022      -15.7250       15.7250       439.306       455.031    
   6  0.891274     -0.115104      -9.99881       9.99881       488.891       498.890    
   7  0.744451     -0.295108      -25.6354       25.6354       499.703       525.338    
   8  0.559638     -0.580466      -50.4238       50.4238       504.066       554.490    
   9  0.821724     -0.196351      -17.0565       17.0565       464.413       481.470    
  10  0.847292     -0.165710      -14.3948       14.3948       480.507       494.901    
  11  0.661676     -0.412979      -35.8746       35.8746       539.254       575.129    
  12  0.993427     -0.659478E-02 -0.572874      0.572874       579.118       579.691    
  13  0.425996     -0.853326      -74.1266       74.1266       511.020       585.147    
  14  0.673132     -0.395813      -34.3834       34.3834       489.342       523.725    
  15  0.234810      -1.44898      -125.870       125.870       493.234       619.103    
  16  0.122926      -2.09617      -182.090       182.090       536.644       718.734    
  17  0.523553     -0.647118      -56.2137       56.2137       615.561       671.775    
  18  0.959317     -0.415333E-01  -3.60791       3.60791       632.888       636.496    
  19  0.321726      -1.13406      -98.5129       98.5129       586.739       685.252    
  20  0.493112     -0.707018      -61.4171       61.4171       548.945       610.362    
  21  0.416134     -0.876748      -76.1611       76.1611       605.948       682.109    
  22  0.409432     -0.892985      -77.5716       77.5716       540.286       617.857    
  23  0.657956     -0.418617      -36.3643       36.3643       582.846       619.210    
  24  0.904324     -0.100567      -8.73607       8.73607       616.461       625.197    
  25  0.714426     -0.336276      -29.2116       29.2116       626.714       655.925    
  26  0.150521      -1.89365      -164.497       164.497       471.666       636.163    
  27  0.758740     -0.276096      -23.9838       23.9838       591.432       615.415    
  28  0.359105      -1.02414      -88.9648       88.9648       590.730       679.695    
  29  0.666937     -0.405060      -35.1866       35.1866       572.886       608.073    
  30  0.343213      -1.06940      -92.8967       92.8967       579.118       672.015    
  31  0.484849     -0.723918      -62.8852       62.8852       471.530       534.415    
loop,thermsimp(1:2)       32  0.342050       424.031    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     81        515.71         73.32          1.00         38.70          0.94          0.04        114.00
Just calling func    0   0        114.00


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

   80    515.71        2.034     -1.619      5.164     -100.8      1.130    
                     -0.6352      2.694     -99.86      2.947      1.725    
                       1.520     -1.578      1.864      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1314E+05 0.1152E+05 -1769.    -0.3932E+05
                      -2.000     -4.696     -3.989     -6.471     -2.072    
                      -12.97     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                     -0.6393     -1.139      2.193      1.519      0.000    
                       0.000      9.205      9.124     -4053.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -5587.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6585.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3519.      1.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    515.71
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    86.8678                91
loop is:       32
neval is:       80
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       32      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    86.8678                91
loop is:       33
neval is:       80


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       80      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.455591     -0.786160      -68.2920       68.2920       453.721       522.013    
   2  0.588265E-01  -2.83316      -246.111       246.111       439.306       685.417    
   3  0.787103E-01  -2.54198      -220.816       220.816       384.612       605.428    
   4  0.597713     -0.514644      -44.7060       44.7060       464.413       509.119    
   5  0.110741      -2.20056      -191.158       191.158       480.507       671.665    
   6  0.677861     -0.388813      -33.7753       33.7753       488.891       522.667    
   7  0.307724      -1.17855      -102.378       102.378       489.342       591.720    
   8  0.550587     -0.596770      -51.8401       51.8401       499.703       551.543    
   9  0.601295     -0.508669      -44.1870       44.1870       471.530       515.717    
  10  0.487121     -0.719243      -62.4790       62.4790       504.066       566.545    
  11  0.146295      -1.92213      -166.971       166.971       539.254       706.225    
  12  0.714050     -0.336802      -29.2572       29.2572       579.118       608.376    
  13  0.723089     -0.324223      -28.1645       28.1645       511.020       539.185    
  14  0.805432     -0.216376      -18.7961       18.7961       572.886       591.682    
  15  0.123280      -2.09329      -181.840       181.840       548.945       730.785    
  16  0.853039     -0.158950      -13.8077       13.8077       591.432       605.239    
  17  0.288289      -1.24379      -108.045       108.045       540.286       648.331    
  18  0.705126     -0.349379      -30.3498       30.3498       493.234       523.584    
  19  0.772420     -0.258227      -22.4316       22.4316       582.846       605.278    
  20  0.962845     -0.378631E-01  -3.28909       3.28909       616.461       619.750    
  21  0.245802      -1.40323      -121.895       121.895       471.666       593.561    
  22  0.752702     -0.284087      -24.6780       24.6780       632.888       657.566    
  23  0.729896     -0.314853      -27.3505       27.3505       626.714       654.064    
  24  0.869278     -0.140092      -12.1695       12.1695       615.561       627.731    
  25  0.597817E-01  -2.81706      -244.711       244.711       579.118       823.830    
  26  0.984108     -0.160195E-01  -1.39158       1.39158       590.730       592.121    
  27  0.278288      -1.27910      -111.112       111.112       605.948       717.060    
  28  0.588278     -0.530555      -46.0881       46.0881       586.739       632.827    
  29  0.807614     -0.213671      -18.5611       18.5611       484.301       502.862    
  30  0.428679     -0.847047      -73.5811       73.5811       536.644       610.226    
  31  0.452991     -0.791883      -68.7891       68.7891       515.714       584.504    
loop,thermsimp(1:2)       33   68.2920       246.111    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     82        469.33         73.72          1.01         38.58          0.88          0.05        114.23
Just calling func    0   0        114.23


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     83        465.72         74.18          1.04         38.56          0.19          0.04        114.01
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    465.72
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    86.8678                91
loop is:       33
neval is:       82
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       33      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    86.8678                91
loop is:       34
neval is:       82


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       82      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.961594E-01  -2.34175      -203.422       203.422       484.301       687.723    
   2  0.298819      -1.20792      -104.929       104.929       464.413       569.342    
   3  0.706385     -0.347595      -30.1948       30.1948       471.530       501.725    
   4  0.958764     -0.421100E-01  -3.65800       3.65800       453.721       457.379    
   5  0.306496      -1.18255      -102.726       102.726       488.891       591.617    
   6  0.905447     -0.993270E-01  -8.62831       8.62831       493.234       501.862    
   7  0.234113      -1.45195      -126.128       126.128       511.020       637.148    
   8  0.704141     -0.350777      -30.4712       30.4712       499.703       530.174    
   9  0.908200     -0.962902E-01  -8.36451       8.36451       504.066       512.431    
  10  0.656383     -0.421011      -36.5723       36.5723       515.714       552.287    
  11  0.967894     -0.326327E-01  -2.83473       2.83473       572.886       575.721    
  12  0.754670     -0.281475      -24.4511       24.4511       489.342       513.793    
  13  0.488960     -0.715475      -62.1517       62.1517       590.730       652.881    
  14  0.451577     -0.795009      -69.0606       69.0606       471.666       540.727    
  15  0.387599E-01  -3.25037      -282.352       282.352       591.432       873.784    
  16  0.210942E-02  -6.16134      -535.222       535.222       582.846       1118.07    
  17  0.656530     -0.420787      -36.5528       36.5528       384.612       421.165    
  18  0.181246      -1.70790      -148.362       148.362       579.118       727.480    
  19  0.758879     -0.275913      -23.9679       23.9679       536.644       560.612    
  20  0.392052     -0.936362      -81.3396       81.3396       616.461       697.800    
  21  0.406710     -0.899654      -78.1509       78.1509       615.561       693.712    
  22  0.830107     -0.186201      -16.1748       16.1748       586.739       602.914    
  23  0.311833      -1.16529      -101.226       101.226       540.286       641.512    
  24  0.945407     -0.561396E-01  -4.87673       4.87673       626.714       631.591    
  25  0.303319      -1.19297      -103.631       103.631       632.888       736.519    
  26  0.284230      -1.25797      -109.277       109.277       480.507       589.784    
  27  0.292492      -1.22932      -106.788       106.788       439.306       546.094    
  28  0.401496     -0.912557      -79.2718       79.2718       539.254       618.526    
  29  0.379648     -0.968510      -84.1323       84.1323       605.948       690.080    
  30  0.723496E-01  -2.62625      -228.136       228.136       548.945       777.081    
  31  0.940338     -0.615157E-01  -5.34373       5.34373       465.723       471.067    
loop,thermsimp(1:2)       34   203.422       104.929    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     84        440.97         73.54          1.00         38.56          1.03          0.05        114.17
Just calling func    0   0        114.17


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     85        464.62         73.34          1.00         38.85          0.92          0.05        114.15
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    440.97
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    86.8678                91
loop is:       34
neval is:       84
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       34      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    86.8678                91
loop is:       35
neval is:       84


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       84      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.348096      -1.05528      -91.6696       91.6696       384.612       476.282    
   2  0.175000      -1.74297      -151.408       151.408       453.721       605.129    
   3  0.131587      -2.02809      -176.176       176.176       465.723       641.899    
   4  0.301717      -1.19826      -104.091       104.091       471.530       575.621    
   5  0.166877      -1.79050      -155.537       155.537       493.234       648.771    
   6  0.481073     -0.731736      -63.5642       63.5642       504.066       567.630    
   7  0.706381     -0.347600      -30.1953       30.1953       489.342       519.537    
   8  0.702617     -0.352943      -30.6594       30.6594       499.703       530.362    
   9  0.552795     -0.592767      -51.4924       51.4924       471.666       523.159    
  10  0.495420     -0.702349      -61.0115       61.0115       439.306       500.318    
  11  0.479343     -0.735339      -63.8772       63.8772       515.714       579.592    
  12  0.462659     -0.770765      -66.9547       66.9547       536.644       603.599    
  13  0.631315E-01  -2.76253      -239.975       239.975       464.413       704.388    
  14  0.785681     -0.241205      -20.9529       20.9529       572.886       593.839    
  15  0.767932     -0.264055      -22.9378       22.9378       480.507       503.444    
  16  0.262689E-01  -3.63937      -316.144       316.144       488.891       805.035    
  17  0.871353     -0.137708      -11.9624       11.9624       586.739       598.701    
  18  0.618350     -0.480701      -41.7574       41.7574       539.254       581.012    
  19  0.196090      -1.62918      -141.524       141.524       626.714       768.237    
  20  0.925050     -0.779078E-01  -6.76768       6.76768       511.020       517.788    
  21  0.903269     -0.101735      -8.83750       8.83750       540.286       549.123    
  22  0.958828     -0.420436E-01  -3.65223       3.65223       590.730       594.382    
  23  0.969274     -0.312081E-01  -2.71098       2.71098       484.301       487.012    
  24  0.313932      -1.15858      -100.643       100.643       605.948       706.591    
  25  0.106324      -2.24126      -194.694       194.694       615.561       810.255    
  26  0.718705     -0.330304      -28.6928       28.6928       616.461       645.153    
  27  0.751116     -0.286195      -24.8611       24.8611       579.118       603.979    
  28  0.996391     -0.361592E-02 -0.314107      0.314107       632.888       633.202    
  29  0.313387      -1.16032      -100.794       100.794       548.945       649.739    
  30  0.305057      -1.18726      -103.134       103.134       591.432       694.566    
  31  0.408833     -0.894447      -77.6986       77.6986       440.973       518.671    
loop,thermsimp(1:2)       35   91.6696       151.408    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     86        435.32         73.53          1.00         39.05          0.76          0.05        114.38
Just calling func    0   0        114.38


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     87        472.76         74.81          1.09         37.99          0.10          0.06        114.05
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    435.32
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    86.8678                91
loop is:       35
neval is:       86
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       35      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    86.8678                91
loop is:       36
neval is:       86


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       86      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.757905E-01  -2.57978      -224.100       224.100       384.612       608.712    
   2  0.962370     -0.383559E-01  -3.33189       3.33189       484.301       487.633    
   3  0.356737      -1.03076      -89.5394       89.5394       439.306       528.846    
   4  0.884319     -0.122937      -10.6793       10.6793       480.507       491.186    
   5  0.919725E-01  -2.38627      -207.290       207.290       511.020       718.310    
   6  0.900184     -0.105156      -9.13466       9.13466       440.973       450.107    
   7  0.390055     -0.941468      -81.7832       81.7832       489.342       571.125    
   8  0.263976      -1.33190      -115.699       115.699       471.666       587.365    
   9  0.898455     -0.107078      -9.30166       9.30166       499.703       509.004    
  10  0.697674E-01  -2.66259      -231.293       231.293       540.286       771.579    
  11  0.888938     -0.117727      -10.2267       10.2267       504.066       514.293    
  12  0.824147     -0.193406      -16.8007       16.8007       471.530       488.331    
  13  0.941109     -0.606968E-01  -5.27260       5.27260       515.714       520.987    
  14  0.885654     -0.121429      -10.5482       10.5482       539.254       549.803    
  15  0.798208     -0.225386      -19.5787       19.5787       572.886       592.465    
  16  0.365331      -1.00695      -87.4717       87.4717       590.730       678.201    
  17  0.519490     -0.654907      -56.8903       56.8903       586.739       643.629    
  18  0.922741     -0.804065E-01  -6.98473       6.98473       536.644       543.629    
  19  0.877443     -0.130744      -11.3574       11.3574       579.118       590.476    
  20  0.584844     -0.536410      -46.5968       46.5968       453.721       500.318    
  21  0.671390     -0.398406      -34.6086       34.6086       632.888       667.497    
  22  0.203335      -1.59290      -138.372       138.372       465.723       604.095    
  23  0.330236E-01  -3.41053      -296.265       296.265       616.461       912.726    
  24  0.879725     -0.128146      -11.1318       11.1318       493.234       504.366    
  25  0.833976     -0.181550      -15.7709       15.7709       548.945       564.716    
  26  0.901698     -0.103475      -8.98866       8.98866       591.432       600.420    
  27  0.692847     -0.366946      -31.8758       31.8758       464.413       496.289    
  28  0.550572     -0.596797      -51.8424       51.8424       605.948       657.790    
  29  0.158383E-01  -4.14532      -360.095       360.095       626.714       986.809    
  30  0.503246     -0.686677      -59.6501       59.6501       488.891       548.541    
  31  0.648812     -0.432612      -37.5801       37.5801       435.322       472.902    
loop,thermsimp(1:2)       36   224.100       3.33189    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     88        729.23         73.52          1.00         38.98          0.49          0.06        114.05
Just calling func    0   0        114.05


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    729.23
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    86.8678                91
loop is:       36
neval is:       87
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       36      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    86.8678                91
loop is:       37
neval is:       87


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       87      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.939165     -0.627646E-01  -5.45222       5.45222       440.973       446.425    
   2  0.112532E-01  -4.48710      -389.784       389.784       435.322       825.106    
   3  0.907929     -0.965891E-01  -8.39047       8.39047       484.301       492.691    
   4  0.478640     -0.736807      -64.0048       64.0048       471.530       535.535    
   5  0.737686     -0.304237      -26.4284       26.4284       480.507       506.935    
   6  0.114880      -2.16387      -187.970       187.970       464.413       652.383    
   7  0.309837      -1.17171      -101.784       101.784       453.721       555.505    
   8  0.469091     -0.756958      -65.7552       65.7552       493.234       558.989    
   9  0.721151     -0.326907      -28.3977       28.3977       499.703       528.100    
  10  0.557251     -0.584740      -50.7951       50.7951       504.066       554.861    
  11  0.581534     -0.542085      -47.0897       47.0897       515.714       562.804    
  12  0.501412     -0.690326      -59.9671       59.9671       439.306       499.273    
  13  0.783062     -0.244543      -21.2429       21.2429       536.644       557.887    
  14  0.571322     -0.559803      -48.6288       48.6288       488.891       537.520    
  15  0.902729E-01  -2.40492      -208.910       208.910       539.254       748.164    
  16  0.695403E-01  -2.66585      -231.576       231.576       548.945       780.521    
  17  0.128872      -2.04894      -177.987       177.987       489.342       667.329    
  18  0.940828E-01  -2.36358      -205.319       205.319       471.666       676.985    
  19  0.326350      -1.11979      -97.2732       97.2732       579.118       676.392    
  20  0.102915      -2.27385      -197.525       197.525       572.886       770.411    
  21  0.324524      -1.12540      -97.7606       97.7606       591.432       689.192    
  22  0.259454      -1.34918      -117.200       117.200       465.723       582.923    
  23  0.782812     -0.244863      -21.2707       21.2707       384.612       405.883    
  24  0.383591     -0.958178      -83.2348       83.2348       586.739       669.973    
  25  0.626880     -0.466999      -40.5672       40.5672       605.948       646.515    
  26  0.292269      -1.23008      -106.854       106.854       632.888       739.743    
  27  0.448852     -0.801062      -69.5865       69.5865       590.730       660.316    
  28  0.685432     -0.377706      -32.8105       32.8105       511.020       543.831    
  29  0.995399     -0.461118E-02 -0.400563      0.400563       540.286       540.686    
  30  0.163323      -1.81203      -157.407       157.407       616.461       773.868    
  31  0.952940     -0.482038E-01  -4.18735       4.18735       729.234       733.421    
loop,thermsimp(1:2)       37   5.45222       389.784    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     89        612.77         73.34          1.00         38.67          1.15          0.06        114.21
Just calling func    0   0        114.21


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    612.77
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    86.8678                91
loop is:       37
neval is:       88
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       37      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    86.8678                91
loop is:       38
neval is:       88


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       88      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.371753     -0.989525      -85.9578       85.9578       384.612       470.570    
   2  0.687927     -0.374072      -32.4948       32.4948       440.973       473.468    
   3  0.288957      -1.24148      -107.844       107.844       484.301       592.145    
   4  0.192838      -1.64590      -142.976       142.976       439.306       582.282    
   5  0.369869     -0.994607      -86.3993       86.3993       480.507       566.906    
   6  0.735973     -0.306562      -26.6303       26.6303       499.703       526.333    
   7  0.637144     -0.450760      -39.1565       39.1565       471.530       510.687    
   8  0.703934     -0.351071      -30.4967       30.4967       488.891       519.388    
   9  0.864279     -0.145859      -12.6705       12.6705       540.286       552.956    
  10  0.473452     -0.747705      -64.9514       64.9514       511.020       575.971    
  11  0.242010      -1.41877      -123.246       123.246       504.066       627.312    
  12  0.510769     -0.671838      -58.3611       58.3611       453.721       512.082    
  13  0.829624     -0.186782      -16.2254       16.2254       536.644       552.870    
  14  0.228911      -1.47442      -128.080       128.080       493.234       621.314    
  15  0.310006      -1.17116      -101.736       101.736       515.714       617.451    
  16  0.248341      -1.39295      -121.003       121.003       465.723       586.726    
  17  0.723214     -0.324050      -28.1495       28.1495       605.948       634.097    
  18  0.420900     -0.865360      -75.1719       75.1719       464.413       539.585    
  19  0.133903      -2.01064      -174.659       174.659       590.730       765.389    
  20  0.571916     -0.558763      -48.5385       48.5385       489.342       537.881    
  21  0.609104     -0.495766      -43.0660       43.0660       586.739       629.805    
  22  0.582057     -0.541186      -47.0116       47.0116       579.118       626.130    
  23  0.440731     -0.819321      -71.1726       71.1726       471.666       542.839    
  24  0.211006      -1.55587      -135.155       135.155       591.432       726.586    
  25  0.665769     -0.406813      -35.3389       35.3389       729.234       764.573    
  26  0.766062     -0.266493      -23.1496       23.1496       632.888       656.038    
  27  0.321416E-01  -3.43760      -298.617       298.617       539.254       837.871    
  28  0.165897E-01  -4.09897      -356.069       356.069       572.886       928.954    
  29  0.634553     -0.454835      -39.5105       39.5105       616.461       655.971    
  30  0.981834     -0.183335E-01  -1.59259       1.59259       548.945       550.537    
  31  0.511720     -0.669978      -58.1995       58.1995       612.767       670.966    
loop,thermsimp(1:2)       38   85.9578       32.4948    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     90        449.01         73.42          1.00         38.86          0.80          0.06        114.14
Just calling func    0   0        114.14


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     91        413.92         73.90          1.05         38.82          0.03          0.05        113.86
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    413.92
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    86.8678                91
loop is:       38
neval is:       90
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       38      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    86.8678                91
loop is:       39
neval is:       90


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       90      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.724264     -0.322600      -28.0235       28.0235       384.612       412.636    
   2  0.309663      -1.17227      -101.832       101.832       440.973       542.805    
   3  0.688114     -0.373801      -32.4712       32.4712       471.530       504.001    
   4  0.677876     -0.388791      -33.7734       33.7734       453.721       487.495    
   5  0.283701      -1.25984      -109.439       109.439       488.891       598.330    
   6  0.183733      -1.69427      -147.177       147.177       499.703       646.880    
   7  0.243414      -1.41299      -122.743       122.743       489.342       612.086    
   8  0.785389     -0.241576      -20.9851       20.9851       464.413       485.398    
   9  0.258033      -1.35467      -117.677       117.677       471.666       589.343    
  10  0.137887      -1.98132      -172.113       172.113       548.945       721.058    
  11  0.386520     -0.950573      -82.5741       82.5741       536.644       619.219    
  12  0.882934     -0.124505      -10.8155       10.8155       540.286       551.101    
  13  0.395106     -0.928602      -80.6655       80.6655       480.507       561.172    
  14  0.107633      -2.22903      -193.631       193.631       511.020       704.651    
  15  0.434094     -0.834495      -72.4907       72.4907       439.306       511.797    
  16  0.558484     -0.582529      -50.6030       50.6030       465.723       516.327    
  17  0.102706      -2.27589      -197.701       197.701       484.301       682.002    
  18  0.325804      -1.12146      -97.4186       97.4186       515.714       613.133    
  19  0.693871     -0.365469      -31.7474       31.7474       493.234       524.981    
  20  0.832622     -0.183176      -15.9121       15.9121       579.118       595.030    
  21  0.691207     -0.369316      -32.0816       32.0816       504.066       536.148    
  22  0.903946     -0.100985      -8.77236       8.77236       586.739       595.511    
  23  0.258785E-01  -3.65434      -317.444       317.444       605.948       923.392    
  24  0.247338      -1.39700      -121.354       121.354       616.461       737.815    
  25  0.861464     -0.149122      -12.9539       12.9539       632.888       645.842    
  26  0.954919     -0.461290E-01  -4.00712       4.00712       612.767       616.774    
  27  0.579638     -0.545352      -47.3735       47.3735       591.432       638.805    
  28  0.537182     -0.621418      -53.9812       53.9812       729.234       783.215    
  29  0.407710     -0.897199      -77.9377       77.9377       590.730       668.667    
  30  0.958466     -0.424211E-01  -3.68502       3.68502       539.254       542.939    
  31  0.884674     -0.122536      -10.6444       10.6444       413.918       424.562    
loop,thermsimp(1:2)       39   28.0235       101.832    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     92        514.73         73.41          1.02         38.96          0.39          0.05        113.83
Just calling func    0   0        113.83


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     93      12822.11         73.68          1.01         38.77          0.78          0.05        114.30
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    514.73
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    86.8678                91
loop is:       39
neval is:       92
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       39      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    86.8678                91
loop is:       40
neval is:       92


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 




neval>tstepnex so lower away!t
---> lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
     new SAtemp,tstepnext are :    43.4339               121

 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      121
neval,tstepnext:       92     121

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.954632     -0.464296E-01  -2.01662       2.01662       384.612       386.629    
   2  0.450411     -0.797594      -34.6426       34.6426       413.918       448.560    
   3  0.691912E-01  -2.67088      -116.007       116.007       464.413       580.420    
   4  0.740935     -0.299842      -13.0233       13.0233       453.721       466.744    
   5  0.452531     -0.792898      -34.4387       34.4387       471.530       505.969    
   6  0.461330     -0.773642      -33.6023       33.6023       439.306       472.908    
   7  0.102999      -2.27303      -98.7267       98.7267       465.723       564.450    
   8  0.475106     -0.744217      -32.3242       32.3242       493.234       525.558    
   9  0.240275      -1.42597      -61.9354       61.9354       504.066       566.002    
  10  0.276707E-01  -3.58738      -155.814       155.814       440.973       596.787    
  11  0.132701E-01  -4.32224      -187.732       187.732       539.254       726.986    
  12  0.997219     -0.278509E-02 -0.120967      0.120967       540.286       540.407    
  13  0.563305     -0.573934      -24.9282       24.9282       480.507       505.435    
  14  0.347949      -1.05570      -45.8532       45.8532       471.666       517.519    
  15  0.546018     -0.605103      -26.2820       26.2820       579.118       605.400    
  16  0.343968      -1.06721      -46.3529       46.3529       586.739       633.092    
  17  0.945234     -0.563230E-01  -2.44632       2.44632       488.891       491.338    
  18  0.346208      -1.06072      -46.0710       46.0710       489.342       535.413    
  19  0.406433     -0.900337      -39.1051       39.1051       515.714       554.820    
  20  0.632259     -0.458455      -19.9125       19.9125       612.767       632.679    
  21  0.983930     -0.162002E-01 -0.703637      0.703637       536.644       537.348    
  22  0.200798      -1.60546      -69.7312       69.7312       591.432       661.163    
  23  0.223962      -1.49628      -64.9891       64.9891       632.888       697.877    
  24  0.594322     -0.520335      -22.6002       22.6002       499.703       522.303    
  25  0.875298     -0.133191      -5.78500       5.78500       590.730       596.515    
  26  0.327822      -1.11529      -48.4412       48.4412       484.301       532.742    
  27  0.215105      -1.53663      -66.7417       66.7417       511.020       577.762    
  28  0.905181     -0.996198E-01  -4.32688       4.32688       548.945       553.272    
  29  0.699086     -0.357981      -15.5485       15.5485       616.461       632.009    
  30  0.747401     -0.291154      -12.6459       12.6459       729.234       741.880    
  31  0.699189     -0.357834      -15.5421       15.5421       514.733       530.275    
loop,thermsimp(1:2)       40   2.01662       34.6426    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     94        589.78         73.53          0.99         38.82          0.48          0.05        113.88
Just calling func    0   0        113.88


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    589.78
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    43.4339               121
loop is:       40
neval is:       93
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       40      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    43.4339               121
loop is:       41
neval is:       93


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      121
neval,tstepnext:       93     121

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.357965      -1.02732      -44.6205       44.6205       384.612       429.233    
   2  0.414955     -0.879585      -38.2038       38.2038       413.918       452.122    
   3  0.407443     -0.897854      -38.9973       38.9973       453.721       492.718    
   4  0.883897     -0.123414      -5.36036       5.36036       439.306       444.667    
   5  0.520045     -0.653840      -28.3988       28.3988       488.891       517.290    
   6  0.634521     -0.454885      -19.7574       19.7574       480.507       500.264    
   7  0.344406      -1.06594      -46.2977       46.2977       471.530       517.828    
   8  0.545595     -0.605879      -26.3157       26.3157       471.666       497.982    
   9  0.766876     -0.265430      -11.5286       11.5286       499.703       511.231    
  10  0.639043     -0.447783      -19.4490       19.4490       493.234       512.683    
  11  0.850701     -0.161694      -7.02302       7.02302       514.733       521.756    
  12  0.832060     -0.183851      -7.98536       7.98536       484.301       492.286    
  13  0.728209     -0.317167      -13.7758       13.7758       489.342       503.118    
  14  0.531327     -0.632378      -27.4666       27.4666       536.644       564.111    
  15  0.188974E-01  -3.96873      -172.377       172.377       540.286       712.663    
  16  0.246817      -1.39911      -60.7686       60.7686       548.945       609.713    
  17  0.935336     -0.668496E-01  -2.90354       2.90354       515.714       518.618    
  18  0.730823     -0.313585      -13.6202       13.6202       465.723       479.344    
  19  0.482288     -0.729213      -31.6726       31.6726       504.066       535.739    
  20  0.782974E-04  -9.45500      -410.667       410.667       511.020       921.687    
  21  0.258744      -1.35192      -58.7190       58.7190       464.413       523.132    
  22  0.389044     -0.944063      -41.0043       41.0043       590.730       631.734    
  23  0.611459E-01  -2.79449      -121.376       121.376       440.973       562.348    
  24  0.124922      -2.08006      -90.3453       90.3453       579.118       669.464    
  25  0.253683      -1.37167      -59.5769       59.5769       616.461       676.038    
  26  0.781437     -0.246621      -10.7117       10.7117       612.767       623.478    
  27  0.835634     -0.179565      -7.79920       7.79920       586.739       594.538    
  28  0.542030     -0.612434      -26.6004       26.6004       591.432       618.032    
  29  0.463443     -0.769071      -33.4037       33.4037       632.888       666.292    
  30  0.120587      -2.11538      -91.8793       91.8793       539.254       631.134    
  31  0.733316     -0.310178      -13.4722       13.4722       589.778       603.250    
loop,thermsimp(1:2)       41   44.6205       38.2038    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     95       1049.03         74.25          1.03         38.64          0.56          0.05        114.54
Just calling func    0   0        114.53


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     96        477.12         73.80          1.02         38.73          0.51          0.06        114.12
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    477.12
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    43.4339               121
loop is:       41
neval is:       95
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       41      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    43.4339               121
loop is:       42
neval is:       95


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      121
neval,tstepnext:       95     121

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.559413E-01  -2.88345      -125.239       125.239       384.612       509.852    
   2  0.688513     -0.373221      -16.2104       16.2104       439.306       455.517    
   3  0.530653     -0.633647      -27.5217       27.5217       413.918       441.440    
   4  0.542886     -0.610856      -26.5318       26.5318       465.723       492.255    
   5  0.603382     -0.505205      -21.9430       21.9430       484.301       506.244    
   6  0.478412     -0.737283      -32.0231       32.0231       453.721       485.744    
   7  0.809657     -0.211144      -9.17082       9.17082       471.666       480.837    
   8  0.764585     -0.268422      -11.6586       11.6586       480.507       492.165    
   9  0.228600      -1.47578      -64.0988       64.0988       489.342       553.441    
  10  0.495526     -0.702136      -30.4965       30.4965       499.703       530.199    
  11  0.368264     -0.998954      -43.3885       43.3885       493.234       536.622    
  12  0.407647     -0.897355      -38.9756       38.9756       488.891       527.867    
  13  0.316165      -1.15149      -50.0137       50.0137       471.530       521.544    
  14  0.458518     -0.779756      -33.8678       33.8678       515.714       549.582    
  15  0.643610     -0.440663      -19.1397       19.1397       514.733       533.873    
  16  0.316553E-01  -3.45285      -149.971       149.971       464.413       614.384    
  17  0.570171     -0.561819      -24.4020       24.4020       504.066       528.468    
  18  0.448642E-01  -3.10412      -134.824       134.824       440.973       575.797    
  19  0.128957      -2.04828      -88.9647       88.9647       536.644       625.609    
  20  0.159422      -1.83620      -79.7534       79.7534       586.739       666.492    
  21  0.154083      -1.87026      -81.2327       81.2327       589.778       671.011    
  22  0.696997     -0.360974      -15.6785       15.6785       548.945       564.623    
  23  0.579421     -0.545727      -23.7030       23.7030       591.432       615.135    
  24  0.528206     -0.638269      -27.7225       27.7225       612.767       640.489    
  25  0.322914      -1.13037      -49.0963       49.0963       539.254       588.351    
  26  0.369562     -0.995437      -43.2357       43.2357       590.730       633.965    
  27  0.134248      -2.00806      -87.2180       87.2180       632.888       720.106    
  28  0.950150     -0.511358E-01  -2.22103       2.22103       579.118       581.339    
  29  0.138040      -1.98021      -86.0083       86.0083       616.461       702.469    
  30  0.316838      -1.14936      -49.9213       49.9213       540.286       590.207    
  31  0.151783      -1.88530      -81.8861       81.8861       477.125       559.011    
loop,thermsimp(1:2)       42   125.239       16.2104    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     97        415.68         73.67          0.99         38.49          1.10          0.06        114.31
Just calling func    0   0        114.31


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     98        486.51         73.50          0.96         38.23          1.23          0.05        113.97
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    415.68
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    43.4339               121
loop is:       42
neval is:       97
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       42      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    43.4339               121
loop is:       43
neval is:       97


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      121
neval,tstepnext:       97     121

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.788601     -0.237495      -10.3153       10.3153       413.918       424.233    
   2  0.796559     -0.227454      -9.87921       9.87921       439.306       449.185    
   3  0.784232     -0.243051      -10.5566       10.5566       471.666       482.223    
   4  0.503549     -0.686074      -29.7989       29.7989       453.721       483.520    
   5  0.468337     -0.758566      -32.9475       32.9475       480.507       513.454    
   6  0.198518      -1.61688      -70.2273       70.2273       465.723       535.951    
   7  0.857529     -0.153700      -6.67579       6.67579       484.301       490.977    
   8  0.845427     -0.167913      -7.29311       7.29311       384.612       391.905    
   9  0.710919     -0.341197      -14.8195       14.8195       471.530       486.350    
  10  0.934107     -0.681640E-01  -2.96063       2.96063       488.891       491.852    
  11  0.565087     -0.570775      -24.7910       24.7910       504.066       528.857    
  12  0.147377      -1.91476      -83.1655       83.1655       499.703       582.868    
  13  0.471965     -0.750851      -32.6124       32.6124       514.733       547.346    
  14  0.287319      -1.24716      -54.1690       54.1690       493.234       547.403    
  15  0.526906     -0.640733      -27.8295       27.8295       515.714       543.544    
  16  0.176999      -1.73161      -75.2106       75.2106       489.342       564.553    
  17  0.868579     -0.140897      -6.11968       6.11968       477.125       483.244    
  18  0.621282     -0.475971      -20.6733       20.6733       548.945       569.618    
  19  0.181881      -1.70440      -74.0289       74.0289       440.973       515.002    
  20  0.565209     -0.570560      -24.7816       24.7816       579.118       603.900    
  21  0.927617     -0.751364E-01  -3.26346       3.26346       539.254       542.518    
  22  0.296120      -1.21699      -52.8586       52.8586       540.286       593.144    
  23  0.152389      -1.88132      -81.7129       81.7129       464.413       546.126    
  24  0.508731     -0.675835      -29.3542       29.3542       591.432       620.786    
  25  0.389654     -0.942496      -40.9363       40.9363       536.644       577.581    
  26  0.770754     -0.260386      -11.3096       11.3096       590.730       602.039    
  27  0.144347      -1.93554      -84.0678       84.0678       612.767       696.834    
  28  0.690124     -0.370884      -16.1089       16.1089       586.739       602.848    
  29  0.882429     -0.125077      -5.43259       5.43259       589.778       595.211    
  30  0.781105     -0.247045      -10.7301       10.7301       616.461       627.191    
  31  0.331946      -1.10278      -47.8981       47.8981       415.681       463.579    
loop,thermsimp(1:2)       43   10.3153       9.87921    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     99        434.45         73.43          0.98         38.77          0.73          0.05        113.98
Just calling func    0   0        113.98


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    434.45
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    43.4339               121
loop is:       43
neval is:       98
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       43      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    43.4339               121
loop is:       44
neval is:       98


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      121
neval,tstepnext:       98     121

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.104987      -2.25392      -97.8965       97.8965       384.612       482.509    
   2  0.780131E-01  -2.55088      -110.795       110.795       413.918       524.712    
   3  0.723689     -0.323394      -14.0463       14.0463       439.306       453.352    
   4  0.439896     -0.821218      -35.6687       35.6687       415.681       451.349    
   5  0.967364     -0.331803E-01  -1.44115       1.44115       471.666       473.107    
   6  0.235884      -1.44441      -62.7365       62.7365       477.125       539.861    
   7  0.311956      -1.16489      -50.5959       50.5959       453.721       504.317    
   8  0.600573     -0.509870      -22.1456       22.1456       471.530       493.676    
   9  0.781739     -0.246234      -10.6949       10.6949       484.301       494.996    
  10  0.505036     -0.683126      -29.6708       29.6708       488.891       518.562    
  11  0.896130     -0.109670      -4.76340       4.76340       480.507       485.270    
  12  0.545040     -0.606897      -26.3599       26.3599       440.973       467.333    
  13  0.338019      -1.08465      -47.1108       47.1108       504.066       551.177    
  14  0.200467      -1.60711      -69.8029       69.8029       465.723       535.526    
  15  0.548763     -0.600089      -26.0642       26.0642       539.254       565.319    
  16  0.897241     -0.108431      -4.70957       4.70957       515.714       520.424    
  17  0.229905      -1.47009      -63.8516       63.8516       464.413       528.265    
  18  0.387828     -0.947193      -41.1403       41.1403       514.733       555.873    
  19  0.789400     -0.236482      -10.2713       10.2713       493.234       503.505    
  20  0.495667     -0.701851      -30.4841       30.4841       489.342       519.826    
  21  0.818926     -0.199761      -8.67641       8.67641       548.945       557.621    
  22  0.181319      -1.70750      -74.1632       74.1632       536.644       610.808    
  23  0.901986     -0.103156      -4.48048       4.48048       499.703       504.183    
  24  0.933790E-01  -2.37109      -102.986       102.986       540.286       643.271    
  25  0.171523      -1.76304      -76.5755       76.5755       589.778       666.354    
  26  0.648450     -0.433170      -18.8142       18.8142       590.730       609.544    
  27  0.777448     -0.251739      -10.9340       10.9340       586.739       597.673    
  28  0.777670     -0.251453      -10.9216       10.9216       579.118       590.040    
  29  0.972420     -0.279672E-01  -1.21473       1.21473       591.432       592.646    
  30  0.825305     -0.192002      -8.33938       8.33938       616.461       624.800    
  31  0.470649     -0.753642      -32.7336       32.7336       434.451       467.184    
loop,thermsimp(1:2)       44   97.8965       110.795    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    100        665.07         73.72          0.99         38.49          1.12          0.05        114.36
Just calling func    0   0        114.36


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    665.07
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    43.4339               121
loop is:       44
neval is:       99
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       44      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    43.4339               121
loop is:       45
neval is:       99


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      121
neval,tstepnext:       99     121

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.872614     -0.136261      -5.91836       5.91836       415.681       421.599    
   2  0.990306     -0.974175E-02 -0.423122      0.423122       439.306       439.729    
   3  0.488656     -0.716096      -31.1028       31.1028       434.451       465.554    
   4  0.865115E-01  -2.44748      -106.303       106.303       440.973       547.276    
   5  0.234262      -1.45132      -63.0363       63.0363       471.666       534.703    
   6  0.906541     -0.981186E-01  -4.26167       4.26167       384.612       388.874    
   7  0.680454     -0.384995      -16.7218       16.7218       480.507       497.228    
   8  0.575574     -0.552388      -23.9924       23.9924       471.530       495.522    
   9  0.537443E-02  -5.22610      -226.990       226.990       484.301       711.291    
  10  0.421676     -0.863518      -37.5060       37.5060       493.234       530.740    
  11  0.297588      -1.21204      -52.6438       52.6438       499.703       552.347    
  12  0.119337      -2.12581      -92.3320       92.3320       453.721       546.053    
  13  0.958276     -0.426192E-01  -1.85112       1.85112       488.891       490.742    
  14  0.115549      -2.15806      -93.7328       93.7328       489.342       583.075    
  15  0.104220      -2.26125      -98.2150       98.2150       515.714       613.930    
  16  0.719503     -0.329194      -14.2982       14.2982       413.918       428.216    
  17  0.875656     -0.132782      -5.76722       5.76722       464.413       470.180    
  18  0.578760     -0.546868      -23.7526       23.7526       465.723       489.476    
  19  0.923704     -0.793639E-01  -3.44708       3.44708       477.125       480.572    
  20  0.457980     -0.780930      -33.9188       33.9188       504.066       537.985    
  21  0.783173     -0.244401      -10.6153       10.6153       514.733       525.348    
  22  0.764479     -0.268561      -11.6646       11.6646       548.945       560.609    
  23  0.496891     -0.699384      -30.3770       30.3770       539.254       569.631    
  24  0.554859     -0.589041      -25.5843       25.5843       579.118       604.703    
  25  0.734503E-02  -4.91373      -213.422       213.422       591.432       804.854    
  26  0.117643      -2.14010      -92.9530       92.9530       586.739       679.692    
  27  0.145440      -1.92799      -83.7401       83.7401       590.730       674.470    
  28  0.375449     -0.979633      -42.5493       42.5493       536.644       579.194    
  29  0.954324E-01  -2.34934      -102.041       102.041       616.461       718.501    
  30  0.449085     -0.800543      -34.7707       34.7707       540.286       575.057    
  31  0.354483      -1.03709      -45.0450       45.0450       665.071       710.116    
loop,thermsimp(1:2)       45   5.91836      0.423122    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    101        426.82         73.53          0.99         38.57          0.62          0.05        113.77
Just calling func    0   0        113.77


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    102        461.88         73.51          0.98         38.44          0.92          0.05        113.90
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  100    426.82        2.073     -1.389      5.378     -101.3      1.453    
                     -0.3894      3.047     -99.84      3.357      1.734    
                       1.862     -1.099      1.642      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1258E+05 0.1637E+05 -42.76    -0.5005E+05
                      -2.000     -4.864     -7.203     -6.920     -2.328    
                      -12.96     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                      -1.118     -1.618      2.074      1.049      0.000    
                       0.000      9.205      9.124     -3396.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -6176.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -9447.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -4699.      1.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    426.82
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    43.4339               121
loop is:       45
neval is:      101
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       45      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    43.4339               121
loop is:       46
neval is:      101


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      121
neval,tstepnext:      101     121

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.880559E-01  -2.42978      -105.535       105.535       384.612       490.147    
   2  0.312747      -1.16236      -50.4859       50.4859       415.681       466.166    
   3  0.317683      -1.14670      -49.8056       49.8056       413.918       463.723    
   4  0.693053     -0.366649      -15.9250       15.9250       439.306       455.231    
   5  0.361881      -1.01644      -44.1479       44.1479       434.451       478.599    
   6  0.127478      -2.05981      -89.4655       89.4655       464.413       553.879    
   7  0.718706     -0.330302      -14.3463       14.3463       477.125       491.471    
   8  0.609419E-01  -2.79783      -121.521       121.521       465.723       587.244    
   9  0.320798      -1.13695      -49.3819       49.3819       488.891       538.273    
  10  0.343503      -1.06856      -46.4117       46.4117       471.530       517.942    
  11  0.671828     -0.397753      -17.2760       17.2760       480.507       497.783    
  12  0.616702     -0.483369      -20.9946       20.9946       514.733       535.728    
  13  0.806358E-01  -2.51781      -109.358       109.358       493.234       602.592    
  14  0.997284     -0.271972E-02 -0.118128      0.118128       471.666       471.784    
  15  0.554344     -0.589969      -25.6247       25.6247       504.066       529.691    
  16  0.411057     -0.889023      -38.6137       38.6137       453.721       492.335    
  17  0.846258E-01  -2.46952      -107.261       107.261       440.973       548.233    
  18  0.737439     -0.304571      -13.2287       13.2287       499.703       512.931    
  19  0.393790     -0.931939      -40.4777       40.4777       548.945       589.422    
  20  0.965947     -0.346467E-01  -1.50484       1.50484       539.254       540.759    
  21  0.150166      -1.89601      -82.3512       82.3512       540.286       622.637    
  22  0.212005      -1.55114      -67.3722       67.3722       536.644       604.017    
  23  0.615060     -0.486036      -21.1104       21.1104       489.342       510.452    
  24  0.382142     -0.961962      -41.7817       41.7817       579.118       620.900    
  25  0.249044      -1.39013      -60.3786       60.3786       515.714       576.093    
  26  0.245943      -1.40266      -60.9228       60.9228       590.730       651.653    
  27  0.108882      -2.21749      -96.3144       96.3144       586.739       683.053    
  28  0.199835      -1.61026      -69.9400       69.9400       665.071       735.011    
  29  0.863954     -0.146235      -6.35157       6.35157       484.301       490.652    
  30  0.392842     -0.934347      -40.5823       40.5823       616.461       657.043    
  31  0.770596     -0.260592      -11.3185       11.3185       426.821       438.140    
loop,thermsimp(1:2)       46   105.535       50.4859    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    103        575.58         73.48          0.98         38.55          1.00          0.05        114.07
Just calling func    0   0        114.07


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    575.58
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    43.4339               121
loop is:       46
neval is:      102
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       46      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    43.4339               121
loop is:       47
neval is:      102


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      121
neval,tstepnext:      102     121

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.419083E-01  -3.17227      -137.784       137.784       426.821       564.605    
   2  0.581082     -0.542864      -23.5787       23.5787       439.306       462.885    
   3  0.690143     -0.370857      -16.1077       16.1077       413.918       430.026    
   4  0.958690     -0.421877E-01  -1.83237       1.83237       415.681       417.513    
   5  0.947492     -0.539367E-01  -2.34268       2.34268       471.666       474.009    
   6  0.253816E-01  -3.67373      -159.564       159.564       434.451       594.015    
   7  0.811950     -0.208316      -9.04797       9.04797       384.612       393.660    
   8  0.448512     -0.801821      -34.8262       34.8262       484.301       519.127    
   9  0.625244     -0.469613      -20.3971       20.3971       477.125       497.522    
  10  0.557627     -0.584065      -25.3682       25.3682       453.721       479.089    
  11  0.762657     -0.270947      -11.7683       11.7683       480.507       492.275    
  12  0.579328     -0.545887      -23.7100       23.7100       489.342       513.052    
  13  0.168395      -1.78144      -77.3750       77.3750       499.703       577.078    
  14  0.993282     -0.674111E-02 -0.292792      0.292792       471.530       471.823    
  15  0.573458     -0.556070      -24.1523       24.1523       504.066       528.218    
  16  0.900456     -0.104854      -4.55419       4.55419       514.733       519.287    
  17  0.961937     -0.388068E-01  -1.68553       1.68553       488.891       490.577    
  18  0.685702     -0.377312      -16.3881       16.3881       539.254       555.642    
  19  0.335644      -1.09171      -47.4170       47.4170       440.973       488.390    
  20  0.726392     -0.319666      -13.8843       13.8843       464.413       478.297    
  21  0.523515     -0.647189      -28.1099       28.1099       515.714       543.824    
  22  0.877914     -0.130206      -5.65537       5.65537       465.723       471.379    
  23  0.893563     -0.112539      -4.88800       4.88800       548.945       553.833    
  24  0.829449     -0.186994      -8.12189       8.12189       493.234       501.356    
  25  0.454457     -0.788653      -34.2543       34.2543       536.644       570.899    
  26  0.261407      -1.34168      -58.2742       58.2742       579.118       637.393    
  27  0.144225      -1.93638      -84.1046       84.1046       540.286       624.391    
  28  0.963744     -0.369299E-01  -1.60401       1.60401       590.730       592.334    
  29  0.267843      -1.31735      -57.2178       57.2178       616.461       673.679    
  30  0.251943E-01  -3.68114      -159.886       159.886       586.739       746.625    
  31  0.321532      -1.13466      -49.2826       49.2826       575.578       624.860    
loop,thermsimp(1:2)       47   137.784       23.5787    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    104        457.05         73.57          0.98         38.51          1.07          0.05        114.19
Just calling func    0   0        114.19


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    457.05
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    43.4339               121
loop is:       47
neval is:      103
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       47      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    43.4339               121
loop is:       48
neval is:      103


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      121
neval,tstepnext:      103     121

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.566816     -0.567720      -24.6583       24.6583       384.612       409.270    
   2  0.216137      -1.53184      -66.5338       66.5338       415.681       482.214    
   3  0.476425     -0.741444      -32.2038       32.2038       413.918       446.122    
   4  0.184047      -1.69256      -73.5146       73.5146       439.306       512.821    
   5  0.722630     -0.324858      -14.1099       14.1099       465.723       479.833    
   6  0.887750     -0.119065      -5.17145       5.17145       471.530       476.701    
   7  0.236344      -1.44247      -62.6520       62.6520       471.666       534.318    
   8  0.798055     -0.225578      -9.79771       9.79771       464.413       474.211    
   9  0.425454     -0.854597      -37.1185       37.1185       453.721       490.840    
  10  0.605701     -0.501368      -21.7764       21.7764       440.973       462.749    
  11  0.742456     -0.297792      -12.9343       12.9343       488.891       501.826    
  12  0.378462E-01  -3.27423      -142.212       142.212       480.507       622.719    
  13  0.341910      -1.07321      -46.6136       46.6136       477.125       523.738    
  14  0.794971E-01  -2.53203      -109.976       109.976       493.234       603.210    
  15  0.586423     -0.533715      -23.1813       23.1813       489.342       512.523    
  16  0.990523     -0.952170E-02 -0.413565      0.413565       484.301       484.714    
  17  0.348475      -1.05419      -45.7875       45.7875       514.733       560.521    
  18  0.998034     -0.196755E-02 -0.854582E-01  0.854582E-01   504.066       504.152    
  19  0.616072     -0.484391      -21.0390       21.0390       515.714       536.753    
  20  0.427239     -0.850411      -36.9366       36.9366       548.945       585.881    
  21  0.598160     -0.513898      -22.3206       22.3206       539.254       561.575    
  22  0.642831     -0.441873      -19.1922       19.1922       426.821       446.013    
  23  0.392766     -0.934541      -40.5907       40.5907       536.644       577.235    
  24  0.738407     -0.303260      -13.1718       13.1718       499.703       512.875    
  25  0.334341      -1.09559      -47.5859       47.5859       590.730       638.316    
  26  0.997912     -0.208996E-02 -0.907749E-01  0.907749E-01   434.451       434.542    
  27  0.492305E-01  -3.01124      -130.790       130.790       540.286       671.076    
  28  0.304734      -1.18832      -51.6131       51.6131       575.578       627.191    
  29  0.159886      -1.83330      -79.6272       79.6272       579.118       658.746    
  30  0.991331     -0.870666E-02 -0.378164      0.378164       616.461       616.839    
  31  0.735164     -0.307662      -13.3630       13.3630       457.048       470.411    
loop,thermsimp(1:2)       48   24.6583       66.5338    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    105        416.69         73.47          0.98         38.24          1.24          0.05        113.98
Just calling func    0   0        113.98


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    416.69
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    43.4339               121
loop is:       48
neval is:      104
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       48      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    43.4339               121
loop is:       49
neval is:      104


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      121
neval,tstepnext:      104     121

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.180970      -1.70942      -74.2468       74.2468       384.612       458.859    
   2  0.335083      -1.09338      -47.4896       47.4896       434.451       481.940    
   3  0.585160     -0.535871      -23.2749       23.2749       426.821       450.096    
   4  0.445729     -0.808044      -35.0965       35.0965       413.918       449.014    
   5  0.963605     -0.370741E-01  -1.61027       1.61027       440.973       442.583    
   6  0.538074     -0.619758      -26.9185       26.9185       457.048       483.967    
   7  0.971443     -0.289729E-01  -1.25841       1.25841       464.413       465.671    
   8  0.817136     -0.201950      -8.77147       8.77147       471.530       480.301    
   9  0.216943      -1.52812      -66.3723       66.3723       465.723       532.096    
  10  0.572311     -0.558074      -24.2393       24.2393       415.681       439.920    
  11  0.511761     -0.669897      -29.0962       29.0962       484.301       513.397    
  12  0.331920E-01  -3.40545      -147.912       147.912       453.721       601.633    
  13  0.662680     -0.411462      -17.8714       17.8714       488.891       506.763    
  14  0.578679     -0.547007      -23.7586       23.7586       504.066       527.825    
  15  0.473979     -0.746592      -32.4274       32.4274       489.342       521.769    
  16  0.243750      -1.41161      -61.3118       61.3118       439.306       500.618    
  17  0.784227     -0.243057      -10.5569       10.5569       499.703       510.260    
  18  0.215065      -1.53682      -66.7498       66.7498       477.125       543.874    
  19  0.813272     -0.206689      -8.97732       8.97732       471.666       480.644    
  20  0.877336     -0.130865      -5.68398       5.68398       515.714       521.398    
  21  0.911070     -0.931357E-01  -4.04524       4.04524       514.733       518.778    
  22  0.424500     -0.856844      -37.2161       37.2161       539.254       576.470    
  23  0.122508      -2.09958      -91.1930       91.1930       536.644       627.837    
  24  0.173199      -1.75331      -76.1532       76.1532       548.945       625.098    
  25  0.243010      -1.41465      -61.4439       61.4439       493.234       554.678    
  26  0.618804     -0.479966      -20.8468       20.8468       616.461       637.307    
  27  0.365303      -1.00703      -43.7391       43.7391       480.507       524.246    
  28  0.178054      -1.72567      -74.9525       74.9525       575.578       650.530    
  29  0.416122     -0.876776      -38.0818       38.0818       590.730       628.811    
  30  0.789287     -0.236625      -10.2776       10.2776       579.118       589.396    
  31  0.786736     -0.239863      -10.4182       10.4182       416.689       427.107    
loop,thermsimp(1:2)       49   74.2468       47.4896    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    106        636.49         73.62          1.00         38.62          0.70          0.05        114.00
Just calling func    0   0        114.00


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    636.49
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    43.4339               121
loop is:       49
neval is:      105
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       49      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    43.4339               121
loop is:       50
neval is:      105


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      121
neval,tstepnext:      105     121

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.317228E-01  -3.45072      -149.878       149.878       416.689       566.567    
   2  0.601445     -0.508421      -22.0827       22.0827       415.681       437.763    
   3  0.651191     -0.428952      -18.6310       18.6310       440.973       459.604    
   4  0.187303      -1.67503      -72.7529       72.7529       413.918       486.671    
   5  0.664603     -0.408566      -17.7456       17.7456       426.821       444.567    
   6  0.945236     -0.563208E-01  -2.44623       2.44623       384.612       387.058    
   7  0.865870     -0.144020      -6.25535       6.25535       464.413       470.668    
   8  0.674117     -0.394351      -17.1282       17.1282       471.530       488.658    
   9  0.959689E-01  -2.34373      -101.797       101.797       471.666       573.464    
  10  0.663337     -0.410472      -17.8284       17.8284       434.451       452.279    
  11  0.384854     -0.954891      -41.4746       41.4746       457.048       498.523    
  12  0.892338     -0.113910      -4.94757       4.94757       439.306       444.254    
  13  0.470837     -0.753243      -32.7163       32.7163       488.891       521.608    
  14  0.262618      -1.33706      -58.0735       58.0735       499.703       557.776    
  15  0.877143     -0.131085      -5.69352       5.69352       484.301       489.994    
  16  0.262102      -1.33902      -58.1589       58.1589       514.733       572.892    
  17  0.306130      -1.18375      -51.4147       51.4147       515.714       567.129    
  18  0.251844      -1.37895      -59.8930       59.8930       489.342       549.235    
  19  0.371147     -0.991157      -43.0498       43.0498       480.507       523.556    
  20  0.244393E-01  -3.71156      -161.208       161.208       504.066       665.274    
  21  0.550903     -0.596197      -25.8951       25.8951       465.723       491.619    
  22  0.509078     -0.675154      -29.3246       29.3246       477.125       506.449    
  23  0.741178     -0.299515      -13.0091       13.0091       493.234       506.243    
  24  0.585965     -0.534496      -23.2152       23.2152       539.254       562.470    
  25  0.602491     -0.506683      -22.0072       22.0072       579.118       601.126    
  26  0.532366     -0.630423      -27.3817       27.3817       453.721       481.103    
  27  0.264247      -1.33087      -57.8048       57.8048       548.945       606.750    
  28  0.468512     -0.758194      -32.9313       32.9313       536.644       569.576    
  29  0.338122      -1.08435      -47.0975       47.0975       590.730       637.827    
  30  0.815455     -0.204008      -8.86088       8.86088       616.461       625.322    
  31  0.126007      -2.07142      -89.9698       89.9698       636.488       726.458    
loop,thermsimp(1:2)       50   149.878       22.0827    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    107        575.58         73.39          0.98         38.56          0.93          0.05        113.91
Just calling func    0   0        113.91


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    575.58
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    43.4339               121
loop is:       50
neval is:      106
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       50      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    43.4339               121
loop is:       51
neval is:      106


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      121
neval,tstepnext:      106     121

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.929295     -0.733287E-01  -3.18495       3.18495       384.612       387.797    
   2  0.669511     -0.401208      -17.4260       17.4260       415.681       433.107    
   3  0.863337E-01  -2.44954      -106.393       106.393       439.306       545.699    
   4  0.279945      -1.27316      -55.2984       55.2984       426.821       482.119    
   5  0.832640     -0.183154      -7.95509       7.95509       434.451       442.406    
   6  0.848933     -0.163775      -7.11340       7.11340       440.973       448.086    
   7  0.141794      -1.95338      -84.8430       84.8430       464.413       549.256    
   8  0.208764      -1.56655      -68.0415       68.0415       453.721       521.763    
   9  0.755787     -0.279996      -12.1613       12.1613       413.918       426.079    
  10  0.177416      -1.72926      -75.1084       75.1084       471.530       546.638    
  11  0.405148     -0.903503      -39.2426       39.2426       484.301       523.543    
  12  0.640380     -0.445693      -19.3582       19.3582       465.723       485.082    
  13  0.548060     -0.601370      -26.1199       26.1199       457.048       483.168    
  14  0.773287     -0.257105      -11.1671       11.1671       493.234       504.401    
  15  0.180768      -1.71054      -74.2954       74.2954       477.125       551.420    
  16  0.135846      -1.99624      -86.7043       86.7043       488.891       575.596    
  17  0.601016     -0.509133      -22.1136       22.1136       480.507       502.620    
  18  0.302263      -1.19646      -51.9668       51.9668       489.342       541.309    
  19  0.189428      -1.66374      -72.2629       72.2629       499.703       571.966    
  20  0.737158     -0.304953      -13.2453       13.2453       539.254       552.500    
  21  0.790680     -0.234862      -10.2010       10.2010       416.689       426.889    
  22  0.177192E-01  -4.03310      -175.173       175.173       515.714       690.888    
  23  0.236042      -1.44375      -62.7075       62.7075       536.644       599.352    
  24  0.459229     -0.778206      -33.8005       33.8005       514.733       548.534    
  25  0.586479E-01  -2.83620      -123.187       123.187       471.666       594.854    
  26  0.263766      -1.33269      -57.8840       57.8840       579.118       637.002    
  27  0.942550     -0.591663E-01  -2.56982       2.56982       548.945       551.515    
  28  0.106855      -2.23628      -97.1303       97.1303       616.461       713.591    
  29  0.710700     -0.341505      -14.8329       14.8329       590.730       605.563    
  30  0.207109E-01  -3.87709      -168.397       168.397       504.066       672.463    
  31  0.901203     -0.104025      -4.51821       4.51821       575.578       580.096    
loop,thermsimp(1:2)       51   3.18495       17.4260    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    108        453.01         73.52          0.99         38.39          1.00          0.05        113.95
Just calling func    0   0        113.95


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    453.01
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    43.4339               121
loop is:       51
neval is:      107
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       51      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    43.4339               121
loop is:       52
neval is:      107


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      121
neval,tstepnext:      107     121

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.658032     -0.418502      -18.1772       18.1772       384.612       402.789    
   2  0.385391     -0.953496      -41.4140       41.4140       413.918       455.332    
   3  0.323679      -1.12800      -48.9935       48.9935       416.689       465.682    
   4  0.402516E-01  -3.21260      -139.536       139.536       415.681       555.216    
   5  0.866022     -0.143846      -6.24777       6.24777       434.451       440.699    
   6  0.560147     -0.579555      -25.1723       25.1723       440.973       466.145    
   7  0.389098     -0.943925      -40.9983       40.9983       426.821       467.819    
   8  0.470755     -0.753417      -32.7238       32.7238       457.048       489.772    
   9  0.794299     -0.230295      -10.0026       10.0026       465.723       475.726    
  10  0.897132     -0.108553      -4.71487       4.71487       480.507       485.221    
  11  0.359474      -1.02311      -44.4378       44.4378       493.234       537.672    
  12  0.604694     -0.503032      -21.8487       21.8487       453.721       475.570    
  13  0.101554      -2.28717      -99.3405       99.3405       484.301       583.641    
  14  0.274480      -1.29288      -56.1546       56.1546       489.342       545.497    
  15  0.916086     -0.876445E-01  -3.80674       3.80674       439.306       443.113    
  16  0.820070E-01  -2.50095      -108.626       108.626       471.530       580.156    
  17  0.975902     -0.243929E-01  -1.05948       1.05948       514.733       515.793    
  18  0.131665      -2.02750      -88.0621       88.0621       464.413       552.475    
  19  0.751313     -0.285933      -12.4192       12.4192       477.125       489.544    
  20  0.775324     -0.254475      -11.0528       11.0528       548.945       559.998    
  21  0.237000      -1.43969      -62.5315       62.5315       539.254       601.786    
  22  0.113641      -2.17471      -94.4560       94.4560       499.703       594.159    
  23  0.762281     -0.271440      -11.7897       11.7897       488.891       500.681    
  24  0.783730     -0.243690      -10.5844       10.5844       575.578       586.162    
  25  0.492891     -0.707468      -30.7281       30.7281       471.666       502.394    
  26  0.471904     -0.750980      -32.6180       32.6180       536.644       569.262    
  27  0.855781     -0.155740      -6.76441       6.76441       590.730       597.494    
  28  0.636473     -0.451814      -19.6240       19.6240       579.118       598.742    
  29  0.433340     -0.836232      -36.3208       36.3208       504.066       540.387    
  30  0.482236     -0.729321      -31.6772       31.6772       515.714       547.392    
  31  0.855143E-01  -2.45907      -106.807       106.807       453.008       559.815    
loop,thermsimp(1:2)       52   18.1772       41.4140    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    109        398.52         73.54          0.94         38.66          0.69          0.05        113.88
Just calling func    0   0        113.88


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    110        420.10         74.00          1.05         38.69          0.00          0.05        113.79
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    398.52
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    43.4339               121
loop is:       52
neval is:      109
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       52      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    43.4339               121
loop is:       53
neval is:      109


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      121
neval,tstepnext:      109     121

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.581749     -0.541717      -23.5289       23.5289       384.612       408.141    
   2  0.307993      -1.17768      -51.1511       51.1511       434.451       485.602    
   3  0.551684     -0.594779      -25.8336       25.8336       439.306       465.140    
   4  0.969976     -0.304835E-01  -1.32402       1.32402       413.918       415.242    
   5  0.401714     -0.912015      -39.6124       39.6124       416.689       456.301    
   6  0.336211      -1.09002      -47.3436       47.3436       440.973       488.316    
   7  0.649191     -0.432028      -18.7646       18.7646       426.821       445.586    
   8  0.426986     -0.851005      -36.9625       36.9625       453.721       490.684    
   9  0.479997     -0.733976      -31.8794       31.8794       465.723       497.603    
  10  0.441527     -0.817516      -35.5079       35.5079       480.507       516.014    
  11  0.218988      -1.51874      -65.9647       65.9647       477.125       543.089    
  12  0.935549     -0.666221E-01  -2.89366       2.89366       457.048       459.942    
  13  0.159996      -1.83261      -79.5973       79.5973       488.891       568.489    
  14  0.486870     -0.719759      -31.2619       31.2619       471.666       502.928    
  15  0.835520     -0.179701      -7.80509       7.80509       514.733       522.538    
  16  0.643759     -0.440431      -19.1296       19.1296       493.234       512.364    
  17  0.177188      -1.73054      -75.1642       75.1642       504.066       579.230    
  18  0.408356     -0.895617      -38.9001       38.9001       489.342       528.242    
  19  0.463768     -0.768371      -33.3734       33.3734       515.714       549.088    
  20  0.616820     -0.483178      -20.9863       20.9863       464.413       485.399    
  21  0.377083     -0.975289      -42.3606       42.3606       415.681       458.041    
  22  0.278016      -1.28008      -55.5987       55.5987       453.008       508.607    
  23  0.746435     -0.292446      -12.7021       12.7021       548.945       561.647    
  24  0.872234     -0.136697      -5.93729       5.93729       536.644       542.582    
  25  0.887073E-01  -2.42241      -105.215       105.215       471.530       576.745    
  26  0.124913      -2.08014      -90.3485       90.3485       484.301       574.649    
  27  0.918160     -0.853835E-01  -3.70854       3.70854       575.578       579.286    
  28  0.924603     -0.783912E-01  -3.40484       3.40484       499.703       503.108    
  29  0.863214     -0.147092      -6.38880       6.38880       590.730       597.119    
  30  0.823499E-02  -4.79936      -208.455       208.455       579.118       787.573    
  31  0.548113     -0.601275      -26.1157       26.1157       398.523       424.638    
loop,thermsimp(1:2)       53   23.5289       51.1511    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    111        421.88         73.95          1.02         38.64          0.24          0.05        113.90
Just calling func    0   0        113.90


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    112        548.10         74.37          1.12         38.38          0.02          0.05        113.94
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    421.88
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    43.4339               121
loop is:       53
neval is:      111
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       53      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    43.4339               121
loop is:       54
neval is:      111


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      121
neval,tstepnext:      111     121

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.565968     -0.569218      -24.7234       24.7234       384.612       409.335    
   2  0.698829     -0.358349      -15.5645       15.5645       413.918       429.482    
   3  0.550231     -0.597418      -25.9482       25.9482       398.523       424.471    
   4  0.844966     -0.168459      -7.31682       7.31682       426.821       434.138    
   5  0.139804      -1.96751      -85.4567       85.4567       416.689       502.145    
   6  0.119451      -2.12485      -92.2905       92.2905       415.681       507.971    
   7  0.474112     -0.746312      -32.4152       32.4152       457.048       489.463    
   8  0.293024      -1.22750      -53.3150       53.3150       439.306       492.621    
   9  0.760137     -0.274256      -11.9120       11.9120       464.413       476.325    
  10  0.216376      -1.53074      -66.4859       66.4859       434.451       500.937    
  11  0.837069     -0.177849      -7.72466       7.72466       440.973       448.697    
  12  0.969258     -0.312245E-01  -1.35620       1.35620       453.721       455.077    
  13  0.335918      -1.09089      -47.3815       47.3815       465.723       513.105    
  14  0.966643     -0.339265E-01  -1.47356       1.47356       471.666       473.140    
  15  0.723887     -0.323119      -14.0343       14.0343       499.703       513.737    
  16  0.459929E-01  -3.07927      -133.745       133.745       453.008       586.753    
  17  0.536724     -0.622271      -27.0277       27.0277       493.234       520.262    
  18  0.432574     -0.838001      -36.3976       36.3976       480.507       516.904    
  19  0.160308      -1.83066      -79.5126       79.5126       514.733       594.246    
  20  0.885158     -0.121989      -5.29845       5.29845       489.342       494.640    
  21  0.753783     -0.282650      -12.2766       12.2766       536.644       548.921    
  22  0.135562      -1.99832      -86.7949       86.7949       477.125       563.920    
  23  0.817964     -0.200937      -8.72746       8.72746       515.714       524.442    
  24  0.286617      -1.24961      -54.2754       54.2754       548.945       603.220    
  25  0.319126      -1.14217      -49.6089       49.6089       488.891       538.500    
  26  0.104479E-01  -4.56135      -198.117       198.117       484.301       682.418    
  27  0.671407     -0.398379      -17.3032       17.3032       471.530       488.833    
  28  0.782955     -0.244680      -10.6274       10.6274       504.066       514.694    
  29  0.186689      -1.67831      -72.8957       72.8957       575.578       648.474    
  30  0.462519     -0.771067      -33.4904       33.4904       590.730       624.220    
  31  0.203171      -1.59371      -69.2209       69.2209       421.881       491.101    
loop,thermsimp(1:2)       54   24.7234       15.5645    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    113        414.02         74.41          1.06         38.53          0.18          0.05        114.23
Just calling func    0   0        114.23


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    114        407.70         73.80          0.99         38.62          1.01          0.05        114.46
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    407.70
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    43.4339               121
loop is:       54
neval is:      113
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       54      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    43.4339               121
loop is:       55
neval is:      113


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      121
neval,tstepnext:      113     121

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.194359      -1.63805      -71.1468       71.1468       384.612       455.759    
   2  0.875287     -0.133204      -5.78555       5.78555       398.523       404.308    
   3  0.103612      -2.26710      -98.4689       98.4689       413.918       512.387    
   4  0.159072      -1.83840      -79.8488       79.8488       426.821       506.670    
   5  0.118738      -2.13084      -92.5505       92.5505       440.973       533.523    
   6  0.294105      -1.22382      -53.1552       53.1552       453.721       506.876    
   7  0.967643     -0.328919E-01  -1.42862       1.42862       471.666       473.095    
   8  0.675183     -0.392772      -17.0596       17.0596       464.413       481.473    
   9  0.170112      -1.77130      -76.9344       76.9344       471.530       548.464    
  10  0.990992     -0.904902E-02 -0.393034      0.393034       457.048       457.441    
  11  0.198513      -1.61690      -70.2284       70.2284       421.881       492.109    
  12  0.404817E-01  -3.20690      -139.288       139.288       439.306       578.594    
  13  0.834933E-01  -2.48299      -107.846       107.846       489.342       597.188    
  14  0.458935     -0.778848      -33.8284       33.8284       434.451       468.279    
  15  0.929311     -0.733118E-01  -3.18422       3.18422       416.689       419.873    
  16  0.593071     -0.522440      -22.6916       22.6916       415.681       438.372    
  17  0.963359E-01  -2.33991      -101.632       101.632       465.723       567.355    
  18  0.383119E-01  -3.26200      -141.681       141.681       499.703       641.384    
  19  0.841843     -0.172161      -7.47763       7.47763       504.066       511.544    
  20  0.874261     -0.134376      -5.83649       5.83649       480.507       486.343    
  21  0.706443     -0.347513      -15.0938       15.0938       493.234       508.328    
  22  0.423649E-01  -3.16143      -137.313       137.313       515.714       653.028    
  23  0.904835     -0.100003      -4.34351       4.34351       488.891       493.235    
  24  0.728800     -0.316356      -13.7406       13.7406       536.644       550.385    
  25  0.764304     -0.268790      -11.6746       11.6746       477.125       488.799    
  26  0.578519     -0.547284      -23.7707       23.7707       453.008       476.779    
  27  0.321737      -1.13402      -49.2549       49.2549       514.733       563.988    
  28  0.592944     -0.522656      -22.7010       22.7010       548.945       571.646    
  29  0.159596      -1.83511      -79.7060       79.7060       590.730       670.436    
  30  0.797332     -0.226484      -9.83707       9.83707       575.578       585.415    
  31  0.263979      -1.33189      -57.8490       57.8490       407.701       465.550    
loop,thermsimp(1:2)       55   71.1468       5.78555    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    115        419.13         73.73          1.01         38.58          0.64          0.06        114.02
Just calling func    0   0        114.02


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    116        568.46         73.54          1.04         38.85          0.32          0.05        113.80
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    419.13
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    43.4339               121
loop is:       55
neval is:      115
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       55      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    43.4339               121
loop is:       56
neval is:      115


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      121
neval,tstepnext:      115     121

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.141299      -1.95688      -84.9949       84.9949       398.523       483.518    
   2  0.197548      -1.62177      -70.4400       70.4400       416.689       487.128    
   3  0.774000     -0.256183      -11.1270       11.1270       415.681       426.808    
   4  0.170284      -1.77029      -76.8905       76.8905       384.612       461.503    
   5  0.250636      -1.38376      -60.1019       60.1019       457.048       517.150    
   6  0.907951     -0.965652E-01  -4.19420       4.19420       407.701       411.895    
   7  0.611678     -0.491549      -21.3499       21.3499       434.451       455.801    
   8  0.735945E-02  -4.91177      -213.337       213.337       471.666       685.003    
   9  0.309131      -1.17399      -50.9909       50.9909       453.008       503.999    
  10  0.577854     -0.548434      -23.8206       23.8206       464.413       488.234    
  11  0.931529     -0.709274E-01  -3.08065       3.08065       480.507       483.587    
  12  0.665703     -0.406912      -17.6738       17.6738       477.125       494.798    
  13  0.585695     -0.534955      -23.2352       23.2352       421.881       445.116    
  14  0.295001      -1.22078      -53.0231       53.0231       488.891       541.914    
  15  0.317712E-01  -3.44920      -149.812       149.812       426.821       576.633    
  16  0.222963      -1.50075      -65.1834       65.1834       453.721       518.905    
  17  0.325931      -1.12107      -48.6924       48.6924       493.234       541.926    
  18  0.785098     -0.241947      -10.5087       10.5087       504.066       514.575    
  19  0.550467     -0.596988      -25.9295       25.9295       413.918       439.847    
  20  0.780222     -0.248176      -10.7793       10.7793       440.973       451.752    
  21  0.130712      -2.03476      -88.3774       88.3774       471.530       559.907    
  22  0.873397     -0.135365      -5.87942       5.87942       536.644       542.524    
  23  0.366975      -1.00246      -43.5408       43.5408       514.733       558.274    
  24  0.813244     -0.206724      -8.97883       8.97883       465.723       474.702    
  25  0.782660E-01  -2.54764      -110.654       110.654       548.945       659.599    
  26  0.700327     -0.356208      -15.4715       15.4715       439.306       454.778    
  27  0.437766     -0.826071      -35.8794       35.8794       575.578       611.457    
  28  0.508966E-01  -2.97796      -129.344       129.344       489.342       618.686    
  29  0.276850      -1.28428      -55.7812       55.7812       499.703       555.484    
  30  0.792031     -0.233154      -10.1268       10.1268       515.714       525.841    
  31  0.174747      -1.74441      -75.7667       75.7667       419.133       494.900    
loop,thermsimp(1:2)       56   84.9949       70.4400    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    117        426.33         73.82          1.06         38.77          0.36          0.05        114.05
Just calling func    0   0        114.05


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    118        534.49         73.58          1.00         38.80          0.91          0.05        114.33
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    426.33
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    43.4339               121
loop is:       56
neval is:      117
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       56      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    43.4339               121
loop is:       57
neval is:      117


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      121
neval,tstepnext:      117     121

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.662269     -0.412083      -17.8984       17.8984       407.701       425.599    
   2  0.724212     -0.322671      -14.0149       14.0149       415.681       429.695    
   3  0.633711     -0.456163      -19.8129       19.8129       413.918       433.731    
   4  0.448566     -0.801700      -34.8209       34.8209       421.881       456.702    
   5  0.964228     -0.364273E-01  -1.58218       1.58218       440.973       442.555    
   6  0.714306     -0.336444      -14.6131       14.6131       439.306       453.919    
   7  0.528330     -0.638035      -27.7123       27.7123       434.451       462.163    
   8  0.654127     -0.424453      -18.4356       18.4356       384.612       403.048    
   9  0.368899     -0.997232      -43.3137       43.3137       465.723       509.037    
  10  0.227697      -1.47974      -64.2709       64.2709       398.523       462.794    
  11  0.612266     -0.490588      -21.3081       21.3081       480.507       501.815    
  12  0.313777      -1.15907      -50.3431       50.3431       416.689       467.032    
  13  0.258526      -1.35276      -58.7557       58.7557       464.413       523.169    
  14  0.119298      -2.12613      -92.3462       92.3462       477.125       569.471    
  15  0.213331      -1.54491      -67.1014       67.1014       419.133       486.234    
  16  0.294218      -1.22343      -53.1385       53.1385       453.008       506.147    
  17  0.352988      -1.04132      -45.2286       45.2286       504.066       549.295    
  18  0.348706      -1.05353      -45.7587       45.7587       457.048       502.807    
  19  0.449249     -0.800179      -34.7549       34.7549       453.721       488.476    
  20  0.879121     -0.128833      -5.59571       5.59571       515.714       521.310    
  21  0.464081     -0.767695      -33.3440       33.3440       488.891       522.235    
  22  0.497582     -0.697995      -30.3166       30.3166       493.234       523.551    
  23  0.920207     -0.831566E-01  -3.61181       3.61181       536.644       540.256    
  24  0.811773     -0.208535      -9.05748       9.05748       499.703       508.760    
  25  0.190651      -1.65731      -71.9834       71.9834       514.733       586.717    
  26  0.645174     -0.438235      -19.0343       19.0343       471.530       490.564    
  27  0.668343     -0.402954      -17.5019       17.5019       426.821       444.323    
  28  0.765111     -0.267735      -11.6288       11.6288       575.578       587.207    
  29  0.991779     -0.825499E-02 -0.358546      0.358546       489.342       489.701    
  30  0.136888      -1.98859      -86.3724       86.3724       548.945       635.317    
  31  0.645145E-01  -2.74086      -119.046       119.046       426.330       545.376    
loop,thermsimp(1:2)       57   17.8984       14.0149    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    119        386.03         73.54          0.98         38.82          0.56          0.06        113.96
Just calling func    0   0        113.96


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    120        389.97         73.54          0.99         39.01          0.17          0.06        113.77
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    386.03
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    43.4339               121
loop is:       57
neval is:      119
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       57      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    43.4339               121
loop is:       58
neval is:      119


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      121
neval,tstepnext:      119     121

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.584865E-01  -2.83896      -123.307       123.307       384.612       507.919    
   2  0.104884      -2.25490      -97.9393       97.9393       407.701       505.640    
   3  0.784254     -0.243023      -10.5554       10.5554       415.681       426.236    
   4  0.813133     -0.206861      -8.98477       8.98477       413.918       422.903    
   5  0.490778     -0.711764      -30.9147       30.9147       440.973       471.887    
   6  0.168573      -1.78039      -77.3291       77.3291       426.821       504.150    
   7  0.450161     -0.798149      -34.6667       34.6667       439.306       473.973    
   8  0.828233     -0.188461      -8.18558       8.18558       421.881       430.066    
   9  0.994731     -0.528342E-02 -0.229480      0.229480       434.451       434.680    
  10  0.813340     -0.206606      -8.97371       8.97371       398.523       407.496    
  11  0.776133     -0.253432      -11.0075       11.0075       416.689       427.696    
  12  0.729556     -0.315319      -13.6955       13.6955       419.133       432.828    
  13  0.530451     -0.634028      -27.5383       27.5383       453.721       481.259    
  14  0.752564E-01  -2.58685      -112.357       112.357       489.342       601.699    
  15  0.918457     -0.850597E-01  -3.69447       3.69447       471.530       475.224    
  16  0.162642      -1.81621      -78.8849       78.8849       480.507       559.391    
  17  0.725851     -0.320411      -13.9167       13.9167       457.048       470.965    
  18  0.322292      -1.13230      -49.1801       49.1801       453.008       502.188    
  19  0.838064     -0.176661      -7.67308       7.67308       499.703       507.376    
  20  0.346062E-01  -3.36372      -146.099       146.099       465.723       611.823    
  21  0.442915     -0.814377      -35.3716       35.3716       515.714       551.086    
  22  0.143708      -1.93997      -84.2605       84.2605       488.891       573.152    
  23  0.940845     -0.609769E-01  -2.64847       2.64847       464.413       467.061    
  24  0.972503     -0.278816E-01  -1.21101       1.21101       493.234       494.445    
  25  0.291831      -1.23158      -53.4924       53.4924       536.644       590.137    
  26  0.211976      -1.55128      -67.3782       67.3782       426.330       493.708    
  27  0.695427     -0.363229      -15.7765       15.7765       504.066       519.843    
  28  0.982540E-01  -2.32020      -100.775       100.775       477.125       577.900    
  29  0.730742     -0.313695      -13.6250       13.6250       514.733       528.358    
  30  0.417794     -0.872766      -37.9076       37.9076       575.578       613.485    
  31  0.868385     -0.141121      -6.12942       6.12942       386.035       392.164    
loop,thermsimp(1:2)       58   123.307       97.9393    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    121        521.63         73.96          1.04         38.91          0.20          0.06        114.18
Just calling func    0   0        114.18


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  120    521.63        1.947     -1.516      5.475     -101.7      1.395    
                     -0.3681      3.125     -100.0      3.175      1.587    
                       1.838     -1.072      1.561      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500      4871.     0.1575E+05 -2483.    -0.5540E+05
                      -2.000     -4.870     -6.971     -6.903     -1.820    
                      -12.84     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                      -1.303     -1.587      2.714      1.010      0.000    
                       0.000      9.205      9.124     -209.6      1.000    
                     -0.5787    -0.7479      9.398      8.548     -6776.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -8048.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -4564.      1.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    521.63
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    43.4339               121
loop is:       58
neval is:      120
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       58      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    43.4339               121
loop is:       59
neval is:      120


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      121
neval,tstepnext:      120     121

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.330032      -1.10857      -48.1493       48.1493       386.035       434.184    
   2  0.939148     -0.627826E-01  -2.72689       2.72689       398.523       401.250    
   3  0.130906      -2.03328      -88.3132       88.3132       413.918       502.231    
   4  0.664370     -0.408916      -17.7608       17.7608       415.681       433.441    
   5  0.490908     -0.711498      -30.9031       30.9031       416.689       447.592    
   6  0.711731     -0.340055      -14.7699       14.7699       421.881       436.650    
   7  0.676080     -0.391444      -17.0019       17.0019       419.133       436.135    
   8  0.611139     -0.492432      -21.3882       21.3882       434.451       455.839    
   9  0.614246     -0.487359      -21.1679       21.1679       464.413       485.581    
  10  0.988045     -0.120275E-01 -0.522403      0.522403       457.048       457.571    
  11  0.232883      -1.45722      -63.2926       63.2926       440.973       504.265    
  12  0.450825     -0.796675      -34.6027       34.6027       439.306       473.909    
  13  0.493319     -0.706599      -30.6903       30.6903       471.530       502.220    
  14  0.191184      -1.65452      -71.8622       71.8622       453.721       525.583    
  15  0.894136     -0.111897      -4.86014       4.86014       426.330       431.190    
  16  0.391751     -0.937128      -40.7031       40.7031       493.234       533.937    
  17  0.236278      -1.44275      -62.6641       62.6641       453.008       515.673    
  18  0.496874E-01  -3.00200      -130.389       130.389       426.821       557.210    
  19  0.784524     -0.242678      -10.5405       10.5405       407.701       418.241    
  20  0.292328      -1.22988      -53.4184       53.4184       499.703       553.121    
  21  0.832247E-01  -2.48621      -107.986       107.986       384.612       492.598    
  22  0.423133     -0.860069      -37.3562       37.3562       504.066       541.422    
  23  0.234472      -1.45042      -62.9973       62.9973       514.733       577.730    
  24  0.868463     -0.141031      -6.12551       6.12551       515.714       521.840    
  25  0.122969      -2.09582      -91.0297       91.0297       480.507       571.536    
  26  0.811771     -0.208537      -9.05757       9.05757       488.891       497.949    
  27  0.786834     -0.239738      -10.4128       10.4128       477.125       487.537    
  28  0.163144      -1.81312      -78.7508       78.7508       536.644       615.395    
  29  0.571103     -0.560186      -24.3311       24.3311       489.342       513.673    
  30  0.769982     -0.261388      -11.3531       11.3531       465.723       477.077    
  31  0.471769     -0.751265      -32.6304       32.6304       521.631       554.262    
loop,thermsimp(1:2)       59   48.1493       2.72689    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    122        376.24         73.57          1.02         38.96          0.38          0.06        113.98
Just calling func    0   0        113.98


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    123        441.96         74.70          1.09         38.37          0.00          0.06        114.21
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    376.24
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    43.4339               121
loop is:       59
neval is:      122
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       59      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    43.4339               121
loop is:       60
neval is:      122


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 




neval>tstepnex so lower away!t
---> lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
     new SAtemp,tstepnext are :    21.7169               151

 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      122     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.304136      -1.19028      -25.8493       25.8493       398.523       424.372    
   2  0.843344     -0.170380      -3.70013       3.70013       407.701       411.401    
   3  0.457815     -0.781289      -16.9672       16.9672       426.330       443.297    
   4  0.933709     -0.685899E-01  -1.48956       1.48956       415.681       417.170    
   5  0.887159     -0.119731      -2.60018       2.60018       386.035       388.635    
   6  0.786211     -0.240530      -5.22358       5.22358       419.133       424.356    
   7  0.794803     -0.229661      -4.98754       4.98754       421.881       426.868    
   8  0.573435E-01  -2.85870      -62.0821       62.0821       416.689       478.771    
   9  0.647106     -0.435245      -9.45218       9.45218       434.451       443.903    
  10  0.110118      -2.20620      -47.9120       47.9120       457.048       504.960    
  11  0.339548      -1.08014      -23.4573       23.4573       439.306       462.763    
  12  0.635246     -0.453742      -9.85390       9.85390       465.723       475.577    
  13  0.488392     -0.716638      -15.5632       15.5632       464.413       479.976    
  14  0.602571     -0.506549      -11.0007       11.0007       477.125       488.125    
  15  0.710041     -0.342433      -7.43660       7.43660       384.612       392.049    
  16  0.585763     -0.534840      -11.6151       11.6151       488.891       500.506    
  17  0.288010      -1.24476      -27.0324       27.0324       471.530       498.562    
  18  0.455238     -0.786934      -17.0898       17.0898       413.918       431.008    
  19  0.723984     -0.322986      -7.01426       7.01426       440.973       447.987    
  20  0.554067     -0.590470      -12.8232       12.8232       489.342       502.165    
  21  0.646516     -0.436157      -9.47199       9.47199       453.008       462.480    
  22  0.271985      -1.30201      -28.2756       28.2756       515.714       543.990    
  23  0.901636E-02  -4.70871      -102.259       102.259       453.721       555.980    
  24  0.383616     -0.958114      -20.8073       20.8073       493.234       514.041    
  25  0.443516     -0.813022      -17.6564       17.6564       504.066       521.722    
  26  0.223023      -1.50048      -32.5859       32.5859       499.703       532.289    
  27  0.123255      -2.09350      -45.4644       45.4644       521.631       567.096    
  28  0.817485     -0.201523      -4.37646       4.37646       426.821       431.197    
  29  0.333893      -1.09693      -23.8220       23.8220       480.507       504.329    
  30  0.867877     -0.141706      -3.07742       3.07742       514.733       517.811    
  31  0.365747      -1.00581      -21.8432       21.8432       376.237       398.080    
loop,thermsimp(1:2)       60   25.8493       3.70013    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    124        546.80         74.49          1.08         38.64          0.02          0.06        114.30
Just calling func    0   0        114.30


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    546.80
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       60
neval is:      123
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       60      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       61
neval is:      123


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      123     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.829682     -0.186713      -4.05483       4.05483       386.035       390.090    
   2  0.735850     -0.306729      -6.66122       6.66122       384.612       391.273    
   3  0.828786     -0.187793      -4.07830       4.07830       376.237       380.315    
   4  0.592078     -0.524118      -11.3822       11.3822       407.701       419.083    
   5  0.691797E-01  -2.67105      -58.0070       58.0070       415.681       473.688    
   6  0.772335     -0.258337      -5.61029       5.61029       419.133       424.743    
   7  0.504563     -0.684063      -14.8558       14.8558       398.523       413.379    
   8  0.700615     -0.355797      -7.72682       7.72682       421.881       429.607    
   9  0.764596     -0.268408      -5.82899       5.82899       413.918       419.747    
  10  0.459614     -0.777368      -16.8821       16.8821       426.821       443.703    
  11  0.931193     -0.712882E-01  -1.54816       1.54816       426.330       427.878    
  12  0.502482E-01  -2.99078      -64.9506       64.9506       434.451       499.401    
  13  0.498197     -0.696760      -15.1315       15.1315       440.973       456.104    
  14  0.551534E-01  -2.89764      -62.9278       62.9278       453.008       515.936    
  15  0.172209      -1.75905      -38.2011       38.2011       439.306       477.507    
  16  0.238868E-01  -3.73443      -81.1004       81.1004       465.723       546.824    
  17  0.699366     -0.357581      -7.76556       7.76556       416.689       424.454    
  18  0.764093     -0.269066      -5.84330       5.84330       464.413       470.256    
  19  0.465633     -0.764357      -16.5995       16.5995       477.125       493.724    
  20  0.209906      -1.56110      -33.9023       33.9023       471.530       505.432    
  21  0.216891      -1.52836      -33.1913       33.1913       488.891       522.083    
  22  0.795854E-01  -2.53092      -54.9639       54.9639       489.342       544.306    
  23  0.701683     -0.354273      -7.69373       7.69373       480.507       488.200    
  24  0.574425     -0.554385      -12.0395       12.0395       457.048       469.088    
  25  0.674968     -0.393090      -8.53671       8.53671       493.234       501.771    
  26  0.684189     -0.379521      -8.24204       8.24204       514.733       522.975    
  27  0.541862     -0.612745      -13.3069       13.3069       504.066       517.373    
  28  0.668027     -0.403426      -8.76118       8.76118       499.703       508.464    
  29  0.353251      -1.04058      -22.5981       22.5981       515.714       538.313    
  30  0.778708     -0.250119      -5.43183       5.43183       453.721       459.153    
  31  0.829283     -0.187194      -4.06528       4.06528       546.798       550.863    
loop,thermsimp(1:2)       61   4.05483       6.66122    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    125        521.63         74.05          1.05         38.86          0.34          0.05        114.35
Just calling func    0   0        114.35


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    521.63
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       61
neval is:      124
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       61      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       62
neval is:      124


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      124     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.917395     -0.862167E-01  -1.87236       1.87236       376.237       378.109    
   2  0.899579E-01  -2.40841      -52.3034       52.3034       386.035       438.338    
   3  0.997625     -0.237830E-02 -0.516495E-01  0.516495E-01   384.612       384.664    
   4  0.224083      -1.49574      -32.4829       32.4829       398.523       431.006    
   5  0.120769      -2.11388      -45.9070       45.9070       407.701       453.608    
   6  0.302676E-01  -3.49768      -75.9588       75.9588       413.918       489.877    
   7  0.315161      -1.15467      -25.0759       25.0759       416.689       441.764    
   8  0.155895      -1.85857      -40.3626       40.3626       419.133       459.495    
   9  0.467639     -0.760060      -16.5062       16.5062       426.330       442.836    
  10  0.277823      -1.28077      -27.8144       27.8144       421.881       449.695    
  11  0.712282     -0.339281      -7.36814       7.36814       426.821       434.189    
  12  0.929560     -0.730437E-01  -1.58629       1.58629       440.973       442.559    
  13  0.499024     -0.695101      -15.0955       15.0955       453.721       468.817    
  14  0.940347     -0.615066E-01  -1.33573       1.33573       457.048       458.384    
  15  0.714006     -0.336864      -7.31565       7.31565       464.413       471.729    
  16  0.162603      -1.81644      -39.4476       39.4476       415.681       455.128    
  17  0.663729     -0.409881      -8.90136       8.90136       439.306       448.208    
  18  0.314148      -1.15789      -25.1459       25.1459       480.507       505.652    
  19  0.497386     -0.698388      -15.1669       15.1669       477.125       492.291    
  20  0.368387     -0.998622      -21.6870       21.6870       434.451       456.138    
  21  0.326342      -1.11981      -24.3188       24.3188       493.234       517.553    
  22  0.442952     -0.814294      -17.6840       17.6840       471.530       489.214    
  23  0.929694     -0.729000E-01  -1.58317       1.58317       499.703       501.286    
  24  0.945450E-01  -2.35868      -51.2233       51.2233       453.008       504.232    
  25  0.407158     -0.898555      -19.5139       19.5139       504.066       523.580    
  26  0.706679     -0.347179      -7.53967       7.53967       488.891       496.431    
  27  0.657848     -0.418781      -9.09465       9.09465       514.733       523.828    
  28  0.968040     -0.324817E-01 -0.705404      0.705404       515.714       516.420    
  29  0.330387      -1.10749      -24.0513       24.0513       489.342       513.393    
  30  0.756161     -0.279501      -6.06991       6.06991       465.723       471.793    
  31  0.307772      -1.17840      -25.5912       25.5912       521.631       547.222    
loop,thermsimp(1:2)       62   1.87236       52.3034    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    126        546.80         74.66          1.10         38.52          0.00          0.06        114.34
Just calling func    0   0        114.34


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    546.80
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       62
neval is:      125
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       62      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       63
neval is:      125


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      125     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.617195     -0.482570      -10.4799       10.4799       376.237       386.717    
   2  0.828850     -0.187716      -4.07661       4.07661       384.612       388.689    
   3  0.138898      -1.97402      -42.8696       42.8696       398.523       441.392    
   4  0.174947      -1.74327      -37.8586       37.8586       426.821       464.680    
   5  0.452367E-01  -3.09585      -67.2323       67.2323       386.035       453.267    
   6  0.982229     -0.179305E-01 -0.389395      0.389395       416.689       417.078    
   7  0.855728     -0.155803      -3.38356       3.38356       440.973       444.356    
   8  0.350750      -1.04768      -22.7524       22.7524       426.330       449.082    
   9  0.880054     -0.127772      -2.77482       2.77482       439.306       442.081    
  10  0.106511      -2.23950      -48.6352       48.6352       421.881       470.516    
  11  0.336060      -1.09047      -23.6816       23.6816       407.701       431.382    
  12  0.904819     -0.100020      -2.17213       2.17213       415.681       417.853    
  13  0.765597     -0.267099      -5.80057       5.80057       434.451       440.251    
  14  0.551789     -0.594589      -12.9127       12.9127       457.048       469.961    
  15  0.832435     -0.183400      -3.98288       3.98288       419.133       423.116    
  16  0.353494      -1.03989      -22.5832       22.5832       453.721       476.304    
  17  0.510104     -0.673140      -14.6186       14.6186       464.413       479.032    
  18  0.523162     -0.647863      -14.0696       14.0696       465.723       479.793    
  19  0.953043     -0.480957E-01  -1.04449       1.04449       471.530       472.574    
  20  0.267001E-01  -3.62309      -78.6824       78.6824       413.918       492.600    
  21  0.280924      -1.26967      -27.5734       27.5734       477.125       504.698    
  22  0.956868     -0.440901E-01 -0.957502      0.957502       488.891       489.849    
  23  0.779725     -0.248814      -5.40347       5.40347       499.703       505.106    
  24  0.901061     -0.104183      -2.26253       2.26253       453.008       455.271    
  25  0.533391     -0.628501      -13.6491       13.6491       480.507       494.156    
  26  0.642536     -0.442333      -9.60612       9.60612       489.342       498.948    
  27  0.520565E-01  -2.95543      -64.1828       64.1828       515.714       579.897    
  28  0.330080      -1.10842      -24.0715       24.0715       493.234       517.305    
  29  0.280801      -1.27011      -27.5829       27.5829       504.066       531.649    
  30  0.144013      -1.93785      -42.0842       42.0842       514.733       556.817    
  31  0.201537      -1.60178      -34.7858       34.7858       546.798       581.583    
loop,thermsimp(1:2)       63   10.4799       4.07661    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    127        521.63         75.19          1.12         38.18          0.03          0.05        114.58
Just calling func    0   0        114.58


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    521.63
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       63
neval is:      126
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       63      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       64
neval is:      126


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      126     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.816548     -0.202670      -4.40136       4.40136       376.237       380.638    
   2  0.209930      -1.56098      -33.8997       33.8997       384.612       418.512    
   3  0.710991     -0.341096      -7.40756       7.40756       416.689       424.096    
   4  0.967365     -0.331789E-01 -0.720544      0.720544       415.681       416.401    
   5  0.650635E-01  -2.73239      -59.3392       59.3392       419.133       478.472    
   6  0.578340     -0.547593      -11.8920       11.8920       407.701       419.593    
   7  0.928890E-01  -2.37635      -51.6071       51.6071       434.451       486.058    
   8  0.486974     -0.719546      -15.6263       15.6263       398.523       414.149    
   9  0.560625     -0.578703      -12.5677       12.5677       439.306       451.874    
  10  0.552834     -0.592698      -12.8716       12.8716       440.973       453.844    
  11  0.744529E-01  -2.59759      -56.4117       56.4117       426.330       482.741    
  12  0.937600     -0.644318E-01  -1.39926       1.39926       386.035       387.434    
  13  0.154459      -1.86783      -40.5635       40.5635       453.008       493.572    
  14  0.186893E-02  -6.28239      -136.434       136.434       426.821       563.255    
  15  0.250797      -1.38311      -30.0370       30.0370       457.048       487.085    
  16  0.924847E-01  -2.38071      -51.7018       51.7018       421.881       473.582    
  17  0.476680     -0.740911      -16.0903       16.0903       471.530       487.620    
  18  0.266527      -1.32228      -28.7158       28.7158       453.721       482.437    
  19  0.369755     -0.994916      -21.6065       21.6065       464.413       486.020    
  20  0.595561     -0.518252      -11.2548       11.2548       465.723       476.978    
  21  0.636070     -0.452447      -9.82577       9.82577       488.891       498.717    
  22  0.447294     -0.804540      -17.4722       17.4722       413.918       431.390    
  23  0.964945     -0.356839E-01 -0.774945      0.774945       480.507       481.282    
  24  0.752421     -0.284460      -6.17759       6.17759       489.342       495.520    
  25  0.705556     -0.348769      -7.57420       7.57420       477.125       484.699    
  26  0.943467     -0.581939E-01  -1.26379       1.26379       499.703       500.967    
  27  0.272564      -1.29988      -28.2294       28.2294       493.234       521.463    
  28  0.215815      -1.53333      -33.2993       33.2993       504.066       537.365    
  29  0.756955     -0.278452      -6.04713       6.04713       514.733       520.780    
  30  0.538381     -0.619189      -13.4469       13.4469       515.714       529.161    
  31  0.182967      -1.69845      -36.8851       36.8851       521.631       558.516    
loop,thermsimp(1:2)       64   4.40136       33.8997    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    128        410.26         74.34          1.07         38.70          0.02          0.06        114.20
Just calling func    0   0        114.20


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    129        793.33         73.90          1.01         39.01          0.16          0.06        114.14
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    410.26
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       64
neval is:      128
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       64      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       65
neval is:      128


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      128     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.367522      -1.00097      -21.7381       21.7381       376.237       397.975    
   2  0.298218      -1.20993      -26.2760       26.2760       386.035       412.311    
   3  0.374092     -0.983254      -21.3533       21.3533       398.523       419.876    
   4  0.417366     -0.873791      -18.9761       18.9761       415.681       434.657    
   5  0.299382      -1.20604      -26.1914       26.1914       384.612       410.803    
   6  0.373029     -0.986099      -21.4151       21.4151       407.701       429.116    
   7  0.628224     -0.464858      -10.0953       10.0953       416.689       426.784    
   8  0.111397      -2.19465      -47.6612       47.6612       413.918       461.579    
   9  0.983555     -0.165818E-01 -0.360105      0.360105       439.306       439.666    
  10  0.394578     -0.929938      -20.1954       20.1954       440.973       461.168    
  11  0.410639     -0.890042      -19.3290       19.3290       421.881       441.210    
  12  0.700680     -0.355705      -7.72481       7.72481       465.723       473.448    
  13  0.223946      -1.49635      -32.4962       32.4962       419.133       451.629    
  14  0.651113E-01  -2.73166      -59.3232       59.3232       480.507       539.830    
  15  0.704010     -0.350963      -7.62184       7.62184       453.721       461.343    
  16  0.172411      -1.75787      -38.1756       38.1756       426.330       464.505    
  17  0.567412     -0.566670      -12.3063       12.3063       477.125       489.431    
  18  0.186334      -1.68021      -36.4891       36.4891       464.413       500.902    
  19  0.677524     -0.389310      -8.45463       8.45463       434.451       442.905    
  20  0.362270      -1.01537      -22.0506       22.0506       457.048       479.099    
  21  0.603880     -0.504381      -10.9536       10.9536       471.530       482.484    
  22  0.782208     -0.245635      -5.33444       5.33444       453.008       458.343    
  23  0.129808      -2.04170      -44.3395       44.3395       489.342       533.682    
  24  0.284816      -1.25591      -27.2746       27.2746       488.891       516.166    
  25  0.246930      -1.39865      -30.3744       30.3744       499.703       530.077    
  26  0.256917      -1.35900      -29.5134       29.5134       514.733       544.247    
  27  0.240545      -1.42485      -30.9434       30.9434       493.234       524.177    
  28  0.218018      -1.52318      -33.0788       33.0788       515.714       548.793    
  29  0.235583E-01  -3.74828      -81.4011       81.4011       504.066       585.467    
  30  0.114660      -2.16578      -47.0341       47.0341       521.631       568.665    
  31  0.119129      -2.12755      -46.2039       46.2039       410.265       456.469    
loop,thermsimp(1:2)       65   21.7381       26.2760    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    130        383.42         74.46          1.04         38.23          0.28          0.06        114.07
Just calling func    0   0        114.07


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    131        382.79         73.75          1.04         38.73          0.39          0.05        113.96
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    382.79
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       65
neval is:      130
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       65      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       66
neval is:      130


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      130     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.255462      -1.36468      -29.6367       29.6367       376.237       405.874    
   2  0.513427E-01  -2.96923      -64.4827       64.4827       384.612       449.095    
   3  0.288453      -1.24322      -26.9990       26.9990       386.035       413.034    
   4  0.107044      -2.23452      -48.5268       48.5268       398.523       447.050    
   5  0.756779     -0.278684      -6.05216       6.05216       416.689       422.741    
   6  0.333762      -1.09733      -23.8306       23.8306       407.701       431.531    
   7  0.270335      -1.30809      -28.4078       28.4078       415.681       444.088    
   8  0.666278E-01  -2.70863      -58.8232       58.8232       439.306       498.129    
   9  0.517510     -0.658727      -14.3055       14.3055       421.881       436.186    
  10  0.719680     -0.328949      -7.14376       7.14376       434.451       441.595    
  11  0.401542     -0.912442      -19.8155       19.8155       419.133       438.948    
  12  0.408125     -0.896181      -19.4623       19.4623       410.265       429.727    
  13  0.481086     -0.731710      -15.8905       15.8905       453.008       468.899    
  14  0.166952E-01  -4.09263      -88.8794       88.8794       440.973       529.852    
  15  0.913266     -0.907286E-01  -1.97035       1.97035       453.721       455.691    
  16  0.972084     -0.283134E-01 -0.614881      0.614881       413.918       414.533    
  17  0.889421     -0.117184      -2.54488       2.54488       426.330       428.874    
  18  0.171754      -1.76169      -38.2586       38.2586       465.723       503.982    
  19  0.925876     -0.770155E-01  -1.67254       1.67254       457.048       458.721    
  20  0.992897     -0.712866E-02 -0.154813      0.154813       471.530       471.685    
  21  0.118575E-01  -4.43479      -96.3102       96.3102       477.125       573.435    
  22  0.492413     -0.708438      -15.3851       15.3851       464.413       479.798    
  23  0.952433     -0.487360E-01  -1.05840       1.05840       488.891       489.950    
  24  0.591826     -0.524543      -11.3915       11.3915       493.234       504.625    
  25  0.762199     -0.271548      -5.89718       5.89718       499.703       505.600    
  26  0.613492     -0.488588      -10.6106       10.6106       489.342       499.953    
  27  0.134863      -2.00350      -43.5099       43.5099       480.507       524.016    
  28  0.633670     -0.456227      -9.90784       9.90784       514.733       524.641    
  29  0.829625     -0.186782      -4.05633       4.05633       515.714       519.771    
  30  0.148219      -1.90906      -41.4590       41.4590       521.631       563.090    
  31  0.198093      -1.61902      -35.1601       35.1601       382.789       417.949    
loop,thermsimp(1:2)       66   29.6367       64.4827    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    132        382.45         73.36          1.02         38.91          0.49          0.05        113.84
Just calling func    0   0        113.84


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    133        379.57         73.48          1.04         38.73          0.71          0.05        114.01
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    379.57
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       66
neval is:      132
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       66      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       67
neval is:      132


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      132     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.297913      -1.21095      -26.2982       26.2982       376.237       402.535    
   2  0.840396     -0.173882      -3.77618       3.77618       386.035       389.811    
   3  0.165782      -1.79708      -39.0271       39.0271       413.918       452.945    
   4  0.516202E-01  -2.96384      -64.3656       64.3656       382.789       447.155    
   5  0.163201      -1.81278      -39.3679       39.3679       416.689       456.056    
   6  0.201529      -1.60182      -34.7866       34.7866       426.330       461.116    
   7  0.791805     -0.233441      -5.06962       5.06962       410.265       415.334    
   8  0.306466      -1.18265      -25.6835       25.6835       407.701       433.384    
   9  0.625963     -0.468465      -10.1736       10.1736       421.881       432.054    
  10  0.255827      -1.36325      -29.6057       29.6057       419.133       448.739    
  11  0.275269      -1.29001      -28.0150       28.0150       434.451       462.466    
  12  0.546374     -0.604451      -13.1268       13.1268       415.681       428.807    
  13  0.738275E-01  -2.60602      -56.5949       56.5949       398.523       455.118    
  14  0.459460     -0.777704      -16.8894       16.8894       384.612       401.501    
  15  0.245891      -1.40287      -30.4660       30.4660       453.721       484.187    
  16  0.818144E-01  -2.50330      -54.3641       54.3641       457.048       511.412    
  17  0.791963     -0.233241      -5.06528       5.06528       453.008       458.074    
  18  0.652560     -0.426852      -9.26992       9.26992       471.530       480.800    
  19  0.743237     -0.296740      -6.44428       6.44428       464.413       470.857    
  20  0.146095      -1.92350      -41.7725       41.7725       488.891       530.664    
  21  0.747148     -0.291492      -6.33032       6.33032       439.306       445.637    
  22  0.935024E-01  -2.36977      -51.4641       51.4641       489.342       540.806    
  23  0.924202     -0.788243E-01  -1.71182       1.71182       465.723       467.435    
  24  0.193934      -1.64024      -35.6209       35.6209       493.234       528.855    
  25  0.112499      -2.18481      -47.4473       47.4473       499.703       547.150    
  26  0.609079     -0.495807      -10.7674       10.7674       515.714       526.482    
  27  0.387822     -0.947210      -20.5705       20.5705       480.507       501.077    
  28  0.151976      -1.88403      -40.9155       40.9155       514.733       555.649    
  29  0.820125     -0.198299      -4.30644       4.30644       440.973       445.279    
  30  0.100865      -2.29397      -49.8180       49.8180       521.631       571.449    
  31  0.246930      -1.39865      -30.3744       30.3744       379.567       409.941    
loop,thermsimp(1:2)       67   26.2982       3.77618    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    134        509.68         74.27          1.07         38.52          0.05          0.05        113.96
Just calling func    0   0        113.96


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    509.68
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       67
neval is:      133
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       67      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       68
neval is:      133


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      133     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.944296E-02  -4.66249      -101.255       101.255       386.035       487.290    
   2  0.714357     -0.336373      -7.30499       7.30499       384.612       391.917    
   3  0.997096     -0.290808E-02 -0.631547E-01  0.631547E-01   376.237       376.300    
   4  0.905437     -0.993373E-01  -2.15730       2.15730       379.567       381.724    
   5  0.307060      -1.18071      -25.6415       25.6415       410.265       435.906    
   6  0.179061      -1.72003      -37.3537       37.3537       415.681       453.034    
   7  0.384312     -0.956301      -20.7679       20.7679       421.881       442.649    
   8  0.901101     -0.104138      -2.26157       2.26157       407.701       409.962    
   9  0.606170     -0.500594      -10.8714       10.8714       440.973       451.844    
  10  0.515234     -0.663133      -14.4012       14.4012       439.306       453.707    
  11  0.639447     -0.447152      -9.71077       9.71077       382.789       392.500    
  12  0.820429     -0.197928      -4.29838       4.29838       419.133       423.431    
  13  0.521739     -0.650587      -14.1288       14.1288       413.918       428.047    
  14  0.767979     -0.263993      -5.73312       5.73312       398.523       404.256    
  15  0.530366     -0.634187      -13.7726       13.7726       416.689       430.461    
  16  0.732471     -0.311332      -6.76118       6.76118       453.008       459.770    
  17  0.440461     -0.819933      -17.8064       17.8064       426.330       444.136    
  18  0.595715     -0.517993      -11.2492       11.2492       434.451       445.700    
  19  0.407958     -0.896592      -19.4712       19.4712       465.723       485.195    
  20  0.544683     -0.607550      -13.1941       13.1941       464.413       477.607    
  21  0.611386E-01  -2.79461      -60.6904       60.6904       471.530       532.220    
  22  0.135041      -2.00218      -43.4811       43.4811       453.721       497.202    
  23  0.547242     -0.602864      -13.0924       13.0924       480.507       493.599    
  24  0.214436      -1.53975      -33.4386       33.4386       457.048       490.487    
  25  0.340220      -1.07816      -23.4144       23.4144       515.714       539.129    
  26  0.270394      -1.30787      -28.4030       28.4030       493.234       521.637    
  27  0.605229     -0.502149      -10.9051       10.9051       488.891       499.796    
  28  0.630206     -0.461709      -10.0269       10.0269       489.342       499.369    
  29  0.942476     -0.592449E-01  -1.28662       1.28662       499.703       500.989    
  30  0.293125      -1.22716      -26.6501       26.6501       514.733       541.383    
  31  0.526210     -0.642056      -13.9435       13.9435       509.682       523.625    
loop,thermsimp(1:2)       68   101.255       7.30499    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    135        475.50         73.70          0.99         38.60          0.87          0.04        114.20
Just calling func    0   0        114.20


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    475.50
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       68
neval is:      134
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       68      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       69
neval is:      134


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      134     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.521048     -0.651914      -14.1576       14.1576       376.237       390.395    
   2  0.554375     -0.589913      -12.8111       12.8111       379.567       392.378    
   3  0.404373     -0.905418      -19.6629       19.6629       384.612       404.275    
   4  0.632877     -0.457478      -9.93503       9.93503       382.789       392.724    
   5  0.395261     -0.928209      -20.1579       20.1579       398.523       418.681    
   6  0.715068     -0.335378      -7.28339       7.28339       407.701       414.984    
   7  0.918313     -0.852174E-01  -1.85066       1.85066       419.133       420.983    
   8  0.529514E-01  -2.93838      -63.8127       63.8127       413.918       477.730    
   9  0.284219      -1.25801      -27.3201       27.3201       416.689       444.009    
  10  0.809402     -0.211460      -4.59227       4.59227       410.265       414.857    
  11  0.604758     -0.502928      -10.9220       10.9220       421.881       432.803    
  12  0.624772     -0.470369      -10.2150       10.2150       426.330       436.545    
  13  0.622683     -0.473718      -10.2877       10.2877       434.451       444.739    
  14  0.491656     -0.709976      -15.4185       15.4185       440.973       456.391    
  15  0.823484     -0.194211      -4.21767       4.21767       415.681       419.898    
  16  0.185629E-01  -3.98659      -86.5765       86.5765       439.306       525.883    
  17  0.911253     -0.929346E-01  -2.01826       2.01826       453.008       455.027    
  18  0.825116     -0.192231      -4.17467       4.17467       464.413       468.588    
  19  0.902913     -0.102129      -2.21794       2.21794       465.723       467.941    
  20  0.869925     -0.139348      -3.02622       3.02622       386.035       389.061    
  21  0.135445      -1.99919      -43.4163       43.4163       457.048       500.464    
  22  0.516840     -0.660022      -14.3337       14.3337       480.507       494.840    
  23  0.127583      -2.05899      -44.7150       44.7150       453.721       498.436    
  24  0.237062E-01  -3.74202      -81.2652       81.2652       489.342       570.607    
  25  0.456233     -0.784753      -17.0424       17.0424       488.891       505.934    
  26  0.547397     -0.602581      -13.0862       13.0862       499.703       512.789    
  27  0.231746E-02  -6.06728      -131.763       131.763       493.234       624.997    
  28  0.467213     -0.760969      -16.5259       16.5259       509.682       526.208    
  29  0.397333     -0.922981      -20.0443       20.0443       471.530       491.574    
  30  0.291343      -1.23325      -26.7825       26.7825       515.714       542.497    
  31  0.964262     -0.363922E-01 -0.790327      0.790327       475.497       476.287    
loop,thermsimp(1:2)       69   14.1576       12.8111    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    136        432.38         73.75          1.05         38.77          0.08          0.05        113.70
Just calling func    0   0        113.70


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    432.38
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       69
neval is:      135
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       69      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       70
neval is:      135


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      135     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.242177      -1.41809      -30.7965       30.7965       386.035       416.831    
   2  0.384023     -0.957054      -20.7843       20.7843       376.237       397.021    
   3  0.672379     -0.396933      -8.62017       8.62017       379.567       388.187    
   4  0.204591      -1.58674      -34.4592       34.4592       382.789       417.248    
   5  0.145151      -1.92998      -41.9132       41.9132       384.612       426.525    
   6  0.235757      -1.44495      -31.3800       31.3800       410.265       441.645    
   7  0.882595     -0.124889      -2.71221       2.71221       407.701       410.413    
   8  0.215562      -1.53451      -33.3248       33.3248       398.523       431.848    
   9  0.248905      -1.39068      -30.2014       30.2014       415.681       445.882    
  10  0.695481     -0.363152      -7.88654       7.88654       419.133       427.019    
  11  0.515786     -0.662063      -14.3780       14.3780       421.881       436.259    
  12  0.956817     -0.441428E-01 -0.958647      0.958647       426.330       427.288    
  13  0.256477      -1.36072      -29.5506       29.5506       416.689       446.239    
  14  0.870409     -0.138792      -3.01414       3.01414       434.451       437.465    
  15  0.296335      -1.21627      -26.4136       26.4136       453.008       479.422    
  16  0.563087     -0.574322      -12.4725       12.4725       440.973       453.445    
  17  0.860973     -0.149692      -3.25085       3.25085       465.723       468.974    
  18  0.336353      -1.08959      -23.6626       23.6626       464.413       488.076    
  19  0.432238     -0.838780      -18.2157       18.2157       475.497       493.713    
  20  0.411587     -0.887734      -19.2789       19.2789       413.918       433.197    
  21  0.685679     -0.377346      -8.19479       8.19479       471.530       479.725    
  22  0.178038E-01  -4.02835      -87.4833       87.4833       480.507       567.990    
  23  0.330516      -1.10710      -24.0428       24.0428       453.721       477.764    
  24  0.987115     -0.129685E-01 -0.281635      0.281635       457.048       457.330    
  25  0.702947     -0.352474      -7.65466       7.65466       488.891       496.546    
  26  0.159040      -1.83860      -39.9287       39.9287       499.703       539.631    
  27  0.329714      -1.10953      -24.0956       24.0956       439.306       463.402    
  28  0.542452     -0.611656      -13.2833       13.2833       509.682       522.965    
  29  0.484074     -0.725518      -15.7560       15.7560       515.714       531.471    
  30  0.574330     -0.554551      -12.0432       12.0432       489.342       501.385    
  31  0.987944     -0.121288E-01 -0.263401      0.263401       432.377       432.640    
loop,thermsimp(1:2)       70   30.7965       20.7843    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    137        411.81         74.43          1.09         38.45          0.01          0.05        114.03
Just calling func    0   0        114.03


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    411.81
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       70
neval is:      136
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       70      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       71
neval is:      136


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      136     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.810305     -0.210344      -4.56803       4.56803       379.567       384.135    
   2  0.601567     -0.508218      -11.0369       11.0369       376.237       387.274    
   3  0.190401      -1.65862      -36.0202       36.0202       407.701       443.721    
   4  0.827263     -0.189632      -4.11823       4.11823       386.035       390.153    
   5  0.581677     -0.541840      -11.7671       11.7671       382.789       394.556    
   6  0.680336     -0.385169      -8.36469       8.36469       384.612       392.977    
   7  0.641383     -0.444128      -9.64511       9.64511       419.133       428.778    
   8  0.593931     -0.520992      -11.3144       11.3144       426.330       437.644    
   9  0.326400      -1.11963      -24.3150       24.3150       398.523       422.838    
  10  0.964323     -0.363286E-01 -0.788946      0.788946       432.377       433.166    
  11  0.481751     -0.730328      -15.8605       15.8605       413.918       429.778    
  12  0.230624E-01  -3.76955      -81.8631       81.8631       421.881       503.744    
  13  0.214859      -1.53777      -33.3958       33.3958       434.451       467.847    
  14  0.325804      -1.12146      -24.3546       24.3546       410.265       434.619    
  15  0.668745     -0.402353      -8.73788       8.73788       415.681       424.418    
  16  0.803263     -0.219073      -4.75759       4.75759       416.689       421.446    
  17  0.465531     -0.764577      -16.6043       16.6043       440.973       457.577    
  18  0.589796     -0.527978      -11.4661       11.4661       457.048       468.514    
  19  0.783335     -0.244195      -5.30317       5.30317       439.306       444.609    
  20  0.937099     -0.649659E-01  -1.41086       1.41086       465.723       467.134    
  21  0.504081     -0.685019      -14.8765       14.8765       453.721       468.598    
  22  0.368431E-01  -3.30109      -71.6895       71.6895       453.008       524.698    
  23  0.462712     -0.770651      -16.7362       16.7362       471.530       488.266    
  24  0.172447      -1.75767      -38.1711       38.1711       464.413       502.584    
  25  0.361979      -1.01617      -22.0681       22.0681       475.497       497.565    
  26  0.616189     -0.484202      -10.5154       10.5154       488.891       499.407    
  27  0.495582     -0.702023      -15.2458       15.2458       489.342       504.588    
  28  0.492859     -0.707532      -15.3654       15.3654       509.682       525.047    
  29  0.189027      -1.66586      -36.1775       36.1775       515.714       551.892    
  30  0.336237      -1.08994      -23.6702       23.6702       499.703       523.373    
  31  0.997382     -0.262184E-02 -0.569382E-01  0.569382E-01   411.806       411.863    
loop,thermsimp(1:2)       71   4.56803       11.0369    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    138        388.18         74.89          1.12         38.07          0.00          0.05        114.14
Just calling func    0   0        114.14


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    139        456.69         73.38          0.96         38.91          0.75          0.05        114.05
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    388.18
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       71
neval is:      138
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       71      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       72
neval is:      138


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      138     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.870330     -0.138883      -3.01611       3.01611       379.567       382.583    
   2  0.470451     -0.754063      -16.3759       16.3759       376.237       392.613    
   3  0.615627     -0.485114      -10.5352       10.5352       386.035       396.570    
   4  0.291899      -1.23135      -26.7411       26.7411       384.612       411.353    
   5  0.584822     -0.536448      -11.6500       11.6500       382.789       394.439    
   6  0.681731     -0.383120      -8.32020       8.32020       411.806       420.126    
   7  0.680149     -0.385444      -8.37066       8.37066       416.689       425.059    
   8  0.560478     -0.578966      -12.5734       12.5734       398.523       411.096    
   9  0.392299     -0.935730      -20.3212       20.3212       415.681       436.002    
  10  0.586793     -0.533083      -11.5769       11.5769       419.133       430.710    
  11  0.461418     -0.773452      -16.7970       16.7970       413.918       430.715    
  12  0.142886      -1.94571      -42.2549       42.2549       432.377       474.632    
  13  0.960325     -0.404831E-01 -0.879169      0.879169       410.265       411.144    
  14  0.547176     -0.602984      -13.0950       13.0950       426.330       439.424    
  15  0.817596     -0.201386      -4.37350       4.37350       407.701       412.074    
  16  0.184065      -1.69247      -36.7552       36.7552       439.306       476.061    
  17  0.763954     -0.269247      -5.84723       5.84723       440.973       446.820    
  18  0.740640     -0.300240      -6.52030       6.52030       465.723       472.244    
  19  0.257299      -1.35751      -29.4811       29.4811       434.451       463.932    
  20  0.274950      -1.29117      -28.0402       28.0402       457.048       485.088    
  21  0.850599     -0.161814      -3.51411       3.51411       453.721       457.235    
  22  0.265651      -1.32557      -28.7874       28.7874       471.530       500.317    
  23  0.388810     -0.944665      -20.5152       20.5152       475.497       496.012    
  24  0.921262     -0.820106E-01  -1.78102       1.78102       488.891       490.672    
  25  0.622168     -0.474545      -10.3057       10.3057       464.413       474.719    
  26  0.831499     -0.184526      -4.00733       4.00733       421.881       425.888    
  27  0.777776     -0.251317      -5.45783       5.45783       489.342       494.800    
  28  0.519638     -0.654624      -14.2164       14.2164       499.703       513.919    
  29  0.343480      -1.06863      -23.2073       23.2073       453.008       476.216    
  30  0.379182     -0.969738      -21.0597       21.0597       509.682       530.742    
  31  0.509964     -0.673415      -14.6245       14.6245       388.176       402.801    
loop,thermsimp(1:2)       72   3.01611       16.3759    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    140        466.82         74.74          1.10         38.08          0.13          0.05        114.11
Just calling func    0   0        114.11


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    466.82
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       72
neval is:      139
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       72      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       73
neval is:      139


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      139     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.741909     -0.298528      -6.48312       6.48312       379.567       386.050    
   2  0.823468     -0.194230      -4.21809       4.21809       376.237       380.455    
   3  0.352913      -1.04153      -22.6189       22.6189       382.789       405.408    
   4  0.268511      -1.31486      -28.5548       28.5548       386.035       414.590    
   5  0.137541      -1.98383      -43.0828       43.0828       388.176       431.259    
   6  0.953738     -0.473661E-01  -1.02865       1.02865       398.523       399.551    
   7  0.366602      -1.00348      -21.7925       21.7925       410.265       432.057    
   8  0.861530     -0.149046      -3.23682       3.23682       384.612       387.849    
   9  0.190086      -1.66028      -36.0561       36.0561       407.701       443.757    
  10  0.931621     -0.708293E-01  -1.53820       1.53820       411.806       413.344    
  11  0.135562      -1.99833      -43.3976       43.3976       416.689       460.086    
  12  0.577052     -0.549824      -11.9405       11.9405       421.881       433.821    
  13  0.937511     -0.645266E-01  -1.40132       1.40132       419.133       420.534    
  14  0.836727     -0.178258      -3.87121       3.87121       413.918       417.789    
  15  0.124731      -2.08159      -45.2058       45.2058       415.681       460.886    
  16  0.830758     -0.185417      -4.02669       4.02669       426.330       430.356    
  17  0.925849     -0.770442E-01  -1.67316       1.67316       440.973       442.646    
  18  0.945668     -0.558633E-01  -1.21318       1.21318       453.721       454.934    
  19  0.700762     -0.355587      -7.72226       7.72226       434.451       442.173    
  20  0.585168E-01  -2.83844      -61.6423       61.6423       465.723       527.366    
  21  0.241985      -1.41888      -30.8137       30.8137       432.377       463.190    
  22  0.426115     -0.853047      -18.5256       18.5256       464.413       482.939    
  23  0.730656     -0.313813      -6.81506       6.81506       439.306       446.121    
  24  0.227460      -1.48078      -32.1581       32.1581       453.008       485.166    
  25  0.824070     -0.193500      -4.20222       4.20222       457.048       461.250    
  26  0.912829     -0.912064E-01  -1.98072       1.98072       488.891       490.872    
  27  0.130860      -2.03363      -44.1642       44.1642       489.342       533.506    
  28  0.126999      -2.06358      -44.8146       44.8146       475.497       520.311    
  29  0.394828E-01  -3.23189      -70.1867       70.1867       471.530       541.717    
  30  0.927793     -0.749466E-01  -1.62761       1.62761       499.703       501.330    
  31  0.161762      -1.82163      -39.5602       39.5602       466.820       506.381    
loop,thermsimp(1:2)       73   6.48312       4.21809    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    141        382.01         74.32          1.07         38.30          0.24          0.05        113.98
Just calling func    0   0        113.98


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    142        385.24         73.47          0.99         38.93          0.54          0.05        113.98
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  140    382.01        1.970     -1.404      5.585     -101.9      1.448    
                     -0.3695      3.288     -100.5      3.476      1.442    
                       2.754     -1.047      1.444      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1462E+05 0.1507E+05 -2617.    -0.5411E+05
                      -2.000     -5.000     -7.026     -6.882     -1.239    
                      -13.19     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                      -1.490     -1.551      3.446      1.267      0.000    
                       0.000      9.205      9.124      2610.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -3593.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -7365.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -4201.      1.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    382.01
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       73
neval is:      141
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       73      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       74
neval is:      141


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      141     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.835960     -0.179175      -3.89113       3.89113       376.237       380.128    
   2  0.439366     -0.822423      -17.8605       17.8605       379.567       397.427    
   3  0.603094     -0.505682      -10.9819       10.9819       384.612       395.594    
   4  0.695854E-01  -2.66520      -57.8800       57.8800       398.523       456.403    
   5  0.273021      -1.29821      -28.1931       28.1931       382.789       410.982    
   6  0.418319     -0.871511      -18.9265       18.9265       411.806       430.733    
   7  0.688437     -0.373331      -8.10761       8.10761       386.035       394.142    
   8  0.400930     -0.913969      -19.8486       19.8486       413.918       433.766    
   9  0.569492     -0.563010      -12.2269       12.2269       419.133       431.360    
  10  0.812441     -0.207712      -4.51087       4.51087       426.330       430.840    
  11  0.222094      -1.50465      -32.6765       32.6765       388.176       420.853    
  12  0.695761     -0.362749      -7.87781       7.87781       410.265       418.142    
  13  0.909536E-01  -2.39741      -52.0643       52.0643       421.881       473.945    
  14  0.297191      -1.21338      -26.3509       26.3509       434.451       460.802    
  15  0.806729     -0.214767      -4.66409       4.66409       440.973       445.637    
  16  0.407021     -0.898891      -19.5212       19.5212       407.701       427.222    
  17  0.520426     -0.653107      -14.1835       14.1835       439.306       453.490    
  18  0.826852     -0.190129      -4.12902       4.12902       453.721       457.850    
  19  0.729268     -0.315714      -6.85634       6.85634       416.689       423.545    
  20  0.344086      -1.06687      -23.1690       23.1690       415.681       438.850    
  21  0.280849      -1.26994      -27.5792       27.5792       457.048       484.627    
  22  0.301244E-01  -3.50242      -76.0619       76.0619       432.377       508.439    
  23  0.503253     -0.686663      -14.9122       14.9122       464.413       479.325    
  24  0.549007     -0.599644      -13.0224       13.0224       453.008       466.031    
  25  0.814230     -0.205513      -4.46311       4.46311       488.891       493.354    
  26  0.641489     -0.443963      -9.64152       9.64152       499.703       509.344    
  27  0.248696      -1.39152      -30.2196       30.2196       466.820       497.040    
  28  0.684472     -0.379107      -8.23304       8.23304       475.497       483.730    
  29  0.815126     -0.204413      -4.43922       4.43922       465.723       470.163    
  30  0.388210     -0.946208      -20.5487       20.5487       489.342       509.891    
  31  0.670538     -0.399675      -8.67972       8.67972       382.012       390.692    
loop,thermsimp(1:2)       74   3.89113       17.8605    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    143        376.96         73.66          1.03         39.04          0.19          0.06        113.97
Just calling func    0   0        113.97


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    144        394.89         73.62          1.01         38.87          0.13          0.06        113.69
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    376.96
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       74
neval is:      143
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       74      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       75
neval is:      143


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      143     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.374776     -0.981426      -21.3136       21.3136       376.237       397.551    
   2  0.269095      -1.31269      -28.5076       28.5076       382.012       410.520    
   3  0.301960      -1.19746      -26.0052       26.0052       386.035       412.040    
   4  0.927593     -0.751619E-01  -1.63229       1.63229       384.612       386.244    
   5  0.783450     -0.244048      -5.29997       5.29997       379.567       384.867    
   6  0.716705     -0.333091      -7.23372       7.23372       382.789       390.023    
   7  0.728578     -0.316661      -6.87691       6.87691       410.265       417.142    
   8  0.752541     -0.284300      -6.17412       6.17412       388.176       394.350    
   9  0.111710      -2.19185      -47.6002       47.6002       416.689       464.289    
  10  0.202752E-01  -3.89836      -84.6604       84.6604       407.701       492.361    
  11  0.967738     -0.327937E-01 -0.712179      0.712179       411.806       412.518    
  12  0.530869     -0.633240      -13.7520       13.7520       426.330       440.082    
  13  0.752699E-01  -2.58668      -56.1747       56.1747       419.133       475.307    
  14  0.658334     -0.418043      -9.07862       9.07862       413.918       422.996    
  15  0.383542     -0.958305      -20.8115       20.8115       415.681       436.492    
  16  0.280803      -1.27010      -27.5828       27.5828       440.973       468.556    
  17  0.976909     -0.233616E-01 -0.507342      0.507342       439.306       439.814    
  18  0.611898     -0.491189      -10.6671       10.6671       398.523       409.190    
  19  0.860469     -0.150278      -3.26358       3.26358       453.721       456.985    
  20  0.375446     -0.979641      -21.2748       21.2748       434.451       455.726    
  21  0.964573     -0.360702E-01 -0.783334      0.783334       453.008       453.792    
  22  0.865663     -0.144259      -3.13287       3.13287       465.723       468.856    
  23  0.498009     -0.697137      -15.1397       15.1397       421.881       437.020    
  24  0.732547     -0.311228      -6.75892       6.75892       464.413       471.172    
  25  0.293766      -1.22497      -26.6026       26.6026       475.497       502.099    
  26  0.805097     -0.216793      -4.70808       4.70808       457.048       461.756    
  27  0.236791      -1.44058      -31.2849       31.2849       488.891       520.176    
  28  0.759809     -0.274688      -5.96539       5.96539       466.820       472.786    
  29  0.279804      -1.27367      -27.6601       27.6601       432.377       460.037    
  30  0.862550     -0.147862      -3.21112       3.21112       499.703       502.914    
  31  0.784800     -0.242327      -5.26259       5.26259       376.962       382.224    
loop,thermsimp(1:2)       75   21.3136       28.5076    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    145        474.03         74.18          1.05         38.79          0.02          0.06        114.11
Just calling func    0   0        114.11


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    474.03
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       75
neval is:      144
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       75      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       76
neval is:      144


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      144     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.497287E-01  -3.00117      -65.1763       65.1763       376.962       442.138    
   2  0.604222     -0.503814      -10.9413       10.9413       379.567       390.508    
   3  0.106168      -2.24273      -48.7052       48.7052       384.612       433.317    
   4  0.342113      -1.07261      -23.2939       23.2939       382.789       406.083    
   5  0.473442     -0.747725      -16.2383       16.2383       388.176       404.415    
   6  0.100866E-01  -4.59655      -99.8230       99.8230       376.237       476.060    
   7  0.911848     -0.922817E-01  -2.00408       2.00408       398.523       400.527    
   8  0.633547     -0.456421      -9.91206       9.91206       382.012       391.924    
   9  0.729024     -0.316048      -6.86360       6.86360       386.035       392.898    
  10  0.620163     -0.477772      -10.3758       10.3758       411.806       422.182    
  11  0.867018     -0.142695      -3.09890       3.09890       410.265       413.364    
  12  0.969344E-01  -2.33372      -50.6813       50.6813       413.918       464.599    
  13  0.358466      -1.02592      -22.2799       22.2799       415.681       437.960    
  14  0.953168     -0.479638E-01  -1.04163       1.04163       421.881       422.922    
  15  0.684510     -0.379052      -8.23184       8.23184       439.306       447.538    
  16  0.482047     -0.729713      -15.8471       15.8471       426.330       442.177    
  17  0.974791     -0.255318E-01 -0.554473      0.554473       453.008       453.563    
  18  0.978669     -0.215619E-01 -0.468259      0.468259       434.451       434.919    
  19  0.929785     -0.728022E-01  -1.58104       1.58104       453.721       455.302    
  20  0.715020     -0.335444      -7.28482       7.28482       432.377       439.662    
  21  0.598247     -0.513752      -11.1571       11.1571       457.048       468.205    
  22  0.107080      -2.23418      -48.5196       48.5196       416.689       465.208    
  23  0.559093     -0.581439      -12.6271       12.6271       440.973       453.600    
  24  0.933094     -0.692491E-01  -1.50388       1.50388       465.723       467.227    
  25  0.470169E-01  -3.05725      -66.3941       66.3941       464.413       530.807    
  26  0.166768      -1.79115      -38.8983       38.8983       466.820       505.719    
  27  0.331277      -1.10480      -23.9929       23.9929       419.133       443.126    
  28  0.961755     -0.389952E-01 -0.846857      0.846857       407.701       408.547    
  29  0.464366E-01  -3.06967      -66.6638       66.6638       475.497       542.161    
  30  0.966136E-03  -6.94221      -150.763       150.763       499.703       650.466    
  31  0.941012     -0.607999E-01  -1.32039       1.32039       474.030       475.350    
loop,thermsimp(1:2)       76   65.1763       10.9413    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    146        418.94         73.87          1.02         38.96          0.31          0.06        114.22
Just calling func    0   0        114.22


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    147        528.56         73.61          1.01         38.78          0.29          0.05        113.73
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    418.94
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       76
neval is:      146
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       76      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       77
neval is:      146


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      146     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.596761     -0.516238      -11.2111       11.2111       379.567       390.778    
   2  0.476930     -0.740385      -16.0789       16.0789       382.012       398.091    
   3  0.845382     -0.167966      -3.64771       3.64771       386.035       389.682    
   4  0.397814     -0.921770      -20.0180       20.0180       398.523       418.541    
   5  0.249923      -1.38660      -30.1128       30.1128       388.176       418.289    
   6  0.591552     -0.525005      -11.4015       11.4015       382.789       394.191    
   7  0.143111      -1.94414      -42.2207       42.2207       407.701       449.921    
   8  0.306099      -1.18385      -25.7095       25.7095       410.265       435.974    
   9  0.441827     -0.816836      -17.7392       17.7392       411.806       429.545    
  10  0.504521     -0.684146      -14.8576       14.8576       421.881       436.738    
  11  0.127660      -2.05839      -44.7019       44.7019       384.612       429.314    
  12  0.333524      -1.09804      -23.8461       23.8461       434.451       458.297    
  13  0.130890      -2.03340      -44.1591       44.1591       415.681       459.840    
  14  0.307732      -1.17853      -25.5940       25.5940       432.377       457.971    
  15  0.154434E-01  -4.17057      -90.5721       90.5721       376.962       467.534    
  16  0.357863      -1.02761      -22.3164       22.3164       426.330       448.646    
  17  0.271898      -1.30233      -28.2826       28.2826       419.133       447.415    
  18  0.906228E-01  -2.40105      -52.1435       52.1435       439.306       491.450    
  19  0.344142      -1.06670      -23.1655       23.1655       453.008       476.174    
  20  0.392886     -0.934237      -20.2888       20.2888       440.973       461.262    
  21  0.454318     -0.788958      -17.1338       17.1338       453.721       470.855    
  22  0.384129     -0.956778      -20.7783       20.7783       413.918       434.696    
  23  0.354037      -1.03835      -22.5499       22.5499       416.689       439.238    
  24  0.154212      -1.86943      -40.5983       40.5983       465.723       506.322    
  25  0.816320     -0.202949      -4.40744       4.40744       457.048       461.456    
  26  0.994970     -0.504291E-02 -0.109516      0.109516       474.030       474.139    
  27  0.374719E-01  -3.28416      -71.3220       71.3220       376.237       447.559    
  28  0.227113      -1.48231      -32.1911       32.1911       466.820       499.012    
  29  0.410587     -0.890167      -19.3317       19.3317       464.413       483.745    
  30  0.104540E-01  -4.56077      -99.0460       99.0460       475.497       574.543    
  31  0.994826     -0.518730E-02 -0.112652      0.112652       418.944       419.057    
loop,thermsimp(1:2)       77   11.2111       16.0789    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    148        425.67         73.64          1.03         38.83          0.51          0.05        114.06
Just calling func    0   0        114.06


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    425.67
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       77
neval is:      147
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       77      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       78
neval is:      147


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      147     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.941883     -0.598737E-01  -1.30027       1.30027       386.035       387.335    
   2  0.368209     -0.999105      -21.6975       21.6975       379.567       401.264    
   3  0.508630     -0.676034      -14.6814       14.6814       382.789       397.470    
   4  0.744324     -0.295279      -6.41256       6.41256       382.012       388.425    
   5  0.401586     -0.912333      -19.8131       19.8131       388.176       407.989    
   6  0.712794     -0.338563      -7.35256       7.35256       398.523       405.875    
   7  0.186976      -1.67678      -36.4144       36.4144       418.944       455.359    
   8  0.688451     -0.373311      -8.10718       8.10718       384.612       392.719    
   9  0.668652     -0.402492      -8.74089       8.74089       411.806       420.547    
  10  0.656767     -0.420426      -9.13038       9.13038       413.918       423.048    
  11  0.853336     -0.158602      -3.44436       3.44436       410.265       413.709    
  12  0.556440     -0.586195      -12.7304       12.7304       421.881       434.611    
  13  0.258558E-01  -3.65522      -79.3802       79.3802       416.689       496.069    
  14  0.121003E-01  -4.41452      -95.8699       95.8699       419.133       515.003    
  15  0.150890      -1.89120      -41.0711       41.0711       376.237       417.308    
  16  0.820074     -0.198360      -4.30778       4.30778       426.330       430.637    
  17  0.151452      -1.88748      -40.9904       40.9904       407.701       448.691    
  18  0.305465      -1.18592      -25.7546       25.7546       432.377       458.131    
  19  0.533202     -0.628854      -13.6568       13.6568       434.451       448.108    
  20  0.143416      -1.94201      -42.1745       42.1745       415.681       457.855    
  21  0.687081     -0.375303      -8.15042       8.15042       440.973       449.123    
  22  0.546247     -0.604685      -13.1319       13.1319       457.048       470.180    
  23  0.356987      -1.03006      -22.3697       22.3697       376.962       399.331    
  24  0.545718     -0.605653      -13.1529       13.1529       453.721       466.874    
  25  0.789688     -0.236117      -5.12773       5.12773       474.030       479.157    
  26  0.752086     -0.284904      -6.18725       6.18725       453.008       459.196    
  27  0.388816     -0.944650      -20.5149       20.5149       464.413       484.928    
  28  0.988428     -0.116395E-01 -0.252775      0.252775       439.306       439.559    
  29  0.124991      -2.07952      -45.1607       45.1607       466.820       511.981    
  30  0.568214     -0.565257      -12.2757       12.2757       465.723       477.999    
  31  0.551032     -0.595962      -12.9425       12.9425       425.672       438.614    
loop,thermsimp(1:2)       78   1.30027       21.6975    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    149        391.09         73.48          0.98         38.61          0.97          0.04        114.08
Just calling func    0   0        114.08


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    150        636.66         74.10          1.05         38.83          0.05          0.05        114.07
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    391.09
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       78
neval is:      149
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       78      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       79
neval is:      149


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      149     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.708826E-01  -2.64673      -57.4789       57.4789       386.035       443.514    
   2  0.952063     -0.491245E-01  -1.06683       1.06683       382.012       383.079    
   3  0.207928      -1.57057      -34.1079       34.1079       384.612       418.720    
   4  0.564009     -0.572686      -12.4370       12.4370       382.789       395.226    
   5  0.461636     -0.772979      -16.7867       16.7867       376.962       393.748    
   6  0.683812     -0.380072      -8.25399       8.25399       379.567       387.821    
   7  0.153569      -1.87360      -40.6889       40.6889       398.523       439.212    
   8  0.605650     -0.501453      -10.8900       10.8900       388.176       399.066    
   9  0.257296      -1.35753      -29.4814       29.4814       410.265       439.746    
  10  0.517987     -0.657805      -14.2855       14.2855       376.237       390.522    
  11  0.571129     -0.560140      -12.1645       12.1645       411.806       423.971    
  12  0.735134     -0.307703      -6.68236       6.68236       413.918       420.600    
  13  0.766340E-02  -4.87130      -105.790       105.790       426.330       532.119    
  14  0.435932     -0.830269      -18.0309       18.0309       421.881       439.911    
  15  0.513945     -0.665639      -14.4556       14.4556       425.672       440.127    
  16  0.447046     -0.805095      -17.4842       17.4842       439.306       456.790    
  17  0.244813      -1.40726      -30.5614       30.5614       434.451       465.012    
  18  0.183933      -1.69318      -36.7708       36.7708       407.701       444.471    
  19  0.413164     -0.883910      -19.1958       19.1958       440.973       460.169    
  20  0.869613     -0.139707      -3.03402       3.03402       418.944       421.978    
  21  0.853260     -0.158691      -3.44628       3.44628       415.681       419.127    
  22  0.138067      -1.98001      -42.9998       42.9998       432.377       475.377    
  23  0.940528     -0.613134E-01  -1.33154       1.33154       453.008       454.340    
  24  0.694939     -0.363931      -7.90347       7.90347       453.721       461.625    
  25  0.962776     -0.379346E-01 -0.823824      0.823824       457.048       457.872    
  26  0.378266     -0.972158      -21.1123       21.1123       465.723       486.836    
  27  0.855922     -0.155576      -3.37863       3.37863       474.030       477.408    
  28  0.393452     -0.932797      -20.2575       20.2575       464.413       484.670    
  29  0.253590      -1.37204      -29.7965       29.7965       416.689       446.485    
  30  0.777948     -0.251096      -5.45303       5.45303       466.820       472.274    
  31  0.654890     -0.423288      -9.19253       9.19253       391.093       400.285    
loop,thermsimp(1:2)       79   57.4789       1.06683    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    151        389.46         73.39          0.98         38.88          0.92          0.04        114.21
Just calling func    0   0        114.22


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    152        450.14         73.38          0.98         38.83          0.70          0.05        113.93
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    389.46
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       79
neval is:      151
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       79      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       80
neval is:      151


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      151
neval,tstepnext:      151     151

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.668425     -0.402832      -8.74827       8.74827       382.012       390.760    
   2  0.238500      -1.43339      -31.1288       31.1288       379.567       410.696    
   3  0.689211     -0.372208      -8.08323       8.08323       376.237       384.320    
   4  0.540774     -0.614753      -13.3506       13.3506       376.962       390.312    
   5  0.178857      -1.72117      -37.3786       37.3786       382.789       420.168    
   6  0.884253     -0.123012      -2.67145       2.67145       388.176       390.848    
   7  0.755546     -0.280314      -6.08757       6.08757       391.093       397.180    
   8  0.654086E-01  -2.72710      -59.2243       59.2243       384.612       443.836    
   9  0.802958     -0.219452      -4.76583       4.76583       415.681       420.446    
  10  0.840665     -0.173562      -3.76923       3.76923       413.918       417.687    
  11  0.864930     -0.145107      -3.15127       3.15127       418.944       422.095    
  12  0.728243     -0.317120      -6.88688       6.88688       411.806       418.693    
  13  0.453086     -0.791672      -17.1927       17.1927       398.523       415.715    
  14  0.702549E-01  -2.65563      -57.6721       57.6721       410.265       467.937    
  15  0.610595     -0.493321      -10.7134       10.7134       421.881       432.594    
  16  0.728410E-02  -4.92206      -106.892       106.892       425.672       532.564    
  17  0.913763     -0.901841E-01  -1.95852       1.95852       386.035       387.993    
  18  0.165001      -1.80180      -39.1297       39.1297       407.701       446.830    
  19  0.917747E-01  -2.38842      -51.8691       51.8691       416.689       468.558    
  20  0.338507      -1.08321      -23.5240       23.5240       453.008       476.532    
  21  0.357666      -1.02815      -22.3284       22.3284       439.306       461.635    
  22  0.389441     -0.943044      -20.4800       20.4800       457.048       477.528    
  23  0.879897     -0.127950      -2.77868       2.77868       440.973       443.751    
  24  0.418897     -0.870129      -18.8965       18.8965       453.721       472.618    
  25  0.838426     -0.176230      -3.82717       3.82717       434.451       438.278    
  26  0.185169      -1.68649      -36.6253       36.6253       466.820       503.446    
  27  0.200952      -1.60469      -34.8489       34.8489       432.377       467.226    
  28  0.877256     -0.130957      -2.84398       2.84398       474.030       476.874    
  29  0.386592     -0.950385      -20.6395       20.6395       464.413       485.052    
  30  0.888706     -0.117988      -2.56235       2.56235       465.723       468.286    
  31  0.105408      -2.24991      -48.8613       48.8613       389.455       438.317    
loop,thermsimp(1:2)       80   8.74827       31.1288    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    153        447.94         74.40          1.03         38.53          0.27          0.05        114.28
Just calling func    0   0        114.28


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    447.94
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    21.7169               151
loop is:       80
neval is:      152
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       80      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    21.7169               151
loop is:       81
neval is:      152


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 




neval>tstepnex so lower away!t
---> lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
     new SAtemp,tstepnext are :    10.8585               181

 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      152     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.270023      -1.30925      -14.2164       14.2164       376.237       390.453    
   2  0.879265     -0.128669      -1.39714       1.39714       386.035       387.432    
   3  0.684902     -0.378479      -4.10970       4.10970       376.962       381.071    
   4  0.893896     -0.112166      -1.21795       1.21795       382.012       383.230    
   5  0.476761     -0.740739      -8.04330       8.04330       388.176       396.220    
   6  0.755167     -0.280817      -3.04924       3.04924       391.093       394.142    
   7  0.452407     -0.793173      -8.61264       8.61264       379.567       388.180    
   8  0.723906     -0.323093      -3.50830       3.50830       398.523       402.031    
   9  0.451260     -0.795711      -8.64021       8.64021       413.918       422.558    
  10  0.668265     -0.403071      -4.37674       4.37674       411.806       416.183    
  11  0.777249     -0.251995      -2.73628       2.73628       382.789       385.525    
  12  0.342240      -1.07224      -11.6429       11.6429       415.681       427.323    
  13  0.639156     -0.447606      -4.86032       4.86032       418.944       423.805    
  14  0.166924      -1.79022      -19.4390       19.4390       421.881       441.320    
  15  0.375260     -0.980137      -10.6428       10.6428       434.451       445.094    
  16  0.299730      -1.20487      -13.0831       13.0831       389.455       402.538    
  17  0.407119     -0.898650      -9.75797       9.75797       440.973       450.731    
  18  0.762992E-01  -2.57309      -27.9399       27.9399       384.612       412.552    
  19  0.281066      -1.26917      -13.7812       13.7812       407.701       421.482    
  20  0.220512      -1.51180      -16.4159       16.4159       439.306       455.722    
  21  0.389846     -0.942004      -10.2287       10.2287       432.377       442.605    
  22  0.660048     -0.415443      -4.51108       4.51108       410.265       414.776    
  23  0.150026      -1.89695      -20.5980       20.5980       465.723       486.321    
  24  0.113767      -2.17360      -23.6020       23.6020       416.689       440.290    
  25  0.810589     -0.209994      -2.28021       2.28021       453.721       456.001    
  26  0.247911      -1.39468      -15.1441       15.1441       453.008       468.153    
  27  0.408875     -0.894345      -9.71122       9.71122       474.030       483.741    
  28  0.310528      -1.16948      -12.6988       12.6988       457.048       469.747    
  29  0.663027     -0.410939      -4.46217       4.46217       464.413       468.875    
  30  0.798362     -0.225193      -2.44525       2.44525       466.820       469.266    
  31  0.564885     -0.571133      -6.20164       6.20164       447.936       454.138    
loop,thermsimp(1:2)       81   14.2164       1.39714    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    154        345.08         73.46          0.98         38.73          0.90          0.06        114.14
Just calling func    0   0        114.14


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    155        813.50         73.72          0.98         38.66          0.96          0.04        114.37
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    345.08
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:       81
neval is:      154
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       81      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:       82
neval is:      154


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      154     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.130014E-01  -4.34270      -47.1551       47.1551       376.962       424.117    
   2  0.906957E-01  -2.40025      -26.0630       26.0630       382.012       408.075    
   3  0.973677     -0.266758E-01 -0.289659      0.289659       382.789       383.079    
   4  0.764409     -0.268653      -2.91716       2.91716       386.035       388.952    
   5  0.647718     -0.434300      -4.71583       4.71583       379.567       384.283    
   6  0.450945     -0.796410      -8.64779       8.64779       376.237       384.885    
   7  0.342138      -1.07254      -11.6462       11.6462       391.093       402.739    
   8  0.491560     -0.710170      -7.71136       7.71136       388.176       395.888    
   9  0.728901     -0.316218      -3.43364       3.43364       398.523       401.956    
  10  0.361124      -1.01853      -11.0597       11.0597       389.455       400.515    
  11  0.187026      -1.67651      -18.2043       18.2043       384.612       402.816    
  12  0.560514     -0.578901      -6.28598       6.28598       410.265       416.551    
  13  0.218776      -1.51971      -16.5017       16.5017       411.806       428.308    
  14  0.109271      -2.21392      -24.0398       24.0398       407.701       431.740    
  15  0.263420E-01  -3.63659      -39.4878       39.4878       413.918       453.406    
  16  0.654642     -0.423667      -4.60038       4.60038       418.944       423.545    
  17  0.975959     -0.243343E-01 -0.264233      0.264233       415.681       415.945    
  18  0.107212      -2.23295      -24.2464       24.2464       416.689       440.935    
  19  0.972340     -0.280494E-01 -0.304574      0.304574       421.881       422.185    
  20  0.259158      -1.35032      -14.6624       14.6624       432.377       447.039    
  21  0.889970     -0.116568      -1.26574       1.26574       434.451       435.717    
  22  0.956672     -0.442943E-01 -0.480968      0.480968       440.973       441.454    
  23  0.299261      -1.20644      -13.1001       13.1001       447.936       461.036    
  24  0.114836      -2.16425      -23.5004       23.5004       439.306       462.807    
  25  0.728848     -0.316291      -3.43443       3.43443       453.721       457.156    
  26  0.650336     -0.430267      -4.67204       4.67204       453.008       457.680    
  27  0.816983     -0.202137      -2.19490       2.19490       464.413       466.608    
  28  0.507860     -0.677550      -7.35715       7.35715       466.820       474.178    
  29  0.920661     -0.826634E-01 -0.897598      0.897598       457.048       457.946    
  30  0.253772      -1.37132      -14.8904       14.8904       474.030       488.920    
  31  0.667512     -0.404198      -4.38897       4.38897       345.084       349.473    
loop,thermsimp(1:2)       82   47.1551       26.0630    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    156        463.77         73.39          0.97         38.80          0.81          0.05        114.02
Just calling func    0   0        114.02


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    463.77
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:       82
neval is:      155
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       82      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:       83
neval is:      155


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      155     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.609134     -0.495717      -5.38272       5.38272       345.084       350.467    
   2  0.266275      -1.32323      -14.3682       14.3682       382.789       397.157    
   3  0.545538     -0.605984      -6.58006       6.58006       379.567       386.147    
   4  0.196234      -1.62845      -17.6824       17.6824       376.237       393.919    
   5  0.786411     -0.240275      -2.60902       2.60902       386.035       388.644    
   6  0.453912     -0.789853      -8.57659       8.57659       388.176       396.753    
   7  0.900549     -0.104751      -1.13743       1.13743       389.455       390.593    
   8  0.339919      -1.07905      -11.7168       11.7168       398.523       410.240    
   9  0.511643     -0.670128      -7.27656       7.27656       391.093       398.369    
  10  0.628202     -0.464894      -5.04803       5.04803       384.612       389.660    
  11  0.672886E-01  -2.69876      -29.3045       29.3045       382.012       411.317    
  12  0.518493     -0.656829      -7.13216       7.13216       415.681       422.813    
  13  0.994926     -0.508642E-02 -0.552307E-01  0.552307E-01   410.265       410.320    
  14  0.733191     -0.310349      -3.36991       3.36991       421.881       425.250    
  15  0.952818     -0.483318E-01 -0.524810      0.524810       418.944       419.469    
  16  0.735955     -0.306586      -3.32906       3.32906       376.962       380.291    
  17  0.743149     -0.296859      -3.22343       3.22343       411.806       415.030    
  18  0.549375     -0.598975      -6.50395       6.50395       407.701       414.204    
  19  0.355140      -1.03524      -11.2412       11.2412       434.451       445.692    
  20  0.482165     -0.729469      -7.92091       7.92091       416.689       424.609    
  21  0.577197     -0.549571      -5.96751       5.96751       440.973       446.940    
  22  0.107316E-01  -4.53456      -49.2384       49.2384       432.377       481.615    
  23  0.923969     -0.790764E-01 -0.858648      0.858648       413.918       414.776    
  24  0.810451     -0.210164      -2.28206       2.28206       453.721       456.003    
  25  0.143346      -1.94249      -21.0925       21.0925       453.008       474.101    
  26  0.994184     -0.583318E-02 -0.633395E-01  0.633395E-01   457.048       457.111    
  27  0.870737     -0.138415      -1.50298       1.50298       447.936       449.439    
  28  0.970691     -0.297469E-01 -0.323006      0.323006       439.306       439.629    
  29  0.351269      -1.04620      -11.3602       11.3602       464.413       475.773    
  30  0.464982     -0.765756      -8.31494       8.31494       466.820       475.135    
  31  0.921785     -0.814432E-01 -0.884348      0.884348       463.765       464.650    
loop,thermsimp(1:2)       83   5.38272       14.3682    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    157        430.23         73.40          0.97         38.55          1.27          0.04        114.23
Just calling func    0   0        114.23


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    430.23
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:       83
neval is:      156
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       83      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:       84
neval is:      156


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      156     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.572627     -0.557521      -6.05382       6.05382       345.084       351.138    
   2  0.468879     -0.757411      -8.22433       8.22433       376.962       385.186    
   3  0.886741E-01  -2.42279      -26.3078       26.3078       379.567       405.875    
   4  0.211783      -1.55219      -16.8544       16.8544       386.035       402.889    
   5  0.573306     -0.556336      -6.04095       6.04095       384.612       390.653    
   6  0.401711     -0.912021      -9.90315       9.90315       389.455       399.358    
   7  0.505706     -0.681800      -7.40331       7.40331       376.237       383.640    
   8  0.603045     -0.505763      -5.49182       5.49182       388.176       393.668    
   9  0.696575     -0.361580      -3.92621       3.92621       382.789       386.715    
  10  0.294614      -1.22209      -13.2700       13.2700       391.093       404.363    
  11  0.527550     -0.639511      -6.94412       6.94412       398.523       405.467    
  12  0.657157     -0.419832      -4.55873       4.55873       410.265       414.823    
  13  0.627866     -0.465428      -5.05383       5.05383       382.012       387.066    
  14  0.993353E-02  -4.61184      -50.0775       50.0775       407.701       457.778    
  15  0.885166E-01  -2.42456      -26.3271       26.3271       413.918       440.245    
  16  0.265764      -1.32515      -14.3891       14.3891       411.806       426.195    
  17  0.446403     -0.806534      -8.75772       8.75772       418.944       427.702    
  18  0.287864      -1.24527      -13.5217       13.5217       415.681       429.202    
  19  0.926928E-01  -2.37846      -25.8265       25.8265       416.689       442.515    
  20  0.394849     -0.929252      -10.0903       10.0903       421.881       431.971    
  21  0.540746     -0.614805      -6.67584       6.67584       439.306       445.982    
  22  0.846435     -0.166721      -1.81034       1.81034       434.451       436.261    
  23  0.417037     -0.874580      -9.49660       9.49660       440.973       450.469    
  24  0.210713      -1.55726      -16.9094       16.9094       447.936       464.846    
  25  0.764669     -0.268312      -2.91346       2.91346       453.721       456.635    
  26  0.219471E-01  -3.81912      -41.4698       41.4698       457.048       498.518    
  27  0.200728      -1.60581      -17.4366       17.4366       463.765       481.202    
  28  0.572660     -0.557463      -6.05320       6.05320       453.008       459.062    
  29  0.599083E-01  -2.81494      -30.5659       30.5659       466.820       497.386    
  30  0.214614      -1.53891      -16.7102       16.7102       464.413       481.123    
  31  0.489389     -0.714598      -7.75944       7.75944       430.234       437.994    
loop,thermsimp(1:2)       84   6.05382       8.22433    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    158        371.59         73.51          0.99         38.69          0.82          0.05        114.07
Just calling func    0   0        114.06


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    371.59
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:       84
neval is:      157
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       84      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:       85
neval is:      157


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      157     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.197499      -1.62202      -17.6127       17.6127       345.084       362.697    
   2  0.793097     -0.231809      -2.51709       2.51709       376.237       378.754    
   3  0.261081      -1.34293      -14.5821       14.5821       376.962       391.544    
   4  0.912198     -0.918984E-01 -0.997876      0.997876       382.789       383.787    
   5  0.493539     -0.706153      -7.66774       7.66774       382.012       389.680    
   6  0.721001     -0.327115      -3.55196       3.55196       384.612       388.164    
   7  0.578790     -0.546816      -5.93759       5.93759       388.176       394.114    
   8  0.684127     -0.379612      -4.12200       4.12200       389.455       393.577    
   9  0.627712     -0.465674      -5.05651       5.05651       386.035       391.091    
  10  0.858540     -0.152522      -1.65616       1.65616       391.093       392.749    
  11  0.712254E-01  -2.64191      -28.6871       28.6871       398.523       427.210    
  12  0.927250     -0.755316E-01 -0.820158      0.820158       379.567       380.387    
  13  0.458073     -0.780727      -8.47750       8.47750       410.265       418.742    
  14  0.940004     -0.618714E-01 -0.671829      0.671829       411.806       412.478    
  15  0.322549      -1.13150      -12.2864       12.2864       418.944       431.231    
  16  0.939473     -0.624358E-01 -0.677957      0.677957       415.681       416.359    
  17  0.726080     -0.320095      -3.47574       3.47574       421.881       425.356    
  18  0.602088E-02  -5.11252      -55.5142       55.5142       434.451       489.965    
  19  0.735289     -0.307492      -3.33889       3.33889       430.234       433.573    
  20  0.847617     -0.165326      -1.79519       1.79519       413.918       415.713    
  21  0.747190E-01  -2.59402      -28.1671       28.1671       416.689       444.856    
  22  0.248374      -1.39282      -15.1239       15.1239       439.306       454.430    
  23  0.350184      -1.04930      -11.3937       11.3937       440.973       452.367    
  24  0.327739E-03  -8.02329      -87.1207       87.1207       453.721       540.842    
  25  0.130012      -2.04013      -22.1527       22.1527       407.701       429.853    
  26  0.609791     -0.494639      -5.37102       5.37102       453.008       458.379    
  27  0.793414     -0.231410      -2.51276       2.51276       447.936       450.449    
  28  0.962567     -0.381519E-01 -0.414271      0.414271       464.413       464.827    
  29  0.499469     -0.694211      -7.53807       7.53807       463.765       471.303    
  30  0.887491     -0.119357      -1.29604       1.29604       466.820       468.117    
  31  0.136374      -1.99236      -21.6339       21.6339       371.589       393.223    
loop,thermsimp(1:2)       85   17.6127       2.51709    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    159        553.08         73.50          0.99         38.79          0.84          0.05        114.16
Just calling func    0   0        114.17


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    160        398.18         73.51          1.00         38.58          0.89          0.05        114.03
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    398.18
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:       85
neval is:      159
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       85      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:       86
neval is:      159


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      159     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.464881     -0.765974      -8.31730       8.31730       345.084       353.402    
   2  0.948887     -0.524654E-01 -0.569694      0.569694       376.237       376.807    
   3  0.532332     -0.630488      -6.84613       6.84613       379.567       386.413    
   4  0.374267     -0.982785      -10.6715       10.6715       382.789       393.461    
   5  0.694531     -0.364519      -3.95812       3.95812       384.612       388.570    
   6  0.414371     -0.880994      -9.56624       9.56624       382.012       391.578    
   7  0.208827E-01  -3.86883      -42.0096       42.0096       386.035       428.044    
   8  0.627187     -0.466511      -5.06559       5.06559       376.962       382.027    
   9  0.148799E-01  -4.20774      -45.6896       45.6896       391.093       436.782    
  10  0.809008     -0.211946      -2.30141       2.30141       371.589       373.890    
  11  0.647680     -0.434359      -4.71648       4.71648       389.455       394.172    
  12  0.289351      -1.24012      -13.4658       13.4658       388.176       401.642    
  13  0.222457      -1.50302      -16.3205       16.3205       411.806       428.127    
  14  0.374268     -0.982782      -10.6715       10.6715       413.918       424.589    
  15  0.785765     -0.241097      -2.61795       2.61795       415.681       418.299    
  16  0.298051      -1.21049      -13.1441       13.1441       410.265       423.409    
  17  0.725075     -0.321480      -3.49078       3.49078       421.881       425.371    
  18  0.386364     -0.950976      -10.3261       10.3261       398.523       408.849    
  19  0.631686     -0.459363      -4.98797       4.98797       407.701       412.688    
  20  0.688282     -0.373557      -4.05626       4.05626       418.944       423.000    
  21  0.373817     -0.983990      -10.6846       10.6846       430.234       440.919    
  22  0.219845      -1.51483      -16.4488       16.4488       416.689       433.137    
  23  0.926271     -0.765889E-01 -0.831638      0.831638       447.936       448.768    
  24  0.618127     -0.481061      -5.22359       5.22359       440.973       446.196    
  25  0.176216      -1.73604      -18.8508       18.8508       439.306       458.157    
  26  0.742943     -0.297136      -3.22644       3.22644       453.008       456.235    
  27  0.357690      -1.02809      -11.1635       11.1635       464.413       475.576    
  28  0.478359     -0.737394      -8.00697       8.00697       466.820       474.827    
  29  0.395976     -0.926401      -10.0593       10.0593       463.765       473.825    
  30  0.803186     -0.219169      -2.37984       2.37984       434.451       436.831    
  31  0.231845      -1.46168      -15.8717       15.8717       398.183       414.055    
loop,thermsimp(1:2)       86   8.31730      0.569694    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    161        376.73         73.46          0.98         38.79          0.79          0.05        114.07
Just calling func    0   0        114.07


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  160    376.73        1.942     -1.319      5.748     -102.7      1.466    
                     -0.2615      3.491     -100.4      3.636      1.492    
                       1.801    -0.7350      1.270      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1465E+05 0.1679E+05 -3082.    -0.5799E+05
                      -2.000     -5.570     -7.149     -6.941    -0.7344    
                      -13.48     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                      -1.772     -1.599      3.665      1.345      0.000    
                       0.000      9.205      9.124      5582.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -2214.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -8287.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -7501.      1.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    376.73
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:       86
neval is:      160
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       86      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:       87
neval is:      160


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      160     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.182970      -1.69843      -18.4424       18.4424       345.084       363.527    
   2  0.721345     -0.326637      -3.54678       3.54678       371.589       375.135    
   3  0.842493     -0.171390      -1.86103       1.86103       376.237       378.098    
   4  0.260540      -1.34500      -14.6046       14.6046       376.962       391.566    
   5  0.782605     -0.245127      -2.66171       2.66171       379.567       382.229    
   6  0.208492      -1.56785      -17.0245       17.0245       384.612       401.637    
   7  0.290568E-01  -3.53850      -38.4227       38.4227       382.012       420.435    
   8  0.673682     -0.394997      -4.28906       4.28906       382.789       387.078    
   9  0.399393     -0.917808      -9.96599       9.96599       389.455       399.421    
  10  0.966971     -0.335863E-01 -0.364696      0.364696       388.176       388.541    
  11  0.390645     -0.939956      -10.2065       10.2065       398.523       408.729    
  12  0.259548      -1.34881      -14.6461       14.6461       407.701       422.347    
  13  0.260765      -1.34413      -14.5952       14.5952       398.183       412.778    
  14  0.110601E-01  -4.50441      -48.9110       48.9110       415.681       464.592    
  15  0.727710     -0.317852      -3.45139       3.45139       418.944       422.396    
  16  0.717076     -0.332574      -3.61125       3.61125       410.265       413.876    
  17  0.612129     -0.490811      -5.32946       5.32946       413.918       419.247    
  18  0.589376     -0.528691      -5.74078       5.74078       421.881       427.621    
  19  0.541615     -0.613199      -6.65841       6.65841       386.035       392.693    
  20  0.330403      -1.10744      -12.0251       12.0251       411.806       423.831    
  21  0.229530      -1.47172      -15.9806       15.9806       416.689       432.669    
  22  0.564010     -0.572684      -6.21847       6.21847       391.093       397.311    
  23  0.454226     -0.789161      -8.56908       8.56908       434.451       443.020    
  24  0.579528     -0.545541      -5.92374       5.92374       430.234       436.158    
  25  0.245500      -1.40446      -15.2503       15.2503       440.973       456.223    
  26  0.708019     -0.345284      -3.74925       3.74925       447.936       451.685    
  27  0.300215      -1.20326      -13.0655       13.0655       453.008       466.074    
  28  0.721461     -0.326478      -3.54505       3.54505       439.306       442.851    
  29  0.326772      -1.11849      -12.1451       12.1451       463.765       475.910    
  30  0.580879     -0.543212      -5.89846       5.89846       466.820       472.719    
  31  0.963075     -0.376241E-01 -0.408540      0.408540       376.733       377.141    
loop,thermsimp(1:2)       87   18.4424       3.54678    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    162        446.57         73.54          0.98         38.67          1.02          0.05        114.26
Just calling func    0   0        114.26


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    446.57
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:       87
neval is:      161
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       87      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:       88
neval is:      161


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      161     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.220180      -1.51331      -16.4322       16.4322       345.084       361.517    
   2  0.246752E-01  -3.70196      -40.1976       40.1976       371.589       411.786    
   3  0.679039     -0.387076      -4.20306       4.20306       376.733       380.936    
   4  0.709027     -0.343862      -3.73381       3.73381       376.237       379.971    
   5  0.577754     -0.548608      -5.95704       5.95704       379.567       385.524    
   6  0.738694     -0.302871      -3.28872       3.28872       382.789       386.078    
   7  0.181723      -1.70527      -18.5167       18.5167       388.176       406.693    
   8  0.103748      -2.26579      -24.6030       24.6030       376.962       401.565    
   9  0.456811E-02  -5.38866      -58.5126       58.5126       386.035       444.547    
  10  0.303247      -1.19321      -12.9564       12.9564       391.093       404.049    
  11  0.284736      -1.25619      -13.6403       13.6403       389.455       403.096    
  12  0.900494     -0.104812      -1.13810       1.13810       384.612       385.750    
  13  0.691792     -0.368470      -4.00102       4.00102       398.523       402.524    
  14  0.502714     -0.687735      -7.46774       7.46774       398.183       405.651    
  15  0.305219      -1.18673      -12.8860       12.8860       410.265       423.151    
  16  0.412005     -0.886720      -9.62843       9.62843       413.918       423.546    
  17  0.412225     -0.886186      -9.62262       9.62262       382.012       391.635    
  18  0.121697      -2.10622      -22.8704       22.8704       407.701       430.571    
  19  0.465374     -0.764915      -8.30580       8.30580       418.944       427.250    
  20  0.273016      -1.29823      -14.0967       14.0967       411.806       425.903    
  21  0.502763     -0.687636      -7.46667       7.46667       421.881       429.347    
  22  0.516442     -0.660793      -7.17520       7.17520       416.689       423.864    
  23  0.554333     -0.589990      -6.40639       6.40639       430.234       436.641    
  24  0.192397E-01  -3.95078      -42.8994       42.8994       439.306       482.206    
  25  0.451279E-01  -3.09825      -33.6423       33.6423       434.451       468.093    
  26  0.457340     -0.782327      -8.49488       8.49488       447.936       456.431    
  27  0.325184      -1.12336      -12.1980       12.1980       440.973       453.171    
  28  0.700952     -0.355315      -3.85818       3.85818       415.681       419.539    
  29  0.961087     -0.396906E-01 -0.430979      0.430979       453.008       453.439    
  30  0.195966E-02  -6.23498      -67.7024       67.7024       466.820       534.523    
  31  0.766376     -0.266082      -2.88925       2.88925       446.574       449.463    
loop,thermsimp(1:2)       88   16.4322       40.1976    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    163        449.61         73.47          0.98         38.77          0.90          0.05        114.16
Just calling func    0   0        114.16


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    449.61
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:       88
neval is:      162
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       88      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:       89
neval is:      162


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      162     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.876761     -0.131521      -1.42812       1.42812       345.084       346.513    
   2  0.765270     -0.267527      -2.90493       2.90493       376.237       379.142    
   3  0.215687      -1.53393      -16.6561       16.6561       376.733       393.389    
   4  0.999601E-01  -2.30298      -25.0069       25.0069       379.567       404.574    
   5  0.706519     -0.347405      -3.77228       3.77228       384.612       388.384    
   6  0.201358      -1.60267      -17.4026       17.4026       382.789       400.192    
   7  0.450677     -0.797005      -8.65426       8.65426       382.012       390.666    
   8  0.897557     -0.108078      -1.17357       1.17357       376.962       378.135    
   9  0.161166      -1.82532      -19.8202       19.8202       398.523       418.343    
  10  0.972556E-01  -2.33041      -25.3047       25.3047       389.455       414.760    
  11  0.742112     -0.298255      -3.23859       3.23859       391.093       394.331    
  12  0.172377      -1.75807      -19.0899       19.0899       398.183       417.273    
  13  0.658751     -0.417410      -4.53243       4.53243       388.176       392.709    
  14  0.725340     -0.321114      -3.48681       3.48681       371.589       375.075    
  15  0.501488     -0.690175      -7.49424       7.49424       415.681       423.175    
  16  0.845372     -0.167978      -1.82399       1.82399       410.265       412.089    
  17  0.132369      -2.02216      -21.9576       21.9576       413.918       435.875    
  18  0.734515E-01  -2.61113      -28.3529       28.3529       416.689       445.041    
  19  0.391205     -0.938523      -10.1909       10.1909       411.806       421.997    
  20  0.376983     -0.975555      -10.5930       10.5930       418.944       429.537    
  21  0.315463      -1.15371      -12.5276       12.5276       421.881       434.408    
  22  0.267113      -1.32008      -14.3341       14.3341       407.701       422.035    
  23  0.965292     -0.353243E-01 -0.383568      0.383568       430.234       430.618    
  24  0.954592     -0.464714E-01 -0.504609      0.504609       386.035       386.539    
  25  0.992414     -0.761515E-02 -0.826889E-01  0.826889E-01   446.574       446.657    
  26  0.867953E-02  -4.74679      -51.5429       51.5429       440.973       492.516    
  27  0.829585     -0.186829      -2.02868       2.02868       453.008       455.037    
  28  0.349695      -1.05069      -11.4089       11.4089       447.936       459.345    
  29  0.673511     -0.395251      -4.29182       4.29182       434.451       438.743    
  30  0.340696      -1.07676      -11.6920       11.6920       439.306       450.998    
  31  0.558731     -0.582087      -6.32057       6.32057       449.609       455.929    
loop,thermsimp(1:2)       89   1.42812       2.90493    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    164        400.85         74.20          1.05         38.60          0.25          0.05        114.14
Just calling func    0   0        114.15


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    400.85
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:       89
neval is:      163
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       89      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:       90
neval is:      163


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      163     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.157371      -1.84915      -20.0789       20.0789       345.084       365.163    
   2  0.894146     -0.111886      -1.21491       1.21491       371.589       372.804    
   3  0.721270     -0.326741      -3.54791       3.54791       376.962       380.510    
   4  0.536866     -0.622006      -6.75403       6.75403       376.237       382.991    
   5  0.418107     -0.872017      -9.46877       9.46877       386.035       395.503    
   6  0.391189     -0.938564      -10.1914       10.1914       384.612       394.803    
   7  0.799669     -0.223558      -2.42749       2.42749       382.012       384.440    
   8  0.595070     -0.519076      -5.63638       5.63638       388.176       393.813    
   9  0.384356E-03  -7.86394      -85.3904       85.3904       376.733       462.123    
  10  0.654302     -0.424187      -4.60602       4.60602       391.093       395.699    
  11  0.873355     -0.135413      -1.47038       1.47038       382.789       384.259    
  12  0.303212      -1.19332      -12.9576       12.9576       379.567       392.525    
  13  0.434159     -0.834344      -9.05970       9.05970       410.265       419.324    
  14  0.970825     -0.296089E-01 -0.321508      0.321508       389.455       389.777    
  15  0.405896     -0.901659      -9.79063       9.79063       398.183       407.974    
  16  0.250423      -1.38461      -15.0347       15.0347       398.523       413.557    
  17  0.517030     -0.659654      -7.16283       7.16283       411.806       418.969    
  18  0.165468      -1.79897      -19.5341       19.5341       407.701       427.235    
  19  0.679403     -0.386541      -4.19724       4.19724       415.681       419.878    
  20  0.554013     -0.590567      -6.41265       6.41265       418.944       425.357    
  21  0.211764E-01  -3.85487      -41.8580       41.8580       430.234       472.092    
  22  0.453828     -0.790038      -8.57860       8.57860       421.881       430.459    
  23  0.377409     -0.974426      -10.5808       10.5808       413.918       424.499    
  24  0.496879     -0.699408      -7.59450       7.59450       434.451       442.045    
  25  0.214619      -1.53889      -16.7100       16.7100       416.689       433.399    
  26  0.724154     -0.322751      -3.50458       3.50458       446.574       450.079    
  27  0.385609     -0.952932      -10.3474       10.3474       439.306       449.654    
  28  0.777864     -0.251204      -2.72769       2.72769       453.008       455.736    
  29  0.709283     -0.343500      -3.72988       3.72988       449.609       453.339    
  30  0.191760      -1.65151      -17.9329       17.9329       447.936       465.869    
  31  0.347616      -1.05666      -11.4737       11.4737       400.853       412.327    
loop,thermsimp(1:2)       90   20.0789       1.21491    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    165        453.44         73.66          1.02         38.88          0.67          0.04        114.27
Just calling func    0   0        114.27


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    453.44
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:       90
neval is:      164
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       90      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:       91
neval is:      164


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      164     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.102884      -2.27415      -24.6938       24.6938       345.084       369.778    
   2  0.846291     -0.166892      -1.81219       1.81219       371.589       373.401    
   3  0.167054      -1.78944      -19.4305       19.4305       376.962       396.392    
   4  0.786038     -0.240750      -2.61418       2.61418       376.237       378.851    
   5  0.680218     -0.385341      -4.18422       4.18422       382.789       386.973    
   6  0.843894     -0.169729      -1.84300       1.84300       382.012       383.855    
   7  0.295559      -1.21889      -13.2353       13.2353       389.455       402.691    
   8  0.383493     -0.958433      -10.4071       10.4071       379.567       389.974    
   9  0.867247     -0.142431      -1.54658       1.54658       388.176       389.723    
  10  0.241960      -1.41898      -15.4080       15.4080       384.612       400.020    
  11  0.486925     -0.719645      -7.81424       7.81424       386.035       393.849    
  12  0.750166     -0.287460      -3.12138       3.12138       391.093       394.214    
  13  0.507045     -0.679156      -7.37459       7.37459       398.183       405.558    
  14  0.237743      -1.43656      -15.5989       15.5989       400.853       416.452    
  15  0.256837E-01  -3.66190      -39.7626       39.7626       398.523       438.285    
  16  0.776460     -0.253010      -2.74730       2.74730       411.806       414.554    
  17  0.316300      -1.15106      -12.4988       12.4988       410.265       422.763    
  18  0.493161     -0.706919      -7.67606       7.67606       415.681       423.357    
  19  0.807271     -0.214096      -2.32476       2.32476       413.918       416.243    
  20  0.338915      -1.08201      -11.7489       11.7489       418.944       430.693    
  21  0.132986      -2.01751      -21.9071       21.9071       407.701       429.608    
  22  0.409975     -0.891659      -9.68205       9.68205       421.881       431.563    
  23  0.525021     -0.644317      -6.99630       6.99630       416.689       423.685    
  24  0.393064     -0.933783      -10.1395       10.1395       434.451       444.590    
  25  0.176068      -1.73689      -18.8599       18.8599       439.306       458.166    
  26  0.965490     -0.351191E-01 -0.381340      0.381340       446.574       446.955    
  27  0.387767     -0.947350      -10.2868       10.2868       449.609       459.895    
  28  0.936248     -0.658753E-01 -0.715305      0.715305       453.008       453.724    
  29  0.914720     -0.891370E-01 -0.967892      0.967892       376.733       377.701    
  30  0.332171      -1.10211      -11.9672       11.9672       447.936       459.903    
  31  0.845314E-01  -2.47063      -26.8273       26.8273       453.442       480.269    
loop,thermsimp(1:2)       91   24.6938       1.81219    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    166        430.23         73.82          1.01         38.68          0.70          0.05        114.25
Just calling func    0   0        114.25


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    430.23
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:       91
neval is:      165
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       91      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:       92
neval is:      165


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      165     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.218624      -1.52040      -16.5092       16.5092       345.084       361.594    
   2  0.389473     -0.942961      -10.2391       10.2391       371.589       381.828    
   3  0.919121     -0.843378E-01 -0.915779      0.915779       376.733       377.649    
   4  0.970518     -0.299250E-01 -0.324940      0.324940       376.237       376.562    
   5  0.713317     -0.337830      -3.66831       3.66831       382.012       385.680    
   6  0.639607     -0.446902      -4.85267       4.85267       382.789       387.642    
   7  0.712661     -0.338749      -3.67829       3.67829       388.176       391.855    
   8  0.212311      -1.54970      -16.8274       16.8274       379.567       396.394    
   9  0.831769     -0.184200      -2.00013       2.00013       386.035       388.035    
  10  0.794875     -0.229571      -2.49279       2.49279       391.093       393.585    
  11  0.909815     -0.945137E-01  -1.02627       1.02627       376.962       377.988    
  12  0.753651E-01  -2.58541      -28.0736       28.0736       384.612       412.686    
  13  0.676081     -0.391442      -4.25046       4.25046       389.455       393.706    
  14  0.597437     -0.515107      -5.59327       5.59327       398.183       403.776    
  15  0.146947      -1.91768      -20.8231       20.8231       411.806       432.629    
  16  0.854910     -0.156760      -1.70217       1.70217       413.918       415.620    
  17  0.984999     -0.151146E-01 -0.164121      0.164121       400.853       401.018    
  18  0.533419     -0.628448      -6.82398       6.82398       410.265       417.089    
  19  0.383774     -0.957703      -10.3992       10.3992       415.681       426.080    
  20  0.691729     -0.368561      -4.00201       4.00201       416.689       420.691    
  21  0.313732E-01  -3.46180      -37.5899       37.5899       407.701       445.290    
  22  0.415635     -0.877947      -9.53316       9.53316       418.944       428.477    
  23  0.288746      -1.24221      -13.4885       13.4885       421.881       435.369    
  24  0.176464      -1.73464      -18.8355       18.8355       398.523       417.358    
  25  0.881312     -0.126344      -1.37190       1.37190       434.451       435.823    
  26  0.962783     -0.379267E-01 -0.411826      0.411826       446.574       446.986    
  27  0.415450     -0.878393      -9.53801       9.53801       453.008       462.546    
  28  0.271836      -1.30256      -14.1438       14.1438       439.306       453.450    
  29  0.926655     -0.761736E-01 -0.827128      0.827128       449.609       450.436    
  30  0.277790      -1.28089      -13.9085       13.9085       447.936       461.845    
  31  0.189974      -1.66087      -18.0345       18.0345       430.234       448.269    
loop,thermsimp(1:2)       92   16.5092       10.2391    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    167        389.39         73.47          1.00         38.86          0.50          0.05        113.89
Just calling func    0   0        113.89


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    168        368.08         74.25          1.02         38.56          0.64          0.05        114.52
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    368.08
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:       92
neval is:      167
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       92      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:       93
neval is:      167


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      167     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.148595      -1.90653      -20.7020       20.7020       345.084       365.786    
   2  0.695074     -0.363738      -3.94963       3.94963       376.237       380.187    
   3  0.541180     -0.614003      -6.66713       6.66713       376.733       383.400    
   4  0.189791      -1.66183      -18.0449       18.0449       376.962       395.007    
   5  0.245553      -1.40424      -15.2479       15.2479       371.589       386.837    
   6  0.641474     -0.443986      -4.82101       4.82101       382.012       386.833    
   7  0.308462      -1.17616      -12.7713       12.7713       382.789       395.560    
   8  0.478005     -0.738133      -8.01500       8.01500       386.035       394.050    
   9  0.395759     -0.926951      -10.0653       10.0653       388.176       398.242    
  10  0.438776E-01  -3.12635      -33.9474       33.9474       391.093       425.040    
  11  0.294628E-01  -3.52463      -38.2721       38.2721       389.455       427.727    
  12  0.331052E-01  -3.40806      -37.0064       37.0064       379.567       416.573    
  13  0.916325E-01  -2.38997      -25.9514       25.9514       400.853       426.805    
  14  0.985908     -0.141919E-01 -0.154102      0.154102       398.183       398.337    
  15  0.511724     -0.669970      -7.27484       7.27484       384.612       391.887    
  16  0.185695      -1.68365      -18.2819       18.2819       413.918       432.200    
  17  0.830711     -0.185474      -2.01396       2.01396       410.265       412.279    
  18  0.765179E-04  -9.47799      -102.916       102.916       398.523       501.439    
  19  0.129365      -2.04512      -22.2069       22.2069       416.689       438.895    
  20  0.796363     -0.227700      -2.47247       2.47247       415.681       418.153    
  21  0.589256     -0.528895      -5.74299       5.74299       418.944       424.687    
  22  0.770995     -0.260073      -2.82399       2.82399       411.806       414.630    
  23  0.685430     -0.377709      -4.10135       4.10135       421.881       425.982    
  24  0.487688     -0.718080      -7.79725       7.79725       434.451       442.248    
  25  0.114898      -2.16371      -23.4946       23.4946       407.701       431.195    
  26  0.165093      -1.80124      -19.5588       19.5588       446.574       466.133    
  27  0.302275      -1.19642      -12.9913       12.9913       430.234       443.226    
  28  0.123669      -2.09014      -22.6958       22.6958       449.609       472.304    
  29  0.960526     -0.402739E-01 -0.437312      0.437312       439.306       439.743    
  30  0.744557     -0.294966      -3.20288       3.20288       447.936       451.139    
  31  0.418436     -0.871232      -9.46024       9.46024       368.084       377.544    
loop,thermsimp(1:2)       93   20.7020       3.94963    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    169        372.25         73.97          1.04         38.70          0.58          0.05        114.34
Just calling func    0   0        114.34


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    170        350.36         74.48          1.05         38.65          0.07          0.04        114.29
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    350.36
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:       93
neval is:      169
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       93      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:       94
neval is:      169


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      169     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.842284     -0.171638      -1.86372       1.86372       345.084       346.948    
   2  0.478368     -0.737375      -8.00677       8.00677       368.084       376.091    
   3  0.283498      -1.26055      -13.6877       13.6877       376.237       389.925    
   4  0.520516     -0.652935      -7.08987       7.08987       376.733       383.823    
   5  0.703282E-01  -2.65458      -28.8247       28.8247       382.012       410.837    
   6  0.914137     -0.897748E-01 -0.974817      0.974817       371.589       372.563    
   7  0.479535     -0.734938      -7.98030       7.98030       384.612       392.592    
   8  0.921875     -0.813456E-01 -0.883289      0.883289       386.035       386.918    
   9  0.739547     -0.301718      -3.27620       3.27620       376.962       380.238    
  10  0.790753     -0.234770      -2.54924       2.54924       382.789       385.338    
  11  0.212247E-01  -3.85259      -41.8332       41.8332       388.176       430.010    
  12  0.286971      -1.24837      -13.5554       13.5554       398.183       411.738    
  13  0.695666     -0.362886      -3.94038       3.94038       410.265       414.205    
  14  0.534590     -0.626255      -6.80017       6.80017       411.806       418.606    
  15  0.945577     -0.559603E-01 -0.607644      0.607644       379.567       380.175    
  16  0.619446     -0.478930      -5.20045       5.20045       415.681       420.881    
  17  0.291083E-01  -3.53673      -38.4035       38.4035       418.944       457.348    
  18  0.372584E-01  -3.28988      -35.7230       35.7230       391.093       426.816    
  19  0.713241     -0.337936      -3.66947       3.66947       421.881       425.550    
  20  0.280281      -1.27196      -13.8116       13.8116       400.853       414.665    
  21  0.254796      -1.36729      -14.8467       14.8467       389.455       404.302    
  22  0.498598     -0.695955      -7.55700       7.55700       407.701       415.258    
  23  0.515261E-01  -2.96567      -32.2026       32.2026       413.918       446.120    
  24  0.347627      -1.05662      -11.4733       11.4733       416.689       428.162    
  25  0.696212     -0.362102      -3.93187       3.93187       439.306       443.238    
  26  0.707749E-01  -2.64825      -28.7559       28.7559       434.451       463.207    
  27  0.364523E-01  -3.31175      -35.9605       35.9605       430.234       466.195    
  28  0.895087E-02  -4.71600      -51.2086       51.2086       447.936       499.145    
  29  0.333194      -1.09903      -11.9338       11.9338       446.574       458.508    
  30  0.451375     -0.795457      -8.63744       8.63744       449.609       458.246    
  31  0.849961E-01  -2.46515      -26.7678       26.7678       350.361       377.129    
loop,thermsimp(1:2)       94   1.86372       8.00677    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    171        435.51         73.74          1.04         38.60          0.41          0.05        113.84
Just calling func    0   0        113.84


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    435.51
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:       94
neval is:      170
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       94      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:       95
neval is:      170


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      170     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.744650     -0.294841      -3.20152       3.20152       345.084       348.286    
   2  0.739179     -0.302215      -3.28159       3.28159       371.589       374.870    
   3  0.131167      -2.03128      -22.0566       22.0566       368.084       390.141    
   4  0.523356     -0.647493      -7.03079       7.03079       350.361       357.392    
   5  0.660412     -0.414891      -4.50508       4.50508       379.567       384.072    
   6  0.433074E-01  -3.13943      -34.0894       34.0894       376.962       411.051    
   7  0.480352     -0.733236      -7.96182       7.96182       376.733       384.695    
   8  0.808114     -0.213053      -2.31343       2.31343       382.789       385.103    
   9  0.723804     -0.323235      -3.50983       3.50983       386.035       389.545    
  10  0.322682      -1.13109      -12.2819       12.2819       376.237       388.519    
  11  0.898907     -0.106576      -1.15725       1.15725       384.612       385.769    
  12  0.359972      -1.02173      -11.0944       11.0944       389.455       400.550    
  13  0.879118     -0.128836      -1.39896       1.39896       382.012       383.411    
  14  0.963559     -0.371220E-01 -0.403088      0.403088       398.183       398.586    
  15  0.662848     -0.411210      -4.46511       4.46511       410.265       414.730    
  16  0.648402     -0.433244      -4.70437       4.70437       400.853       405.558    
  17  0.375343     -0.979916      -10.6404       10.6404       407.701       418.341    
  18  0.812441     -0.207712      -2.25544       2.25544       411.806       414.062    
  19  0.248177E-01  -3.69620      -40.1350       40.1350       415.681       455.816    
  20  0.653530     -0.425366      -4.61883       4.61883       421.881       426.499    
  21  0.712244     -0.339334      -3.68465       3.68465       391.093       394.777    
  22  0.358229      -1.02658      -11.1471       11.1471       416.689       427.836    
  23  0.325518      -1.12234      -12.1869       12.1869       388.176       400.363    
  24  0.770349     -0.260912      -2.83310       2.83310       439.306       442.139    
  25  0.633518E-01  -2.75905      -29.9591       29.9591       413.918       443.877    
  26  0.168796      -1.77907      -19.3179       19.3179       418.944       438.262    
  27  0.562007     -0.576241      -6.25709       6.25709       449.609       455.866    
  28  0.156316      -1.85588      -20.1520       20.1520       446.574       466.726    
  29  0.967732     -0.328002E-01 -0.356160      0.356160       434.451       434.807    
  30  0.538071     -0.619766      -6.72971       6.72971       430.234       436.964    
  31  0.967495     -0.330453E-01 -0.358822      0.358822       435.510       435.868    
loop,thermsimp(1:2)       95   3.20152       3.28159    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    172        445.85         73.63          1.02         38.61          0.79          0.04        114.09
Just calling func    0   0        114.09


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    445.85
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:       95
neval is:      171
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       95      95
 right before GO TO 250



 right after: 250 IF (loop < nloop) CYCLE Main_loop 
loop,nloop:       95      95
loop was equal to nloop so did not start main cycle again, now will do the following: 




calculate mean & stdev of func values for current simplex (hmean,hstd)
 write hstd
 RMS of function values of last simplex =   26.6857    

hmean,hstd :    399.989       26.6857    


writing best so far by calling functn2 
 but just writing params not moments. see the change in functn2
hmean,hstd :    399.989       26.6857    
h(1),h(best1),h(np1) :    345.084       345.084       445.851    
htherm(1),htherm(best1),htherm(np1) :    348.286       348.286       466.726    


 CHECK hstd>?stopcr
---------> IF hstd>stopcr (and maxfn,neval.nevalp conditions as well) then set iflag and loop to zero and go to the start of the main cycle again 
---------> IF hstd<=stopcr then find the centroid of the current simplex and get the function value there 
 ............
 ............
 ............
 ............
  (hstd > stopcr .AND. (((maxfn>=0).AND.(neval <= maxfn)).OR.((maxfn<0).AND.(nevalp <= -1*maxfn))  )) 
  so set iflag=0 and loop=0 and start the main cycle again 
  right before CYCLE MAIN_LOOP 



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:        1
neval is:      171


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      171     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.204528E-01  -3.88964      -42.2355       42.2355       345.084       387.320    
   2  0.977100     -0.231667E-01 -0.251554      0.251554       350.361       350.613    
   3  0.491467     -0.710361      -7.71343       7.71343       371.589       379.302    
   4  0.802113E-01  -2.52309      -27.3969       27.3969       382.012       409.409    
   5  0.891044     -0.115361      -1.25265       1.25265       379.567       380.820    
   6  0.397551     -0.922433      -10.0162       10.0162       376.733       386.749    
   7  0.121203      -2.11029      -22.9145       22.9145       382.789       405.704    
   8  0.789985E-01  -2.53833      -27.5623       27.5623       384.612       412.174    
   9  0.921855     -0.813679E-01 -0.883531      0.883531       376.237       377.121    
  10  0.252671      -1.37567      -14.9376       14.9376       386.035       400.972    
  11  0.787271     -0.239182      -2.59715       2.59715       368.084       370.681    
  12  0.634653     -0.454676      -4.93709       4.93709       391.093       396.030    
  13  0.706648     -0.347222      -3.77030       3.77030       398.183       401.953    
  14  0.349740E-01  -3.35315      -36.4101       36.4101       388.176       424.586    
  15  0.686787     -0.375731      -4.07986       4.07986       389.455       393.535    
  16  0.309348      -1.17329      -12.7401       12.7401       400.853       413.594    
  17  0.703748     -0.351336      -3.81497       3.81497       376.962       380.777    
  18  0.985092     -0.150207E-01 -0.163102      0.163102       411.806       411.969    
  19  0.440741     -0.819298      -8.89633       8.89633       410.265       419.161    
  20  0.796112     -0.228015      -2.47590       2.47590       407.701       410.176    
  21  0.451938     -0.794210      -8.62391       8.62391       421.881       430.504    
  22  0.230902      -1.46576      -15.9159       15.9159       416.689       432.604    
  23  0.760212     -0.274159      -2.97694       2.97694       434.451       437.428    
  24  0.250434E-02  -5.98973      -65.0393       65.0393       435.510       500.549    
  25  0.627913E-01  -2.76794      -30.0556       30.0556       430.234       460.290    
  26  0.263128      -1.33511      -14.4973       14.4973       418.944       433.442    
  27  0.177986      -1.72605      -18.7423       18.7423       439.306       458.048    
  28  0.919776     -0.836247E-01 -0.908036      0.908036       413.918       414.826    
  29  0.854272     -0.157506      -1.71027       1.71027       415.681       417.391    
  30  0.648187     -0.433576      -4.70797       4.70797       449.609       454.317    
  31  0.853797     -0.158061      -1.71631       1.71631       445.851       447.568    
loop,thermsimp(1:2)        1   42.2355      0.251554    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    173        448.56         73.52          1.01         38.73          0.82          0.04        114.12
Just calling func    0   0        114.12


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    448.56
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:        1
neval is:      172
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        1      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:        2
neval is:      172


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      172     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.225672      -1.48867      -16.1647       16.1647       350.361       366.526    
   2  0.726663     -0.319292      -3.46702       3.46702       368.084       371.551    
   3  0.929061     -0.735808E-01 -0.798975      0.798975       376.237       377.036    
   4  0.764703     -0.268268      -2.91298       2.91298       371.589       374.502    
   5  0.119617      -2.12346      -23.0576       23.0576       376.962       400.019    
   6  0.369672     -0.995138      -10.8057       10.8057       379.567       390.373    
   7  0.875806     -0.132611      -1.43995       1.43995       376.733       378.173    
   8  0.657886     -0.418723      -4.54669       4.54669       345.084       349.631    
   9  0.387095E-01  -3.25167      -35.3082       35.3082       389.455       424.763    
  10  0.454078     -0.789485      -8.57260       8.57260       391.093       399.665    
  11  0.890470     -0.116006      -1.25964       1.25964       386.035       387.294    
  12  0.118445      -2.13331      -23.1644       23.1644       398.183       421.347    
  13  0.190238      -1.65948      -18.0194       18.0194       382.789       400.809    
  14  0.435624     -0.830976      -9.02313       9.02313       382.012       391.035    
  15  0.768655     -0.263114      -2.85701       2.85701       407.701       410.558    
  16  0.870896E-01  -2.44082      -26.5035       26.5035       411.806       438.310    
  17  0.936453     -0.656556E-01 -0.712919      0.712919       384.612       385.325    
  18  0.159312      -1.83689      -19.9458       19.9458       400.853       420.799    
  19  0.988165     -0.119051E-01 -0.129271      0.129271       413.918       414.047    
  20  0.713347     -0.337787      -3.66785       3.66785       415.681       419.348    
  21  0.417075     -0.874489      -9.49562       9.49562       410.265       419.760    
  22  0.719048     -0.329827      -3.58141       3.58141       388.176       391.758    
  23  0.785519     -0.241411      -2.62136       2.62136       421.881       424.502    
  24  0.356994      -1.03004      -11.1846       11.1846       416.689       427.873    
  25  0.357951      -1.02736      -11.1556       11.1556       418.944       430.100    
  26  0.154816      -1.86552      -20.2567       20.2567       434.451       454.708    
  27  0.246912      -1.39872      -15.1880       15.1880       445.851       461.039    
  28  0.553458     -0.591570      -6.42354       6.42354       449.609       456.032    
  29  0.729602     -0.315256      -3.42320       3.42320       439.306       442.729    
  30  0.605470     -0.501750      -5.44824       5.44824       430.234       435.683    
  31  0.278987E-01  -3.57918      -38.8644       38.8644       448.560       487.424    
loop,thermsimp(1:2)        2   16.1647       3.46702    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    174        435.51         73.43          1.01         38.81          0.42          0.05        113.72
Just calling func    0   0        113.72


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    435.51
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:        2
neval is:      173
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        2      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:        3
neval is:      173


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      173     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.415533     -0.878194      -9.53584       9.53584       345.084       354.620    
   2  0.117190E-02  -6.74913      -73.2852       73.2852       350.361       423.646    
   3  0.432199     -0.838870      -9.10884       9.10884       368.084       377.193    
   4  0.466381     -0.762753      -8.28233       8.28233       371.589       379.871    
   5  0.696685     -0.361422      -3.92449       3.92449       376.237       380.161    
   6  0.193714      -1.64137      -17.8228       17.8228       376.733       394.556    
   7  0.535145     -0.625217      -6.78890       6.78890       384.612       391.401    
   8  0.812984     -0.207044      -2.24818       2.24818       386.035       388.283    
   9  0.956789     -0.441723E-01 -0.479644      0.479644       379.567       380.047    
  10  0.496711E-01  -3.00233      -32.6007       32.6007       382.012       414.613    
  11  0.206308E-01  -3.88097      -42.1414       42.1414       388.176       430.318    
  12  0.423434     -0.859358      -9.33132       9.33132       391.093       400.424    
  13  0.216826      -1.52866      -16.5989       16.5989       376.962       393.561    
  14  0.792422     -0.232661      -2.52635       2.52635       382.789       385.315    
  15  0.265940      -1.32449      -14.3819       14.3819       407.701       422.082    
  16  0.993400     -0.662201E-02 -0.719049E-01  0.719049E-01   413.918       413.990    
  17  0.645200E-01  -2.74078      -29.7607       29.7607       415.681       445.441    
  18  0.651527     -0.428436      -4.65216       4.65216       410.265       414.917    
  19  0.858875     -0.152131      -1.65191       1.65191       400.853       402.505    
  20  0.126056      -2.07103      -22.4882       22.4882       398.183       420.671    
  21  0.772661E-01  -2.56050      -27.8031       27.8031       421.881       449.684    
  22  0.441429     -0.817737      -8.87937       8.87937       389.455       398.335    
  23  0.166586      -1.79224      -19.4610       19.4610       416.689       436.150    
  24  0.217490      -1.52560      -16.5657       16.5657       418.944       435.510    
  25  0.632871     -0.457488      -4.96762       4.96762       430.234       435.202    
  26  0.201694      -1.60100      -17.3845       17.3845       411.806       429.191    
  27  0.282690      -1.26341      -13.7187       13.7187       439.306       453.025    
  28  0.255086E-01  -3.66874      -39.8369       39.8369       434.451       474.288    
  29  0.562308     -0.575706      -6.25128       6.25128       449.609       455.860    
  30  0.283366E-01  -3.56360      -38.6952       38.6952       445.851       484.546    
  31  0.404254E-01  -3.20830      -34.8372       34.8372       435.510       470.347    
loop,thermsimp(1:2)        3   9.53584       73.2852    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    175        446.57         73.51          1.01         38.77          0.35          0.05        113.68
Just calling func    0   0        113.68


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    446.57
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:        3
neval is:      174
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        3      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:        4
neval is:      174


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      174     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.656626     -0.420640      -4.56751       4.56751       345.084       349.652    
   2  0.880966     -0.126736      -1.37616       1.37616       368.084       369.460    
   3  0.854972     -0.156687      -1.70138       1.70138       371.589       373.290    
   4  0.797101     -0.226774      -2.46242       2.46242       379.567       382.029    
   5  0.158477      -1.84214      -20.0029       20.0029       376.237       396.240    
   6  0.593839     -0.521148      -5.65887       5.65887       382.789       388.448    
   7  0.817101     -0.201993      -2.19333       2.19333       386.035       388.228    
   8  0.997190     -0.281377E-02 -0.305532E-01  0.305532E-01   384.612       384.643    
   9  0.402857     -0.909174      -9.87224       9.87224       376.962       386.834    
  10  0.690455     -0.370405      -4.02203       4.02203       376.733       380.755    
  11  0.609635     -0.494895      -5.37380       5.37380       389.455       394.829    
  12  0.491117     -0.711073      -7.72116       7.72116       391.093       398.814    
  13  0.990676     -0.936814E-02 -0.101724      0.101724       400.853       400.955    
  14  0.976919     -0.233519E-01 -0.253566      0.253566       413.918       414.171    
  15  0.692556     -0.367366      -3.98904       3.98904       382.012       386.001    
  16  0.549694     -0.598394      -6.49765       6.49765       410.265       416.762    
  17  0.538267E-01  -2.92199      -31.7283       31.7283       398.183       429.911    
  18  0.602193     -0.507178      -5.50718       5.50718       407.701       413.208    
  19  0.537276     -0.621243      -6.74575       6.74575       350.361       357.107    
  20  0.338220      -1.08406      -11.7712       11.7712       411.806       423.577    
  21  0.306772      -1.18165      -12.8309       12.8309       388.176       401.007    
  22  0.895389     -0.110497      -1.19983       1.19983       430.234       431.434    
  23  0.120096      -2.11946      -23.0141       23.0141       418.944       441.958    
  24  0.680166     -0.385418      -4.18505       4.18505       416.689       420.874    
  25  0.369434     -0.995782      -10.8127       10.8127       415.681       426.493    
  26  0.235484      -1.44611      -15.7026       15.7026       421.881       437.583    
  27  0.260836      -1.34386      -14.5923       14.5923       439.306       453.898    
  28  0.720259     -0.328144      -3.56315       3.56315       449.609       453.172    
  29  0.695069     -0.363744      -3.94970       3.94970       435.510       439.459    
  30  0.105076      -2.25307      -24.4649       24.4649       434.451       458.916    
  31  0.968349     -0.321628E-01 -0.349239      0.349239       446.574       446.923    
loop,thermsimp(1:2)        4   4.56751       1.37616    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    176        377.95         73.67          0.99         38.64          0.69          0.04        114.04
Just calling func    0   0        114.04


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    377.95
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:        4
neval is:      175
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        4      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:        5
neval is:      175


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      175     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.630229     -0.461672      -5.01305       5.01305       345.084       350.098    
   2  0.876370     -0.131967      -1.43296       1.43296       350.361       351.794    
   3  0.840080     -0.174259      -1.89218       1.89218       368.084       369.976    
   4  0.608986E-01  -2.79854      -30.3879       30.3879       371.589       401.977    
   5  0.311901      -1.16507      -12.6509       12.6509       376.733       389.384    
   6  0.937552E-01  -2.36707      -25.7027       25.7027       379.567       405.270    
   7  0.608418     -0.496893      -5.39550       5.39550       384.612       390.008    
   8  0.297707      -1.21164      -13.1566       13.1566       382.012       395.169    
   9  0.365777      -1.00573      -10.9207       10.9207       376.962       387.882    
  10  0.194673      -1.63643      -17.7691       17.7691       386.035       403.804    
  11  0.941388     -0.604003E-01 -0.655855      0.655855       382.789       383.445    
  12  0.984881     -0.152343E-01 -0.165421      0.165421       389.455       389.621    
  13  0.750245     -0.287355      -3.12023       3.12023       376.237       379.357    
  14  0.437446     -0.826803      -8.97781       8.97781       391.093       400.070    
  15  0.174754      -1.74437      -18.9412       18.9412       400.853       419.795    
  16  0.300465E-01  -3.50501      -38.0590       38.0590       388.176       426.235    
  17  0.372924     -0.986380      -10.7106       10.7106       407.701       418.411    
  18  0.803506     -0.218771      -2.37552       2.37552       413.918       416.293    
  19  0.232583      -1.45851      -15.8372       15.8372       410.265       426.102    
  20  0.383368     -0.958759      -10.4107       10.4107       416.689       427.099    
  21  0.622786     -0.473552      -5.14205       5.14205       411.806       416.948    
  22  0.356422      -1.03164      -11.2020       11.2020       415.681       426.883    
  23  0.919964     -0.834212E-01 -0.905827      0.905827       398.183       399.089    
  24  0.550740     -0.596492      -6.47699       6.47699       430.234       436.711    
  25  0.402627     -0.909745      -9.87843       9.87843       421.881       431.759    
  26  0.256265      -1.36154      -14.7843       14.7843       435.510       450.294    
  27  0.763510     -0.269828      -2.92992       2.92992       418.944       421.874    
  28  0.388963     -0.944271      -10.2533       10.2533       446.574       456.827    
  29  0.981923     -0.182423E-01 -0.198083      0.198083       449.609       449.807    
  30  0.656629     -0.420635      -4.56746       4.56746       439.306       443.874    
  31  0.932472     -0.699161E-01 -0.759182      0.759182       377.949       378.708    
loop,thermsimp(1:2)        5   5.01305       1.43296    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    177        456.28         73.37          0.99         38.38          1.34          0.05        114.14
Just calling func    0   0        114.14


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    456.28
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:        5
neval is:      176
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        5      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:        6
neval is:      176


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      176     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.215976      -1.53259      -16.6415       16.6415       345.084       361.726    
   2  0.942431     -0.592928E-01 -0.643830      0.643830       350.361       351.005    
   3  0.193824      -1.64081      -17.8166       17.8166       368.084       385.901    
   4  0.162512      -1.81700      -19.7299       19.7299       377.949       397.679    
   5  0.625243     -0.469616      -5.09931       5.09931       376.237       381.336    
   6  0.499178     -0.694793      -7.54439       7.54439       382.789       390.333    
   7  0.706095     -0.348006      -3.77881       3.77881       376.962       380.741    
   8  0.527414     -0.639770      -6.94692       6.94692       376.733       383.680    
   9  0.575748     -0.552085      -5.99480       5.99480       389.455       395.450    
  10  0.490522     -0.712286      -7.73434       7.73434       384.612       392.346    
  11  0.306517      -1.18248      -12.8400       12.8400       382.012       394.852    
  12  0.798470     -0.225057      -2.44378       2.44378       398.183       400.627    
  13  0.333550      -1.09796      -11.9222       11.9222       391.093       403.015    
  14  0.166731      -1.79138      -19.4516       19.4516       371.589       391.040    
  15  0.443580     -0.812878      -8.82661       8.82661       386.035       394.861    
  16  0.669985     -0.400500      -4.34882       4.34882       379.567       383.916    
  17  0.339921      -1.07904      -11.7167       11.7167       413.918       425.635    
  18  0.201260      -1.60316      -17.4078       17.4078       411.806       429.214    
  19  0.772250     -0.258447      -2.80634       2.80634       407.701       410.507    
  20  0.401372E-01  -3.21545      -34.9149       34.9149       400.853       435.768    
  21  0.940962     -0.608526E-01 -0.660766      0.660766       418.944       419.605    
  22  0.115324      -2.16001      -23.4544       23.4544       410.265       433.719    
  23  0.939991E-01  -2.36447      -25.6745       25.6745       388.176       413.851    
  24  0.412221     -0.886196      -9.62273       9.62273       415.681       425.303    
  25  0.136462      -1.99171      -21.6269       21.6269       416.689       438.315    
  26  0.310095      -1.17088      -12.7139       12.7139       421.881       434.594    
  27  0.985727     -0.143755E-01 -0.156096      0.156096       430.234       430.390    
  28  0.900161     -0.105182      -1.14211       1.14211       439.306       440.448    
  29  0.250220      -1.38542      -15.0435       15.0435       449.609       464.652    
  30  0.780405     -0.247942      -2.69227       2.69227       435.510       438.202    
  31  0.228719      -1.47526      -16.0191       16.0191       456.282       472.301    
loop,thermsimp(1:2)        6   16.6415      0.643830    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    178        446.57         73.46          1.02         38.82          0.26          0.05        113.60
Just calling func    0   0        113.60


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    446.57
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:        6
neval is:      177
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        6      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:        7
neval is:      177


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      177     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.264215      -1.33099      -14.4526       14.4526       350.361       364.814    
   2  0.401807     -0.911784      -9.90058       9.90058       345.084       354.985    
   3  0.418885     -0.870159      -9.44859       9.44859       376.962       386.410    
   4  0.753378     -0.283189      -3.07500       3.07500       376.237       379.312    
   5  0.792066     -0.233111      -2.53123       2.53123       376.733       379.264    
   6  0.868474     -0.141017      -1.53123       1.53123       379.567       381.098    
   7  0.318670      -1.14360      -12.4177       12.4177       368.084       380.502    
   8  0.863267     -0.147031      -1.59653       1.59653       382.789       384.386    
   9  0.589255     -0.528896      -5.74300       5.74300       371.589       377.332    
  10  0.632079E-01  -2.76133      -29.9838       29.9838       384.612       414.596    
  11  0.992270     -0.775975E-02 -0.842590E-01  0.842590E-01   382.012       382.096    
  12  0.466140     -0.763269      -8.28793       8.28793       386.035       394.323    
  13  0.177509      -1.72873      -18.7714       18.7714       389.455       408.227    
  14  0.933326     -0.690005E-01 -0.749240      0.749240       377.949       378.698    
  15  0.876357     -0.131982      -1.43312       1.43312       398.183       399.616    
  16  0.673496     -0.395274      -4.29207       4.29207       391.093       395.385    
  17  0.648708     -0.432773      -4.69925       4.69925       407.701       412.400    
  18  0.400813     -0.914259      -9.92746       9.92746       388.176       398.104    
  19  0.763164     -0.270282      -2.93485       2.93485       418.944       421.879    
  20  0.196240      -1.62842      -17.6821       17.6821       415.681       433.363    
  21  0.923666     -0.794046E-01 -0.862212      0.862212       413.918       414.780    
  22  0.999600     -0.400298E-03 -0.434662E-02  0.434662E-02   411.806       411.811    
  23  0.379715     -0.968335      -10.5146       10.5146       430.234       440.749    
  24  0.197375      -1.62265      -17.6195       17.6195       410.265       427.884    
  25  0.760736     -0.273468      -2.96945       2.96945       421.881       424.850    
  26  0.392182     -0.936030      -10.1639       10.1639       400.853       411.017    
  27  0.256208      -1.36177      -14.7867       14.7867       435.510       450.296    
  28  0.251796      -1.37914      -14.9753       14.9753       416.689       431.664    
  29  0.332089E-01  -3.40494      -36.9724       36.9724       439.306       476.279    
  30  0.970457     -0.299883E-01 -0.325627      0.325627       449.609       449.934    
  31  0.467370E-01  -3.06322      -33.2619       33.2619       446.574       479.836    
loop,thermsimp(1:2)        7   14.4526       9.90058    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    179        456.28         73.57          1.00         38.79          0.69          0.04        114.09
Just calling func    0   0        114.09


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    456.28
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:        7
neval is:      178
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        7      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:        8
neval is:      178


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      178     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.105813      -2.24608      -24.3890       24.3890       345.084       369.473    
   2  0.476819     -0.740619      -8.04199       8.04199       350.361       358.403    
   3  0.564430     -0.571938      -6.21038       6.21038       371.589       377.799    
   4  0.211741      -1.55239      -16.8566       16.8566       377.949       394.805    
   5  0.154226E-01  -4.17192      -45.3006       45.3006       376.733       422.033    
   6  0.489577     -0.714213      -7.75526       7.75526       376.237       383.992    
   7  0.583965     -0.537914      -5.84092       5.84092       368.084       373.925    
   8  0.430258     -0.843370      -9.15771       9.15771       379.567       388.725    
   9  0.280982      -1.26946      -13.7844       13.7844       382.012       395.797    
  10  0.535183     -0.625146      -6.78813       6.78813       382.789       389.577    
  11  0.306750      -1.18172      -12.8317       12.8317       376.962       389.793    
  12  0.924930     -0.780370E-01 -0.847362      0.847362       386.035       386.882    
  13  0.829670E-01  -2.48931      -27.0301       27.0301       391.093       418.123    
  14  0.330275      -1.10783      -12.0293       12.0293       388.176       400.206    
  15  0.229751      -1.47076      -15.9702       15.9702       398.183       414.153    
  16  0.455737     -0.785839      -8.53301       8.53301       389.455       397.988    
  17  0.830949     -0.185187      -2.01085       2.01085       400.853       402.864    
  18  0.148624      -1.90634      -20.6999       20.6999       411.806       432.506    
  19  0.883001     -0.124429      -1.35111       1.35111       407.701       409.052    
  20  0.668001     -0.403466      -4.38102       4.38102       384.612       388.993    
  21  0.610583     -0.493341      -5.35693       5.35693       413.918       419.275    
  22  0.689050     -0.372441      -4.04414       4.04414       418.944       422.988    
  23  0.124417      -2.08412      -22.6303       22.6303       421.881       444.511    
  24  0.785584E-01  -2.54391      -27.6230       27.6230       410.265       437.888    
  25  0.936565     -0.655366E-01 -0.711627      0.711627       416.689       417.400    
  26  0.483719     -0.726252      -7.88598       7.88598       415.681       423.567    
  27  0.715685     -0.334515      -3.63233       3.63233       430.234       433.867    
  28  0.786437     -0.240243      -2.60867       2.60867       449.609       452.217    
  29  0.361023      -1.01881      -11.0628       11.0628       435.510       446.572    
  30  0.325559      -1.12221      -12.1855       12.1855       439.306       451.492    
  31  0.850460     -0.161978      -1.75883       1.75883       456.282       458.041    
loop,thermsimp(1:2)        8   24.3890       8.04199    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    180        446.57         73.48          0.97         38.63          0.84          0.04        113.97
Just calling func    0   0        113.97


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    446.57
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:        8
neval is:      179
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        8      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:        9
neval is:      179


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      179     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.641422     -0.444068      -4.82190       4.82190       350.361       355.183    
   2  0.805197     -0.216668      -2.35268       2.35268       345.084       347.437    
   3  0.976428     -0.238543E-01 -0.259021      0.259021       368.084       368.343    
   4  0.599028     -0.512447      -5.56439       5.56439       371.589       377.153    
   5  0.591081     -0.525802      -5.70941       5.70941       376.237       381.946    
   6  0.151500      -1.88717      -20.4917       20.4917       386.035       406.526    
   7  0.565682     -0.569723      -6.18631       6.18631       379.567       385.753    
   8  0.345258      -1.06346      -11.5476       11.5476       384.612       396.160    
   9  0.658101     -0.418397      -4.54315       4.54315       382.789       387.332    
  10  0.691977E-01  -2.67079      -29.0007       29.0007       376.962       405.962    
  11  0.289062      -1.24111      -13.4766       13.4766       377.949       391.425    
  12  0.949819     -0.514835E-01 -0.559033      0.559033       382.012       382.571    
  13  0.791632     -0.233658      -2.53717       2.53717       389.455       391.992    
  14  0.400532     -0.914962      -9.93509       9.93509       388.176       398.111    
  15  0.241886      -1.41929      -15.4113       15.4113       400.853       416.265    
  16  0.383016     -0.959678      -10.4206       10.4206       407.701       418.121    
  17  0.993978     -0.604041E-02 -0.655896E-01  0.655896E-01   398.183       398.249    
  18  0.807089     -0.214322      -2.32721       2.32721       416.689       419.016    
  19  0.732161     -0.311755      -3.38518       3.38518       391.093       394.478    
  20  0.176507      -1.73440      -18.8329       18.8329       413.918       432.751    
  21  0.628098     -0.465059      -5.04983       5.04983       376.733       381.783    
  22  0.383392     -0.958697      -10.4100       10.4100       418.944       429.354    
  23  0.906421     -0.982517E-01  -1.06686       1.06686       415.681       416.747    
  24  0.329288      -1.11082      -12.0618       12.0618       411.806       423.868    
  25  0.869436     -0.139911      -1.51922       1.51922       430.234       431.754    
  26  0.354994      -1.03565      -11.2456       11.2456       410.265       421.510    
  27  0.127935      -2.05623      -22.3276       22.3276       421.881       444.208    
  28  0.840123     -0.174207      -1.89162       1.89162       435.510       437.401    
  29  0.625861     -0.468627      -5.08857       5.08857       439.306       444.395    
  30  0.488384     -0.716653      -7.78175       7.78175       449.609       457.390    
  31  0.888226E-01  -2.42111      -26.2896       26.2896       446.574       472.864    
loop,thermsimp(1:2)        9   4.82190       2.35268    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    181        456.28         73.54          1.00         38.80          0.78          0.05        114.18
Just calling func    0   0        114.18


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  180    456.28        2.273     -1.391      5.471     -100.8      1.222    
                     -0.4045      2.996     -99.79      3.322      2.053    
                       1.703     -1.275      1.184      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1226E+05 0.1204E+05 -2546.    -0.3827E+05
                      -2.000     -5.096     -6.687     -6.718    -0.3339    
                      -13.25     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                      -1.020     -1.461      2.866      1.441      0.000    
                       0.000      9.205      9.124     -1253.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -2594.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -7088.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3705.      1.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    456.28
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:        9
neval is:      180
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        9      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:       10
neval is:      180


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      180     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.833163     -0.182525      -1.98195       1.98195       345.084       347.066    
   2  0.367543      -1.00091      -10.8684       10.8684       350.361       361.229    
   3  0.528755     -0.637231      -6.91935       6.91935       368.084       375.003    
   4  0.776829     -0.252535      -2.74215       2.74215       371.589       374.331    
   5  0.149594E-01  -4.20242      -45.6318       45.6318       376.733       422.365    
   6  0.892228     -0.114033      -1.23822       1.23822       376.237       377.475    
   7  0.191037      -1.65529      -17.9739       17.9739       382.012       399.986    
   8  0.516533     -0.660616      -7.17327       7.17327       379.567       386.740    
   9  0.273230      -1.29744      -14.0882       14.0882       382.789       396.877    
  10  0.822225     -0.195741      -2.12545       2.12545       377.949       380.074    
  11  0.359850      -1.02207      -11.0981       11.0981       389.455       400.553    
  12  0.611658     -0.491581      -5.33782       5.33782       391.093       396.430    
  13  0.249481      -1.38837      -15.0756       15.0756       384.612       399.688    
  14  0.441252     -0.818139      -8.88374       8.88374       388.176       397.060    
  15  0.910514E-01  -2.39633      -26.0205       26.0205       398.183       424.204    
  16  0.745146     -0.294175      -3.19429       3.19429       376.962       380.156    
  17  0.758301     -0.276675      -3.00427       3.00427       386.035       389.039    
  18  0.638521     -0.448601      -4.87112       4.87112       400.853       405.725    
  19  0.150180      -1.89592      -20.5868       20.5868       415.681       436.267    
  20  0.144147      -1.93692      -21.0320       21.0320       407.701       428.733    
  21  0.104928      -2.25448      -24.4802       24.4802       416.689       441.169    
  22  0.398120     -0.921002      -10.0007       10.0007       410.265       420.265    
  23  0.802258     -0.220325      -2.39239       2.39239       411.806       414.199    
  24  0.399299     -0.918044      -9.96855       9.96855       418.944       428.913    
  25  0.493060     -0.707124      -7.67829       7.67829       430.234       437.913    
  26  0.504407     -0.684372      -7.43123       7.43123       413.918       421.349    
  27  0.762058     -0.271733      -2.95060       2.95060       435.510       438.460    
  28  0.430267     -0.843350      -9.15749       9.15749       421.881       431.038    
  29  0.993832     -0.618725E-02 -0.671840E-01  0.671840E-01   439.306       439.373    
  30  0.705390     -0.349005      -3.78966       3.78966       449.609       453.398    
  31  0.969760     -0.307069E-01 -0.333430      0.333430       456.282       456.616    
loop,thermsimp(1:2)       10   1.98195       10.8684    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    182        446.57         73.48          0.99         38.71          0.80          0.05        114.03
Just calling func    0   0        114.03


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    446.57
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:       10
neval is:      181
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       10      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:       11
neval is:      181


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      181     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.919397     -0.840375E-01 -0.912519      0.912519       345.084       345.997    
   2  0.309089      -1.17413      -12.7492       12.7492       350.361       363.110    
   3  0.237901      -1.43590      -15.5917       15.5917       371.589       387.180    
   4  0.542467     -0.611627      -6.64133       6.64133       368.084       374.725    
   5  0.523672     -0.646889      -7.02423       7.02423       376.237       383.261    
   6  0.850058     -0.162450      -1.76396       1.76396       377.949       379.713    
   7  0.589343     -0.528746      -5.74138       5.74138       376.962       382.703    
   8  0.979269     -0.209490E-01 -0.227474      0.227474       379.567       379.794    
   9  0.110419      -2.20347      -23.9264       23.9264       386.035       409.961    
  10  0.557914     -0.583550      -6.33646       6.33646       391.093       397.429    
  11  0.474464     -0.745569      -8.09573       8.09573       382.789       390.885    
  12  0.312482      -1.16321      -12.6306       12.6306       388.176       400.807    
  13  0.297011      -1.21399      -13.1820       13.1820       384.612       397.794    
  14  0.857571     -0.153651      -1.66842       1.66842       382.012       383.681    
  15  0.792567     -0.232479      -2.52436       2.52436       389.455       391.980    
  16  0.963006     -0.376958E-01 -0.409319      0.409319       400.853       401.263    
  17  0.294103      -1.22382      -13.2889       13.2889       411.806       425.095    
  18  0.403484     -0.907618      -9.85534       9.85534       410.265       420.120    
  19  0.449313     -0.800035      -8.68716       8.68716       413.918       422.605    
  20  0.721912     -0.325852      -3.53825       3.53825       376.733       380.271    
  21  0.512488     -0.668479      -7.25866       7.25866       398.183       405.442    
  22  0.885190     -0.121953      -1.32422       1.32422       407.701       409.025    
  23  0.694751E-01  -2.66679      -28.9572       28.9572       418.944       447.901    
  24  0.820879     -0.197380      -2.14324       2.14324       421.881       424.024    
  25  0.211527      -1.55340      -16.8676       16.8676       415.681       432.548    
  26  0.937420     -0.646236E-01 -0.701713      0.701713       430.234       430.936    
  27  0.515756E-01  -2.96471      -32.1922       32.1922       435.510       467.702    
  28  0.695222     -0.363525      -3.94732       3.94732       439.306       443.254    
  29  0.718776     -0.330205      -3.58552       3.58552       416.689       420.274    
  30  0.536080     -0.623471      -6.76994       6.76994       449.609       456.379    
  31  0.585855     -0.534682      -5.80583       5.80583       446.574       452.380    
loop,thermsimp(1:2)       11  0.912519       12.7492    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    183        444.63         73.50          0.99         38.84          0.64          0.05        114.01
Just calling func    0   0        114.01


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    444.63
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    10.8585               181
loop is:       11
neval is:      182
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       11      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    10.8585               181
loop is:       12
neval is:      182


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 




neval>tstepnex so lower away!t
---> lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
     new SAtemp,tstepnext are :    5.42923               211

 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      182     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.762868     -0.270671      -1.46953       1.46953       345.084       346.554    
   2  0.482922E-01  -3.03048      -16.4532       16.4532       350.361       366.814    
   3  0.612960     -0.489456      -2.65737       2.65737       368.084       370.741    
   4  0.910127     -0.941714E-01 -0.511279      0.511279       377.949       378.460    
   5  0.362433      -1.01492      -5.51022       5.51022       379.567       385.077    
   6  0.476779     -0.740702      -4.02145       4.02145       376.733       380.754    
   7  0.179006E-01  -4.02292      -21.8414       21.8414       376.962       398.803    
   8  0.589646     -0.528233      -2.86790       2.86790       376.237       379.105    
   9  0.926206     -0.766581E-01 -0.416195      0.416195       382.012       382.428    
  10  0.492629     -0.707999      -3.84389       3.84389       371.589       375.433    
  11  0.661123     -0.413815      -2.24670       2.24670       382.789       385.036    
  12  0.542248     -0.612032      -3.32286       3.32286       389.455       392.778    
  13  0.216527      -1.53004      -8.30694       8.30694       391.093       399.400    
  14  0.549832     -0.598143      -3.24746       3.24746       384.612       387.859    
  15  0.429556     -0.845003      -4.58772       4.58772       388.176       392.764    
  16  0.264838      -1.32864      -7.21348       7.21348       400.853       408.067    
  17  0.251706      -1.37949      -7.48960       7.48960       398.183       405.673    
  18  0.701724     -0.354215      -1.92311       1.92311       407.701       409.624    
  19  0.324289      -1.12612      -6.11397       6.11397       386.035       392.149    
  20  0.160749E-02  -6.43308      -34.9267       34.9267       410.265       445.191    
  21  0.533627     -0.628058      -3.40988       3.40988       416.689       420.098    
  22  0.883065     -0.124357     -0.675161      0.675161       413.918       414.593    
  23  0.484824     -0.723969      -3.93060       3.93060       421.881       425.811    
  24  0.724157     -0.322747      -1.75227       1.75227       411.806       413.559    
  25  0.847375     -0.165612     -0.899148      0.899148       430.234       431.134    
  26  0.167586      -1.78626      -9.69802       9.69802       415.681       425.379    
  27  0.890079     -0.116445     -0.632206      0.632206       439.306       439.938    
  28  0.235223      -1.44722      -7.85731       7.85731       418.944       426.802    
  29  0.206112      -1.57934      -8.57458       8.57458       446.574       455.149    
  30  0.463385     -0.769198      -4.17616       4.17616       449.609       453.785    
  31  0.487880E-01  -3.02027      -16.3978       16.3978       444.632       461.030    
loop,thermsimp(1:2)       12   1.46953       16.4532    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    184        435.51         73.50          0.97         38.82          0.59          0.06        113.95
Just calling func    0   0        113.95


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    435.51
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       12
neval is:      183
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       12      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       13
neval is:      183


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      183     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.592808     -0.522884      -2.83886       2.83886       345.084       347.923    
   2  0.691791     -0.368472      -2.00052       2.00052       350.361       352.362    
   3  0.688173     -0.373715      -2.02899       2.02899       368.084       370.113    
   4  0.439966     -0.821058      -4.45771       4.45771       371.589       376.046    
   5  0.945690     -0.558403E-01 -0.303170      0.303170       377.949       378.252    
   6  0.238956      -1.43147      -7.77181       7.77181       376.237       384.009    
   7  0.280830E-01  -3.57259      -19.3964       19.3964       376.733       396.129    
   8  0.902031E-01  -2.40569      -13.0611       13.0611       382.012       395.073    
   9  0.198361      -1.61767      -8.78269       8.78269       382.789       391.572    
  10  0.201288      -1.60302      -8.70316       8.70316       379.567       388.270    
  11  0.710033     -0.342444      -1.85921       1.85921       384.612       386.471    
  12  0.182913      -1.69874      -9.22288       9.22288       386.035       395.258    
  13  0.817316     -0.201730      -1.09524       1.09524       388.176       389.272    
  14  0.894732     -0.111231     -0.603898      0.603898       389.455       390.059    
  15  0.854000     -0.157824     -0.856864      0.856864       376.962       377.819    
  16  0.248066      -1.39406      -7.56869       7.56869       391.093       398.661    
  17  0.670877     -0.399170      -2.16719       2.16719       398.183       400.350    
  18  0.701473     -0.354573      -1.92506       1.92506       400.853       402.779    
  19  0.199467      -1.61210      -8.75250       8.75250       407.701       416.453    
  20  0.391533     -0.937685      -5.09091       5.09091       411.806       416.897    
  21  0.586761     -0.533138      -2.89453       2.89453       413.918       416.812    
  22  0.163799      -1.80912      -9.82211       9.82211       416.689       426.511    
  23  0.955964     -0.450353E-01 -0.244507      0.244507       415.681       415.925    
  24  0.365727      -1.00587      -5.46109       5.46109       421.881       427.342    
  25  0.733577     -0.309822      -1.68210       1.68210       418.944       420.626    
  26  0.111597      -2.19286      -11.9056       11.9056       430.234       442.140    
  27  0.714895     -0.335619      -1.82215       1.82215       439.306       441.128    
  28  0.816688     -0.202498      -1.09941       1.09941       410.265       411.364    
  29  0.480603     -0.732714      -3.97808       3.97808       449.609       453.587    
  30  0.573891     -0.555316      -3.01494       3.01494       446.574       449.589    
  31  0.204452      -1.58742      -8.61849       8.61849       435.510       444.128    
loop,thermsimp(1:2)       13   2.83886       2.00052    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    185        511.78         73.98          1.02         38.89          0.11          0.06        114.06
Just calling func    0   0        114.06


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    186        409.17         73.92          1.02         38.79          0.34          0.06        114.13
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    409.17
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       13
neval is:      185
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       13      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       14
neval is:      185


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      185     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.338981      -1.08181      -5.87340       5.87340       345.084       350.958    
   2  0.649641     -0.431335      -2.34182       2.34182       350.361       352.703    
   3  0.930116     -0.724456E-01 -0.393324      0.393324       368.084       368.477    
   4  0.297326      -1.21293      -6.58527       6.58527       371.589       378.174    
   5  0.751734     -0.285373      -1.54935       1.54935       376.962       378.511    
   6  0.409056     -0.893902      -4.85321       4.85321       377.949       382.802    
   7  0.115094      -2.16201      -11.7380       11.7380       376.237       387.975    
   8  0.606681     -0.499753      -2.71327       2.71327       384.612       387.325    
   9  0.140571      -1.96204      -10.6524       10.6524       379.567       390.219    
  10  0.447669E-01  -3.10629      -16.8648       16.8648       388.176       405.041    
  11  0.517394     -0.658951      -3.57760       3.57760       389.455       393.033    
  12  0.587057     -0.532633      -2.89179       2.89179       382.789       385.681    
  13  0.384993E-01  -3.25712      -17.6836       17.6836       382.012       399.696    
  14  0.829105E-01  -2.48999      -13.5188       13.5188       386.035       399.553    
  15  0.382179     -0.961866      -5.22220       5.22220       376.733       381.955    
  16  0.269516      -1.31113      -7.11843       7.11843       391.093       398.211    
  17  0.879580     -0.128311     -0.696629      0.696629       398.183       398.880    
  18  0.760503E-01  -2.57636      -13.9877       13.9877       400.853       414.841    
  19  0.482544     -0.728684      -3.95619       3.95619       410.265       414.221    
  20  0.561499     -0.577145      -3.13346       3.13346       415.681       418.814    
  21  0.254621      -1.36798      -7.42707       7.42707       407.701       415.128    
  22  0.479261     -0.735511      -3.99326       3.99326       413.918       417.911    
  23  0.638455     -0.448704      -2.43612       2.43612       411.806       414.242    
  24  0.289082      -1.24105      -6.73793       6.73793       418.944       425.682    
  25  0.656024     -0.421558      -2.28874       2.28874       416.689       418.977    
  26  0.597431     -0.515117      -2.79669       2.79669       421.881       424.677    
  27  0.859562     -0.151333     -0.821622      0.821622       439.306       440.128    
  28  0.554826     -0.589100      -3.19836       3.19836       430.234       433.433    
  29  0.128413      -2.05250      -11.1435       11.1435       435.510       446.653    
  30  0.311170      -1.16742      -6.33818       6.33818       446.574       452.912    
  31  0.606679     -0.499755      -2.71329       2.71329       409.170       411.883    
loop,thermsimp(1:2)       14   5.87340       2.34182    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    187        468.03         73.49          0.98         38.92          0.73          0.06        114.17
Just calling func    0   0        114.17


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    188        386.05         73.48          0.98         38.74          0.87          0.06        114.14
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    386.05
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       14
neval is:      187
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       14      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       15
neval is:      187


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      187     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.219724      -1.51538      -8.22737       8.22737       345.084       353.312    
   2  0.894567E-01  -2.41400      -13.1062       13.1062       350.361       363.467    
   3  0.863615     -0.146628     -0.796078      0.796078       368.084       368.880    
   4  0.807990     -0.213206      -1.15754       1.15754       371.589       372.746    
   5  0.318173      -1.14516      -6.21735       6.21735       376.962       383.179    
   6  0.464606     -0.766566      -4.16186       4.16186       376.733       380.895    
   7  0.574933     -0.553501      -3.00509       3.00509       377.949       380.954    
   8  0.974939     -0.253802E-01 -0.137795      0.137795       382.789       382.927    
   9  0.415757     -0.877653      -4.76499       4.76499       384.612       389.377    
  10  0.187109      -1.67606      -9.09974       9.09974       376.237       385.337    
  11  0.730515E-01  -2.61659      -14.2061       14.2061       379.567       393.773    
  12  0.209185      -1.56454      -8.49425       8.49425       389.455       397.950    
  13  0.496690     -0.699790      -3.79932       3.79932       391.093       394.892    
  14  0.862986     -0.147356     -0.800033      0.800033       398.183       398.983    
  15  0.888200     -0.118558     -0.643679      0.643679       386.035       386.678    
  16  0.380888     -0.965250      -5.24057       5.24057       382.012       387.253    
  17  0.135305      -2.00022      -10.8597       10.8597       388.176       399.036    
  18  0.927079     -0.757167E-01 -0.411084      0.411084       409.170       409.581    
  19  0.603067     -0.505727      -2.74571       2.74571       410.265       413.010    
  20  0.136202      -1.99362      -10.8238       10.8238       411.806       422.630    
  21  0.954653     -0.464076E-01 -0.251958      0.251958       400.853       401.105    
  22  0.151192      -1.88920      -10.2569       10.2569       407.701       417.957    
  23  0.449259     -0.800155      -4.34423       4.34423       413.918       418.262    
  24  0.780874     -0.247341      -1.34287       1.34287       415.681       417.023    
  25  0.456238     -0.784740      -4.26054       4.26054       416.689       420.949    
  26  0.163284      -1.81227      -9.83922       9.83922       421.881       431.720    
  27  0.821444     -0.196692      -1.06789       1.06789       418.944       420.012    
  28  0.861448     -0.149141     -0.809720      0.809720       430.234       431.044    
  29  0.924167     -0.788621E-01 -0.428161      0.428161       439.306       439.734    
  30  0.195059      -1.63445      -8.87384       8.87384       435.510       444.383    
  31  0.375134     -0.980472      -5.32321       5.32321       386.047       391.371    
loop,thermsimp(1:2)       15   8.22737       13.1062    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    189        427.57         73.78          1.00         38.80          0.73          0.06        114.37
Just calling func    0   0        114.37


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    427.57
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       15
neval is:      188
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       15      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       16
neval is:      188


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      188     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.231724      -1.46221      -7.93866       7.93866       345.084       353.023    
   2  0.641193     -0.444425      -2.41289       2.41289       350.361       352.774    
   3  0.353033      -1.04119      -5.65289       5.65289       368.084       373.737    
   4  0.928955     -0.736953E-01 -0.400109      0.400109       371.589       371.989    
   5  0.350257      -1.04909      -5.69575       5.69575       376.733       382.429    
   6  0.682617     -0.381821      -2.07300       2.07300       377.949       380.022    
   7  0.162763      -1.81546      -9.85655       9.85655       382.789       392.646    
   8  0.874032     -0.134639     -0.730984      0.730984       376.962       377.693    
   9  0.518909     -0.656027      -3.56172       3.56172       376.237       379.799    
  10  0.461984     -0.772226      -4.19260       4.19260       386.035       390.227    
  11  0.449468     -0.799691      -4.34171       4.34171       382.012       386.354    
  12  0.523281     -0.647637      -3.51618       3.51618       384.612       388.128    
  13  0.637377     -0.450394      -2.44530       2.44530       386.047       388.493    
  14  0.596329     -0.516963      -2.80672       2.80672       379.567       382.374    
  15  0.286246      -1.25090      -6.79144       6.79144       391.093       397.884    
  16  0.590425     -0.526913      -2.86074       2.86074       389.455       392.316    
  17  0.853637     -0.158249     -0.859170      0.859170       398.183       399.042    
  18  0.245572      -1.40416      -7.62354       7.62354       388.176       395.800    
  19  0.375654     -0.979088      -5.31570       5.31570       400.853       406.169    
  20  0.281654      -1.26708      -6.87925       6.87925       409.170       416.049    
  21  0.443392     -0.813302      -4.41561       4.41561       410.265       414.680    
  22  0.442934     -0.814335      -4.42122       4.42122       415.681       420.102    
  23  0.171790      -1.76149      -9.56352       9.56352       407.701       417.264    
  24  0.802582     -0.219921      -1.19401       1.19401       413.918       415.112    
  25  0.162733      -1.81564      -9.85756       9.85756       418.944       428.802    
  26  0.838320     -0.176355     -0.957472      0.957472       416.689       417.646    
  27  0.210754      -1.55706      -8.45367       8.45367       411.806       420.260    
  28  0.240377      -1.42554      -7.73962       7.73962       430.234       437.974    
  29  0.173042E-01  -4.05680      -22.0253       22.0253       421.881       443.906    
  30  0.640146     -0.446059      -2.42176       2.42176       439.306       441.728    
  31  0.749210     -0.288736      -1.56761       1.56761       427.572       429.140    
loop,thermsimp(1:2)       16   7.93866       2.41289    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    190        354.40         73.86          0.97         38.70          0.93          0.06        114.51
Just calling func    0   0        114.51


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    354.40
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       16
neval is:      189
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       16      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       17
neval is:      189


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      189     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.776913     -0.252427      -1.37048       1.37048       350.361       351.732    
   2  0.350417      -1.04863      -5.69327       5.69327       345.084       350.778    
   3  0.533846     -0.627648      -3.40765       3.40765       371.589       374.996    
   4  0.622955     -0.473280      -2.56955       2.56955       368.084       370.654    
   5  0.661091E-01  -2.71645      -14.7482       14.7482       376.962       391.710    
   6  0.759206     -0.275482      -1.49566       1.49566       376.237       377.733    
   7  0.430535     -0.842727      -4.57536       4.57536       377.949       382.524    
   8  0.257678      -1.35604      -7.36228       7.36228       379.567       386.929    
   9  0.296561      -1.21550      -6.59924       6.59924       376.733       383.332    
  10  0.805929     -0.215760      -1.17141       1.17141       382.012       383.184    
  11  0.421616     -0.863661      -4.68902       4.68902       384.612       389.301    
  12  0.767803     -0.264223      -1.43453       1.43453       386.047       387.482    
  13  0.605260     -0.502097      -2.72600       2.72600       386.035       388.761    
  14  0.566784     -0.567776      -3.08259       3.08259       389.455       392.538    
  15  0.292740      -1.22847      -6.66965       6.66965       382.789       389.459    
  16  0.898463     -0.107069     -0.581305      0.581305       388.176       388.758    
  17  0.218067      -1.52295      -8.26848       8.26848       391.093       399.361    
  18  0.856756     -0.154603     -0.839374      0.839374       398.183       399.022    
  19  0.338883      -1.08210      -5.87498       5.87498       400.853       406.728    
  20  0.796034     -0.228113      -1.23848       1.23848       410.265       411.503    
  21  0.778636     -0.250212      -1.35846       1.35846       413.918       415.276    
  22  0.575989     -0.551667      -2.99513       2.99513       409.170       412.165    
  23  0.355531      -1.03414      -5.61461       5.61461       407.701       413.315    
  24  0.164949      -1.80212      -9.78414       9.78414       416.689       426.473    
  25  0.315998      -1.15202      -6.25459       6.25459       415.681       421.935    
  26  0.330933      -1.10584      -6.00386       6.00386       411.806       417.810    
  27  0.429436     -0.845283      -4.58924       4.58924       418.944       423.533    
  28  0.464808     -0.766130      -4.15950       4.15950       427.572       431.732    
  29  0.192211      -1.64916      -8.95369       8.95369       430.234       439.188    
  30  0.866849     -0.142891     -0.775786      0.775786       439.306       440.082    
  31  0.474973     -0.744498      -4.04205       4.04205       354.403       358.446    
loop,thermsimp(1:2)       17   1.37048       5.69327    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    191        413.43         73.70          0.96         38.83          0.77          0.06        114.33
Just calling func    0   0        114.33


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    413.43
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       17
neval is:      190
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       17      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       18
neval is:      190


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      190     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.240395      -1.42547      -7.73921       7.73921       345.084       352.824    
   2  0.711556E-02  -4.94547      -26.8501       26.8501       350.361       377.211    
   3  0.909796     -0.945347E-01 -0.513251      0.513251       354.403       354.917    
   4  0.659218     -0.416702      -2.26237       2.26237       368.084       370.346    
   5  0.833482     -0.182144     -0.988901      0.988901       371.589       372.578    
   6  0.726295E-01  -2.62238      -14.2375       14.2375       376.237       390.475    
   7  0.687091     -0.375288      -2.03753       2.03753       377.949       379.986    
   8  0.860775     -0.149922     -0.813961      0.813961       382.012       382.826    
   9  0.846215     -0.166982     -0.906585      0.906585       376.733       377.639    
  10  0.398551     -0.919919      -4.99446       4.99446       379.567       384.561    
  11  0.416092     -0.876849      -4.76062       4.76062       386.047       390.808    
  12  0.463389     -0.769189      -4.17611       4.17611       388.176       392.352    
  13  0.207356      -1.57332      -8.54192       8.54192       386.035       394.577    
  14  0.133003      -2.01738      -10.9529       10.9529       384.612       395.565    
  15  0.464971     -0.765779      -4.15760       4.15760       382.789       386.947    
  16  0.568281     -0.565140      -3.06828       3.06828       376.962       380.030    
  17  0.638811     -0.448147      -2.43309       2.43309       389.455       391.888    
  18  0.865664     -0.144259     -0.783215      0.783215       398.183       398.966    
  19  0.475002     -0.744436      -4.04172       4.04172       391.093       395.134    
  20  0.537086     -0.621597      -3.37480       3.37480       400.853       404.228    
  21  0.782345     -0.245459      -1.33265       1.33265       410.265       411.597    
  22  0.725469     -0.320937      -1.74244       1.74244       409.170       410.912    
  23  0.701426E-01  -2.65723      -14.4267       14.4267       407.701       422.127    
  24  0.297043      -1.21388      -6.59044       6.59044       413.918       420.508    
  25  0.444870     -0.809973      -4.39753       4.39753       411.806       416.204    
  26  0.685684     -0.377338      -2.04866       2.04866       415.681       417.729    
  27  0.651244     -0.428871      -2.32844       2.32844       418.944       421.273    
  28  0.269082      -1.31274      -7.12717       7.12717       416.689       423.816    
  29  0.177107      -1.73100      -9.39802       9.39802       427.572       436.970    
  30  0.766464     -0.265968      -1.44400       1.44400       430.234       431.678    
  31  0.801833     -0.220855      -1.19907       1.19907       413.432       414.632    
loop,thermsimp(1:2)       18   7.73921       26.8501    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    192        427.49         73.62          1.00         38.93          0.32          0.05        113.93
Just calling func    0   0        113.93


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    427.49
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       18
neval is:      191
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       18      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       19
neval is:      191


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      191     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.722200     -0.325453      -1.76696       1.76696       345.084       346.851    
   2  0.240049      -1.42691      -7.74704       7.74704       354.403       362.151    
   3  0.365543      -1.00637      -5.46382       5.46382       368.084       373.548    
   4  0.399010     -0.918769      -4.98822       4.98822       371.589       376.577    
   5  0.685268     -0.377945      -2.05195       2.05195       350.361       352.413    
   6  0.335805E-01  -3.39381      -18.4258       18.4258       376.733       395.159    
   7  0.820520     -0.197817      -1.07399       1.07399       377.949       379.023    
   8  0.756560     -0.278973      -1.51461       1.51461       376.962       378.476    
   9  0.869461     -0.139882     -0.759453      0.759453       382.012       382.772    
  10  0.787378     -0.239047      -1.29784       1.29784       379.567       380.865    
  11  0.330926      -1.10586      -6.00398       6.00398       382.789       388.793    
  12  0.339084E-01  -3.38409      -18.3730       18.3730       376.237       394.610    
  13  0.672805     -0.396300      -2.15161       2.15161       386.047       388.199    
  14  0.822413     -0.195513      -1.06149       1.06149       389.455       390.517    
  15  0.928870     -0.737865E-01 -0.400604      0.400604       388.176       388.577    
  16  0.778944     -0.249816      -1.35631       1.35631       386.035       387.391    
  17  0.301602E-01  -3.50123      -19.0090       19.0090       391.093       410.102    
  18  0.292626      -1.22886      -6.67178       6.67178       384.612       391.284    
  19  0.149515      -1.90036      -10.3175       10.3175       398.183       408.501    
  20  0.500330E-01  -2.99507      -16.2609       16.2609       400.853       417.114    
  21  0.759114E-01  -2.57819      -13.9976       13.9976       409.170       423.167    
  22  0.613440     -0.488673      -2.65312       2.65312       410.265       412.918    
  23  0.132502      -2.02116      -10.9733       10.9733       413.432       424.406    
  24  0.189750E-02  -6.26722      -34.0262       34.0262       411.806       445.832    
  25  0.507622     -0.678018      -3.68112       3.68112       415.681       419.362    
  26  0.378733     -0.970924      -5.27137       5.27137       413.918       419.189    
  27  0.139411      -1.97033      -10.6974       10.6974       418.944       429.642    
  28  0.298599      -1.20865      -6.56207       6.56207       407.701       414.263    
  29  0.767617     -0.264464      -1.43584       1.43584       416.689       418.124    
  30  0.656077     -0.421478      -2.28830       2.28830       430.234       432.523    
  31  0.701883     -0.353988      -1.92188       1.92188       427.490       429.412    
loop,thermsimp(1:2)       19   1.76696       7.74704    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    193        394.58         73.81          0.97         38.82          0.57          0.06        114.22
Just calling func    0   0        114.22


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    394.58
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       19
neval is:      192
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       19      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       20
neval is:      192


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      192     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.311857      -1.16521      -6.32620       6.32620       345.084       351.411    
   2  0.362384      -1.01505      -5.51095       5.51095       350.361       355.872    
   3  0.900627     -0.104664     -0.568246      0.568246       354.403       354.972    
   4  0.233893      -1.45289      -7.88808       7.88808       368.084       375.972    
   5  0.183338      -1.69642      -9.21029       9.21029       371.589       380.799    
   6  0.351708      -1.04495      -5.67329       5.67329       376.962       382.635    
   7  0.979617     -0.205938E-01 -0.111808      0.111808       377.949       378.061    
   8  0.801294     -0.221527      -1.20272       1.20272       379.567       380.770    
   9  0.423893     -0.858275      -4.65978       4.65978       382.012       386.672    
  10  0.486446     -0.720630      -3.91247       3.91247       386.035       389.947    
  11  0.430531     -0.842736      -4.57541       4.57541       386.047       390.623    
  12  0.214629      -1.53884      -8.35474       8.35474       388.176       396.531    
  13  0.860310     -0.150463     -0.816899      0.816899       382.789       383.606    
  14  0.450659     -0.797045      -4.32734       4.32734       389.455       393.783    
  15  0.867432     -0.142218     -0.772135      0.772135       384.612       385.384    
  16  0.850327     -0.162134     -0.880263      0.880263       376.237       377.117    
  17  0.914193     -0.897130E-01 -0.487073      0.487073       376.733       377.220    
  18  0.908448     -0.960172E-01 -0.521300      0.521300       398.183       398.704    
  19  0.349788E-01  -3.35301      -18.2043       18.2043       391.093       409.297    
  20  0.825048     -0.192314      -1.04412       1.04412       410.265       411.309    
  21  0.628933     -0.463730      -2.51770       2.51770       407.701       410.218    
  22  0.756366     -0.279229      -1.51600       1.51600       400.853       402.369    
  23  0.545707     -0.605674      -3.28834       3.28834       416.689       419.977    
  24  0.653619     -0.425231      -2.30868       2.30868       413.918       416.226    
  25  0.781643     -0.246357      -1.33753       1.33753       415.681       417.018    
  26  0.444411     -0.811005      -4.40314       4.40314       409.170       413.573    
  27  0.223111      -1.50008      -8.14431       8.14431       413.432       421.577    
  28  0.143901      -1.93863      -10.5253       10.5253       427.490       438.015    
  29  0.419282E-01  -3.17180      -17.2204       17.2204       418.944       436.165    
  30  0.407367     -0.898040      -4.87567       4.87567       430.234       435.110    
  31  0.722138     -0.325538      -1.76742       1.76742       394.579       396.346    
loop,thermsimp(1:2)       20   6.32620       5.51095    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    194        426.92         74.02          1.00         38.73          0.61          0.05        114.41
Just calling func    0   0        114.41


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    426.92
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       20
neval is:      193
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       20      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       21
neval is:      193


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      193     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.307193      -1.18028      -6.40801       6.40801       345.084       351.492    
   2  0.575213     -0.553015      -3.00245       3.00245       354.403       357.406    
   3  0.632244     -0.458480      -2.48920       2.48920       350.361       352.850    
   4  0.819203     -0.199424      -1.08272       1.08272       368.084       369.167    
   5  0.137693E-02  -6.58790      -35.7672       35.7672       376.237       412.004    
   6  0.367814      -1.00018      -5.43021       5.43021       376.733       382.163    
   7  0.452636     -0.792666      -4.30357       4.30357       377.949       382.252    
   8  0.278102      -1.27977      -6.94817       6.94817       379.567       386.515    
   9  0.417803     -0.872745      -4.73834       4.73834       371.589       376.327    
  10  0.682140     -0.382521      -2.07680       2.07680       376.962       379.039    
  11  0.204733      -1.58605      -8.61102       8.61102       382.789       391.400    
  12  0.637442     -0.450292      -2.44474       2.44474       384.612       387.057    
  13  0.114518      -2.16702      -11.7653       11.7653       382.012       393.777    
  14  0.724207     -0.322678      -1.75190       1.75190       386.035       387.787    
  15  0.461399     -0.773492      -4.19947       4.19947       386.047       390.247    
  16  0.731739     -0.312332      -1.69572       1.69572       389.455       391.151    
  17  0.773272     -0.257124      -1.39599       1.39599       394.579       395.975    
  18  0.789195     -0.236742      -1.28533       1.28533       388.176       389.462    
  19  0.762001     -0.271807      -1.47570       1.47570       398.183       399.659    
  20  0.933384     -0.689386E-01 -0.374284      0.374284       400.853       401.228    
  21  0.694037     -0.365230      -1.98292       1.98292       391.093       393.076    
  22  0.423570     -0.859038      -4.66392       4.66392       407.701       412.364    
  23  0.272919      -1.29858      -7.05030       7.05030       410.265       417.315    
  24  0.535843     -0.623914      -3.38738       3.38738       409.170       412.557    
  25  0.902288     -0.102822     -0.558243      0.558243       413.918       414.476    
  26  0.479374     -0.735275      -3.99198       3.99198       415.681       419.673    
  27  0.494900E-01  -3.00599      -16.3202       16.3202       416.689       433.009    
  28  0.921867     -0.813539E-01 -0.441689      0.441689       413.432       413.874    
  29  0.132425      -2.02174      -10.9765       10.9765       430.234       441.211    
  30  0.640539     -0.445446      -2.41843       2.41843       418.944       421.363    
  31  0.215363      -1.53543      -8.33621       8.33621       426.924       435.260    
loop,thermsimp(1:2)       21   6.40801       3.00245    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    195        399.04         73.54          0.95         38.60          0.95          0.06        114.09
Just calling func    0   0        114.09


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    399.04
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       21
neval is:      194
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       21      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       22
neval is:      194


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      194     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.838898     -0.175666     -0.953731      0.953731       345.084       346.038    
   2  0.801853     -0.220830      -1.19894       1.19894       350.361       351.560    
   3  0.768645     -0.263126      -1.42857       1.42857       354.403       355.832    
   4  0.855557     -0.156003     -0.846976      0.846976       368.084       368.931    
   5  0.845591     -0.167720     -0.910590      0.910590       371.589       372.499    
   6  0.350050      -1.04968      -5.69895       5.69895       376.962       382.661    
   7  0.927608     -0.751463E-01 -0.407987      0.407987       376.733       377.141    
   8  0.655345E-01  -2.72518      -14.7956       14.7956       377.949       392.744    
   9  0.355481      -1.03428      -5.61537       5.61537       379.567       385.182    
  10  0.728523     -0.316737      -1.71964       1.71964       384.612       386.332    
  11  0.573220     -0.556486      -3.02129       3.02129       386.035       389.056    
  12  0.112478      -2.18499      -11.8628       11.8628       388.176       400.039    
  13  0.338739      -1.08253      -5.87729       5.87729       386.047       391.925    
  14  0.239648      -1.42858      -7.75611       7.75611       389.455       397.211    
  15  0.918959     -0.845134E-01 -0.458843      0.458843       382.789       383.248    
  16  0.283771      -1.25959      -6.83860       6.83860       391.093       397.931    
  17  0.414404     -0.880913      -4.78268       4.78268       382.012       386.795    
  18  0.716403     -0.333512      -1.81072       1.81072       394.579       396.390    
  19  0.317726      -1.14657      -6.22498       6.22498       398.183       404.408    
  20  0.339005      -1.08174      -5.87302       5.87302       400.853       406.726    
  21  0.163059      -1.81364      -9.84670       9.84670       376.237       386.084    
  22  0.477081     -0.740069      -4.01801       4.01801       407.701       411.719    
  23  0.105851      -2.24573      -12.1926       12.1926       409.170       421.362    
  24  0.840431     -0.173840     -0.943818      0.943818       413.432       414.376    
  25  0.235315      -1.44683      -7.85519       7.85519       413.918       421.773    
  26  0.865464     -0.144489     -0.784467      0.784467       410.265       411.049    
  27  0.909462     -0.949026E-01 -0.515249      0.515249       415.681       416.196    
  28  0.152105E-01  -4.18577      -22.7255       22.7255       418.944       441.670    
  29  0.962485     -0.382371E-01 -0.207598      0.207598       416.689       416.896    
  30  0.259410      -1.34934      -7.32591       7.32591       426.924       434.249    
  31  0.364880      -1.00819      -5.47368       5.47368       399.042       404.516    
loop,thermsimp(1:2)       22  0.953731       1.19894    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    196        385.51         73.71          0.95         38.82          0.67          0.05        114.21
Just calling func    0   0        114.21


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    385.51
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       22
neval is:      195
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       22      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       23
neval is:      195


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      195     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.848355     -0.164456     -0.892870      0.892870       345.084       345.977    
   2  0.848474     -0.164316     -0.892111      0.892111       350.361       351.253    
   3  0.146795      -1.91872      -10.4172       10.4172       354.403       364.821    
   4  0.398624     -0.919738      -4.99347       4.99347       368.084       373.078    
   5  0.888093     -0.118679     -0.644334      0.644334       371.589       372.233    
   6  0.475009     -0.744421      -4.04164       4.04164       376.733       380.774    
   7  0.120824      -2.11342      -11.4743       11.4743       376.962       388.436    
   8  0.270052      -1.30914      -7.10763       7.10763       382.789       389.897    
   9  0.201748E-01  -3.90332      -21.1921       21.1921       379.567       400.759    
  10  0.999386     -0.614559E-03 -0.333658E-02  0.333658E-02   376.237       376.240    
  11  0.212655      -1.54808      -8.40492       8.40492       384.612       393.017    
  12  0.197911      -1.61994      -8.79503       8.79503       382.012       390.807    
  13  0.786394     -0.240297      -1.30463       1.30463       386.035       387.339    
  14  0.781263     -0.246844      -1.34017       1.34017       386.047       387.388    
  15  0.788011     -0.238244      -1.29348       1.29348       377.949       379.242    
  16  0.956387     -0.445927E-01 -0.242104      0.242104       394.579       394.821    
  17  0.717415     -0.332100      -1.80305       1.80305       389.455       391.258    
  18  0.808756     -0.212258      -1.15240       1.15240       391.093       392.245    
  19  0.756838     -0.278606      -1.51262       1.51262       388.176       389.689    
  20  0.570684     -0.560919      -3.04536       3.04536       398.183       401.228    
  21  0.946031     -0.554796E-01 -0.301212      0.301212       399.042       399.343    
  22  0.678634E-01  -2.69026      -14.6060       14.6060       400.853       415.460    
  23  0.631502     -0.459654      -2.49557       2.49557       410.265       412.760    
  24  0.114784E-01  -4.46729      -24.2539       24.2539       407.701       431.954    
  25  0.549681     -0.598417      -3.24895       3.24895       413.432       416.681    
  26  0.846433     -0.166725     -0.905188      0.905188       415.681       416.586    
  27  0.441841     -0.816805      -4.43463       4.43463       416.689       421.123    
  28  0.299100      -1.20698      -6.55296       6.55296       409.170       415.723    
  29  0.378130     -0.972517      -5.28002       5.28002       413.918       419.198    
  30  0.830469     -0.185764      -1.00856       1.00856       426.924       427.932    
  31  0.675108     -0.392883      -2.13305       2.13305       385.510       387.643    
loop,thermsimp(1:2)       23  0.892870      0.892111    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    197        406.22         73.96          1.02         38.73          0.57          0.05        114.33
Just calling func    0   0        114.33


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    406.22
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       23
neval is:      196
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       23      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       24
neval is:      196


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      196     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.102026      -2.28253      -12.3924       12.3924       345.084       357.477    
   2  0.372115     -0.988552      -5.36708       5.36708       350.361       355.728    
   3  0.732875     -0.310780      -1.68730       1.68730       354.403       356.091    
   4  0.341646      -1.07398      -5.83089       5.83089       371.589       377.420    
   5  0.406512     -0.900141      -4.88708       4.88708       368.084       372.971    
   6  0.271848      -1.30251      -7.07164       7.07164       376.237       383.309    
   7  0.738418     -0.303245      -1.64639       1.64639       377.949       379.595    
   8  0.903199     -0.101813     -0.552766      0.552766       376.733       377.286    
   9  0.511789     -0.669842      -3.63673       3.63673       386.035       389.671    
  10  0.202674      -1.59616      -8.66592       8.66592       386.047       394.713    
  11  0.325695      -1.12179      -6.09049       6.09049       385.510       391.600    
  12  0.719720     -0.328893      -1.78564       1.78564       376.962       378.747    
  13  0.715609     -0.334622      -1.81674       1.81674       388.176       389.993    
  14  0.973328     -0.270339E-01 -0.146774      0.146774       382.789       382.936    
  15  0.373998     -0.983504      -5.33968       5.33968       382.012       387.352    
  16  0.977965     -0.222815E-01 -0.120971      0.120971       389.455       389.576    
  17  0.105495      -2.24909      -12.2109       12.2109       391.093       403.303    
  18  0.729809     -0.314973      -1.71006       1.71006       384.612       386.322    
  19  0.378008     -0.972839      -5.28177       5.28177       394.579       399.861    
  20  0.678326     -0.388127      -2.10723       2.10723       399.042       401.149    
  21  0.671993     -0.397507      -2.15816       2.15816       379.567       381.725    
  22  0.515926     -0.661792      -3.59303       3.59303       398.183       401.776    
  23  0.363490      -1.01200      -5.49441       5.49441       410.265       415.759    
  24  0.206319      -1.57833      -8.56912       8.56912       400.853       409.423    
  25  0.755157E-01  -2.58341      -14.0260       14.0260       409.170       423.196    
  26  0.413763     -0.882461      -4.79109       4.79109       415.681       420.472    
  27  0.279023      -1.27646      -6.93020       6.93020       413.432       420.363    
  28  0.506422     -0.680385      -3.69397       3.69397       413.918       417.612    
  29  0.643082E-02  -5.04665      -27.3995       27.3995       416.689       444.088    
  30  0.285888E-01  -3.55474      -19.2995       19.2995       426.924       446.223    
  31  0.660419     -0.414880      -2.25248       2.25248       406.218       408.470    
loop,thermsimp(1:2)       24   12.3924       5.36708    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    198        433.04         73.60          1.03         38.98          0.16          0.05        113.83
Just calling func    0   0        113.83


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    433.04
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       24
neval is:      197
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       24      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       25
neval is:      197


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      197     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.962782     -0.379284E-01 -0.205922      0.205922       350.361       350.567    
   2  0.355374      -1.03458      -5.61700       5.61700       354.403       360.020    
   3  0.294461      -1.22261      -6.63783       6.63783       345.084       351.722    
   4  0.644538     -0.439222      -2.38464       2.38464       368.084       370.469    
   5  0.741622     -0.298915      -1.62288       1.62288       376.733       378.356    
   6  0.805913E-01  -2.51837      -13.6728       13.6728       371.589       385.261    
   7  0.498180     -0.696794      -3.78306       3.78306       376.962       380.745    
   8  0.771004     -0.260061      -1.41193       1.41193       377.949       379.361    
   9  0.753480     -0.283053      -1.53676       1.53676       379.567       381.104    
  10  0.460525     -0.775387      -4.20976       4.20976       382.789       386.999    
  11  0.918626     -0.848759E-01 -0.460811      0.460811       376.237       376.698    
  12  0.355379      -1.03457      -5.61692       5.61692       384.612       390.229    
  13  0.664646     -0.408501      -2.21785       2.21785       382.012       384.230    
  14  0.328018      -1.11469      -6.05190       6.05190       389.455       395.507    
  15  0.529583     -0.635665      -3.45118       3.45118       386.035       389.486    
  16  0.259823      -1.34775      -7.31727       7.31727       388.176       395.494    
  17  0.463690E-01  -3.07112      -16.6739       16.6739       385.510       402.183    
  18  0.366509      -1.00373      -5.44949       5.44949       386.047       391.497    
  19  0.794534     -0.229999      -1.24872       1.24872       394.579       395.828    
  20  0.669373     -0.401413      -2.17937       2.17937       399.042       401.221    
  21  0.798901     -0.224518      -1.21896       1.21896       398.183       399.402    
  22  0.610403     -0.493636      -2.68007       2.68007       391.093       393.773    
  23  0.267818      -1.31745      -7.15273       7.15273       406.218       413.370    
  24  0.663049     -0.410906      -2.23091       2.23091       400.853       403.084    
  25  0.782871     -0.244788      -1.32901       1.32901       410.265       411.594    
  26  0.706545     -0.347368      -1.88594       1.88594       413.918       415.804    
  27  0.120119      -2.11927      -11.5060       11.5060       413.432       424.939    
  28  0.270575      -1.30721      -7.09714       7.09714       415.681       422.778    
  29  0.505391     -0.682422      -3.70503       3.70503       409.170       412.875    
  30  0.665734     -0.406865      -2.20896       2.20896       416.689       418.897    
  31  0.836788     -0.178185     -0.967408      0.967408       433.037       434.004    
loop,thermsimp(1:2)       25  0.205922       5.61700    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    199        426.92         73.73          0.97         38.92          0.55          0.06        114.23
Just calling func    0   0        114.23


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    200        393.78         73.59          0.98         38.80          0.61          0.05        114.03
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    393.78
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       25
neval is:      199
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       25      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       26
neval is:      199


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      199     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.987524     -0.125549E-01 -0.681633E-01  0.681633E-01   350.361       350.429    
   2  0.516099     -0.661457      -3.59121       3.59121       345.084       348.676    
   3  0.202206      -1.59847      -8.67847       8.67847       354.403       363.082    
   4  0.240260      -1.42603      -7.74227       7.74227       368.084       375.826    
   5  0.717263E-01  -2.63490      -14.3055       14.3055       376.237       390.542    
   6  0.395382     -0.927902      -5.03780       5.03780       376.733       381.771    
   7  0.494348     -0.704516      -3.82498       3.82498       377.949       381.774    
   8  0.970815     -0.296196E-01 -0.160812      0.160812       376.962       377.123    
   9  0.992795     -0.723105E-02 -0.392591E-01  0.392591E-01   379.567       379.606    
  10  0.387320     -0.948503      -5.14965       5.14965       382.012       387.162    
  11  0.586568     -0.533466      -2.89631       2.89631       371.589       374.485    
  12  0.119144      -2.12742      -11.5503       11.5503       382.789       394.339    
  13  0.145144      -1.93003      -10.4786       10.4786       386.035       396.513    
  14  0.767931     -0.264056      -1.43362       1.43362       384.612       386.046    
  15  0.415014     -0.879442      -4.77470       4.77470       386.047       390.822    
  16  0.994477     -0.553801E-02 -0.300671E-01  0.300671E-01   391.093       391.123    
  17  0.757243     -0.278071      -1.50971       1.50971       388.176       389.686    
  18  0.669290     -0.401537      -2.18004       2.18004       389.455       391.635    
  19  0.112026      -2.18903      -11.8847       11.8847       394.579       406.464    
  20  0.434244     -0.834148      -4.52879       4.52879       398.183       402.712    
  21  0.491828     -0.709627      -3.85273       3.85273       399.042       402.895    
  22  0.517535     -0.658677      -3.57611       3.57611       385.510       389.086    
  23  0.411147     -0.888804      -4.82553       4.82553       400.853       405.679    
  24  0.250164      -1.38564      -7.52296       7.52296       410.265       417.788    
  25  0.109742E-01  -4.51221      -24.4979       24.4979       409.170       433.668    
  26  0.559459     -0.580786      -3.15322       3.15322       406.218       409.371    
  27  0.289677      -1.23899      -6.72676       6.72676       413.918       420.645    
  28  0.835809     -0.179356     -0.973764      0.973764       416.689       417.662    
  29  0.236182      -1.44315      -7.83521       7.83521       415.681       423.516    
  30  0.700988     -0.355264      -1.92881       1.92881       413.432       415.361    
  31  0.886914     -0.120007     -0.651548      0.651548       393.781       394.432    
loop,thermsimp(1:2)       26  0.681633E-01   3.59121    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    201        368.36         74.04          1.04         38.81          0.10          0.06        114.05
Just calling func    0   0        114.05


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  200    368.36        1.972     -1.150      5.778     -101.6      1.343    
                     -0.1913      3.336     -100.2      3.760      1.637    
                       1.780     -1.062      1.333      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1713E+05 0.1443E+05 -3048.    -0.4944E+05
                      -2.000     -5.123     -6.971     -6.796    -0.6681    
                      -13.83     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                      -1.253     -1.508      3.049      1.488      0.000    
                       0.000      9.205      9.124      2288.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -761.8    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -8021.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3880.      1.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    368.36
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       26
neval is:      200
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       26      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       27
neval is:      200


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      200     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.199609      -1.61140      -8.74864       8.74864       345.084       353.833    
   2  0.983274     -0.168677E-01 -0.915785E-01  0.915785E-01   350.361       350.453    
   3  0.569108     -0.563685      -3.06038       3.06038       354.403       357.464    
   4  0.411179     -0.888728      -4.82511       4.82511       371.589       376.414    
   5  0.889241     -0.117387     -0.637319      0.637319       368.084       368.721    
   6  0.109537      -2.21149      -12.0067       12.0067       376.962       388.968    
   7  0.658027     -0.418509      -2.27219       2.27219       379.567       381.839    
   8  0.427534     -0.849722      -4.61334       4.61334       376.733       381.346    
   9  0.277803      -1.28084      -6.95399       6.95399       377.949       384.903    
  10  0.568421     -0.564892      -3.06693       3.06693       384.612       387.679    
  11  0.368489     -0.998346      -5.42025       5.42025       382.012       387.432    
  12  0.100945E-01  -4.59576      -24.9515       24.9515       385.510       410.461    
  13  0.811445     -0.208939      -1.13438       1.13438       388.176       389.311    
  14  0.135138      -2.00146      -10.8664       10.8664       376.237       387.103    
  15  0.600340     -0.510258      -2.77031       2.77031       386.047       388.818    
  16  0.537538     -0.620755      -3.37023       3.37023       391.093       394.463    
  17  0.923261     -0.798434E-01 -0.433488      0.433488       389.455       389.889    
  18  0.296505      -1.21569      -6.60028       6.60028       382.789       389.389    
  19  0.975666     -0.246348E-01 -0.133748      0.133748       393.781       393.914    
  20  0.102971      -2.27331      -12.3423       12.3423       386.035       398.377    
  21  0.110137      -2.20603      -11.9771       11.9771       398.183       410.160    
  22  0.874539     -0.134058     -0.727833      0.727833       399.042       399.770    
  23  0.887507     -0.119339     -0.647922      0.647922       400.853       401.501    
  24  0.811767     -0.208543      -1.13223       1.13223       394.579       395.711    
  25  0.304283      -1.18980      -6.45969       6.45969       406.218       412.677    
  26  0.304144      -1.19025      -6.46217       6.46217       413.432       419.895    
  27  0.854538     -0.157194     -0.853443      0.853443       416.689       417.542    
  28  0.543001     -0.610645      -3.31533       3.31533       410.265       413.580    
  29  0.808766     -0.212246      -1.15233       1.15233       413.918       415.070    
  30  0.286176      -1.25115      -6.79278       6.79278       415.681       422.473    
  31  0.328161      -1.11425      -6.04952       6.04952       368.360       374.409    
loop,thermsimp(1:2)       27   8.74864      0.915785E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    202        340.41         73.78          1.00         39.04          0.44          0.06        114.32
Just calling func    0   0        114.32


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    203        431.98         74.09          0.99         38.68          0.71          0.05        114.52
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    340.41
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       27
neval is:      202
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       27      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       28
neval is:      202


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      202     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.231666      -1.46246      -7.94004       7.94004       350.361       358.301    
   2  0.922423     -0.807516E-01 -0.438420      0.438420       345.084       345.523    
   3  0.556007     -0.586974      -3.18682       3.18682       354.403       357.590    
   4  0.921345     -0.819211E-01 -0.444769      0.444769       368.084       368.529    
   5  0.623358     -0.472635      -2.56605       2.56605       368.360       370.926    
   6  0.967150     -0.334012E-01 -0.181343      0.181343       371.589       371.770    
   7  0.239844      -1.42777      -7.75168       7.75168       376.733       384.485    
   8  0.707370     -0.346201      -1.87961       1.87961       379.567       381.447    
   9  0.375591     -0.979256      -5.31661       5.31661       377.949       383.265    
  10  0.164915      -1.80233      -9.78525       9.78525       376.237       386.022    
  11  0.634729     -0.454558      -2.46790       2.46790       382.012       384.480    
  12  0.956585     -0.443852E-01 -0.240978      0.240978       384.612       384.853    
  13  0.281051      -1.26922      -6.89088       6.89088       386.047       392.938    
  14  0.332446      -1.10128      -5.97910       5.97910       376.962       382.941    
  15  0.417901     -0.872510      -4.73706       4.73706       388.176       392.913    
  16  0.454459     -0.788647      -4.28175       4.28175       382.789       387.071    
  17  0.163150      -1.81309      -9.84368       9.84368       389.455       399.299    
  18  0.412675     -0.885095      -4.80539       4.80539       393.781       398.586    
  19  0.510076     -0.673195      -3.65493       3.65493       391.093       394.748    
  20  0.159872E-02  -6.43855      -34.9564       34.9564       394.579       429.535    
  21  0.279094      -1.27620      -6.92882       6.92882       386.035       392.964    
  22  0.229843E-01  -3.77294      -20.4842       20.4842       399.042       419.526    
  23  0.829240E-02  -4.79242      -26.0192       26.0192       400.853       426.873    
  24  0.722732     -0.324717      -1.76297       1.76297       398.183       399.946    
  25  0.399402     -0.917787      -4.98288       4.98288       385.510       390.492    
  26  0.321457      -1.13489      -6.16160       6.16160       406.218       412.379    
  27  0.103147      -2.27160      -12.3330       12.3330       410.265       422.598    
  28  0.488570     -0.716273      -3.88882       3.88882       413.918       417.807    
  29  0.775391     -0.254388      -1.38113       1.38113       416.689       418.070    
  30  0.264831      -1.32866      -7.21363       7.21363       413.432       420.646    
  31  0.291634      -1.23225      -6.69020       6.69020       340.410       347.100    
loop,thermsimp(1:2)       28   7.94004      0.438420    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    204        417.53         73.74          1.03         38.59          0.54          0.04        113.95
Just calling func    0   0        113.95


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    417.53
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       28
neval is:      203
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       28      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       29
neval is:      203


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      203     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.332051      -1.10247      -5.98556       5.98556       345.084       351.070    
   2  0.991191     -0.884791E-02 -0.480374E-01  0.480374E-01   340.410       340.458    
   3  0.752830     -0.283916      -1.54145       1.54145       354.403       355.945    
   4  0.718872     -0.330071      -1.79204       1.79204       350.361       352.153    
   5  0.362244      -1.01544      -5.51305       5.51305       368.084       373.597    
   6  0.993342E-01  -2.30927      -12.5375       12.5375       368.360       380.897    
   7  0.734379     -0.308729      -1.67616       1.67616       371.589       373.265    
   8  0.190509      -1.65806      -9.00197       9.00197       379.567       388.569    
   9  0.113713      -2.17408      -11.8036       11.8036       376.962       388.765    
  10  0.582158     -0.541014      -2.93729       2.93729       377.949       380.886    
  11  0.100405E-01  -4.60113      -24.9806       24.9806       382.012       406.993    
  12  0.614877     -0.486333      -2.64042       2.64042       376.733       379.373    
  13  0.996806     -0.319890E-02 -0.173676E-01  0.173676E-01   384.612       384.629    
  14  0.439871E-01  -3.12386      -16.9602       16.9602       376.237       393.197    
  15  0.610456     -0.493549      -2.67959       2.67959       382.789       385.469    
  16  0.676471     -0.390866      -2.12210       2.12210       385.510       387.632    
  17  0.263829      -1.33246      -7.23421       7.23421       388.176       395.411    
  18  0.761962     -0.271858      -1.47598       1.47598       386.047       387.523    
  19  0.405295     -0.903140      -4.90336       4.90336       386.035       390.938    
  20  0.184680      -1.68913      -9.17070       9.17070       391.093       400.263    
  21  0.695434     -0.363219      -1.97200       1.97200       393.781       395.753    
  22  0.597154     -0.515580      -2.79920       2.79920       389.455       392.255    
  23  0.254276      -1.36933      -7.43443       7.43443       398.183       405.617    
  24  0.777974     -0.251062      -1.36308       1.36308       406.218       407.581    
  25  0.597236     -0.515443      -2.79846       2.79846       413.918       416.716    
  26  0.658168     -0.418295      -2.27102       2.27102       416.689       418.960    
  27  0.917953     -0.856086E-01 -0.464789      0.464789       399.042       399.507    
  28  0.167567      -1.78637      -9.69864       9.69864       413.432       423.131    
  29  0.867739E-02  -4.74703      -25.7728       25.7728       410.265       436.037    
  30  0.157469      -1.84853      -10.0361       10.0361       400.853       410.890    
  31  0.947458     -0.539724E-01 -0.293029      0.293029       417.530       417.823    
loop,thermsimp(1:2)       29   5.98556      0.480374E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    205        419.16         73.61          1.03         38.61          0.73          0.04        114.02
Just calling func    0   0        114.02


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    419.16
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       29
neval is:      204
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       29      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       30
neval is:      204


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      204     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.157557      -1.84797      -10.0330       10.0330       340.410       350.443    
   2  0.553200     -0.592035      -3.21430       3.21430       345.084       348.299    
   3  0.825049     -0.192313      -1.04411       1.04411       350.361       351.405    
   4  0.767336     -0.264830      -1.43783       1.43783       354.403       355.841    
   5  0.966534     -0.340385E-01 -0.184803      0.184803       371.589       371.773    
   6  0.954430     -0.466410E-01 -0.253225      0.253225       368.084       368.337    
   7  0.780674     -0.247598      -1.34427       1.34427       376.733       378.077    
   8  0.312863      -1.16199      -6.30872       6.30872       377.949       384.257    
   9  0.990226     -0.982218E-02 -0.533269E-01  0.533269E-01   368.360       368.413    
  10  0.893872     -0.112193     -0.609120      0.609120       384.612       385.221    
  11  0.322320      -1.13221      -6.14703       6.14703       382.789       388.936    
  12  0.927465     -0.752997E-01 -0.408820      0.408820       386.047       386.456    
  13  0.539466     -0.617176      -3.35079       3.35079       385.510       388.860    
  14  0.461474     -0.773330      -4.19859       4.19859       379.567       383.765    
  15  0.745701     -0.293430      -1.59310       1.59310       376.962       378.555    
  16  0.703580     -0.351573      -1.90877       1.90877       386.035       387.943    
  17  0.917420E-01  -2.38878      -12.9692       12.9692       389.455       402.425    
  18  0.671661     -0.398001      -2.16084       2.16084       376.237       378.398    
  19  0.845179     -0.168207     -0.913236      0.913236       388.176       389.090    
  20  0.283605E-01  -3.56276      -19.3431       19.3431       393.781       413.124    
  21  0.108883E-01  -4.52006      -24.5405       24.5405       399.042       423.583    
  22  0.506006     -0.681208      -3.69844       3.69844       391.093       394.791    
  23  0.353918      -1.03869      -5.63930       5.63930       398.183       403.822    
  24  0.656862     -0.420282      -2.28181       2.28181       382.012       384.294    
  25  0.691560     -0.368806      -2.00233       2.00233       406.218       408.220    
  26  0.445402     -0.808779      -4.39105       4.39105       400.853       405.245    
  27  0.832700     -0.183081     -0.993991      0.993991       413.918       414.912    
  28  0.963063     -0.376360E-01 -0.204335      0.204335       417.530       417.734    
  29  0.422212     -0.862247      -4.68134       4.68134       416.689       421.370    
  30  0.917895     -0.856720E-01 -0.465133      0.465133       413.432       413.898    
  31  0.767210     -0.264994      -1.43872       1.43872       419.160       420.598    
loop,thermsimp(1:2)       30   10.0330       3.21430    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    206        405.44         73.54          0.98         38.91          0.37          0.04        113.84
Just calling func    0   0        113.84


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    405.44
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       30
neval is:      205
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       30      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       31
neval is:      205


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      205     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.277512      -1.28189      -6.95968       6.95968       345.084       352.044    
   2  0.202445      -1.59728      -8.67203       8.67203       340.410       349.082    
   3  0.927152     -0.756373E-01 -0.410653      0.410653       350.361       350.772    
   4  0.403144     -0.908460      -4.93224       4.93224       354.403       359.336    
   5  0.791838     -0.233398      -1.26717       1.26717       368.084       369.351    
   6  0.292576      -1.22903      -6.67269       6.67269       368.360       375.033    
   7  0.135578      -1.99821      -10.8488       10.8488       371.589       382.437    
   8  0.516570     -0.660545      -3.58626       3.58626       376.733       380.319    
   9  0.730579     -0.313918      -1.70433       1.70433       376.237       377.941    
  10  0.508248     -0.676786      -3.67443       3.67443       376.962       380.636    
  11  0.928455     -0.742338E-01 -0.403033      0.403033       379.567       379.970    
  12  0.696477     -0.361721      -1.96387       1.96387       377.949       379.913    
  13  0.465556     -0.764522      -4.15077       4.15077       382.012       386.163    
  14  0.194653      -1.63654      -8.88514       8.88514       384.612       393.497    
  15  0.650312     -0.430303      -2.33622       2.33622       386.047       388.384    
  16  0.555802     -0.587343      -3.18882       3.18882       386.035       389.224    
  17  0.985517     -0.145893E-01 -0.792087E-01  0.792087E-01   385.510       385.589    
  18  0.923066     -0.800544E-01 -0.434634      0.434634       382.789       383.224    
  19  0.658765     -0.417388      -2.26610       2.26610       388.176       390.442    
  20  0.197878      -1.62010      -8.79593       8.79593       391.093       399.889    
  21  0.449673     -0.799236      -4.33924       4.33924       389.455       393.795    
  22  0.208093      -1.56977      -8.52266       8.52266       398.183       406.706    
  23  0.102791      -2.27506      -12.3518       12.3518       400.853       413.205    
  24  0.650538     -0.429955      -2.33433       2.33433       406.218       408.552    
  25  0.223365      -1.49895      -8.13815       8.13815       393.781       401.919    
  26  0.520729     -0.652525      -3.54271       3.54271       413.432       416.975    
  27  0.919707E-01  -2.38629      -12.9557       12.9557       413.918       426.873    
  28  0.788427     -0.237716      -1.29061       1.29061       417.530       418.821    
  29  0.395754     -0.926961      -5.03269       5.03269       419.160       424.192    
  30  0.903388     -0.101603     -0.551629      0.551629       416.689       417.240    
  31  0.569415     -0.563145      -3.05745       3.05745       405.444       408.501    
loop,thermsimp(1:2)       31   6.95968       8.67203    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    207        336.33         73.76          0.99         38.87          0.37          0.06        114.05
Just calling func    0   0        114.05


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    208       2000.10         74.28          1.04         38.80          0.29          0.04        114.46
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    336.33
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       31
neval is:      207
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       31      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       32
neval is:      207


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      207     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.701343     -0.354759      -1.92607       1.92607       340.410       342.336    
   2  0.779682     -0.248869      -1.35117       1.35117       350.361       351.712    
   3  0.611645     -0.491604      -2.66903       2.66903       345.084       347.753    
   4  0.380626     -0.965937      -5.24430       5.24430       354.403       359.648    
   5  0.986599     -0.134915E-01 -0.732484E-01  0.732484E-01   368.084       368.157    
   6  0.699021     -0.358075      -1.94407       1.94407       368.360       370.304    
   7  0.981217E-01  -2.32155      -12.6042       12.6042       376.237       388.841    
   8  0.221199      -1.50869      -8.19104       8.19104       377.949       386.140    
   9  0.802460     -0.220073      -1.19483       1.19483       379.567       380.762    
  10  0.623430     -0.472519      -2.56541       2.56541       376.733       379.298    
  11  0.669862     -0.400684      -2.17541       2.17541       376.962       379.137    
  12  0.957999     -0.429090E-01 -0.232963      0.232963       371.589       371.822    
  13  0.569879E-01  -2.86492      -15.5543       15.5543       382.789       398.343    
  14  0.245244      -1.40550      -7.63080       7.63080       385.510       393.140    
  15  0.870123     -0.139121     -0.755320      0.755320       382.012       382.767    
  16  0.429679     -0.844716      -4.58616       4.58616       386.047       390.634    
  17  0.369880     -0.994577      -5.39979       5.39979       386.035       391.435    
  18  0.964882     -0.357490E-01 -0.194090      0.194090       388.176       388.370    
  19  0.625983     -0.468432      -2.54323       2.54323       384.612       387.155    
  20  0.508652     -0.675991      -3.67011       3.67011       389.455       393.125    
  21  0.694697     -0.364279      -1.97776       1.97776       391.093       393.070    
  22  0.817819     -0.201114      -1.09189       1.09189       393.781       394.873    
  23  0.655732     -0.422003      -2.29115       2.29115       398.183       400.474    
  24  0.658757     -0.417401      -2.26617       2.26617       405.444       407.710    
  25  0.325934      -1.12106      -6.08650       6.08650       406.218       412.304    
  26  0.849137     -0.163535     -0.887868      0.887868       400.853       401.741    
  27  0.953435     -0.476843E-01 -0.258889      0.258889       413.432       413.691    
  28  0.435049     -0.832297      -4.51873       4.51873       416.689       421.207    
  29  0.155341E-01  -4.16472      -22.6112       22.6112       417.530       440.141    
  30  0.390095     -0.941364      -5.11089       5.11089       419.160       424.270    
  31  0.400867E-02  -5.51929      -29.9655       29.9655       336.329       366.294    
loop,thermsimp(1:2)       32   1.92607       1.35117    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    209        398.98         73.62          0.96         38.28          1.65          0.04        114.56
Just calling func    0   0        114.56


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    398.98
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       32
neval is:      208
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       32      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       33
neval is:      208


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      208     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.403971     -0.906412      -4.92112       4.92112       340.410       345.331    
   2  0.598662     -0.513057      -2.78551       2.78551       345.084       347.870    
   3  0.165178      -1.80073      -9.77659       9.77659       350.361       360.138    
   4  0.785331     -0.241651      -1.31198       1.31198       354.403       355.715    
   5  0.422061     -0.862604      -4.68328       4.68328       336.329       341.012    
   6  0.343624      -1.06821      -5.79954       5.79954       368.084       373.884    
   7  0.988862     -0.112001E-01 -0.608079E-01  0.608079E-01   368.360       368.421    
   8  0.586093E-01  -2.83686      -15.4020       15.4020       371.589       386.991    
   9  0.324880      -1.12430      -6.10409       6.10409       376.962       383.066    
  10  0.869373     -0.139983     -0.760001      0.760001       376.733       377.493    
  11  0.314362      -1.15721      -6.28276       6.28276       379.567       385.850    
  12  0.635265     -0.453712      -2.46331       2.46331       382.012       384.475    
  13  0.800738     -0.222221      -1.20649       1.20649       377.949       379.155    
  14  0.234515      -1.45024      -7.87367       7.87367       384.612       392.486    
  15  0.818766     -0.199957      -1.08561       1.08561       388.176       389.262    
  16  0.480807     -0.732289      -3.97577       3.97577       376.237       380.213    
  17  0.173083      -1.75398      -9.52279       9.52279       386.047       395.570    
  18  0.544835     -0.607272      -3.29702       3.29702       386.035       389.332    
  19  0.955728     -0.452816E-01 -0.245844      0.245844       391.093       391.338    
  20  0.909631     -0.947157E-01 -0.514234      0.514234       389.455       389.970    
  21  0.538276     -0.619384      -3.36278       3.36278       385.510       388.872    
  22  0.640373     -0.445705      -2.41984       2.41984       393.781       396.200    
  23  0.588429     -0.530300      -2.87912       2.87912       382.789       385.668    
  24  0.954392     -0.466804E-01 -0.253439      0.253439       398.183       398.436    
  25  0.976738     -0.235363E-01 -0.127784      0.127784       400.853       400.981    
  26  0.801897     -0.220775      -1.19864       1.19864       405.444       406.642    
  27  0.679499     -0.386400      -2.09786       2.09786       406.218       408.316    
  28  0.303686      -1.19176      -6.47035       6.47035       413.432       419.903    
  29  0.907562     -0.969936E-01 -0.526601      0.526601       416.689       417.215    
  30  0.117971E-01  -4.43990      -24.1053       24.1053       419.160       443.265    
  31  0.324683      -1.12491      -6.10738       6.10738       398.979       405.087    
loop,thermsimp(1:2)       33   4.92112       2.78551    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    210        423.23         73.43          0.97         38.46          1.42          0.04        114.32
Just calling func    0   0        114.32


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    211        362.53         73.41          0.97         38.32          1.09          0.04        113.82
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    362.53
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       33
neval is:      210
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       33      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       34
neval is:      210


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      210     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.228924      -1.47437      -8.00468       8.00468       336.329       344.333    
   2  0.299376      -1.20605      -6.54795       6.54795       340.410       346.957    
   3  0.220114      -1.51361      -8.21774       8.21774       345.084       353.302    
   4  0.229209      -1.47312      -7.99793       7.99793       354.403       362.401    
   5  0.902477     -0.102612     -0.557107      0.557107       350.361       350.918    
   6  0.659052     -0.416953      -2.26373       2.26373       368.360       370.624    
   7  0.100321E-01  -4.60197      -24.9852       24.9852       368.084       393.069    
   8  0.588837     -0.529606      -2.87535       2.87535       376.733       379.608    
   9  0.270943      -1.30585      -7.08976       7.08976       377.949       385.038    
  10  0.505518     -0.682171      -3.70367       3.70367       376.237       379.941    
  11  0.264565      -1.32967      -7.21909       7.21909       376.962       384.181    
  12  0.806386     -0.215193      -1.16834       1.16834       382.012       383.180    
  13  0.340560      -1.07716      -5.84818       5.84818       382.789       388.637    
  14  0.906186     -0.985106E-01 -0.534837      0.534837       379.567       380.102    
  15  0.786070     -0.240709      -1.30687       1.30687       371.589       372.895    
  16  0.540508     -0.615247      -3.34032       3.34032       385.510       388.850    
  17  0.935065     -0.671392E-01 -0.364514      0.364514       388.176       388.541    
  18  0.915359     -0.884391E-01 -0.480157      0.480157       386.035       386.515    
  19  0.958261     -0.426353E-01 -0.231477      0.231477       389.455       389.687    
  20  0.935110     -0.670907E-01 -0.364251      0.364251       391.093       391.457    
  21  0.637755     -0.449800      -2.44207       2.44207       384.612       387.054    
  22  0.975714     -0.245861E-01 -0.133484      0.133484       386.047       386.181    
  23  0.797424     -0.226369      -1.22901       1.22901       393.781       395.010    
  24  0.214179      -1.54094      -8.36615       8.36615       398.183       406.549    
  25  0.372145     -0.988472      -5.36665       5.36665       400.853       406.220    
  26  0.925208     -0.777367E-01 -0.422051      0.422051       398.979       399.401    
  27  0.175897      -1.73786      -9.43522       9.43522       405.444       414.879    
  28  0.952033     -0.491554E-01 -0.266876      0.266876       406.218       406.485    
  29  0.158274E-01  -4.14601      -22.5097       22.5097       416.689       439.198    
  30  0.799308     -0.224008      -1.21619       1.21619       413.432       414.649    
  31  0.248227      -1.39341      -7.56515       7.56515       362.531       370.096    
loop,thermsimp(1:2)       34   8.00468       6.54795    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    212        373.77         73.67          0.98         38.31          1.16          0.05        114.18
Just calling func    0   0        114.18


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    373.77
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       34
neval is:      211
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       34      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       35
neval is:      211


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      211
neval,tstepnext:      211     211

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.347237      -1.05775      -5.74276       5.74276       336.329       342.071    
   2  0.621479     -0.475653      -2.58243       2.58243       340.410       342.992    
   3  0.221273      -1.50836      -8.18924       8.18924       350.361       358.550    
   4  0.180626E-01  -4.01391      -21.7925       21.7925       345.084       366.877    
   5  0.216093      -1.53205      -8.31785       8.31785       354.403       362.721    
   6  0.351343      -1.04599      -5.67893       5.67893       362.531       368.210    
   7  0.360847      -1.01930      -5.53403       5.53403       368.360       373.894    
   8  0.439525     -0.822061      -4.46316       4.46316       371.589       376.052    
   9  0.910616E-01  -2.39622      -13.0096       13.0096       376.733       389.742    
  10  0.549745     -0.598300      -3.24831       3.24831       376.237       379.485    
  11  0.619825     -0.478318      -2.59690       2.59690       379.567       382.164    
  12  0.548169E-01  -2.90376      -15.7652       15.7652       382.012       397.777    
  13  0.947163     -0.542842E-01 -0.294722      0.294722       376.962       377.256    
  14  0.725459     -0.320951      -1.74252       1.74252       377.949       379.691    
  15  0.481613     -0.730615      -3.96668       3.96668       386.047       390.014    
  16  0.866286     -0.143540     -0.779315      0.779315       386.035       386.814    
  17  0.221988E-01  -3.80772      -20.6730       20.6730       384.612       405.285    
  18  0.980823     -0.193630E-01 -0.105127      0.105127       388.176       388.281    
  19  0.332549      -1.10097      -5.97741       5.97741       382.789       388.767    
  20  0.989035     -0.110256E-01 -0.598606E-01  0.598606E-01   385.510       385.569    
  21  0.364016      -1.01056      -5.48655       5.48655       389.455       394.942    
  22  0.861799     -0.148733     -0.807507      0.807507       391.093       391.900    
  23  0.622306     -0.474324      -2.57522       2.57522       368.084       370.659    
  24  0.575476     -0.552558      -2.99997       2.99997       393.781       396.781    
  25  0.205536      -1.58213      -8.58977       8.58977       398.979       407.569    
  26  0.124037      -2.08718      -11.3318       11.3318       400.853       412.185    
  27  0.467008     -0.761408      -4.13387       4.13387       406.218       410.352    
  28  0.273870      -1.29510      -7.03141       7.03141       398.183       405.214    
  29  0.842780     -0.171050     -0.928668      0.928668       413.432       414.361    
  30  0.709315     -0.343455      -1.86470       1.86470       405.444       407.308    
  31  0.677144     -0.389871      -2.11670       2.11670       373.775       375.892    
loop,thermsimp(1:2)       35   5.74276       2.58243    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    213        464.70         73.54          0.99         38.68          0.67          0.05        113.93
Just calling func    0   0        113.93


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    214        360.16         74.45          1.09         38.29          0.00          0.04        113.87
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    360.16
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    5.42923               211
loop is:       35
neval is:      213
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       35      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    5.42923               211
loop is:       36
neval is:      213


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 




neval>tstepnex so lower away!t
---> lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
     new SAtemp,tstepnext are :    2.71462               241

 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      213     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.233712      -1.45367      -3.94615       3.94615       336.329       340.275    
   2  0.607568     -0.498291      -1.35267       1.35267       340.410       341.762    
   3  0.905785     -0.989529E-01 -0.268619      0.268619       350.361       350.630    
   4  0.995938E-01  -2.30666      -6.26169       6.26169       354.403       360.665    
   5  0.851360     -0.160920     -0.436837      0.436837       345.084       345.521    
   6  0.730583     -0.313913     -0.852154      0.852154       362.531       363.383    
   7  0.426216     -0.852810      -2.31505       2.31505       368.084       370.399    
   8  0.285108      -1.25489      -3.40654       3.40654       368.360       371.766    
   9  0.839246     -0.175251     -0.475741      0.475741       373.775       374.251    
  10  0.217639      -1.52492      -4.13956       4.13956       371.589       375.728    
  11  0.183996E-02  -6.29801      -17.0967       17.0967       376.962       394.058    
  12  0.682631     -0.381801      -1.03644       1.03644       376.237       377.273    
  13  0.203596      -1.59162      -4.32064       4.32064       377.949       382.269    
  14  0.881164     -0.126512     -0.343432      0.343432       379.567       379.910    
  15  0.711431     -0.340477     -0.924264      0.924264       385.510       386.434    
  16  0.874326     -0.134302     -0.364578      0.364578       386.035       386.399    
  17  0.814222     -0.205523     -0.557916      0.557916       388.176       388.734    
  18  0.995668     -0.434126E-02 -0.117849E-01  0.117849E-01   382.789       382.801    
  19  0.693805     -0.365564     -0.992367      0.992367       376.733       377.725    
  20  0.958584     -0.422984E-01 -0.114824      0.114824       386.047       386.162    
  21  0.748022     -0.290323     -0.788116      0.788116       391.093       391.881    
  22  0.696703     -0.361396     -0.981052      0.981052       389.455       390.436    
  23  0.732990     -0.310623     -0.843223      0.843223       393.781       394.624    
  24  0.534749     -0.625958      -1.69924       1.69924       382.012       383.711    
  25  0.691641     -0.368688      -1.00085       1.00085       398.183       399.184    
  26  0.300458      -1.20245      -3.26418       3.26418       384.612       387.876    
  27  0.977116     -0.231502E-01 -0.628440E-01  0.628440E-01   405.444       405.507    
  28  0.542581     -0.611418      -1.65977       1.65977       398.979       400.639    
  29  0.266111      -1.32384      -3.59372       3.59372       406.218       409.811    
  30  0.692298     -0.367738     -0.998268      0.998268       400.853       401.852    
  31  0.664047     -0.409403      -1.11137       1.11137       360.164       361.275    
loop,thermsimp(1:2)       36   3.94615       1.35267    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    215        373.97         73.73          0.96         38.61          0.82          0.05        114.16
Just calling func    0   0        114.16


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    373.97
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       36
neval is:      214
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       36      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       37
neval is:      214


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      214     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.411300     -0.888432      -2.41175       2.41175       336.329       338.740    
   2  0.697205     -0.360676     -0.979098      0.979098       340.410       341.389    
   3  0.314648E-01  -3.45889      -9.38955       9.38955       345.084       354.474    
   4  0.857269     -0.154003     -0.418059      0.418059       350.361       350.779    
   5  0.652165     -0.427457      -1.16038       1.16038       354.403       355.564    
   6  0.510145     -0.673060      -1.82710       1.82710       360.164       361.991    
   7  0.175175      -1.74197      -4.72878       4.72878       362.531       367.259    
   8  0.373803     -0.984025      -2.67125       2.67125       368.084       370.755    
   9  0.514972     -0.663642      -1.80153       1.80153       368.360       370.161    
  10  0.548235     -0.601051      -1.63162       1.63162       373.775       375.407    
  11  0.541310     -0.613763      -1.66613       1.66613       371.589       373.255    
  12  0.734083     -0.309133     -0.839177      0.839177       376.237       377.076    
  13  0.422599     -0.861332      -2.33819       2.33819       376.733       379.071    
  14  0.287055      -1.24808      -3.38806       3.38806       379.567       382.955    
  15  0.885133     -0.122017     -0.331230      0.331230       377.949       378.280    
  16  0.391075     -0.938857      -2.54864       2.54864       382.789       385.338    
  17  0.473784     -0.747003      -2.02783       2.02783       382.012       384.040    
  18  0.691812     -0.368440      -1.00017       1.00017       386.047       387.048    
  19  0.644447     -0.439363      -1.19270       1.19270       386.035       387.227    
  20  0.805933     -0.215754     -0.585690      0.585690       385.510       386.095    
  21  0.393766     -0.931998      -2.53002       2.53002       384.612       387.142    
  22  0.907098E-01  -2.40009      -6.51533       6.51533       388.176       394.692    
  23  0.376515     -0.976796      -2.65163       2.65163       389.455       392.107    
  24  0.819190     -0.199439     -0.541402      0.541402       391.093       391.634    
  25  0.692438     -0.367536     -0.997720      0.997720       376.962       377.959    
  26  0.188370      -1.66935      -4.53164       4.53164       393.781       398.312    
  27  0.500532     -0.692083      -1.87874       1.87874       398.183       400.062    
  28  0.282311      -1.26475      -3.43330       3.43330       398.979       402.413    
  29  0.338061      -1.08453      -2.94408       2.94408       400.853       403.798    
  30  0.466208     -0.763123      -2.07159       2.07159       405.444       407.515    
  31  0.893084     -0.113075     -0.306955      0.306955       373.969       374.276    
loop,thermsimp(1:2)       37   2.41175      0.979098    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    216        358.62         73.76          0.95         38.55          0.96          0.05        114.27
Just calling func    0   0        114.26


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    358.62
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       37
neval is:      215
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       37      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       38
neval is:      215


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      215     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.408852     -0.894401      -2.42796       2.42796       336.329       338.757    
   2  0.259700      -1.34823      -3.65992       3.65992       340.410       344.069    
   3  0.681144E-01  -2.68657      -7.29300       7.29300       350.361       357.654    
   4  0.158140      -1.84427      -5.00649       5.00649       345.084       350.091    
   5  0.497681     -0.697796      -1.89425       1.89425       354.403       356.298    
   6  0.800218     -0.222871     -0.605008      0.605008       360.164       360.769    
   7  0.831967     -0.183962     -0.499387      0.499387       362.531       363.030    
   8  0.707345     -0.346237     -0.939900      0.939900       368.360       369.300    
   9  0.265927      -1.32454      -3.59561       3.59561       368.084       371.680    
  10  0.659046     -0.416962      -1.13189       1.13189       371.589       372.721    
  11  0.654587E-01  -2.72634      -7.40096       7.40096       373.969       381.370    
  12  0.223329      -1.49911      -4.06951       4.06951       373.775       377.844    
  13  0.996019     -0.398855E-02 -0.108274E-01  0.108274E-01   376.237       376.248    
  14  0.553910     -0.590753      -1.60367       1.60367       376.962       378.565    
  15  0.218863      -1.51931      -4.12435       4.12435       377.949       382.073    
  16  0.414020     -0.881841      -2.39386       2.39386       376.733       379.127    
  17  0.229117      -1.47352      -4.00005       4.00005       379.567       383.567    
  18  0.341764      -1.07363      -2.91451       2.91451       382.012       384.927    
  19  0.357052      -1.02987      -2.79571       2.79571       382.789       385.585    
  20  0.780779     -0.247463     -0.671768      0.671768       385.510       386.181    
  21  0.382234     -0.961721      -2.61071       2.61071       386.047       388.658    
  22  0.123899      -2.08829      -5.66891       5.66891       384.612       390.281    
  23  0.393312     -0.933152      -2.53315       2.53315       386.035       388.568    
  24  0.481741     -0.730349      -1.98262       1.98262       391.093       393.075    
  25  0.120001      -2.12026      -5.75569       5.75569       389.455       395.211    
  26  0.506023     -0.681173      -1.84912       1.84912       388.176       390.025    
  27  0.891157     -0.115235     -0.312819      0.312819       393.781       394.093    
  28  0.584674     -0.536701      -1.45694       1.45694       398.183       399.640    
  29  0.313196      -1.16093      -3.15147       3.15147       398.979       402.131    
  30  0.507340     -0.678574      -1.84207       1.84207       400.853       402.696    
  31  0.985030     -0.150835E-01 -0.409461E-01  0.409461E-01   358.619       358.660    
loop,thermsimp(1:2)       38   2.42796       3.65992    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    217        360.60         73.52          0.95         38.56          0.82          0.05        113.89
Just calling func    0   0        113.90


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    360.60
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       38
neval is:      216
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       38      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       39
neval is:      216


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      216     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.125069      -2.07889      -5.64339       5.64339       336.329       341.972    
   2  0.274837      -1.29158      -3.50613       3.50613       340.410       343.916    
   3  0.305931E-01  -3.48698      -9.46582       9.46582       345.084       354.550    
   4  0.929157     -0.734779E-01 -0.199464      0.199464       354.403       354.603    
   5  0.995956     -0.405208E-02 -0.109998E-01  0.109998E-01   350.361       350.372    
   6  0.904971     -0.998521E-01 -0.271060      0.271060       358.619       358.890    
   7  0.189758      -1.66200      -4.51171       4.51171       360.164       364.676    
   8  0.134931      -2.00299      -5.43736       5.43736       362.531       367.968    
   9  0.302412      -1.19596      -3.24659       3.24659       368.360       371.606    
  10  0.389155     -0.943777      -2.56199       2.56199       368.084       370.646    
  11  0.947428     -0.540040E-01 -0.146600      0.146600       371.589       371.735    
  12  0.338357      -1.08365      -2.94170       2.94170       376.237       379.179    
  13  0.937476     -0.645645E-01 -0.175268      0.175268       373.775       373.950    
  14  0.399493     -0.917560      -2.49082       2.49082       376.962       379.453    
  15  0.527586     -0.639444      -1.73585       1.73585       376.733       378.469    
  16  0.297740      -1.21153      -3.28885       3.28885       373.969       377.258    
  17  0.557978     -0.583436      -1.58381       1.58381       377.949       379.533    
  18  0.267521      -1.31856      -3.57938       3.57938       379.567       383.146    
  19  0.637637     -0.449986      -1.22154       1.22154       382.012       383.234    
  20  0.838569     -0.176059     -0.477932      0.477932       382.789       383.267    
  21  0.132199E-01  -4.32603      -11.7435       11.7435       385.510       397.253    
  22  0.745606     -0.293557     -0.796896      0.796896       386.035       386.832    
  23  0.334504      -1.09511      -2.97279       2.97279       386.047       389.020    
  24  0.118852      -2.12987      -5.78179       5.78179       388.176       393.958    
  25  0.319911      -1.13971      -3.09389       3.09389       384.612       387.706    
  26  0.638302E-01  -2.75153      -7.46935       7.46935       391.093       398.562    
  27  0.173204      -1.75329      -4.75950       4.75950       393.781       398.540    
  28  0.885640     -0.121444     -0.329675      0.329675       389.455       389.785    
  29  0.710758     -0.341423     -0.926833      0.926833       398.183       399.110    
  30  0.938919     -0.630265E-01 -0.171093      0.171093       398.979       399.150    
  31  0.217740      -1.52445      -4.13830       4.13830       360.596       364.734    
loop,thermsimp(1:2)       39   5.64339       3.50613    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    218        398.92         73.79          1.02         38.63          0.24          0.06        113.74
Just calling func    0   0        113.74


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    398.92
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       39
neval is:      217
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       39      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       40
neval is:      217


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      217     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.465620     -0.764385      -2.07501       2.07501       336.329       338.404    
   2  0.310178      -1.17061      -3.17775       3.17775       340.410       343.587    
   3  0.883713     -0.123623     -0.335590      0.335590       350.361       350.697    
   4  0.641465     -0.444001      -1.20529       1.20529       345.084       346.290    
   5  0.458576E-01  -3.08222      -8.36704       8.36704       354.403       362.771    
   6  0.611421     -0.491970      -1.33551       1.33551       358.619       359.954    
   7  0.292603      -1.22894      -3.33610       3.33610       360.164       363.500    
   8  0.180818      -1.71026      -4.64271       4.64271       360.596       365.239    
   9  0.490648     -0.712028      -1.93288       1.93288       362.531       364.464    
  10  0.538601     -0.618781      -1.67975       1.67975       368.084       369.764    
  11  0.451209     -0.795824      -2.16036       2.16036       368.360       370.520    
  12  0.610260     -0.493870      -1.34067       1.34067       371.589       372.929    
  13  0.425113     -0.855401      -2.32209       2.32209       373.775       376.097    
  14  0.647858     -0.434084      -1.17837       1.17837       373.969       375.148    
  15  0.394937     -0.929029      -2.52196       2.52196       376.733       379.255    
  16  0.452279E-01  -3.09604      -8.40457       8.40457       376.237       384.642    
  17  0.954905     -0.461437E-01 -0.125262      0.125262       376.962       377.087    
  18  0.362548      -1.01460      -2.75424       2.75424       377.949       380.703    
  19  0.808078     -0.213097     -0.578477      0.578477       379.567       380.145    
  20  0.219348      -1.51709      -4.11833       4.11833       382.012       386.130    
  21  0.206981      -1.57513      -4.27586       4.27586       382.789       387.065    
  22  0.719933     -0.328597     -0.892016      0.892016       386.035       386.927    
  23  0.950238     -0.510432E-01 -0.138563      0.138563       384.612       384.751    
  24  0.845993     -0.167244     -0.454003      0.454003       386.047       386.501    
  25  0.157926      -1.84563      -5.01018       5.01018       389.455       394.466    
  26  0.430020     -0.843924      -2.29093       2.29093       388.176       390.467    
  27  0.624159     -0.471350      -1.27953       1.27953       385.510       386.789    
  28  0.355386      -1.03455      -2.80841       2.80841       393.781       396.589    
  29  0.297353      -1.21284      -3.29239       3.29239       391.093       394.385    
  30  0.185476      -1.68483      -4.57367       4.57367       398.183       402.757    
  31  0.406569     -0.900002      -2.44316       2.44316       398.920       401.363    
loop,thermsimp(1:2)       40   2.07501       3.17775    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    219        356.60         73.80          0.97         38.81          0.64          0.06        114.28
Just calling func    0   0        114.28


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    356.60
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       40
neval is:      218
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       40      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       41
neval is:      218


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      218     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.231075      -1.46501      -3.97695       3.97695       336.329       340.306    
   2  0.984723     -0.153953E-01 -0.417924E-01  0.417924E-01   340.410       340.451    
   3  0.689569     -0.371688      -1.00899       1.00899       345.084       346.093    
   4  0.539532     -0.617054      -1.67506       1.67506       350.361       352.036    
   5  0.103859      -2.26472      -6.14786       6.14786       358.619       364.767    
   6  0.403261     -0.908171      -2.46534       2.46534       354.403       356.869    
   7  0.545138     -0.606716      -1.64700       1.64700       360.164       361.811    
   8  0.211198      -1.55496      -4.22113       4.22113       362.531       366.752    
   9  0.533123     -0.629004      -1.70750       1.70750       360.596       362.304    
  10  0.891214     -0.115171     -0.312644      0.312644       368.084       368.397    
  11  0.604806     -0.502847      -1.36504       1.36504       368.360       369.725    
  12  0.176166      -1.73633      -4.71347       4.71347       371.589       376.302    
  13  0.733693     -0.309664     -0.840619      0.840619       373.969       374.810    
  14  0.248504      -1.39230      -3.77956       3.77956       373.775       377.554    
  15  0.183808      -1.69387      -4.59820       4.59820       376.962       381.560    
  16  0.308674E-02  -5.78064      -15.6922       15.6922       376.733       392.425    
  17  0.651025     -0.429207      -1.16513       1.16513       379.567       380.732    
  18  0.864353     -0.145775     -0.395722      0.395722       377.949       378.344    
  19  0.547352     -0.602664      -1.63600       1.63600       376.237       377.873    
  20  0.631248     -0.460057      -1.24888       1.24888       384.612       385.861    
  21  0.344368E-01  -3.36863      -9.14454       9.14454       382.012       391.157    
  22  0.876828     -0.131444     -0.356821      0.356821       386.047       386.404    
  23  0.884538     -0.122690     -0.333057      0.333057       385.510       385.843    
  24  0.926808     -0.760084E-01 -0.206334      0.206334       386.035       386.241    
  25  0.823462     -0.194237     -0.527280      0.527280       382.789       383.316    
  26  0.852580     -0.159489     -0.432951      0.432951       388.176       388.609    
  27  0.577707     -0.548689      -1.48948       1.48948       391.093       392.582    
  28  0.510093     -0.673163      -1.82738       1.82738       389.455       391.283    
  29  0.890288     -0.116210     -0.315466      0.315466       393.781       394.096    
  30  0.304875      -1.18785      -3.22456       3.22456       398.920       402.144    
  31  0.152164      -1.88279      -5.11106       5.11106       356.596       361.707    
loop,thermsimp(1:2)       41   3.97695      0.417924E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    220        401.36         73.86          0.98         38.65          0.77          0.06        114.33
Just calling func    0   0        114.33


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    221        374.13         73.61          0.98         38.85          0.84          0.05        114.32
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  220    374.13        1.678     -1.195      5.792     -102.1      1.309    
                     -0.1554      3.389     -100.2      3.805      1.708    
                       1.846    -0.9717      1.345      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1209E+05 0.1477E+05 -2989.    -0.4906E+05
                      -2.000     -5.339     -7.176     -6.927     0.6361    
                      -13.64     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                      -1.470     -1.679      3.620      1.447      0.000    
                       0.000      9.205      9.124      4834.      1.000    
                     -0.5787    -0.7479      9.398      8.548     -2182.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -8417.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3909.      1.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    374.13
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       41
neval is:      220
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       41      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       42
neval is:      220


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      220     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.442958E-01  -3.11686      -8.46109       8.46109       336.329       344.790    
   2  0.196215      -1.62854      -4.42087       4.42087       340.410       344.830    
   3  0.501152     -0.690846      -1.87538       1.87538       345.084       346.960    
   4  0.288339      -1.24362      -3.37595       3.37595       350.361       353.737    
   5  0.773132     -0.257306     -0.698487      0.698487       354.403       355.102    
   6  0.417683     -0.873033      -2.36995       2.36995       356.596       358.966    
   7  0.229479      -1.47195      -3.99577       3.99577       360.164       364.160    
   8  0.964123     -0.365367E-01 -0.991831E-01  0.991831E-01   360.596       360.695    
   9  0.263782      -1.33263      -3.61759       3.61759       358.619       362.237    
  10  0.102960      -2.27342      -6.17145       6.17145       362.531       368.702    
  11  0.828790     -0.187788     -0.509773      0.509773       368.084       368.594    
  12  0.738697     -0.302868     -0.822170      0.822170       368.360       369.182    
  13  0.458595     -0.779589      -2.11628       2.11628       373.969       376.086    
  14  0.905176     -0.996260E-01 -0.270446      0.270446       371.589       371.859    
  15  0.147067      -1.91687      -5.20356       5.20356       373.775       378.978    
  16  0.142365      -1.94936      -5.29176       5.29176       376.237       381.529    
  17  0.483147     -0.727435      -1.97471       1.97471       377.949       379.923    
  18  0.640417     -0.445636      -1.20973       1.20973       379.567       380.777    
  19  0.719349     -0.329408     -0.894218      0.894218       376.962       377.856    
  20  0.714234     -0.336545     -0.913590      0.913590       382.789       383.703    
  21  0.825507     -0.191757     -0.520547      0.520547       385.510       386.030    
  22  0.155188      -1.86312      -5.05765       5.05765       384.612       389.670    
  23  0.248874      -1.39081      -3.77552       3.77552       386.035       389.810    
  24  0.107953      -2.22606      -6.04290       6.04290       386.047       392.090    
  25  0.349169      -1.05220      -2.85632       2.85632       388.176       391.033    
  26  0.967311     -0.332356E-01 -0.902219E-01  0.902219E-01   382.012       382.102    
  27  0.519506     -0.654877      -1.77774       1.77774       389.455       391.233    
  28  0.462662     -0.770758      -2.09231       2.09231       376.733       378.825    
  29  0.811438     -0.208948     -0.567213      0.567213       391.093       391.660    
  30  0.394710E-01  -3.23219      -8.77416       8.77416       393.781       402.555    
  31  0.482930     -0.727884      -1.97593       1.97593       374.126       376.102    
loop,thermsimp(1:2)       42   8.46109       4.42087    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    222        356.38         73.92          1.00         38.69          0.80          0.05        114.46
Just calling func    0   0        114.46


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    356.38
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       42
neval is:      221
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       42      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       43
neval is:      221


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      221     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.298594      -1.20867      -3.28108       3.28108       336.329       339.610    
   2  0.383173     -0.959268      -2.60405       2.60405       340.410       343.014    
   3  0.386205     -0.951387      -2.58265       2.58265       345.084       347.667    
   4  0.362178      -1.01562      -2.75702       2.75702       350.361       353.118    
   5  0.394462     -0.930233      -2.52523       2.52523       354.403       356.929    
   6  0.883072     -0.124349     -0.337559      0.337559       356.596       356.933    
   7  0.571477     -0.559531      -1.51891       1.51891       360.596       362.115    
   8  0.944036     -0.575912E-01 -0.156338      0.156338       358.619       358.775    
   9  0.326573      -1.11910      -3.03793       3.03793       360.164       363.202    
  10  0.467297     -0.760791      -2.06526       2.06526       368.084       370.149    
  11  0.828365     -0.188301     -0.511165      0.511165       362.531       363.042    
  12  0.826991     -0.189962     -0.515674      0.515674       368.360       368.876    
  13  0.675447E-01  -2.69497      -7.31580       7.31580       371.589       378.904    
  14  0.924113     -0.789214E-01 -0.214241      0.214241       373.969       374.184    
  15  0.810131     -0.210560     -0.571590      0.571590       374.126       374.697    
  16  0.410286     -0.890900      -2.41845       2.41845       376.962       379.380    
  17  0.334977      -1.09369      -2.96896       2.96896       376.733       379.702    
  18  0.119017      -2.12849      -5.77803       5.77803       373.775       379.553    
  19  0.447328     -0.804463      -2.18381       2.18381       377.949       380.133    
  20  0.324388E-02  -5.73098      -15.5574       15.5574       379.567       395.124    
  21  0.158272      -1.84344      -5.00424       5.00424       376.237       381.241    
  22  0.241219      -1.42205      -3.86033       3.86033       382.012       385.872    
  23  0.259790      -1.34788      -3.65898       3.65898       382.789       386.448    
  24  0.521973     -0.650139      -1.76488       1.76488       385.510       387.274    
  25  0.336335      -1.08965      -2.95798       2.95798       384.612       387.570    
  26  0.642248     -0.442780      -1.20198       1.20198       386.035       387.237    
  27  0.984615     -0.155047E-01 -0.420893E-01  0.420893E-01   388.176       388.218    
  28  0.373782     -0.984082      -2.67141       2.67141       389.455       392.127    
  29  0.932479     -0.699087E-01 -0.189775      0.189775       391.093       391.282    
  30  0.711360     -0.340577     -0.924537      0.924537       386.047       386.972    
  31  0.315363      -1.15403      -3.13276       3.13276       356.376       359.509    
loop,thermsimp(1:2)       43   3.28108       2.60405    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    223        584.65         74.05          0.98         38.74          0.87          0.06        114.71
Just calling func    0   0        114.71


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    224        391.46         74.05          1.03         38.74          0.14          0.06        114.02
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    391.46
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       43
neval is:      223
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       43      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       44
neval is:      223


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      223     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.287044      -1.24812      -3.38817       3.38817       336.329       339.717    
   2  0.260243      -1.34614      -3.65425       3.65425       340.410       344.064    
   3  0.646915     -0.435540      -1.18232       1.18232       345.084       346.267    
   4  0.572447     -0.557835      -1.51431       1.51431       350.361       351.875    
   5  0.105907      -2.24520      -6.09485       6.09485       354.403       360.498    
   6  0.693038     -0.366671     -0.995370      0.995370       356.596       357.591    
   7  0.329408      -1.11046      -3.01447       3.01447       358.619       361.633    
   8  0.187221      -1.67546      -4.54824       4.54824       356.376       360.925    
   9  0.545731     -0.605630      -1.64405       1.64405       360.596       362.240    
  10  0.752820     -0.283930     -0.770761      0.770761       362.531       363.301    
  11  0.153542      -1.87378      -5.08659       5.08659       360.164       365.250    
  12  0.400659     -0.914645      -2.48291       2.48291       368.360       370.843    
  13  0.306182      -1.18357      -3.21295       3.21295       368.084       371.297    
  14  0.270957E-01  -3.60838      -9.79538       9.79538       373.969       383.765    
  15  0.776765     -0.252618     -0.685761      0.685761       374.126       374.811    
  16  0.711945     -0.339755     -0.922305      0.922305       371.589       372.511    
  17  0.217190      -1.52698      -4.14518       4.14518       376.962       381.107    
  18  0.285226      -1.25447      -3.40542       3.40542       373.775       377.180    
  19  0.348904      -1.05296      -2.85838       2.85838       376.733       379.591    
  20  0.686414     -0.376275      -1.02144       1.02144       377.949       378.970    
  21  0.212825      -1.54729      -4.20029       4.20029       376.237       380.437    
  22  0.501697     -0.689760      -1.87243       1.87243       382.012       383.885    
  23  0.363771      -1.01123      -2.74510       2.74510       382.789       385.534    
  24  0.789273     -0.236642     -0.642394      0.642394       386.047       386.690    
  25  0.232884      -1.45721      -3.95578       3.95578       386.035       389.990    
  26  0.754896     -0.281175     -0.763282      0.763282       385.510       386.273    
  27  0.639358     -0.447290      -1.21422       1.21422       384.612       385.826    
  28  0.532505     -0.630163      -1.71065       1.71065       388.176       389.887    
  29  0.759813     -0.274683     -0.745660      0.745660       391.093       391.838    
  30  0.768360     -0.263497     -0.715294      0.715294       389.455       390.171    
  31  0.245116      -1.40602      -3.81681       3.81681       391.464       395.281    
loop,thermsimp(1:2)       44   3.38817       3.65425    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    225        360.98         74.90          1.08         38.21          0.00          0.05        114.25
Just calling func    0   0        114.25


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    360.98
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       44
neval is:      224
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       44      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       45
neval is:      224


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      224     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.204302      -1.58816      -4.31124       4.31124       336.329       340.640    
   2  0.455846E-01  -3.08818      -8.38324       8.38324       340.410       348.793    
   3  0.655807     -0.421889      -1.14527       1.14527       345.084       346.230    
   4  0.902989     -0.102045     -0.277014      0.277014       350.361       350.638    
   5  0.826012     -0.191146     -0.518887      0.518887       356.596       357.115    
   6  0.160871      -1.82715      -4.96002       4.96002       354.403       359.364    
   7  0.516410     -0.660854      -1.79397       1.79397       356.376       358.170    
   8  0.506939     -0.679364      -1.84421       1.84421       358.619       360.463    
   9  0.728359     -0.316962     -0.860430      0.860430       360.596       361.457    
  10  0.453162     -0.791506      -2.14864       2.14864       362.531       364.679    
  11  0.837994     -0.176745     -0.479794      0.479794       360.164       360.644    
  12  0.118024      -2.13686      -5.80077       5.80077       368.360       374.161    
  13  0.274030      -1.29452      -3.51412       3.51412       368.084       371.598    
  14  0.402227     -0.910738      -2.47230       2.47230       371.589       374.061    
  15  0.444245     -0.811380      -2.20259       2.20259       374.126       376.328    
  16  0.594880     -0.519396      -1.40996       1.40996       373.775       375.185    
  17  0.548806     -0.600010      -1.62880       1.62880       377.949       379.578    
  18  0.222827      -1.50136      -4.07561       4.07561       376.733       380.808    
  19  0.152541      -1.88032      -5.10435       5.10435       376.237       381.341    
  20  0.816533     -0.202688     -0.550219      0.550219       376.962       377.512    
  21  0.525417     -0.643564      -1.74703       1.74703       373.969       375.716    
  22  0.661450     -0.413320      -1.12201       1.12201       382.012       383.134    
  23  0.437535     -0.826598      -2.24390       2.24390       382.789       385.033    
  24  0.464442     -0.766918      -2.08189       2.08189       384.612       386.694    
  25  0.683975     -0.379834      -1.03110       1.03110       385.510       386.541    
  26  0.407919     -0.896688      -2.43416       2.43416       386.047       388.482    
  27  0.934669     -0.675632E-01 -0.183408      0.183408       388.176       388.360    
  28  0.866891     -0.142842     -0.387760      0.387760       386.035       386.422    
  29  0.145435E-01  -4.23061      -11.4845       11.4845       389.455       400.940    
  30  0.514599     -0.664368      -1.80350       1.80350       391.093       392.896    
  31  0.370591     -0.992656      -2.69468       2.69468       360.982       363.677    
loop,thermsimp(1:2)       45   4.31124       8.38324    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    226        357.68         74.04          0.99         38.55          1.09          0.06        114.72
Just calling func    0   0        114.72


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    357.68
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       45
neval is:      225
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       45      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       46
neval is:      225


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      225     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.794521     -0.230016     -0.624406      0.624406       336.329       336.953    
   2  0.338444      -1.08340      -2.94100       2.94100       345.084       348.025    
   3  0.563800     -0.573055      -1.55563       1.55563       340.410       341.965    
   4  0.295284      -1.21982      -3.31133       3.31133       350.361       353.672    
   5  0.506481     -0.680269      -1.84667       1.84667       356.596       358.443    
   6  0.345803      -1.06189      -2.88262       2.88262       356.376       359.259    
   7  0.741641     -0.298890     -0.811371      0.811371       354.403       355.215    
   8  0.182310      -1.70204      -4.62040       4.62040       358.619       363.239    
   9  0.315187      -1.15459      -3.13426       3.13426       360.164       363.298    
  10  0.598844     -0.512755      -1.39193       1.39193       360.596       361.988    
  11  0.659119     -0.416852      -1.13159       1.13159       360.982       362.114    
  12  0.247481      -1.39642      -3.79075       3.79075       362.531       366.321    
  13  0.255298      -1.36532      -3.70633       3.70633       368.084       371.790    
  14  0.876488     -0.131833     -0.357875      0.357875       371.589       371.946    
  15  0.358010      -1.02719      -2.78844       2.78844       368.360       371.148    
  16  0.317480      -1.14734      -3.11459       3.11459       373.775       376.890    
  17  0.153422      -1.87456      -5.08872       5.08872       373.969       379.058    
  18  0.296162      -1.21685      -3.30328       3.30328       374.126       377.429    
  19  0.629760     -0.462417      -1.25528       1.25528       376.962       378.217    
  20  0.458345E-01  -3.08272      -8.36840       8.36840       377.949       386.317    
  21  0.209534      -1.56287      -4.24259       4.24259       376.733       380.975    
  22  0.490210E-01  -3.01551      -8.18595       8.18595       376.237       384.423    
  23  0.144817      -1.93229      -5.24542       5.24542       382.012       387.258    
  24  0.764061     -0.269107     -0.730524      0.730524       382.789       383.520    
  25  0.158664      -1.84097      -4.99753       4.99753       386.035       391.032    
  26  0.242818      -1.41544      -3.84238       3.84238       385.510       389.352    
  27  0.779950     -0.248525     -0.674650      0.674650       384.612       385.287    
  28  0.763580     -0.269737     -0.732233      0.732233       388.176       388.909    
  29  0.817639     -0.201335     -0.546546      0.546546       386.047       386.594    
  30  0.656802     -0.420373      -1.14115       1.14115       391.093       392.234    
  31  0.202192      -1.59854      -4.33942       4.33942       357.685       362.024    
loop,thermsimp(1:2)       46  0.624406       2.94100    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    227        370.21         74.00          1.00         38.78          0.42          0.06        114.25
Just calling func    0   0        114.25


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    370.21
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       46
neval is:      226
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       46      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       47
neval is:      226


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      226     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.652512     -0.426926      -1.15894       1.15894       336.329       337.488    
   2  0.474910     -0.744630      -2.02139       2.02139       340.410       342.431    
   3  0.125725      -2.07366      -5.62919       5.62919       345.084       350.714    
   4  0.950967     -0.502756E-01 -0.136479      0.136479       350.361       350.498    
   5  0.562475     -0.575409      -1.56202       1.56202       354.403       355.965    
   6  0.728528     -0.316729     -0.859797      0.859797       356.596       357.456    
   7  0.326058      -1.12068      -3.04222       3.04222       356.376       359.419    
   8  0.460979     -0.774402      -2.10221       2.10221       360.596       362.698    
   9  0.186861      -1.67739      -4.55348       4.55348       357.685       362.238    
  10  0.737773     -0.304119     -0.825567      0.825567       360.982       361.808    
  11  0.254524      -1.36836      -3.71458       3.71458       358.619       362.334    
  12  0.475390     -0.743621      -2.01865       2.01865       360.164       362.182    
  13  0.783107     -0.244486     -0.663685      0.663685       362.531       363.194    
  14  0.615536     -0.485261      -1.31730       1.31730       368.360       369.677    
  15  0.600710E-01  -2.81223      -7.63412       7.63412       368.084       375.718    
  16  0.834417     -0.181022     -0.491407      0.491407       371.589       372.080    
  17  0.270355      -1.30802      -3.55077       3.55077       373.775       377.326    
  18  0.408387     -0.895540      -2.43105       2.43105       374.126       376.557    
  19  0.248286      -1.39318      -3.78194       3.78194       376.962       380.744    
  20  0.586808E-01  -2.83564      -7.69768       7.69768       373.969       381.667    
  21  0.747050     -0.291623     -0.791646      0.791646       376.733       377.524    
  22  0.261869E-01  -3.64250      -9.88799       9.88799       382.789       392.677    
  23  0.495813     -0.701557      -1.90446       1.90446       376.237       378.141    
  24  0.600032     -0.510772      -1.38655       1.38655       384.612       385.999    
  25  0.936456     -0.656531E-01 -0.178223      0.178223       377.949       378.127    
  26  0.583260     -0.539121      -1.46351       1.46351       386.047       387.511    
  27  0.994266     -0.575021E-02 -0.156096E-01  0.156096E-01   382.012       382.028    
  28  0.149755      -1.89876      -5.15439       5.15439       388.176       393.331    
  29  0.751239     -0.286032     -0.776466      0.776466       385.510       386.286    
  30  0.703931     -0.351075     -0.953034      0.953034       386.035       386.988    
  31  0.998476     -0.152564E-02 -0.414153E-02  0.414153E-02   370.206       370.210    
loop,thermsimp(1:2)       47   1.15894       2.02139    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    228        358.88         73.88          0.96         38.87          0.61          0.06        114.38
Just calling func    0   0        114.38


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    358.88
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       47
neval is:      227
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       47      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       48
neval is:      227


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      227     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.316013      -1.15197      -3.12716       3.12716       336.329       339.456    
   2  0.452730     -0.792459      -2.15122       2.15122       340.410       342.561    
   3  0.463916     -0.768051      -2.08497       2.08497       350.361       352.446    
   4  0.531172E-01  -2.93526      -7.96809       7.96809       345.084       353.053    
   5  0.933113     -0.692290E-01 -0.187930      0.187930       354.403       354.591    
   6  0.107612      -2.22922      -6.05148       6.05148       356.596       362.647    
   7  0.228017      -1.47833      -4.01311       4.01311       356.376       360.390    
   8  0.766526     -0.265887     -0.721782      0.721782       360.982       361.704    
   9  0.676418     -0.390944      -1.06126       1.06126       360.164       361.225    
  10  0.220696      -1.51097      -4.10170       4.10170       357.685       361.787    
  11  0.959946E-01  -2.34346      -6.36161       6.36161       358.619       364.981    
  12  0.570655     -0.560971      -1.52282       1.52282       360.596       362.119    
  13  0.736426     -0.305947     -0.830528      0.830528       362.531       363.361    
  14  0.966377     -0.342013E-01 -0.928436E-01  0.928436E-01   368.360       368.453    
  15  0.797662     -0.226070     -0.613694      0.613694       370.206       370.819    
  16  0.413688     -0.882643      -2.39604       2.39604       371.589       373.985    
  17  0.200670      -1.60609      -4.35993       4.35993       368.084       372.444    
  18  0.843958E-01  -2.47224      -6.71118       6.71118       374.126       380.837    
  19  0.375580     -0.979284      -2.65838       2.65838       373.775       376.433    
  20  0.968669     -0.318322E-01 -0.864122E-01  0.864122E-01   376.733       376.819    
  21  0.379263     -0.969525      -2.63189       2.63189       377.949       380.581    
  22  0.421746     -0.863352      -2.34367       2.34367       376.237       378.581    
  23  0.639909     -0.446429      -1.21188       1.21188       376.962       378.174    
  24  0.549878     -0.598059      -1.62350       1.62350       373.969       375.593    
  25  0.226469      -1.48515      -4.03161       4.03161       382.012       386.044    
  26  0.547044E-02  -5.20840      -14.1388       14.1388       384.612       398.751    
  27  0.372808     -0.986692      -2.67849       2.67849       385.510       388.188    
  28  0.406819E-01  -3.20197      -8.69213       8.69213       386.035       394.727    
  29  0.664564     -0.408624      -1.10926       1.10926       386.047       387.157    
  30  0.708700     -0.344323     -0.934704      0.934704       382.789       383.724    
  31  0.863329     -0.146959     -0.398937      0.398937       358.878       359.277    
loop,thermsimp(1:2)       48   3.12716       2.15122    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    229        389.82         74.40          1.01         38.75          0.10          0.06        114.32
Just calling func    0   0        114.32


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    389.82
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       48
neval is:      228
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       48      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       49
neval is:      228


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      228     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.991535     -0.850114E-02 -0.230774E-01  0.230774E-01   336.329       336.352    
   2  0.120199      -2.11861      -5.75120       5.75120       340.410       346.161    
   3  0.825835     -0.191360     -0.519469      0.519469       350.361       350.881    
   4  0.769690     -0.261767     -0.710597      0.710597       345.084       345.795    
   5  0.206534      -1.57729      -4.28174       4.28174       354.403       358.685    
   6  0.435455     -0.831363      -2.25683       2.25683       358.878       361.135    
   7  0.408718     -0.894731      -2.42885       2.42885       356.376       358.805    
   8  0.504170E-01  -2.98743      -8.10972       8.10972       360.164       368.274    
   9  0.943874     -0.577631E-01 -0.156805      0.156805       360.982       361.139    
  10  0.161493      -1.82330      -4.94955       4.94955       357.685       362.634    
  11  0.248560      -1.39207      -3.77894       3.77894       360.596       364.375    
  12  0.952734     -0.484195E-01 -0.131441      0.131441       356.596       356.727    
  13  0.349224      -1.05204      -2.85589       2.85589       362.531       365.387    
  14  0.245013      -1.40644      -3.81795       3.81795       358.619       362.437    
  15  0.713805     -0.337146     -0.915221      0.915221       368.360       369.275    
  16  0.206995      -1.57506      -4.27569       4.27569       370.206       374.481    
  17  0.573984     -0.555154      -1.50703       1.50703       368.084       369.591    
  18  0.791297     -0.234082     -0.635444      0.635444       371.589       372.224    
  19  0.599323     -0.511955      -1.38976       1.38976       373.969       375.359    
  20  0.632893     -0.457454      -1.24181       1.24181       373.775       375.017    
  21  0.920472     -0.828688E-01 -0.224957      0.224957       376.733       376.958    
  22  0.650695     -0.429713      -1.16651       1.16651       376.962       378.128    
  23  0.759327     -0.275322     -0.747395      0.747395       376.237       376.984    
  24  0.547563     -0.602278      -1.63495       1.63495       377.949       379.584    
  25  0.375945     -0.978312      -2.65574       2.65574       374.126       376.781    
  26  0.436593     -0.828753      -2.24975       2.24975       382.789       385.039    
  27  0.226348      -1.48568      -4.03305       4.03305       382.012       386.045    
  28  0.889061     -0.117589     -0.319210      0.319210       386.047       386.367    
  29  0.294563      -1.22226      -3.31797       3.31797       385.510       388.828    
  30  0.760606     -0.273640     -0.742829      0.742829       386.035       386.778    
  31  0.131934      -2.02545      -5.49832       5.49832       389.822       395.321    
loop,thermsimp(1:2)       49  0.230774E-01   5.75120    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    230        384.61         73.69          1.02         38.79          0.39          0.05        113.95
Just calling func    0   0        113.95


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    384.61
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       49
neval is:      229
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       49      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       50
neval is:      229


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      229     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.919134E-02  -4.68949      -12.7302       12.7302       336.329       349.059    
   2  0.902150     -0.102974     -0.279536      0.279536       345.084       345.364    
   3  0.375868     -0.978517      -2.65630       2.65630       340.410       343.066    
   4  0.136549E-01  -4.29366      -11.6556       11.6556       350.361       362.017    
   5  0.948329     -0.530533E-01 -0.144019      0.144019       356.596       356.740    
   6  0.489379E-01  -3.01720      -8.19055       8.19055       354.403       362.594    
   7  0.319400      -1.14131      -3.09822       3.09822       356.376       359.475    
   8  0.748008     -0.290342     -0.788167      0.788167       358.878       359.666    
   9  0.468015     -0.759255      -2.06109       2.06109       360.982       363.044    
  10  0.467420     -0.760527      -2.06454       2.06454       358.619       360.683    
  11  0.345085      -1.06396      -2.88825       2.88825       357.685       360.573    
  12  0.598981     -0.512526      -1.39131       1.39131       360.596       361.987    
  13  0.231496      -1.46319      -3.97200       3.97200       362.531       366.503    
  14  0.685496     -0.377613      -1.02507       1.02507       360.164       361.189    
  15  0.225803      -1.48809      -4.03960       4.03960       368.360       372.399    
  16  0.744991E-01  -2.59697      -7.04977       7.04977       368.084       375.134    
  17  0.436777     -0.828332      -2.24860       2.24860       371.589       373.837    
  18  0.241074      -1.42265      -3.86196       3.86196       370.206       374.068    
  19  0.728071     -0.317357     -0.861504      0.861504       373.775       374.636    
  20  0.228500      -1.47622      -4.00737       4.00737       373.969       377.977    
  21  0.423678     -0.858781      -2.33126       2.33126       374.126       376.457    
  22  0.812855     -0.207202     -0.562474      0.562474       376.733       377.295    
  23  0.810546     -0.210047     -0.570198      0.570198       376.237       376.807    
  24  0.113500      -2.17595      -5.90687       5.90687       376.962       382.869    
  25  0.197385      -1.62260      -4.40474       4.40474       377.949       382.353    
  26  0.101018      -2.29246      -6.22315       6.22315       382.789       389.012    
  27  0.857009E-01  -2.45689      -6.66952       6.66952       382.012       388.682    
  28  0.693668     -0.365762     -0.992903      0.992903       386.047       387.040    
  29  0.705918     -0.348256     -0.945382      0.945382       386.035       386.980    
  30  0.309793      -1.17185      -3.18113       3.18113       385.510       388.691    
  31  0.144843      -1.93210      -5.24492       5.24492       384.612       389.857    
loop,thermsimp(1:2)       50   12.7302      0.279536    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    231        389.82         74.39          1.00         38.52          0.66          0.05        114.62
Just calling func    0   0        114.62


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    389.82
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       50
neval is:      230
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       50      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       51
neval is:      230


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      230     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.903412     -0.101577     -0.275742      0.275742       340.410       340.685    
   2  0.808902     -0.212077     -0.575709      0.575709       345.084       345.660    
   3  0.762147     -0.271616     -0.737333      0.737333       336.329       337.066    
   4  0.287851      -1.24531      -3.38054       3.38054       356.596       359.976    
   5  0.212418      -1.54920      -4.20549       4.20549       356.376       360.582    
   6  0.380717     -0.965699      -2.62150       2.62150       358.878       361.499    
   7  0.877795     -0.130342     -0.353829      0.353829       357.685       358.039    
   8  0.836834     -0.178130     -0.483554      0.483554       358.619       359.102    
   9  0.435183     -0.831988      -2.25853       2.25853       360.164       362.422    
  10  0.900166     -0.105177     -0.285514      0.285514       360.596       360.882    
  11  0.175095      -1.74242      -4.73002       4.73002       350.361       355.091    
  12  0.322232      -1.13248      -3.07426       3.07426       354.403       357.478    
  13  0.706662     -0.347203     -0.942525      0.942525       360.982       361.925    
  14  0.494297     -0.704618      -1.91277       1.91277       362.531       364.443    
  15  0.324383      -1.12583      -3.05620       3.05620       368.360       371.416    
  16  0.777122     -0.252157     -0.684511      0.684511       371.589       372.273    
  17  0.499054E-01  -2.99763      -8.13741       8.13741       370.206       378.343    
  18  0.489193E-01  -3.01758      -8.19159       8.19159       373.775       381.967    
  19  0.480140     -0.733678      -1.99165       1.99165       368.084       370.076    
  20  0.914126     -0.897865E-01 -0.243736      0.243736       374.126       374.369    
  21  0.613008     -0.489378      -1.32847       1.32847       376.237       377.565    
  22  0.470573     -0.753804      -2.04629       2.04629       376.733       378.779    
  23  0.614279     -0.487307      -1.32285       1.32285       373.969       375.292    
  24  0.410529     -0.890308      -2.41684       2.41684       377.949       380.366    
  25  0.582759     -0.539981      -1.46584       1.46584       376.962       378.428    
  26  0.422753E-01  -3.16355      -8.58783       8.58783       386.035       394.623    
  27  0.717044     -0.332618     -0.902931      0.902931       386.047       386.950    
  28  0.420765     -0.865682      -2.34999       2.34999       382.012       384.362    
  29  0.801392     -0.221405     -0.601029      0.601029       385.510       386.111    
  30  0.426188     -0.852875      -2.31523       2.31523       382.789       385.104    
  31  0.338881      -1.08211      -2.93751       2.93751       389.822       392.760    
loop,thermsimp(1:2)       51  0.275742      0.575709    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    232        352.33         74.39          1.01         38.75          0.22          0.05        114.43
Just calling func    0   0        114.43


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    352.33
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       51
neval is:      231
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       51      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       52
neval is:      231


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      231     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.421091     -0.864906      -2.34789       2.34789       336.329       338.677    
   2  0.315135      -1.15476      -3.13472       3.13472       340.410       343.544    
   3  0.696708     -0.361389     -0.981033      0.981033       345.084       346.065    
   4  0.922116     -0.810842E-01 -0.220113      0.220113       350.361       350.581    
   5  0.908133     -0.963648E-01 -0.261594      0.261594       354.403       354.665    
   6  0.174132      -1.74794      -4.74499       4.74499       357.685       362.430    
   7  0.490629     -0.712068      -1.93299       1.93299       358.619       360.552    
   8  0.382604     -0.960755      -2.60808       2.60808       356.596       359.204    
   9  0.985159     -0.149527E-01 -0.405909E-01  0.405909E-01   356.376       356.417    
  10  0.182634      -1.70027      -4.61559       4.61559       360.596       365.212    
  11  0.554568     -0.589565      -1.60044       1.60044       358.878       360.478    
  12  0.999791     -0.209153E-03 -0.567770E-03  0.567770E-03   360.982       360.983    
  13  0.284621      -1.25660      -3.41118       3.41118       360.164       363.575    
  14  0.920706E-01  -2.38520      -6.47490       6.47490       362.531       369.006    
  15  0.243911      -1.41095      -3.83020       3.83020       368.084       371.914    
  16  0.866829     -0.142914     -0.387956      0.387956       368.360       368.748    
  17  0.640039     -0.446225      -1.21133       1.21133       371.589       372.800    
  18  0.737488E-01  -2.60709      -7.07725       7.07725       374.126       381.203    
  19  0.511916     -0.669594      -1.81769       1.81769       373.969       375.787    
  20  0.870220     -0.139009     -0.377357      0.377357       376.237       376.614    
  21  0.594690     -0.519714      -1.41083       1.41083       370.206       371.616    
  22  0.659508     -0.416262      -1.12999       1.12999       376.962       378.092    
  23  0.702023     -0.353789     -0.960403      0.960403       376.733       377.693    
  24  0.178121      -1.72529      -4.68351       4.68351       377.949       382.632    
  25  0.622271     -0.474379      -1.28776       1.28776       373.775       375.063    
  26  0.877027     -0.131217     -0.356204      0.356204       382.012       382.368    
  27  0.206753      -1.57623      -4.27887       4.27887       382.789       387.068    
  28  0.927381     -0.753912E-01 -0.204658      0.204658       385.510       385.714    
  29  0.610274     -0.493848      -1.34061       1.34061       386.047       387.388    
  30  0.453676     -0.790373      -2.14556       2.14556       389.822       391.968    
  31  0.203335      -1.59290      -4.32411       4.32411       352.327       356.651    
loop,thermsimp(1:2)       52   2.34789       3.13472    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    233        380.96         73.71          1.02         38.61          0.68          0.05        114.08
Just calling func    0   0        114.08


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    380.96
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       52
neval is:      232
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       52      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       53
neval is:      232


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      232     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.340866E-01  -3.37885      -9.17229       9.17229       336.329       345.501    
   2  0.714674     -0.335928     -0.911916      0.911916       340.410       341.321    
   3  0.977792     -0.224587E-01 -0.609668E-01  0.609668E-01   345.084       345.145    
   4  0.771231     -0.259767     -0.705168      0.705168       350.361       351.066    
   5  0.265148      -1.32747      -3.60357       3.60357       354.403       358.007    
   6  0.559491     -0.580728      -1.57645       1.57645       356.376       357.953    
   7  0.934824E-01  -2.36998      -6.43359       6.43359       352.327       358.761    
   8  0.928182     -0.745278E-01 -0.202314      0.202314       356.596       356.798    
   9  0.464905     -0.765922      -2.07918       2.07918       358.878       360.957    
  10  0.871919     -0.137059     -0.372062      0.372062       358.619       358.991    
  11  0.982233     -0.179265E-01 -0.486635E-01  0.486635E-01   360.982       361.031    
  12  0.426376     -0.852433      -2.31403       2.31403       357.685       359.999    
  13  0.471128E-01  -3.05521      -8.29373       8.29373       360.164       368.458    
  14  0.686439     -0.376238      -1.02134       1.02134       360.596       361.617    
  15  0.117826      -2.13855      -5.80533       5.80533       368.360       374.165    
  16  0.756878E-01  -2.58114      -7.00680       7.00680       362.531       369.538    
  17  0.196211      -1.62856      -4.42093       4.42093       370.206       374.626    
  18  0.431930     -0.839491      -2.27890       2.27890       368.084       370.363    
  19  0.707794     -0.345602     -0.938178      0.938178       371.589       372.527    
  20  0.174358E-01  -4.04923      -10.9921       10.9921       373.775       384.767    
  21  0.267976      -1.31686      -3.57476       3.57476       373.969       377.544    
  22  0.793866     -0.230841     -0.626644      0.626644       376.237       376.864    
  23  0.135848      -1.99622      -5.41898       5.41898       376.733       382.152    
  24  0.663958     -0.409536      -1.11173       1.11173       376.962       378.073    
  25  0.281101      -1.26904      -3.44496       3.44496       374.126       377.571    
  26  0.606466     -0.500106      -1.35760       1.35760       382.012       383.370    
  27  0.940056     -0.618158E-01 -0.167806      0.167806       377.949       378.117    
  28  0.124106      -2.08662      -5.66438       5.66438       385.510       391.174    
  29  0.205090      -1.58431      -4.30079       4.30079       382.789       387.090    
  30  0.852960     -0.159043     -0.431741      0.431741       386.047       386.479    
  31  0.241701      -1.42005      -3.85490       3.85490       380.964       384.819    
loop,thermsimp(1:2)       53   9.17229      0.911916    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    234        372.88         73.87          1.00         38.71          0.27          0.05        113.91
Just calling func    0   0        113.90


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    372.88
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       53
neval is:      233
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       53      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       54
neval is:      233


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      233     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.615000     -0.486133      -1.31967       1.31967       340.410       341.729    
   2  0.438442     -0.824528      -2.23828       2.23828       345.084       347.323    
   3  0.666371     -0.405908      -1.10189       1.10189       336.329       337.431    
   4  0.419797     -0.867984      -2.35624       2.35624       350.361       352.717    
   5  0.662493     -0.411746      -1.11773       1.11773       356.596       357.714    
   6  0.261021      -1.34315      -3.64615       3.64615       356.376       360.023    
   7  0.451731     -0.794667      -2.15722       2.15722       354.403       356.561    
   8  0.858047     -0.153096     -0.415598      0.415598       352.327       352.743    
   9  0.678039     -0.388550      -1.05477       1.05477       358.619       359.674    
  10  0.257304      -1.35750      -3.68508       3.68508       357.685       361.370    
  11  0.379774     -0.968178      -2.62823       2.62823       358.878       361.506    
  12  0.200314      -1.60787      -4.36475       4.36475       360.982       365.347    
  13  0.702955E-01  -2.65505      -7.20744       7.20744       360.596       367.804    
  14  0.846007     -0.167228     -0.453960      0.453960       360.164       360.618    
  15  0.692217     -0.367856     -0.998589      0.998589       362.531       363.529    
  16  0.830541     -0.185678     -0.504045      0.504045       368.084       368.588    
  17  0.162133E-02  -6.42451      -17.4401       17.4401       371.589       389.029    
  18  0.829216     -0.187275     -0.508379      0.508379       368.360       368.868    
  19  0.464918     -0.765894      -2.07911       2.07911       370.206       372.285    
  20  0.204157      -1.58887      -4.31316       4.31316       376.237       380.550    
  21  0.203429      -1.59244      -4.32286       4.32286       373.969       378.292    
  22  0.403935     -0.906500      -2.46080       2.46080       374.126       376.586    
  23  0.508037     -0.677201      -1.83834       1.83834       376.962       378.800    
  24  0.337702      -1.08559      -2.94696       2.94696       377.949       380.896    
  25  0.375672     -0.979039      -2.65772       2.65772       376.733       379.391    
  26  0.218755      -1.51980      -4.12568       4.12568       382.012       386.138    
  27  0.803422     -0.218876     -0.594164      0.594164       373.775       374.369    
  28  0.324101      -1.12670      -3.05856       3.05856       380.964       384.022    
  29  0.804001     -0.218155     -0.592206      0.592206       386.047       386.640    
  30  0.727676     -0.317899     -0.862975      0.862975       382.789       383.652    
  31  0.769479     -0.262042     -0.711344      0.711344       372.876       373.587    
loop,thermsimp(1:2)       54   1.31967       2.23828    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    235        565.76         73.84          0.97         38.84          0.54          0.06        114.26
Just calling func    0   0        114.26


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    236        352.64         73.68          0.97         38.60          0.79          0.06        114.10
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    352.64
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       54
neval is:      235
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       54      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       55
neval is:      235


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      235     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.626103     -0.468241      -1.27109       1.27109       336.329       337.600    
   2  0.909442     -0.949244E-01 -0.257683      0.257683       340.410       340.667    
   3  0.449837     -0.798870      -2.16863       2.16863       345.084       347.253    
   4  0.761598     -0.272336     -0.739288      0.739288       350.361       351.100    
   5  0.706800     -0.347007     -0.941993      0.941993       352.327       353.269    
   6  0.214343      -1.54018      -4.18099       4.18099       354.403       358.584    
   7  0.855661     -0.155881     -0.423157      0.423157       356.596       357.019    
   8  0.432924E-01  -3.13978      -8.52329       8.52329       358.619       367.142    
   9  0.902784     -0.102271     -0.277628      0.277628       356.376       356.654    
  10  0.706965     -0.346774     -0.941359      0.941359       360.164       361.105    
  11  0.826667     -0.190354     -0.516737      0.516737       357.685       358.202    
  12  0.824436     -0.193055     -0.524071      0.524071       358.878       359.402    
  13  0.442772     -0.814700      -2.21160       2.21160       362.531       364.742    
  14  0.416355     -0.876217      -2.37859       2.37859       360.982       363.361    
  15  0.268464      -1.31504      -3.56983       3.56983       360.596       364.166    
  16  0.779742     -0.248792     -0.675375      0.675375       368.084       368.759    
  17  0.406799E-01  -3.20202      -8.69227       8.69227       368.360       377.052    
  18  0.975397     -0.249106E-01 -0.676228E-01  0.676228E-01   370.206       370.273    
  19  0.425150E-01  -3.15790      -8.57249       8.57249       372.876       381.448    
  20  0.302481      -1.19574      -3.24597       3.24597       373.775       377.021    
  21  0.732033     -0.311930     -0.846771      0.846771       374.126       374.972    
  22  0.774561     -0.255459     -0.693474      0.693474       373.969       374.663    
  23  0.899897     -0.105475     -0.286324      0.286324       376.962       377.248    
  24  0.549624     -0.598520      -1.62475       1.62475       376.733       378.358    
  25  0.143543      -1.94112      -5.26940       5.26940       376.237       381.506    
  26  0.229055      -1.47379      -4.00079       4.00079       377.949       381.950    
  27  0.334206      -1.09600      -2.97521       2.97521       382.789       385.764    
  28  0.301620      -1.19859      -3.25371       3.25371       380.964       384.217    
  29  0.856030     -0.155449     -0.421986      0.421986       382.012       382.434    
  30  0.978878     -0.213482E-01 -0.579521E-01  0.579521E-01   386.047       386.105    
  31  0.890790E-01  -2.41823      -6.56458       6.56458       352.637       359.202    
loop,thermsimp(1:2)       55   1.27109      0.257683    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    237        337.67         73.82          0.97         38.73          0.66          0.05        114.23
Just calling func    0   0        114.24


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    238        334.03         74.28          1.02         38.63          0.51          0.05        114.50
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    334.03
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       55
neval is:      237
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       55      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       56
neval is:      237


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      237     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.245842      -1.40307      -3.80879       3.80879       336.329       340.137    
   2  0.963480     -0.372033E-01 -0.100993      0.100993       340.410       340.511    
   3  0.633143     -0.457059      -1.24074       1.24074       345.084       346.325    
   4  0.939850E-02  -4.66721      -12.6697       12.6697       350.361       363.031    
   5  0.796978     -0.226928     -0.616023      0.616023       352.327       352.943    
   6  0.229125      -1.47349      -3.99996       3.99996       356.376       360.376    
   7  0.926958     -0.758467E-01 -0.205895      0.205895       356.596       356.802    
   8  0.687512     -0.374676      -1.01710       1.01710       357.685       358.702    
   9  0.695030     -0.363800     -0.987578      0.987578       354.403       355.391    
  10  0.900736     -0.104543     -0.283793      0.283793       352.637       352.921    
  11  0.867179     -0.142510     -0.386860      0.386860       358.878       359.265    
  12  0.879271     -0.128662     -0.349268      0.349268       360.164       360.513    
  13  0.197557      -1.62173      -4.40237       4.40237       360.982       365.385    
  14  0.790701     -0.234835     -0.637487      0.637487       360.596       361.234    
  15  0.807456     -0.213867     -0.580566      0.580566       362.531       363.111    
  16  0.688117     -0.373796      -1.01471       1.01471       358.619       359.634    
  17  0.227000      -1.48280      -4.02525       4.02525       368.084       372.109    
  18  0.374715     -0.981589      -2.66464       2.66464       370.206       372.870    
  19  0.176077      -1.73683      -4.71484       4.71484       373.969       378.684    
  20  0.446126E-01  -3.10974      -8.44175       8.44175       374.126       382.567    
  21  0.997763E-01  -2.30482      -6.25672       6.25672       373.775       380.032    
  22  0.142978E-01  -4.24765      -11.5307       11.5307       368.360       379.891    
  23  0.652216     -0.427379      -1.16017       1.16017       376.962       378.122    
  24  0.909797     -0.945339E-01 -0.256623      0.256623       376.733       376.989    
  25  0.145015      -1.93092      -5.24171       5.24171       372.876       378.117    
  26  0.189723      -1.66219      -4.51222       4.51222       376.237       380.749    
  27  0.260997      -1.34324      -3.64640       3.64640       377.949       381.595    
  28  0.167755      -1.78525      -4.84627       4.84627       382.012       386.858    
  29  0.148939      -1.90422      -5.16923       5.16923       380.964       386.133    
  30  0.209474      -1.56315      -4.24337       4.24337       382.789       387.032    
  31  0.594522     -0.519998      -1.41160       1.41160       334.032       335.444    
loop,thermsimp(1:2)       56   3.80879      0.100993    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    239        340.37         74.30          1.02         38.81          0.25          0.05        114.43
Just calling func    0   0        114.44


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    340.37
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       56
neval is:      238
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       56      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       57
neval is:      238


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      238     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.303901      -1.19105      -3.23325       3.23325       334.032       337.265    
   2  0.729962     -0.314762     -0.854459      0.854459       336.329       337.183    
   3  0.788140     -0.238080     -0.646296      0.646296       340.410       341.056    
   4  0.718031     -0.331242     -0.899197      0.899197       345.084       345.984    
   5  0.603575     -0.504885      -1.37057       1.37057       352.637       354.008    
   6  0.287757      -1.24564      -3.38144       3.38144       352.327       355.709    
   7  0.690986     -0.369635      -1.00342       1.00342       354.403       355.407    
   8  0.976315     -0.239695E-01 -0.650680E-01  0.650680E-01   356.596       356.661    
   9  0.983892     -0.162393E-01 -0.440835E-01  0.440835E-01   357.685       357.729    
  10  0.858769     -0.152255     -0.413314      0.413314       358.878       359.291    
  11  0.968889     -0.316048E-01 -0.857949E-01  0.857949E-01   358.619       358.705    
  12  0.364921      -1.00807      -2.73654       2.73654       356.376       359.113    
  13  0.540930     -0.614466      -1.66804       1.66804       360.164       361.832    
  14  0.812278E-01  -2.51050      -6.81504       6.81504       360.596       367.411    
  15  0.919841     -0.835539E-01 -0.226817      0.226817       350.361       350.588    
  16  0.275462      -1.28930      -3.49997       3.49997       362.531       366.031    
  17  0.704362     -0.350463     -0.951374      0.951374       360.982       361.934    
  18  0.896809     -0.108913     -0.295657      0.295657       368.084       368.380    
  19  0.166873      -1.79052      -4.86059       4.86059       370.206       375.066    
  20  0.927791E-02  -4.68012      -12.7047       12.7047       376.733       389.438    
  21  0.906733     -0.979074E-01 -0.265781      0.265781       372.876       373.141    
  22  0.575421     -0.552654      -1.50024       1.50024       376.962       378.462    
  23  0.975069     -0.252469E-01 -0.685358E-01  0.685358E-01   373.969       374.038    
  24  0.610094     -0.494143      -1.34141       1.34141       368.360       369.701    
  25  0.823028     -0.194765     -0.528711      0.528711       373.775       374.304    
  26  0.709022     -0.343869     -0.933472      0.933472       376.237       377.170    
  27  0.956893     -0.440633E-01 -0.119615      0.119615       377.949       378.068    
  28  0.897850E-01  -2.41034      -6.54314       6.54314       374.126       380.669    
  29  0.836996     -0.177936     -0.483029      0.483029       380.964       381.447    
  30  0.688664     -0.373001      -1.01256       1.01256       382.012       383.025    
  31  0.587454     -0.531957      -1.44406       1.44406       340.367       341.811    
loop,thermsimp(1:2)       57   3.23325      0.854459    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    240        351.81         74.50          1.03         38.55          0.34          0.06        114.48
Just calling func    0   0        114.49


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    351.81
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       57
neval is:      239
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       57      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       58
neval is:      239


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      239     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.530208     -0.634486      -1.72239       1.72239       336.329       338.051    
   2  0.175946E-01  -4.04016      -10.9675       10.9675       334.032       344.999    
   3  0.419998     -0.867504      -2.35494       2.35494       340.410       342.764    
   4  0.448197E-01  -3.10511      -8.42918       8.42918       340.367       348.796    
   5  0.501784     -0.689586      -1.87196       1.87196       345.084       346.956    
   6  0.858173     -0.152949     -0.415199      0.415199       350.361       350.776    
   7  0.101932      -2.28345      -6.19870       6.19870       352.637       358.836    
   8  0.453268     -0.791273      -2.14800       2.14800       354.403       356.551    
   9  0.128092      -2.05501      -5.57856       5.57856       352.327       357.906    
  10  0.779644     -0.248918     -0.675716      0.675716       356.596       357.272    
  11  0.769943E-01  -2.56402      -6.96034       6.96034       357.685       364.645    
  12  0.140214      -1.96458      -5.33309       5.33309       358.619       363.952    
  13  0.571588     -0.559337      -1.51839       1.51839       356.376       357.895    
  14  0.455096     -0.787247      -2.13707       2.13707       358.878       361.015    
  15  0.594240     -0.520471      -1.41288       1.41288       360.164       361.577    
  16  0.833288     -0.182376     -0.495081      0.495081       360.982       361.478    
  17  0.807090E-01  -2.51691      -6.83243       6.83243       362.531       369.363    
  18  0.430313     -0.843242      -2.28908       2.28908       360.596       362.885    
  19  0.990463     -0.958277E-02 -0.260135E-01  0.260135E-01   368.084       368.110    
  20  0.907906     -0.966144E-01 -0.262271      0.262271       368.360       368.622    
  21  0.607469     -0.498455      -1.35311       1.35311       372.876       374.229    
  22  0.927102     -0.756916E-01 -0.205474      0.205474       373.969       374.175    
  23  0.379122     -0.969896      -2.63290       2.63290       373.775       376.408    
  24  0.183121E-01  -4.00019      -10.8590       10.8590       370.206       381.065    
  25  0.561966     -0.576313      -1.56447       1.56447       376.237       377.801    
  26  0.638772     -0.448208      -1.21671       1.21671       377.949       379.165    
  27  0.234202      -1.45157      -3.94046       3.94046       376.962       380.902    
  28  0.257221      -1.35782      -3.68596       3.68596       374.126       377.812    
  29  0.688379     -0.373416      -1.01368       1.01368       380.964       381.977    
  30  0.360237E-01  -3.32358      -9.02224       9.02224       382.012       391.034    
  31  0.849177     -0.163487     -0.443805      0.443805       351.812       352.256    
loop,thermsimp(1:2)       58   1.72239       10.9675    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    241        357.28         74.08          0.99         38.80          0.51          0.05        114.44
Just calling func    0   0        114.44


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  240    357.28        1.943     -1.001      5.783     -102.2      1.188    
                     -0.1682      3.701     -100.1      4.088      1.629    
                      0.7702     -1.083      1.340      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1351E+05 0.1361E+05 -3830.    -0.4721E+05
                      -2.000     -5.739     -6.592     -7.111      3.545    
                      -13.64     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                      -1.790     -2.018      5.011      1.984      0.000    
                       0.000      9.205      9.124     0.1632E+05  1.000    
                     -0.5787    -0.7479      9.398      8.548     -120.2    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -8067.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -2857.      1.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    357.28
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       58
neval is:      240
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       58      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       59
neval is:      240


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      240     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.946919     -0.545412E-01 -0.148058      0.148058       336.329       336.477    
   2  0.224221      -1.49512      -4.05868       4.05868       340.410       344.468    
   3  0.699642     -0.357186     -0.969623      0.969623       334.032       335.002    
   4  0.490916     -0.711482      -1.93140       1.93140       345.084       347.016    
   5  0.204251      -1.58840      -4.31191       4.31191       340.367       344.679    
   6  0.356522      -1.03136      -2.79975       2.79975       350.361       353.161    
   7  0.745938     -0.293113     -0.795689      0.795689       351.812       352.608    
   8  0.451533     -0.795107      -2.15841       2.15841       354.403       356.562    
   9  0.101038      -2.29226      -6.22261       6.22261       356.596       362.818    
  10  0.826978     -0.189977     -0.515715      0.515715       356.376       356.892    
  11  0.212337      -1.54958      -4.20652       4.20652       352.327       356.534    
  12  0.490540     -0.712248      -1.93348       1.93348       352.637       354.570    
  13  0.672078     -0.397381      -1.07874       1.07874       358.878       359.957    
  14  0.690580     -0.370223      -1.00501       1.00501       360.982       361.987    
  15  0.513190     -0.667108      -1.81094       1.81094       360.164       361.975    
  16  0.268393      -1.31530      -3.57055       3.57055       360.596       364.167    
  17  0.896898     -0.108813     -0.295386      0.295386       358.619       358.914    
  18  0.911953     -0.921674E-01 -0.250199      0.250199       357.685       357.935    
  19  0.355703      -1.03366      -2.80599       2.80599       368.084       370.890    
  20  0.293818      -1.22479      -3.32485       3.32485       368.360       371.685    
  21  0.713392     -0.337724     -0.916791      0.916791       362.531       363.447    
  22  0.660627     -0.414565      -1.12539       1.12539       373.969       375.095    
  23  0.795097     -0.229291     -0.622437      0.622437       372.876       373.498    
  24  0.919484     -0.839428E-01 -0.227873      0.227873       373.775       374.003    
  25  0.976382     -0.239014E-01 -0.648831E-01  0.648831E-01   376.237       376.302    
  26  0.922195     -0.809991E-01 -0.219882      0.219882       374.126       374.346    
  27  0.436062     -0.829970      -2.25305       2.25305       377.949       380.202    
  28  0.271848      -1.30251      -3.53582       3.53582       376.962       380.498    
  29  0.389360     -0.943252      -2.56057       2.56057       370.206       372.766    
  30  0.314178E-01  -3.46038      -9.39361       9.39361       380.964       390.357    
  31  0.545460     -0.606126      -1.64540       1.64540       357.280       358.926    
loop,thermsimp(1:2)       59  0.148058       4.05868    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    242        365.74         73.90          0.98         38.82          0.60          0.05        114.36
Just calling func    0   0        114.36


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    365.74
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       59
neval is:      241
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       59      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       60
neval is:      241


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      241
neval,tstepnext:      241     241

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.347122      -1.05808      -2.87228       2.87228       334.032       336.904    
   2  0.605757     -0.501276      -1.36077       1.36077       336.329       337.689    
   3  0.690633     -0.370146      -1.00480       1.00480       340.410       341.414    
   4  0.400665     -0.914628      -2.48287       2.48287       340.367       342.850    
   5  0.862165     -0.148309     -0.402602      0.402602       345.084       345.487    
   6  0.874011     -0.134662     -0.365556      0.365556       351.812       352.178    
   7  0.389525     -0.942826      -2.55941       2.55941       350.361       352.921    
   8  0.102225E-01  -4.58317      -12.4415       12.4415       352.637       365.078    
   9  0.102697      -2.27597      -6.17839       6.17839       352.327       358.506    
  10  0.818271     -0.200561     -0.544447      0.544447       354.403       354.948    
  11  0.888768     -0.117920     -0.320107      0.320107       356.376       356.697    
  12  0.539210     -0.617651      -1.67669       1.67669       357.685       359.362    
  13  0.317914      -1.14597      -3.11088       3.11088       358.619       361.730    
  14  0.437422     -0.826857      -2.24460       2.24460       357.280       359.525    
  15  0.925263     -0.776773E-01 -0.210864      0.210864       358.878       359.089    
  16  0.422436     -0.861717      -2.33923       2.33923       360.164       362.503    
  17  0.965248     -0.353697E-01 -0.960152E-01  0.960152E-01   360.982       361.078    
  18  0.771278     -0.259706     -0.705002      0.705002       356.596       357.301    
  19  0.902488     -0.102600     -0.278520      0.278520       362.531       362.809    
  20  0.512816     -0.667839      -1.81293       1.81293       360.596       362.409    
  21  0.915966     -0.877758E-01 -0.238278      0.238278       368.084       368.322    
  22  0.612605     -0.490035      -1.33026       1.33026       368.360       369.690    
  23  0.323528      -1.12847      -3.06336       3.06336       370.206       373.269    
  24  0.206646      -1.57675      -4.28027       4.28027       372.876       377.156    
  25  0.481057     -0.731769      -1.98647       1.98647       373.775       375.761    
  26  0.287887E-01  -3.54777      -9.63085       9.63085       374.126       383.757    
  27  0.996968     -0.303648E-02 -0.824288E-02  0.824288E-02   373.969       373.978    
  28  0.132770      -2.01914      -5.48119       5.48119       376.237       381.718    
  29  0.716038     -0.334023     -0.906743      0.906743       377.949       378.855    
  30  0.229552      -1.47162      -3.99490       3.99490       376.962       380.957    
  31  0.236358      -1.44241      -3.91558       3.91558       365.744       369.659    
loop,thermsimp(1:2)       60   2.87228       1.36077    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    243        334.51         73.97          0.97         38.80          0.68          0.06        114.48
Just calling func    0   0        114.48


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    244        348.54         74.09          1.01         38.80          0.55          0.05        114.51
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    334.51
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.71462               241
loop is:       60
neval is:      243
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       60      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    2.71462               241
loop is:       61
neval is:      243


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 




neval>tstepnex so lower away!t
---> lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
     new SAtemp,tstepnext are :    1.35731               271

 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      243     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.663917     -0.409597     -0.555950      0.555950       334.032       334.588    
   2  0.718953     -0.329960     -0.447857      0.447857       336.329       336.776    
   3  0.454275     -0.789053      -1.07099       1.07099       340.410       341.481    
   4  0.253407E-01  -3.67534      -4.98857       4.98857       340.367       345.356    
   5  0.611947     -0.491110     -0.666588      0.666588       345.084       345.751    
   6  0.234016      -1.45237      -1.97131       1.97131       351.812       353.784    
   7  0.359481E-01  -3.32568      -4.51397       4.51397       350.361       354.875    
   8  0.222118E-01  -3.80713      -5.16745       5.16745       354.403       359.571    
   9  0.905838E-01  -2.40148      -3.25955       3.25955       356.376       359.636    
  10  0.791683     -0.233594     -0.317059      0.317059       356.596       356.913    
  11  0.557734     -0.583873     -0.792496      0.792496       352.327       353.120    
  12  0.936048E-01  -2.36867      -3.21502       3.21502       358.878       362.093    
  13  0.431059     -0.841510      -1.14219       1.14219       357.685       358.827    
  14  0.225758      -1.48829      -2.02007       2.02007       357.280       359.300    
  15  0.275181E-01  -3.59291      -4.87669       4.87669       360.982       365.859    
  16  0.802517     -0.220002     -0.298611      0.298611       358.619       358.918    
  17  0.423872     -0.858323      -1.16501       1.16501       360.596       361.761    
  18  0.300971      -1.20074      -1.62978       1.62978       360.164       361.794    
  19  0.479556     -0.734895     -0.997480      0.997480       362.531       363.528    
  20  0.621838     -0.475076     -0.644825      0.644825       352.637       353.282    
  21  0.397654     -0.922172      -1.25167       1.25167       368.084       369.336    
  22  0.664976     -0.408004     -0.553788      0.553788       365.744       366.298    
  23  0.288358      -1.24355      -1.68788       1.68788       368.360       370.048    
  24  0.442017     -0.816406      -1.10812       1.10812       370.206       371.314    
  25  0.150763E-01  -4.19463      -5.69341       5.69341       373.969       379.663    
  26  0.600886     -0.509350     -0.691346      0.691346       373.775       374.466    
  27  0.162927      -1.81446      -2.46278       2.46278       372.876       375.338    
  28  0.932743     -0.696251E-01 -0.945028E-01  0.945028E-01   377.949       378.043    
  29  0.997186     -0.281799E-02 -0.382489E-02  0.382489E-02   376.962       376.966    
  30  0.418339     -0.871463      -1.18284       1.18284       376.237       377.420    
  31  0.694800     -0.364132     -0.494239      0.494239       334.508       335.002    
loop,thermsimp(1:2)       61  0.555950      0.447857    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    245        358.50         73.67          1.00         38.75          0.77          0.06        114.25
Just calling func    0   0        114.25


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    358.50
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       61
neval is:      244
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       61      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       62
neval is:      244


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      244     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.985932     -0.141675E-01 -0.192296E-01  0.192296E-01   334.032       334.051    
   2  0.420912     -0.865330      -1.17452       1.17452       334.508       335.683    
   3  0.617210     -0.482545     -0.654963      0.654963       336.329       336.984    
   4  0.787846     -0.238453     -0.323655      0.323655       340.410       340.733    
   5  0.608770     -0.496315     -0.673653      0.673653       340.367       341.041    
   6  0.925975     -0.769083E-01 -0.104388      0.104388       345.084       345.189    
   7  0.545822     -0.605462     -0.821798      0.821798       352.327       353.149    
   8  0.240142      -1.42653      -1.93624       1.93624       352.637       354.573    
   9  0.800257     -0.222822     -0.302438      0.302438       351.812       352.115    
  10  0.250149      -1.38570      -1.88082       1.88082       350.361       352.242    
  11  0.814044     -0.205741     -0.279254      0.279254       356.596       356.875    
  12  0.897552     -0.108084     -0.146703      0.146703       357.685       357.832    
  13  0.807530     -0.213775     -0.290159      0.290159       358.619       358.909    
  14  0.369031     -0.996874      -1.35307       1.35307       357.280       358.633    
  15  0.892620     -0.113594     -0.154182      0.154182       354.403       354.558    
  16  0.992736     -0.729054E-02 -0.989552E-02  0.989552E-02   356.376       356.386    
  17  0.264259      -1.33083      -1.80634       1.80634       360.596       362.402    
  18  0.164586      -1.80432      -2.44903       2.44903       360.164       362.613    
  19  0.594739     -0.519633     -0.705302      0.705302       358.878       359.583    
  20  0.766319     -0.266156     -0.361256      0.361256       362.531       362.892    
  21  0.392663     -0.934804      -1.26882       1.26882       360.982       362.251    
  22  0.900399     -0.104917     -0.142405      0.142405       365.744       365.886    
  23  0.853164E-01  -2.46139      -3.34086       3.34086       368.084       371.425    
  24  0.753181     -0.283450     -0.384729      0.384729       368.360       368.745    
  25  0.801958     -0.220699     -0.299556      0.299556       370.206       370.505    
  26  0.840206     -0.174108     -0.236319      0.236319       373.775       374.011    
  27  0.899787     -0.105597     -0.143328      0.143328       372.876       373.019    
  28  0.555629     -0.587654     -0.797628      0.797628       376.962       377.759    
  29  0.117481E-01  -4.44406      -6.03196       6.03196       376.237       382.269    
  30  0.228476      -1.47632      -2.00382       2.00382       377.949       379.953    
  31  0.121877      -2.10474      -2.85679       2.85679       358.500       361.357    
loop,thermsimp(1:2)       62  0.192296E-01   1.17452    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    246        346.39         75.57          1.12         37.98          0.00          0.05        114.72
Just calling func    0   0        114.72


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    346.39
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       62
neval is:      245
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       62      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       63
neval is:      245


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      245     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.984982     -0.151315E-01 -0.205381E-01  0.205381E-01   334.032       334.052    
   2  0.760415     -0.273890     -0.371754      0.371754       334.508       334.880    
   3  0.328612      -1.11288      -1.51052       1.51052       336.329       337.839    
   4  0.164880      -1.80254      -2.44660       2.44660       340.410       342.856    
   5  0.706606     -0.347282     -0.471369      0.471369       340.367       340.839    
   6  0.832070     -0.183839     -0.249527      0.249527       345.084       345.334    
   7  0.231505      -1.46315      -1.98595       1.98595       351.812       353.798    
   8  0.802671E-01  -2.52240      -3.42367       3.42367       350.361       353.785    
   9  0.116349      -2.15116      -2.91979       2.91979       352.327       355.247    
  10  0.874222     -0.134421     -0.182451      0.182451       354.403       354.586    
  11  0.729333     -0.315625     -0.428401      0.428401       352.637       353.065    
  12  0.301675      -1.19841      -1.62661       1.62661       356.376       358.003    
  13  0.496896     -0.699375     -0.949267      0.949267       356.596       357.545    
  14  0.692174     -0.367918     -0.499379      0.499379       357.685       358.184    
  15  0.717718     -0.331678     -0.450190      0.450190       357.280       357.730    
  16  0.867334E-01  -2.44492      -3.31851       3.31851       358.619       361.937    
  17  0.762934     -0.270584     -0.367265      0.367265       358.878       359.245    
  18  0.966741     -0.338246E-01 -0.459104E-01  0.459104E-01   358.500       358.546    
  19  0.375386     -0.979801      -1.32989       1.32989       360.982       362.312    
  20  0.878716     -0.129293     -0.175491      0.175491       360.596       360.772    
  21  0.238969      -1.43142      -1.94288       1.94288       360.164       362.107    
  22  0.939578     -0.623249E-01 -0.845941E-01  0.845941E-01   362.531       362.615    
  23  0.694828     -0.364091     -0.494183      0.494183       365.744       366.238    
  24  0.869149     -0.140241     -0.190350      0.190350       368.360       368.550    
  25  0.310010      -1.17115      -1.58961       1.58961       370.206       371.795    
  26  0.831753     -0.184219     -0.250043      0.250043       368.084       368.334    
  27  0.621050     -0.476344     -0.646545      0.646545       372.876       373.522    
  28  0.902274     -0.102837     -0.139582      0.139582       373.775       373.915    
  29  0.341345      -1.07486      -1.45892       1.45892       376.962       378.421    
  30  0.718647     -0.330385     -0.448434      0.448434       377.949       378.397    
  31  0.489532     -0.714305     -0.969532      0.969532       346.390       347.359    
loop,thermsimp(1:2)       63  0.205381E-01  0.371754    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    247        372.29         73.88          0.98         38.78          1.07          0.05        114.76
Just calling func    0   0        114.76


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    372.29
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       63
neval is:      246
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       63      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       64
neval is:      246


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      246     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.964311     -0.363416E-01 -0.493268E-01  0.493268E-01   334.032       334.081    
   2  0.186231      -1.68077      -2.28132       2.28132       334.508       336.789    
   3  0.127308      -2.06115      -2.79761       2.79761       336.329       339.126    
   4  0.305661      -1.18528      -1.60879       1.60879       340.367       341.976    
   5  0.685804     -0.377164     -0.511928      0.511928       340.410       340.921    
   6  0.713250     -0.337923     -0.458666      0.458666       345.084       345.543    
   7  0.562604     -0.575180     -0.780697      0.780697       346.390       347.170    
   8  0.410540     -0.890283      -1.20839       1.20839       352.637       353.845    
   9  0.667633     -0.404017     -0.548376      0.548376       350.361       350.909    
  10  0.111237      -2.19609      -2.98077       2.98077       351.812       354.793    
  11  0.987129     -0.129550E-01 -0.175839E-01  0.175839E-01   354.403       354.421    
  12  0.525481     -0.643442     -0.873349      0.873349       352.327       353.201    
  13  0.740553     -0.300358     -0.407678      0.407678       356.596       357.004    
  14  0.456748E-01  -3.08621      -4.18894       4.18894       357.280       361.469    
  15  0.831796     -0.184168     -0.249973      0.249973       356.376       356.626    
  16  0.798422     -0.225118     -0.305555      0.305555       357.685       357.990    
  17  0.985535     -0.145708E-01 -0.197770E-01  0.197770E-01   358.500       358.520    
  18  0.323340      -1.12905      -1.53247       1.53247       358.878       360.410    
  19  0.745026     -0.294336     -0.399505      0.399505       360.596       360.996    
  20  0.711871     -0.339858     -0.461293      0.461293       358.619       359.080    
  21  0.232875      -1.45725      -1.97794       1.97794       360.164       362.142    
  22  0.118192      -2.13545      -2.89846       2.89846       360.982       363.881    
  23  0.310641      -1.16912      -1.58685       1.58685       362.531       364.118    
  24  0.220899      -1.51005      -2.04961       2.04961       365.744       367.793    
  25  0.487797     -0.717856     -0.974352      0.974352       368.084       369.058    
  26  0.278848      -1.27709      -1.73340       1.73340       368.360       370.093    
  27  0.159355      -1.83662      -2.49286       2.49286       370.206       372.698    
  28  0.473156     -0.748329      -1.01571       1.01571       372.876       373.891    
  29  0.358980      -1.02449      -1.39055       1.39055       373.775       375.165    
  30  0.873266     -0.135515     -0.183935      0.183935       377.949       378.133    
  31  0.168201      -1.78260      -2.41953       2.41953       372.286       374.706    
loop,thermsimp(1:2)       64  0.493268E-01   2.28132    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    248        327.64         73.86          0.96         38.64          1.10          0.06        114.62
Just calling func    0   0        114.62


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    249        405.27         74.07          1.00         38.98          0.68          0.05        114.77
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    327.64
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       64
neval is:      248
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       64      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       65
neval is:      248


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      248     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.424550     -0.856726      -1.16284       1.16284       334.032       335.195    
   2  0.350039      -1.04971      -1.42478       1.42478       334.508       335.933    
   3  0.872911     -0.135921     -0.184487      0.184487       336.329       336.513    
   4  0.829005     -0.187529     -0.254534      0.254534       340.410       340.664    
   5  0.201827      -1.60035      -2.17216       2.17216       340.367       342.539    
   6  0.735791     -0.306809     -0.416435      0.416435       345.084       345.501    
   7  0.985788     -0.143135E-01 -0.194278E-01  0.194278E-01   346.390       346.409    
   8  0.962727     -0.379858E-01 -0.515585E-01  0.515585E-01   350.361       350.413    
   9  0.796954     -0.226958     -0.308053      0.308053       352.327       352.635    
  10  0.563149     -0.574211     -0.779382      0.779382       352.637       353.416    
  11  0.776846     -0.252513     -0.342739      0.342739       354.403       354.746    
  12  0.921010     -0.822839E-01 -0.111685      0.111685       351.812       351.924    
  13  0.884938     -0.122238     -0.165915      0.165915       356.376       356.542    
  14  0.850974     -0.161373     -0.219033      0.219033       356.596       356.815    
  15  0.391065     -0.938882      -1.27435       1.27435       357.685       358.959    
  16  0.150921      -1.89100      -2.56667       2.56667       358.500       361.067    
  17  0.295162      -1.22023      -1.65623       1.65623       358.619       360.275    
  18  0.662567     -0.411634     -0.558715      0.558715       358.878       359.437    
  19  0.893994     -0.112056     -0.152094      0.152094       360.596       360.748    
  20  0.103282      -2.27029      -3.08149       3.08149       357.280       360.362    
  21  0.416341     -0.876251      -1.18934       1.18934       360.164       361.353    
  22  0.986101E-01  -2.31658      -3.14432       3.14432       360.982       364.127    
  23  0.617817E-01  -2.78415      -3.77895       3.77895       362.531       366.310    
  24  0.371945     -0.989010      -1.34239       1.34239       365.744       367.086    
  25  0.884755     -0.122444     -0.166195      0.166195       368.084       368.250    
  26  0.584237     -0.537449     -0.729485      0.729485       368.360       369.089    
  27  0.239981      -1.42719      -1.93714       1.93714       370.206       372.143    
  28  0.106477      -2.23982      -3.04013       3.04013       372.876       375.916    
  29  0.142954      -1.94523      -2.64028       2.64028       372.286       374.927    
  30  0.802284     -0.220292     -0.299005      0.299005       373.775       374.074    
  31  0.373571     -0.984648      -1.33647       1.33647       327.638       328.975    
loop,thermsimp(1:2)       65   1.16284       1.42478    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    250        388.03         73.94          0.96         38.69          0.89          0.05        114.53
Just calling func    0   0        114.53


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    251        340.72         74.14          0.99         38.75          0.27          0.05        114.20
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    340.72
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       65
neval is:      250
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       65      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       66
neval is:      250


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      250     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.474155     -0.746220      -1.01285       1.01285       327.638       328.651    
   2  0.162949E-01  -4.11691      -5.58791       5.58791       334.032       339.620    
   3  0.560104     -0.579632     -0.786740      0.786740       334.508       335.295    
   4  0.583629     -0.538490     -0.730897      0.730897       336.329       337.060    
   5  0.794243     -0.230366     -0.312678      0.312678       340.410       340.722    
   6  0.183626E-01  -3.99744      -5.42576       5.42576       340.367       345.793    
   7  0.642495     -0.442397     -0.600469      0.600469       345.084       345.685    
   8  0.611061E-02  -5.09773      -6.91919       6.91919       346.390       353.309    
   9  0.974115E-01  -2.32881      -3.16092       3.16092       350.361       353.522    
  10  0.817249E-01  -2.50440      -3.39924       3.39924       351.812       355.211    
  11  0.644422     -0.439401     -0.596402      0.596402       352.327       352.924    
  12  0.378181     -0.972383      -1.31982       1.31982       352.637       353.957    
  13  0.105422      -2.24978      -3.05365       3.05365       354.403       357.457    
  14  0.713647     -0.337367     -0.457911      0.457911       356.376       356.834    
  15  0.602100     -0.507333     -0.688607      0.688607       356.596       357.284    
  16  0.746624     -0.292194     -0.396598      0.396598       357.685       358.082    
  17  0.687673     -0.374442     -0.508234      0.508234       358.878       359.386    
  18  0.356323      -1.03192      -1.40063       1.40063       358.619       360.020    
  19  0.631203     -0.460128     -0.624536      0.624536       357.280       357.905    
  20  0.348432      -1.05431      -1.43103       1.43103       360.596       362.027    
  21  0.200848      -1.60521      -2.17876       2.17876       358.500       360.679    
  22  0.863860     -0.146345     -0.198635      0.198635       360.164       360.362    
  23  0.278415      -1.27864      -1.73551       1.73551       360.982       362.718    
  24  0.871038     -0.138069     -0.187403      0.187403       362.531       362.718    
  25  0.581010     -0.542987     -0.737001      0.737001       365.744       366.481    
  26  0.960519     -0.402815E-01 -0.546744E-01  0.546744E-01   368.084       368.139    
  27  0.104828      -2.25543      -3.06132       3.06132       368.360       371.421    
  28  0.907238     -0.973501E-01 -0.132134      0.132134       370.206       370.338    
  29  0.685005     -0.378330     -0.513510      0.513510       373.775       374.288    
  30  0.239566E-01  -3.73151      -5.06481       5.06481       372.286       377.351    
  31  0.643900     -0.440211     -0.597502      0.597502       340.722       341.320    
loop,thermsimp(1:2)       66   1.01285       5.58791    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    252        367.83         74.07          1.05         38.67          0.02          0.05        113.86
Just calling func    0   0        113.86


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    367.83
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       66
neval is:      251
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       66      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       67
neval is:      251


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      251     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.711215     -0.340780     -0.462544      0.462544       327.638       328.101    
   2  0.492413     -0.708438     -0.961569      0.961569       334.508       335.470    
   3  0.156563      -1.85430      -2.51685       2.51685       336.329       338.845    
   4  0.185270      -1.68594      -2.28834       2.28834       334.032       336.320    
   5  0.685983     -0.376903     -0.511573      0.511573       340.410       340.921    
   6  0.518581     -0.656659     -0.891289      0.891289       340.722       341.614    
   7  0.430667     -0.842421      -1.14343       1.14343       345.084       346.228    
   8  0.748228     -0.290047     -0.393684      0.393684       340.367       340.761    
   9  0.348167      -1.05507      -1.43206       1.43206       352.327       353.759    
  10  0.281980E-01  -3.56850      -4.84356       4.84356       346.390       351.233    
  11  0.670749     -0.399360     -0.542055      0.542055       350.361       350.903    
  12  0.225031      -1.49152      -2.02445       2.02445       352.637       354.661    
  13  0.258016      -1.35474      -1.83879       1.83879       351.812       353.651    
  14  0.122388      -2.10056      -2.85110       2.85110       356.376       359.228    
  15  0.556210     -0.586609     -0.796210      0.796210       356.596       357.392    
  16  0.938933     -0.630108E-01 -0.855252E-01  0.855252E-01   354.403       354.489    
  17  0.440352     -0.820180      -1.11324       1.11324       357.280       358.393    
  18  0.779048     -0.249683     -0.338897      0.338897       357.685       358.024    
  19  0.929725     -0.728667E-01 -0.989025E-01  0.989025E-01   358.878       358.977    
  20  0.330740      -1.10642      -1.50176       1.50176       358.619       360.121    
  21  0.214890      -1.53763      -2.08704       2.08704       360.164       362.251    
  22  0.363221      -1.01274      -1.37461       1.37461       358.500       359.874    
  23  0.681309     -0.383740     -0.520854      0.520854       360.596       361.117    
  24  0.107313      -2.23200      -3.02952       3.02952       360.982       364.012    
  25  0.622524     -0.473973     -0.643327      0.643327       362.531       363.174    
  26  0.532378     -0.630402     -0.855650      0.855650       365.744       366.599    
  27  0.298562      -1.20878      -1.64069       1.64069       368.084       369.725    
  28  0.432099     -0.839100      -1.13892       1.13892       370.206       371.344    
  29  0.243978      -1.41068      -1.91473       1.91473       368.360       370.275    
  30  0.581243     -0.542587     -0.736458      0.736458       373.775       374.511    
  31  0.897127E-01  -2.41114      -3.27266       3.27266       367.833       371.105    
loop,thermsimp(1:2)       67  0.462544      0.961569    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    253        373.16         73.68          0.95         38.55          0.88          0.05        114.11
Just calling func    0   0        114.11


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    254        333.15         73.80          0.95         38.57          0.85          0.05        114.21
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    333.15
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       67
neval is:      253
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       67      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       68
neval is:      253


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      253     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.595062     -0.519089     -0.704564      0.704564       327.638       328.343    
   2  0.204294      -1.58819      -2.15567       2.15567       334.508       336.664    
   3  0.902141     -0.102985     -0.139782      0.139782       334.032       334.172    
   4  0.317306      -1.14789      -1.55804       1.55804       336.329       337.887    
   5  0.914914E-01  -2.39151      -3.24602       3.24602       340.367       343.613    
   6  0.362439      -1.01490      -1.37753       1.37753       340.410       341.787    
   7  0.284546      -1.25686      -1.70595       1.70595       340.722       342.428    
   8  0.752727     -0.284053     -0.385548      0.385548       345.084       345.470    
   9  0.972148     -0.282475E-01 -0.383405E-01  0.383405E-01   350.361       350.399    
  10  0.312417      -1.16342      -1.57911       1.57911       346.390       347.969    
  11  0.772549E-01  -2.56064      -3.47559       3.47559       351.812       355.288    
  12  0.190763      -1.65672      -2.24869       2.24869       352.327       354.576    
  13  0.829036     -0.187492     -0.254485      0.254485       354.403       354.658    
  14  0.309766      -1.17194      -1.59068       1.59068       352.637       354.228    
  15  0.691616     -0.368724     -0.500473      0.500473       356.596       357.096    
  16  0.177510      -1.72873      -2.34642       2.34642       357.685       360.031    
  17  0.848561     -0.164214     -0.222889      0.222889       357.280       357.503    
  18  0.464945     -0.765836      -1.03948       1.03948       358.878       359.917    
  19  0.626682     -0.467316     -0.634292      0.634292       356.376       357.011    
  20  0.451266     -0.795699      -1.08001       1.08001       358.500       359.580    
  21  0.161179E-01  -4.12783      -5.60273       5.60273       358.619       364.222    
  22  0.848853     -0.163869     -0.222421      0.222421       360.596       360.819    
  23  0.565946     -0.569256     -0.772657      0.772657       360.164       360.936    
  24  0.798567     -0.224937     -0.305309      0.305309       362.531       362.836    
  25  0.282371      -1.26453      -1.71636       1.71636       360.982       362.699    
  26  0.887219     -0.119663     -0.162420      0.162420       365.744       365.906    
  27  0.311981      -1.16481      -1.58101       1.58101       368.084       369.665    
  28  0.454937     -0.787596      -1.06901       1.06901       368.360       369.429    
  29  0.200774E-01  -3.90816      -5.30458       5.30458       367.833       373.137    
  30  0.549692     -0.598397     -0.812209      0.812209       370.206       371.018    
  31  0.928164     -0.745470E-01 -0.101183      0.101183       333.149       333.250    
loop,thermsimp(1:2)       68  0.704564       2.15567    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    255        376.39         73.84          0.96         38.48          1.09          0.06        114.43
Just calling func    0   0        114.43


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    256        342.78         75.11          1.12         38.10          0.00          0.06        114.38
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    342.78
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       68
neval is:      255
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       68      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       69
neval is:      255


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      255     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.440626     -0.819560      -1.11240       1.11240       327.638       328.751    
   2  0.752309     -0.284608     -0.386300      0.386300       333.149       333.535    
   3  0.209108      -1.56490      -2.12406       2.12406       334.032       336.156    
   4  0.842922     -0.170881     -0.231939      0.231939       334.508       334.740    
   5  0.161148      -1.82543      -2.47767       2.47767       336.329       338.806    
   6  0.601748     -0.507917     -0.689401      0.689401       340.410       341.099    
   7  0.890912     -0.115510     -0.156783      0.156783       340.722       340.879    
   8  0.631939     -0.458963     -0.622955      0.622955       340.367       340.990    
   9  0.144759E-01  -4.23527      -5.74857       5.74857       345.084       350.833    
  10  0.653698     -0.425110     -0.577006      0.577006       346.390       346.967    
  11  0.401463     -0.912639      -1.23873       1.23873       350.361       351.600    
  12  0.906126     -0.985765E-01 -0.133799      0.133799       352.637       352.771    
  13  0.480601E-01  -3.03530      -4.11984       4.11984       352.327       356.447    
  14  0.264260      -1.33082      -1.80633       1.80633       354.403       356.210    
  15  0.586033     -0.534379     -0.725317      0.725317       351.812       352.538    
  16  0.323072      -1.12988      -1.53359       1.53359       356.376       357.910    
  17  0.785147     -0.241884     -0.328311      0.328311       356.596       356.924    
  18  0.139165      -1.97210      -2.67675       2.67675       357.280       359.957    
  19  0.105818E-01  -4.54862      -6.17388       6.17388       358.500       364.674    
  20  0.896943     -0.108763     -0.147625      0.147625       358.878       359.025    
  21  0.854239     -0.157544     -0.213835      0.213835       357.685       357.899    
  22  0.566003     -0.569157     -0.772521      0.772521       360.596       361.369    
  23  0.566387     -0.568477     -0.771599      0.771599       360.164       360.935    
  24  0.414905     -0.879707      -1.19403       1.19403       360.982       362.177    
  25  0.173772      -1.75001      -2.37531       2.37531       362.531       364.906    
  26  0.884308E-01  -2.42554      -3.29220       3.29220       358.619       361.911    
  27  0.417457     -0.873573      -1.18571       1.18571       365.744       366.930    
  28  0.334615      -1.09477      -1.48595       1.48595       368.360       369.846    
  29  0.706024E-01  -2.65069      -3.59781       3.59781       368.084       371.682    
  30  0.996422     -0.358418E-02 -0.486483E-02  0.486483E-02   370.206       370.210    
  31  0.894500     -0.111491     -0.151327      0.151327       342.779       342.930    
loop,thermsimp(1:2)       69   1.11240      0.386300    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    257       1648.45         74.10          1.02         38.73          0.41          0.05        114.31
Just calling func    0   0        114.31


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    258        345.82         73.76          0.99         38.54          0.79          0.05        114.13
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    345.82
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       69
neval is:      257
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       69      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       70
neval is:      257


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      257     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.988390     -0.116781E-01 -0.158508E-01  0.158508E-01   327.638       327.654    
   2  0.482301     -0.729186     -0.989731      0.989731       333.149       334.139    
   3  0.546964     -0.603372     -0.818963      0.818963       334.508       335.327    
   4  0.543918     -0.608957     -0.826543      0.826543       334.032       334.858    
   5  0.427641     -0.849472      -1.15300       1.15300       336.329       337.482    
   6  0.498345     -0.696462     -0.945314      0.945314       340.722       341.668    
   7  0.989308     -0.107494E-01 -0.145902E-01  0.145902E-01   340.367       340.382    
   8  0.658822     -0.417302     -0.566407      0.566407       340.410       340.976    
   9  0.917808     -0.857673E-01 -0.116413      0.116413       342.779       342.895    
  10  0.914490E-04  -9.29973      -12.6226       12.6226       346.390       359.012    
  11  0.989901     -0.101499E-01 -0.137765E-01  0.137765E-01   345.084       345.098    
  12  0.558183     -0.583069     -0.791405      0.791405       350.361       351.153    
  13  0.706994     -0.346733     -0.470624      0.470624       351.812       352.283    
  14  0.599152     -0.512240     -0.695268      0.695268       352.637       353.332    
  15  0.845909     -0.167343     -0.227136      0.227136       354.403       354.631    
  16  0.655384     -0.422534     -0.573509      0.573509       352.327       352.901    
  17  0.412232E-01  -3.18875      -4.32812       4.32812       356.596       360.924    
  18  0.495401     -0.702387     -0.953356      0.953356       357.685       358.638    
  19  0.378829     -0.970671      -1.31750       1.31750       356.376       357.694    
  20  0.653665E-02  -5.03033      -6.82771       6.82771       358.878       365.706    
  21  0.782670     -0.245045     -0.332601      0.332601       357.280       357.613    
  22  0.945547     -0.559921E-01 -0.759986E-01  0.759986E-01   360.164       360.240    
  23  0.969857     -0.306063E-01 -0.415423E-01  0.415423E-01   360.596       360.638    
  24  0.822249     -0.195712     -0.265641      0.265641       358.619       358.885    
  25  0.265012E-01  -3.63056      -4.92780       4.92780       360.982       365.910    
  26  0.360432E-01  -3.32304      -4.51039       4.51039       358.500       363.010    
  27  0.796418     -0.227631     -0.308965      0.308965       362.531       362.840    
  28  0.292313E-01  -3.53252      -4.79471       4.79471       365.744       370.539    
  29  0.227321      -1.48139      -2.01071       2.01071       368.360       370.371    
  30  0.812637     -0.207471     -0.281602      0.281602       370.206       370.487    
  31  0.930544     -0.719857E-01 -0.977069E-01  0.977069E-01   345.818       345.916    
loop,thermsimp(1:2)       70  0.158508E-01  0.989731    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    259        361.95         73.50          0.99         38.64          0.73          0.05        113.91
Just calling func    0   0        113.92


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    361.95
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       70
neval is:      258
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       70      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       71
neval is:      258


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      258     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.860213     -0.150575     -0.204377      0.204377       327.638       327.843    
   2  0.573661     -0.555717     -0.754279      0.754279       333.149       333.903    
   3  0.499290     -0.694569     -0.942744      0.942744       334.032       334.975    
   4  0.677563     -0.389253     -0.528337      0.528337       334.508       335.036    
   5  0.476566     -0.741149      -1.00597       1.00597       336.329       337.335    
   6  0.153036      -1.87708      -2.54778       2.54778       340.367       342.915    
   7  0.626270     -0.467973     -0.635184      0.635184       340.410       341.045    
   8  0.794744     -0.229735     -0.311822      0.311822       340.722       341.034    
   9  0.111868E-01  -4.49302      -6.09841       6.09841       342.779       348.877    
  10  0.643880     -0.440243     -0.597546      0.597546       345.084       345.682    
  11  0.634705     -0.454595     -0.617026      0.617026       345.818       346.436    
  12  0.653568     -0.425308     -0.577275      0.577275       350.361       350.938    
  13  0.888231     -0.118524     -0.160873      0.160873       351.812       351.973    
  14  0.681775E-01  -2.68564      -3.64524       3.64524       352.327       355.973    
  15  0.241248      -1.42193      -1.93000       1.93000       352.637       354.567    
  16  0.208857      -1.56610      -2.12569       2.12569       354.403       356.529    
  17  0.652439     -0.427038     -0.579622      0.579622       357.280       357.860    
  18  0.489833     -0.713691     -0.968699      0.968699       356.376       357.345    
  19  0.719225     -0.329581     -0.447342      0.447342       357.685       358.132    
  20  0.924762     -0.782189E-01 -0.106167      0.106167       358.619       358.725    
  21  0.845502     -0.167825     -0.227790      0.227790       346.390       346.617    
  22  0.665989     -0.406482     -0.551722      0.551722       360.164       360.716    
  23  0.378562     -0.971376      -1.31846       1.31846       360.596       361.915    
  24  0.396889     -0.924098      -1.25429       1.25429       356.596       357.850    
  25  0.158089      -1.84460      -2.50369       2.50369       362.531       365.034    
  26  0.590577     -0.526655     -0.714834      0.714834       358.500       359.215    
  27  0.949513     -0.518061E-01 -0.703168E-01  0.703168E-01   358.878       358.948    
  28  0.518198     -0.657398     -0.892292      0.892292       360.982       361.875    
  29  0.551080     -0.595875     -0.808786      0.808786       368.360       369.169    
  30  0.986285     -0.138097E-01 -0.187441E-01  0.187441E-01   370.206       370.224    
  31  0.920142     -0.832276E-01 -0.112966      0.112966       361.951       362.064    
loop,thermsimp(1:2)       71  0.204377      0.754279    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    260        351.14         73.81          1.00         38.69          0.62          0.05        114.17
Just calling func    0   0        114.17


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    351.14
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       71
neval is:      259
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       71      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       72
neval is:      259


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      259     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.440770     -0.819232      -1.11195       1.11195       327.638       328.750    
   2  0.202294      -1.59803      -2.16902       2.16902       333.149       335.318    
   3  0.873786     -0.134920     -0.183128      0.183128       334.032       334.215    
   4  0.262141      -1.33887      -1.81727       1.81727       334.508       336.325    
   5  0.342005      -1.07293      -1.45630       1.45630       336.329       337.785    
   6  0.421217     -0.864607      -1.17354       1.17354       340.722       341.896    
   7  0.618489     -0.480477     -0.652155      0.652155       340.410       341.062    
   8  0.412552     -0.885393      -1.20175       1.20175       340.367       341.569    
   9  0.951192     -0.500396E-01 -0.679192E-01  0.679192E-01   345.084       345.152    
  10  0.298546      -1.20883      -1.64076       1.64076       345.818       347.459    
  11  0.805120     -0.216763     -0.294215      0.294215       346.390       346.684    
  12  0.208146      -1.56951      -2.13031       2.13031       342.779       344.909    
  13  0.924021     -0.790209E-01 -0.107256      0.107256       350.361       350.468    
  14  0.447624     -0.803802      -1.09101       1.09101       351.812       352.903    
  15  0.667709     -0.403903     -0.548221      0.548221       352.637       353.185    
  16  0.767295E-01  -2.56747      -3.48485       3.48485       352.327       355.812    
  17  0.301582      -1.19871      -1.62702       1.62702       354.403       356.031    
  18  0.788580     -0.237522     -0.322390      0.322390       356.376       356.699    
  19  0.887020     -0.119888     -0.162725      0.162725       356.596       356.759    
  20  0.233035E-01  -3.75915      -5.10233       5.10233       357.280       362.383    
  21  0.899320     -0.106116     -0.144033      0.144033       357.685       357.829    
  22  0.144480      -1.93461      -2.62587       2.62587       358.619       361.245    
  23  0.274629      -1.29233      -1.75410       1.75410       358.878       360.632    
  24  0.831597     -0.184407     -0.250297      0.250297       358.500       358.750    
  25  0.388827     -0.944620      -1.28214       1.28214       360.164       361.446    
  26  0.257578      -1.35643      -1.84110       1.84110       360.982       362.824    
  27  0.427791     -0.849120      -1.15252       1.15252       360.596       361.749    
  28  0.837664E-01  -2.47972      -3.36575       3.36575       361.951       365.317    
  29  0.782727     -0.244972     -0.332502      0.332502       362.531       362.863    
  30  0.259676E-01  -3.65091      -4.95541       4.95541       368.360       373.315    
  31  0.166181      -1.79468      -2.43593       2.43593       351.138       353.574    
loop,thermsimp(1:2)       72   1.11195       2.16902    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    261        413.91         73.98          0.97         38.22          1.09          0.05        114.32
Just calling func    0   0        114.32


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    262        347.30         73.89          0.98         38.66          0.95          0.05        114.53
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  260    413.91        1.991     -1.216      5.771     -102.2      1.018    
                     -0.2585      3.822     -100.3      4.061      1.331    
                       1.599     -1.115      1.466      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1091E+05 0.1273E+05 -3882.    -0.4973E+05
                      -2.000     -5.355     -6.259     -7.395      3.597    
                      -13.29     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                      -2.103     -2.006      6.012      2.190      0.000    
                       0.000      9.205      9.124     0.1984E+05  1.000    
                     -0.5787    -0.7479      9.398      8.548     -1977.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6707.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -2654.      1.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    347.30
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       72
neval is:      261
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       72      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       73
neval is:      261


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      261     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.807892     -0.213326     -0.289550      0.289550       327.638       327.928    
   2  0.554495     -0.589697     -0.800401      0.800401       334.032       334.832    
   3  0.997056     -0.294851E-02 -0.400204E-02  0.400204E-02   333.149       333.153    
   4  0.901183E-01  -2.40663      -3.26654       3.26654       334.508       337.775    
   5  0.296736      -1.21491      -1.64901       1.64901       336.329       337.978    
   6  0.907820     -0.967094E-01 -0.131265      0.131265       340.410       340.541    
   7  0.325542      -1.12226      -1.52326       1.52326       340.367       341.890    
   8  0.947537     -0.538896E-01 -0.731449E-01  0.731449E-01   340.722       340.795    
   9  0.378276     -0.972130      -1.31948       1.31948       342.779       344.098    
  10  0.985613     -0.144920E-01 -0.196701E-01  0.196701E-01   345.084       345.104    
  11  0.167434      -1.78717      -2.42574       2.42574       346.390       348.815    
  12  0.693849E-01  -2.66809      -3.62142       3.62142       345.818       349.440    
  13  0.434983     -0.832447      -1.12989       1.12989       350.361       351.491    
  14  0.998656     -0.134491E-02 -0.182546E-02  0.182546E-02   351.812       351.814    
  15  0.650302     -0.430318     -0.584074      0.584074       352.637       353.221    
  16  0.152610      -1.87987      -2.55157       2.55157       351.138       353.690    
  17  0.273947      -1.29482      -1.75747       1.75747       352.327       354.085    
  18  0.990471     -0.957469E-02 -0.129958E-01  0.129958E-01   354.403       354.416    
  19  0.684493     -0.379077     -0.514524      0.514524       356.376       356.891    
  20  0.864467E-01  -2.44823      -3.32300       3.32300       356.596       359.919    
  21  0.546085     -0.604980     -0.821145      0.821145       357.685       358.506    
  22  0.246642      -1.39982      -1.89998       1.89998       358.500       360.400    
  23  0.484505     -0.724627     -0.983543      0.983543       358.878       359.861    
  24  0.567359     -0.566763     -0.769272      0.769272       358.619       359.388    
  25  0.564371     -0.572043     -0.776439      0.776439       360.164       360.940    
  26  0.825604     -0.191640     -0.260115      0.260115       360.596       360.856    
  27  0.302493      -1.19570      -1.62293       1.62293       357.280       358.903    
  28  0.630396     -0.461407     -0.626271      0.626271       360.982       361.609    
  29  0.886734     -0.120210     -0.163163      0.163163       362.531       362.694    
  30  0.389345     -0.943288      -1.28033       1.28033       361.951       363.232    
  31  0.181391      -1.70710      -2.31706       2.31706       347.298       349.615    
loop,thermsimp(1:2)       73  0.289550      0.800401    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    263        353.61         73.99          1.00         38.60          0.74          0.05        114.38
Just calling func    0   0        114.38


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    353.61
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       73
neval is:      262
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       73      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       74
neval is:      262


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      262     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.889684     -0.116889     -0.158655      0.158655       327.638       327.797    
   2  0.480213     -0.733525     -0.995620      0.995620       333.149       334.144    
   3  0.226156      -1.48653      -2.01768       2.01768       334.032       336.050    
   4  0.633402     -0.456651     -0.619816      0.619816       334.508       335.128    
   5  0.925311     -0.776258E-01 -0.105362      0.105362       336.329       336.434    
   6  0.498405     -0.696343     -0.945152      0.945152       340.410       341.355    
   7  0.133283      -2.01528      -2.73536       2.73536       340.722       343.458    
   8  0.657074E-01  -2.72254      -3.69533       3.69533       340.367       344.063    
   9  0.726758     -0.319162     -0.433201      0.433201       342.779       343.212    
  10  0.398365     -0.920388      -1.24925       1.24925       345.084       346.334    
  11  0.321047E-01  -3.43875      -4.66745       4.66745       346.390       351.057    
  12  0.276307      -1.28624      -1.74583       1.74583       345.818       347.564    
  13  0.483740     -0.726208     -0.985689      0.985689       347.298       348.284    
  14  0.224589      -1.49348      -2.02712       2.02712       350.361       352.388    
  15  0.832041     -0.183874     -0.249573      0.249573       351.812       352.062    
  16  0.939301     -0.626192E-01 -0.849936E-01  0.849936E-01   352.637       352.722    
  17  0.624052     -0.471522     -0.640000      0.640000       351.138       351.778    
  18  0.172753      -1.75589      -2.38329       2.38329       352.327       354.711    
  19  0.468323     -0.758597      -1.02965       1.02965       354.403       355.433    
  20  0.963461     -0.372229E-01 -0.505230E-01  0.505230E-01   356.376       356.427    
  21  0.812092     -0.208142     -0.282513      0.282513       357.685       357.967    
  22  0.376764     -0.976137      -1.32492       1.32492       357.280       358.605    
  23  0.791872E-01  -2.53594      -3.44206       3.44206       358.619       362.061    
  24  0.237003      -1.43968      -1.95409       1.95409       358.878       360.832    
  25  0.320094      -1.13914      -1.54617       1.54617       356.596       358.142    
  26  0.821410E-01  -2.49932      -3.39235       3.39235       358.500       361.892    
  27  0.789147     -0.236802     -0.321414      0.321414       360.596       360.918    
  28  0.734353E-01  -2.61135      -3.54441       3.54441       360.164       363.708    
  29  0.226401      -1.48545      -2.01621       2.01621       360.982       362.999    
  30  0.380831     -0.965399      -1.31034       1.31034       362.531       363.841    
  31  0.264857      -1.32857      -1.80327       1.80327       353.612       355.416    
loop,thermsimp(1:2)       74  0.158655      0.995620    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    264        338.52         74.55          1.04         38.68          0.30          0.05        114.63
Just calling func    0   0        114.63


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    338.52
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       74
neval is:      263
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       74      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       75
neval is:      263


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      263     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.645801     -0.437264     -0.593502      0.593502       327.638       328.232    
   2  0.108032      -2.22533      -3.02045       3.02045       333.149       336.169    
   3  0.908790     -0.956413E-01 -0.129815      0.129815       334.508       334.638    
   4  0.987883     -0.121914E-01 -0.165474E-01  0.165474E-01   334.032       334.048    
   5  0.318380      -1.14451      -1.55345       1.55345       336.329       337.882    
   6  0.924426     -0.785824E-01 -0.106661      0.106661       340.410       340.516    
   7  0.965220     -0.353996E-01 -0.480481E-01  0.480481E-01   342.779       342.827    
   8  0.852248     -0.159878     -0.217004      0.217004       340.722       340.939    
   9  0.329186      -1.11113      -1.50815       1.50815       340.367       341.875    
  10  0.282479      -1.26415      -1.71584       1.71584       345.084       346.800    
  11  0.818943     -0.199740     -0.271109      0.271109       345.818       346.090    
  12  0.842569     -0.171300     -0.232507      0.232507       347.298       347.531    
  13  0.370966     -0.991644      -1.34597       1.34597       346.390       347.736    
  14  0.362233      -1.01547      -1.37830       1.37830       351.138       352.516    
  15  0.356944E-01  -3.33276      -4.52359       4.52359       351.812       356.336    
  16  0.149119      -1.90301      -2.58297       2.58297       350.361       352.944    
  17  0.127170      -2.06223      -2.79909       2.79909       352.637       355.436    
  18  0.589256     -0.528895     -0.717873      0.717873       352.327       353.045    
  19  0.702139     -0.353624     -0.479977      0.479977       353.612       354.092    
  20  0.713819     -0.337127     -0.457585      0.457585       354.403       354.861    
  21  0.121783      -2.10552      -2.85784       2.85784       356.376       359.234    
  22  0.992321     -0.770837E-02 -0.104626E-01  0.104626E-01   357.685       357.695    
  23  0.622746     -0.473616     -0.642844      0.642844       356.596       357.239    
  24  0.388486     -0.945499      -1.28333       1.28333       357.280       358.564    
  25  0.365204      -1.00730      -1.36722       1.36722       358.878       360.245    
  26  0.416566     -0.875710      -1.18861       1.18861       360.596       361.785    
  27  0.250735      -1.38336      -1.87764       1.87764       358.500       360.377    
  28  0.243824      -1.41131      -1.91558       1.91558       358.619       360.535    
  29  0.177195      -1.73050      -2.34883       2.34883       360.982       363.331    
  30  0.723685     -0.323399     -0.438952      0.438952       360.164       360.603    
  31  0.157256      -1.84988      -2.51086       2.51086       338.524       341.035    
loop,thermsimp(1:2)       75  0.593502       3.02045    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    265        380.71         74.08          1.00         38.84          0.82          0.06        114.80
Just calling func    0   0        114.80


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    266        347.06         74.43          1.05         38.72          0.45          0.05        114.71
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    347.06
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       75
neval is:      265
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       75      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       76
neval is:      265


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      265     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.202436      -1.59733      -2.16807       2.16807       327.638       329.807    
   2  0.337724      -1.08553      -1.47340       1.47340       334.032       335.505    
   3  0.870295     -0.138923     -0.188562      0.188562       334.508       334.697    
   4  0.837087     -0.177827     -0.241366      0.241366       333.149       333.390    
   5  0.512110     -0.669215     -0.908332      0.908332       336.329       337.237    
   6  0.998742     -0.125879E-02 -0.170857E-02  0.170857E-02   340.410       340.411    
   7  0.203490      -1.59214      -2.16102       2.16102       340.722       342.883    
   8  0.525951E-01  -2.94513      -3.99745       3.99745       338.524       342.522    
   9  0.474810     -0.744841      -1.01098       1.01098       340.367       341.378    
  10  0.440755     -0.819266      -1.11200       1.11200       342.779       343.891    
  11  0.225689      -1.48860      -2.02049       2.02049       345.818       347.839    
  12  0.902704     -0.102360     -0.138934      0.138934       345.084       345.223    
  13  0.663331     -0.410481     -0.557149      0.557149       347.298       347.855    
  14  0.511480     -0.670447     -0.910003      0.910003       346.390       347.300    
  15  0.625297     -0.469528     -0.637295      0.637295       351.138       351.775    
  16  0.812907     -0.207139     -0.281152      0.281152       350.361       350.642    
  17  0.979453     -0.207607E-01 -0.281786E-01  0.281786E-01   352.327       352.356    
  18  0.255329      -1.36520      -1.85300       1.85300       353.612       355.465    
  19  0.856654     -0.154722     -0.210005      0.210005       354.403       354.613    
  20  0.610394     -0.493650     -0.670036      0.670036       352.637       353.307    
  21  0.703614     -0.351525     -0.477128      0.477128       351.812       352.289    
  22  0.623403     -0.472562     -0.641412      0.641412       356.596       357.237    
  23  0.375727     -0.978893      -1.32866       1.32866       357.685       359.014    
  24  0.870528     -0.138656     -0.188198      0.188198       357.280       357.468    
  25  0.175838E-01  -4.04078      -5.48458       5.48458       356.376       361.861    
  26  0.237914      -1.43585      -1.94889       1.94889       358.878       360.827    
  27  0.464352     -0.767112      -1.04121       1.04121       358.500       359.541    
  28  0.776873     -0.252478     -0.342691      0.342691       358.619       358.962    
  29  0.380679     -0.965800      -1.31089       1.31089       360.164       361.475    
  30  0.391295     -0.938295      -1.27356       1.27356       360.596       361.870    
  31  0.369488     -0.995636      -1.35139       1.35139       347.058       348.409    
loop,thermsimp(1:2)       76   2.16807       1.47340    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    267        337.25         74.32          1.01         38.75          0.79          0.05        114.93
Just calling func    0   0        114.93


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    337.25
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       76
neval is:      266
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       76      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       77
neval is:      266


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      266     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.608851     -0.496181     -0.673471      0.673471       327.638       328.312    
   2  0.437836     -0.825911      -1.12102       1.12102       333.149       334.270    
   3  0.123560      -2.09103      -2.83818       2.83818       334.508       337.346    
   4  0.943438     -0.582242E-01 -0.790283E-01  0.790283E-01   334.032       334.111    
   5  0.215054      -1.53686      -2.08600       2.08600       336.329       338.415    
   6  0.984763     -0.153546E-01 -0.208409E-01  0.208409E-01   340.410       340.430    
   7  0.154160E-01  -4.17235      -5.66317       5.66317       340.367       346.030    
   8  0.231957      -1.46120      -1.98330       1.98330       338.524       340.508    
   9  0.476349     -0.741605      -1.00659       1.00659       340.722       341.729    
  10  0.620436     -0.477333     -0.647888      0.647888       342.779       343.427    
  11  0.456145     -0.784945      -1.06541       1.06541       345.084       346.150    
  12  0.507296     -0.678660     -0.921151      0.921151       346.390       347.311    
  13  0.910123     -0.941755E-01 -0.127825      0.127825       345.818       345.946    
  14  0.323556      -1.12838      -1.53156       1.53156       347.298       348.830    
  15  0.666279     -0.406046     -0.551130      0.551130       347.058       347.609    
  16  0.781920     -0.246002     -0.333901      0.333901       350.361       350.695    
  17  0.921689     -0.815478E-01 -0.110685      0.110685       351.138       351.249    
  18  0.152544      -1.88030      -2.55215       2.55215       351.812       354.364    
  19  0.265926      -1.32454      -1.79781       1.79781       352.327       354.125    
  20  0.812409     -0.207751     -0.281982      0.281982       352.637       352.919    
  21  0.517560E-01  -2.96121      -4.01928       4.01928       354.403       358.423    
  22  0.559187     -0.581271     -0.788964      0.788964       353.612       354.401    
  23  0.708792     -0.344194     -0.467177      0.467177       356.596       357.063    
  24  0.287762      -1.24562      -1.69069       1.69069       357.280       358.971    
  25  0.896953     -0.108752     -0.147611      0.147611       358.619       358.767    
  26  0.305048      -1.18729      -1.61152       1.61152       357.685       359.296    
  27  0.752428     -0.284450     -0.386086      0.386086       358.500       358.886    
  28  0.248159      -1.39369      -1.89166       1.89166       358.878       360.770    
  29  0.997822     -0.217989E-02 -0.295879E-02  0.295879E-02   360.164       360.167    
  30  0.706427     -0.347535     -0.471712      0.471712       356.376       356.848    
  31  0.885217     -0.121923     -0.165487      0.165487       337.249       337.414    
loop,thermsimp(1:2)       77  0.673471       1.12102    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    268        333.15         73.98          0.97         38.82          0.54          0.05        114.36
Just calling func    0   0        114.36


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    333.15
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       77
neval is:      267
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       77      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       78
neval is:      267


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      267     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.980204E-01  -2.32258      -3.15246       3.15246       327.638       330.791    
   2  0.700279     -0.356277     -0.483578      0.483578       334.032       334.516    
   3  0.681564     -0.383366     -0.520346      0.520346       333.149       333.669    
   4  0.838213E-01  -2.47907      -3.36486       3.36486       334.508       337.873    
   5  0.708687     -0.344341     -0.467377      0.467377       337.249       337.716    
   6  0.253966      -1.37055      -1.86026       1.86026       336.329       338.189    
   7  0.210796      -1.55686      -2.11314       2.11314       340.410       342.523    
   8  0.967741     -0.327906E-01 -0.445070E-01  0.445070E-01   338.524       338.569    
   9  0.901331     -0.103882     -0.141000      0.141000       340.722       340.863    
  10  0.985067     -0.150452E-01 -0.204209E-01  0.204209E-01   342.779       342.799    
  11  0.153899      -1.87146      -2.54015       2.54015       345.818       348.359    
  12  0.297572      -1.21210      -1.64519       1.64519       340.367       342.012    
  13  0.111036      -2.19790      -2.98323       2.98323       345.084       348.068    
  14  0.489011     -0.715370     -0.970978      0.970978       346.390       347.361    
  15  0.970731     -0.297058E-01 -0.403200E-01  0.403200E-01   347.058       347.098    
  16  0.246322      -1.40112      -1.90175       1.90175       347.298       349.200    
  17  0.293332      -1.22645      -1.66467       1.66467       350.361       352.026    
  18  0.545752     -0.605591     -0.821974      0.821974       351.138       351.960    
  19  0.455999     -0.785265      -1.06585       1.06585       352.637       353.703    
  20  0.427211     -0.850477      -1.15436       1.15436       352.327       353.482    
  21  0.185046E-01  -3.98974      -5.41530       5.41530       351.812       357.228    
  22  0.768936     -0.262748     -0.356630      0.356630       353.612       353.969    
  23  0.870591     -0.138583     -0.188100      0.188100       356.376       356.565    
  24  0.563023     -0.574436     -0.779686      0.779686       356.596       357.376    
  25  0.132150E-01  -4.32640      -5.87227       5.87227       354.403       360.276    
  26  0.890415     -0.116068     -0.157540      0.157540       358.619       358.776    
  27  0.163417      -1.81145      -2.45870       2.45870       358.500       360.959    
  28  0.360288      -1.02085      -1.38561       1.38561       357.280       358.666    
  29  0.622131     -0.474604     -0.644184      0.644184       357.685       358.329    
  30  0.942630     -0.590811E-01 -0.801913E-01  0.801913E-01   360.164       360.244    
  31  0.135626      -1.99785      -2.71170       2.71170       333.153       335.864    
loop,thermsimp(1:2)       78   3.15246      0.483578    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    269        355.35         74.02          0.99         38.66          1.04          0.05        114.77
Just calling func    0   0        114.77


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    355.35
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       78
neval is:      268
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       78      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       79
neval is:      268


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      268     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.190215      -1.65960      -2.25259       2.25259       327.638       329.891    
   2  0.812983     -0.207045     -0.281024      0.281024       333.149       333.430    
   3  0.820046E-01  -2.50098      -3.39460       3.39460       334.032       337.427    
   4  0.863006     -0.147333     -0.199977      0.199977       333.153       333.352    
   5  0.647901     -0.434017     -0.589096      0.589096       337.249       337.838    
   6  0.650063E-01  -2.73327      -3.70989       3.70989       334.508       338.218    
   7  0.407685E-02  -5.50243      -7.46850       7.46850       336.329       343.797    
   8  0.935930     -0.662149E-01 -0.898741E-01  0.898741E-01   338.524       338.614    
   9  0.158531      -1.84180      -2.49990       2.49990       340.722       343.222    
  10  0.846482     -0.166666     -0.226218      0.226218       340.367       340.593    
  11  0.252208      -1.37750      -1.86970       1.86970       340.410       342.279    
  12  0.781651E-02  -4.85152      -6.58501       6.58501       342.779       349.364    
  13  0.990286     -0.976134E-02 -0.132492E-01  0.132492E-01   347.058       347.071    
  14  0.550116     -0.597625     -0.811162      0.811162       346.390       347.201    
  15  0.483066     -0.727601     -0.987579      0.987579       345.084       346.072    
  16  0.196160      -1.62883      -2.21082       2.21082       345.818       348.029    
  17  0.469455     -0.756184      -1.02637       1.02637       347.298       348.324    
  18  0.624392     -0.470977     -0.639261      0.639261       351.138       351.777    
  19  0.743593     -0.296262     -0.402119      0.402119       350.361       350.763    
  20  0.348439      -1.05429      -1.43100       1.43100       352.327       353.758    
  21  0.779083     -0.249637     -0.338835      0.338835       352.637       352.976    
  22  0.989010     -0.110506E-01 -0.149991E-01  0.149991E-01   353.612       353.627    
  23  0.655432E-01  -2.72505      -3.69873       3.69873       356.376       360.075    
  24  0.470908     -0.753092      -1.02218       1.02218       351.812       352.834    
  25  0.685537     -0.377553     -0.512455      0.512455       356.596       357.108    
  26  0.863060E-02  -4.75244      -6.45053       6.45053       357.685       364.135    
  27  0.526195     -0.642084     -0.871506      0.871506       357.280       358.152    
  28  0.767692     -0.264367     -0.358827      0.358827       358.619       358.978    
  29  0.380048     -0.967459      -1.31314       1.31314       360.164       361.477    
  30  0.337508E-01  -3.38875      -4.59958       4.59958       354.403       359.003    
  31  0.683667     -0.380285     -0.516164      0.516164       355.349       355.865    
loop,thermsimp(1:2)       79   2.25259      0.281024    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    270        326.46         73.81          0.96         38.29          1.60          0.05        114.71
Just calling func    0   0        114.71


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    271        358.51         73.96          0.99         38.80          0.80          0.06        114.61
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    326.46
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       79
neval is:      270
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       79      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       80
neval is:      270


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      270     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.337114      -1.08733      -1.47585       1.47585       327.638       329.114    
   2  0.744737     -0.294724     -0.400031      0.400031       333.153       333.553    
   3  0.361564E-01  -3.31990      -4.50613       4.50613       333.149       337.655    
   4  0.312099      -1.16444      -1.58050       1.58050       334.032       335.612    
   5  0.119132      -2.12752      -2.88771       2.88771       337.249       340.137    
   6  0.617735     -0.481696     -0.653810      0.653810       334.508       335.162    
   7  0.117626      -2.14025      -2.90498       2.90498       338.524       341.429    
   8  0.258570      -1.35259      -1.83588       1.83588       340.367       342.203    
   9  0.851854E-01  -2.46293      -3.34295       3.34295       340.410       343.752    
  10  0.220620      -1.51131      -2.05132       2.05132       340.722       342.774    
  11  0.648876     -0.432513     -0.587054      0.587054       336.329       336.916    
  12  0.958689     -0.421884E-01 -0.572627E-01  0.572627E-01   345.084       345.142    
  13  0.240652      -1.42440      -1.93335       1.93335       347.058       348.991    
  14  0.975871     -0.244252E-01 -0.331525E-01  0.331525E-01   346.390       346.423    
  15  0.467835     -0.759639      -1.03106       1.03106       345.818       346.850    
  16  0.398205     -0.920788      -1.24979       1.24979       347.298       348.548    
  17  0.757338E-01  -2.58053      -3.50258       3.50258       342.779       346.282    
  18  0.654643     -0.423666     -0.575045      0.575045       350.361       350.936    
  19  0.305298      -1.18647      -1.61040       1.61040       351.138       352.749    
  20  0.435768     -0.830645      -1.12744       1.12744       351.812       352.940    
  21  0.689410     -0.371920     -0.504810      0.504810       352.637       353.142    
  22  0.267500      -1.31864      -1.78980       1.78980       353.612       355.402    
  23  0.590747     -0.526367     -0.714443      0.714443       352.327       353.042    
  24  0.108947E-01  -4.51948      -6.13432       6.13432       355.349       361.484    
  25  0.236025      -1.44382      -1.95971       1.95971       356.596       358.556    
  26  0.590760     -0.526345     -0.714413      0.714413       357.280       357.995    
  27  0.782443     -0.245334     -0.332994      0.332994       358.619       358.952    
  28  0.702257     -0.353456     -0.479749      0.479749       354.403       354.883    
  29  0.764991     -0.267891     -0.363611      0.363611       356.376       356.740    
  30  0.753362     -0.283210     -0.384403      0.384403       360.164       360.548    
  31  0.961949E-01  -2.34138      -3.17797       3.17797       326.457       329.635    
loop,thermsimp(1:2)       80   1.47585      0.400031    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    272        361.72         73.95          1.04         38.80          0.07          0.05        113.91
Just calling func    0   0        113.91


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    361.72
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       80
neval is:      271
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       80      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       81
neval is:      271


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      271     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.343927      -1.06733      -1.44869       1.44869       327.638       329.087    
   2  0.822787     -0.195058     -0.264754      0.264754       326.457       326.722    
   3  0.320831E-01  -3.43942      -4.66836       4.66836       333.153       337.821    
   4  0.224034      -1.49596      -2.03048       2.03048       334.508       336.539    
   5  0.200770      -1.60559      -2.17929       2.17929       334.032       336.211    
   6  0.983846     -0.162863E-01 -0.221055E-01  0.221055E-01   336.329       336.351    
   7  0.762274     -0.271449     -0.368440      0.368440       333.149       333.517    
   8  0.872649     -0.136221     -0.184895      0.184895       337.249       337.434    
   9  0.366891      -1.00269      -1.36096       1.36096       338.524       339.885    
  10  0.800852     -0.222079     -0.301430      0.301430       340.367       340.669    
  11  0.755695     -0.280117     -0.380205      0.380205       340.722       341.103    
  12  0.595174     -0.518902     -0.704310      0.704310       340.410       341.114    
  13  0.316509      -1.15040      -1.56145       1.56145       345.084       346.646    
  14  0.847901     -0.164991     -0.223943      0.223943       342.779       343.003    
  15  0.116195      -2.15248      -2.92158       2.92158       346.390       349.311    
  16  0.121963      -2.10403      -2.85582       2.85582       345.818       348.674    
  17  0.298485      -1.20903      -1.64103       1.64103       347.298       348.939    
  18  0.698751     -0.358461     -0.486542      0.486542       347.058       347.544    
  19  0.248186      -1.39358      -1.89151       1.89151       350.361       352.253    
  20  0.717251     -0.332329     -0.451073      0.451073       351.138       351.589    
  21  0.591856     -0.524491     -0.711897      0.711897       351.812       352.524    
  22  0.780177E-01  -2.55082      -3.46225       3.46225       352.327       355.790    
  23  0.314281      -1.15747      -1.57104       1.57104       352.637       354.208    
  24  0.565423E-01  -2.87277      -3.89923       3.89923       354.403       358.303    
  25  0.964829     -0.358044E-01 -0.485977E-01  0.485977E-01   353.612       353.661    
  26  0.900157     -0.105186     -0.142770      0.142770       356.376       356.519    
  27  0.656998     -0.420074     -0.570170      0.570170       357.280       357.850    
  28  0.888436E-01  -2.42088      -3.28588       3.28588       356.596       359.882    
  29  0.853838     -0.158014     -0.214474      0.214474       358.619       358.833    
  30  0.704842     -0.349782     -0.474762      0.474762       360.164       360.639    
  31  0.890111     -0.116409     -0.158003      0.158003       361.723       361.881    
loop,thermsimp(1:2)       81   1.44869      0.264754    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    273        355.35         75.41          1.10         38.26          0.08          0.05        114.91
Just calling func    0   0        114.91


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    355.35
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.35731               271
loop is:       81
neval is:      272
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       81      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:    1.35731               271
loop is:       82
neval is:      272


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 




neval>tstepnex so lower away!t
---> lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
     new SAtemp,tstepnext are :   0.678654               301

 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      272     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.556446     -0.586184     -0.397817      0.397817       326.457       326.855    
   2  0.926592     -0.762421E-01 -0.517420E-01  0.517420E-01   327.638       327.690    
   3  0.766762     -0.265579     -0.180236      0.180236       333.149       333.329    
   4  0.627980     -0.465247     -0.315742      0.315742       334.032       334.348    
   5  0.647527     -0.434594     -0.294939      0.294939       336.329       336.624    
   6  0.639464     -0.447125     -0.303443      0.303443       334.508       334.812    
   7  0.168437      -1.78119      -1.20881       1.20881       337.249       338.458    
   8  0.725133     -0.321400     -0.218120      0.218120       333.153       333.371    
   9  0.620073     -0.477917     -0.324341      0.324341       338.524       338.849    
  10  0.837394     -0.177461     -0.120434      0.120434       340.367       340.488    
  11  0.763326     -0.270070     -0.183284      0.183284       340.722       340.906    
  12  0.216703      -1.52923      -1.03782       1.03782       340.410       341.447    
  13  0.846730     -0.166373     -0.112910      0.112910       342.779       342.892    
  14  0.712127     -0.339499     -0.230403      0.230403       345.084       345.315    
  15  0.731222     -0.313039     -0.212445      0.212445       347.058       347.270    
  16  0.131329      -2.03005      -1.37770       1.37770       345.818       347.196    
  17  0.946517     -0.549662E-01 -0.373031E-01  0.373031E-01   347.298       347.335    
  18  0.303743      -1.19157     -0.808667      0.808667       346.390       347.198    
  19  0.452199     -0.793633     -0.538602      0.538602       351.138       351.677    
  20  0.176302      -1.73556      -1.17784       1.17784       350.361       351.539    
  21  0.569871     -0.562345     -0.381638      0.381638       351.812       352.194    
  22  0.267873      -1.31724     -0.893953      0.893953       353.612       354.506    
  23  0.295877      -1.21781     -0.826472      0.826472       352.637       353.463    
  24  0.658567     -0.417689     -0.283466      0.283466       352.327       352.611    
  25  0.633120     -0.457096     -0.310210      0.310210       356.376       356.687    
  26  0.655522     -0.422324     -0.286612      0.286612       357.280       357.567    
  27  0.532295     -0.630558     -0.427931      0.427931       354.403       354.831    
  28  0.611209     -0.492317     -0.334113      0.334113       358.619       358.953    
  29  0.768812E-01  -2.56549      -1.74108       1.74108       356.596       358.337    
  30  0.845132     -0.168262     -0.114192      0.114192       360.164       360.278    
  31  0.133696      -2.01219      -1.36558       1.36558       355.349       356.715    
loop,thermsimp(1:2)       82  0.397817      0.517420E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    274        339.28         74.47          1.02         38.92          0.21          0.06        114.67
Just calling func    0   0        114.67


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    339.28
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:       82
neval is:      273
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       82      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:       83
neval is:      273


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      273     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.620562     -0.477129     -0.323806      0.323806       326.457       326.781    
   2  0.835522     -0.179699     -0.121953      0.121953       327.638       327.760    
   3  0.626661     -0.467350     -0.317169      0.317169       333.149       333.466    
   4  0.197939      -1.61980      -1.09928       1.09928       333.153       334.252    
   5  0.842637     -0.171219     -0.116198      0.116198       334.032       334.148    
   6  0.873669     -0.135053     -0.916546E-01  0.916546E-01   334.508       334.600    
   7  0.298180E-01  -3.51264      -2.38387       2.38387       336.329       338.713    
   8  0.548374     -0.600797     -0.407734      0.407734       337.249       337.657    
   9  0.407469E-01  -3.20037      -2.17195       2.17195       338.524       340.696    
  10  0.210105E-02  -6.16532      -4.18412       4.18412       340.367       344.551    
  11  0.631577     -0.459536     -0.311866      0.311866       340.722       341.034    
  12  0.944026     -0.576013E-01 -0.390914E-01  0.390914E-01   340.410       340.449    
  13  0.492775     -0.707703     -0.480286      0.480286       342.779       343.259    
  14  0.195107      -1.63421      -1.10906       1.10906       345.084       346.194    
  15  0.775688     -0.254005     -0.172381      0.172381       345.818       345.991    
  16  0.763907     -0.269310     -0.182768      0.182768       346.390       346.572    
  17  0.797499     -0.226275     -0.153562      0.153562       347.058       347.211    
  18  0.639217     -0.447511     -0.303706      0.303706       347.298       347.602    
  19  0.775225     -0.254602     -0.172787      0.172787       350.361       350.534    
  20  0.680633     -0.384733     -0.261100      0.261100       351.138       351.399    
  21  0.532184     -0.630766     -0.428072      0.428072       351.812       352.240    
  22  0.843009     -0.170778     -0.115899      0.115899       352.327       352.443    
  23  0.943186     -0.584913E-01 -0.396954E-01  0.396954E-01   352.637       352.677    
  24  0.601611     -0.508143     -0.344854      0.344854       353.612       353.957    
  25  0.259021      -1.35084     -0.916756      0.916756       354.403       355.320    
  26  0.855132     -0.156500     -0.106209      0.106209       356.376       356.483    
  27  0.351229      -1.04632     -0.710088      0.710088       355.349       356.059    
  28  0.950362     -0.509122E-01 -0.345518E-01  0.345518E-01   357.280       357.315    
  29  0.447301     -0.804524     -0.545994      0.545994       356.596       357.142    
  30  0.325509      -1.12237     -0.761699      0.761699       358.619       359.381    
  31  0.717010     -0.332666     -0.225765      0.225765       339.281       339.507    
loop,thermsimp(1:2)       83  0.323806      0.121953    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    275        383.92         74.17          0.99         39.06          0.16          0.06        114.44
Just calling func    0   0        114.44


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    276        341.10         73.86          0.96         38.92          0.55          0.05        114.34
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    341.10
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:       83
neval is:      275
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       83      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:       84
neval is:      275


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      275     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.573743     -0.555573     -0.377042      0.377042       326.457       326.835    
   2  0.583943E-01  -2.84054      -1.92774       1.92774       327.638       329.566    
   3  0.377108     -0.975224     -0.661840      0.661840       333.149       333.811    
   4  0.117758      -2.13912      -1.45173       1.45173       334.032       335.484    
   5  0.531627     -0.631812     -0.428782      0.428782       333.153       333.581    
   6  0.348101      -1.05526     -0.716158      0.716158       334.508       335.224    
   7  0.713050     -0.338204     -0.229524      0.229524       337.249       337.478    
   8  0.895286     -0.110612     -0.750674E-01  0.750674E-01   336.329       336.404    
   9  0.873863     -0.134831     -0.915038E-01  0.915038E-01   339.281       339.373    
  10  0.225074      -1.49132      -1.01209       1.01209       340.410       341.422    
  11  0.542220     -0.612083     -0.415393      0.415393       338.524       338.940    
  12  0.262707      -1.33672     -0.907169      0.907169       340.722       341.630    
  13  0.864358E-01  -2.44835      -1.66159       1.66159       342.779       344.441    
  14  0.468331     -0.758581     -0.514814      0.514814       340.367       340.882    
  15  0.896509     -0.109247     -0.741411E-01  0.741411E-01   345.818       345.893    
  16  0.169842E-01  -4.07547      -2.76584       2.76584       345.084       347.850    
  17  0.980158     -0.200410E-01 -0.136009E-01  0.136009E-01   346.390       346.403    
  18  0.252821      -1.37507     -0.933199      0.933199       347.058       347.991    
  19  0.556823     -0.585507     -0.397357      0.397357       347.298       347.695    
  20  0.520304     -0.653342     -0.443393      0.443393       350.361       350.804    
  21  0.956705E-01  -2.34685      -1.59270       1.59270       351.138       352.731    
  22  0.458762     -0.779224     -0.528824      0.528824       351.812       352.341    
  23  0.684654     -0.378842     -0.257102      0.257102       352.327       352.584    
  24  0.749393     -0.288492     -0.195786      0.195786       352.637       352.833    
  25  0.112724      -2.18282      -1.48138       1.48138       353.612       355.094    
  26  0.642114     -0.442989     -0.300637      0.300637       354.403       354.704    
  27  0.881888     -0.125691     -0.853005E-01  0.853005E-01   355.349       355.435    
  28  0.933845     -0.684452E-01 -0.464506E-01  0.464506E-01   356.376       356.423    
  29  0.124482      -2.08359      -1.41404       1.41404       356.596       358.010    
  30  0.189487      -1.66344      -1.12890       1.12890       357.280       358.409    
  31  0.526869     -0.640804     -0.434885      0.434885       341.103       341.538    
loop,thermsimp(1:2)       84  0.377042       1.92774    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    277        324.35         73.81          0.94         38.38          1.21          0.06        114.40
Just calling func    0   0        114.40


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    278        450.49         73.38          0.99         38.59          1.08          0.05        114.09
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    324.35
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:       84
neval is:      277
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       84      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:       85
neval is:      277


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      277     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.936701     -0.653915E-01 -0.443782E-01  0.443782E-01   326.457       326.502    
   2  0.765516     -0.267206     -0.181340      0.181340       327.638       327.820    
   3  0.899266     -0.106176     -0.720568E-01  0.720568E-01   333.153       333.225    
   4  0.953341     -0.477822E-01 -0.324276E-01  0.324276E-01   333.149       333.181    
   5  0.642356     -0.442612     -0.300381      0.300381       334.508       334.809    
   6  0.265713      -1.32534     -0.899448      0.899448       334.032       334.931    
   7  0.379937     -0.967749     -0.656767      0.656767       336.329       336.985    
   8  0.449606     -0.799384     -0.542506      0.542506       337.249       337.791    
   9  0.810725     -0.209826     -0.142400      0.142400       338.524       338.667    
  10  0.218977      -1.51879      -1.03073       1.03073       339.281       340.312    
  11  0.456613     -0.783919     -0.532010      0.532010       340.367       340.899    
  12  0.439289E-02  -5.42777      -3.68358       3.68358       340.410       344.093    
  13  0.710409     -0.341914     -0.232042      0.232042       341.103       341.335    
  14  0.385315     -0.953695     -0.647229      0.647229       340.722       341.370    
  15  0.116701      -2.14814      -1.45785       1.45785       342.779       344.237    
  16  0.985237     -0.148728E-01 -0.100935E-01  0.100935E-01   345.818       345.829    
  17  0.856588     -0.154798     -0.105054      0.105054       346.390       346.495    
  18  0.155419      -1.86163      -1.26340       1.26340       347.298       348.562    
  19  0.257525      -1.35664     -0.920690      0.920690       345.084       346.005    
  20  0.548716     -0.600174     -0.407311      0.407311       347.058       347.465    
  21  0.589698     -0.528145     -0.358428      0.358428       350.361       350.720    
  22  0.884364     -0.122887     -0.833975E-01  0.833975E-01   351.812       351.896    
  23  0.871018E-01  -2.44068      -1.65638       1.65638       352.327       353.984    
  24  0.486795     -0.719912     -0.488572      0.488572       351.138       351.627    
  25  0.161417      -1.82376      -1.23771       1.23771       352.637       353.875    
  26  0.598774     -0.512871     -0.348062      0.348062       354.403       354.752    
  27  0.483527     -0.726647     -0.493142      0.493142       353.612       354.106    
  28  0.715961     -0.334130     -0.226759      0.226759       355.349       355.576    
  29  0.771801     -0.259029     -0.175791      0.175791       356.376       356.552    
  30  0.458713     -0.779330     -0.528896      0.528896       356.596       357.125    
  31  0.235181      -1.44740     -0.982285      0.982285       324.352       325.334    
loop,thermsimp(1:2)       85  0.443782E-01  0.181340    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    279        338.86         73.91          0.98         38.50          1.03          0.05        114.47
Just calling func    0   0        114.48


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    338.86
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:       85
neval is:      278
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       85      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:       86
neval is:      278


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      278     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.334399      -1.09542     -0.743412      0.743412       324.352       325.095    
   2  0.140144      -1.96508      -1.33361       1.33361       326.457       327.791    
   3  0.520913     -0.652172     -0.442599      0.442599       327.638       328.081    
   4  0.628337     -0.464678     -0.315356      0.315356       333.149       333.464    
   5  0.203324      -1.59296      -1.08107       1.08107       333.153       334.234    
   6  0.481205     -0.731462     -0.496410      0.496410       334.508       335.005    
   7  0.948759     -0.526009E-01 -0.356978E-01  0.356978E-01   334.032       334.068    
   8  0.251825      -1.37902     -0.935878      0.935878       336.329       337.265    
   9  0.363806      -1.01114     -0.686211      0.686211       337.249       337.935    
  10  0.465077     -0.765552     -0.519545      0.519545       338.524       339.044    
  11  0.580920     -0.543143     -0.368606      0.368606       339.281       339.650    
  12  0.957129     -0.438167E-01 -0.297364E-01  0.297364E-01   340.367       340.397    
  13  0.345007      -1.06419     -0.722217      0.722217       341.103       341.825    
  14  0.177852E-01  -4.02939      -2.73456       2.73456       340.722       343.457    
  15  0.843779     -0.169864     -0.115279      0.115279       340.410       340.525    
  16  0.765452     -0.267288     -0.181396      0.181396       342.779       342.960    
  17  0.453925     -0.789824     -0.536017      0.536017       345.818       346.355    
  18  0.378234     -0.972243     -0.659817      0.659817       345.084       345.744    
  19  0.167312      -1.78790      -1.21336       1.21336       346.390       347.603    
  20  0.240345      -1.42568     -0.967543      0.967543       347.058       348.025    
  21  0.868226     -0.141303     -0.958960E-01  0.958960E-01   347.298       347.394    
  22  0.907002     -0.976102E-01 -0.662436E-01  0.662436E-01   350.361       350.427    
  23  0.433040     -0.836925     -0.567983      0.567983       351.138       351.706    
  24  0.291080      -1.23416     -0.837566      0.837566       351.812       352.650    
  25  0.391091     -0.938815     -0.637131      0.637131       352.637       353.274    
  26  0.541803     -0.612853     -0.415916      0.415916       352.327       352.743    
  27  0.494251     -0.704711     -0.478256      0.478256       353.612       354.091    
  28  0.617376     -0.482277     -0.327299      0.327299       354.403       354.731    
  29  0.919515     -0.839094E-01 -0.569455E-01  0.569455E-01   355.349       355.406    
  30  0.836216     -0.178868     -0.121390      0.121390       356.376       356.498    
  31  0.436173     -0.829716     -0.563091      0.563091       338.856       339.419    
loop,thermsimp(1:2)       86  0.743412       1.33361    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    280        319.38         75.27          1.10         38.13          0.00          0.06        114.56
Just calling func    0   0        114.56


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    281        405.04         74.13          0.97         38.79          0.74          0.04        114.67
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  280    405.04        1.753     -1.111      6.386     -102.7     0.4333    
                     -0.4886      4.312     -100.3      4.382      1.154    
                       1.443     -1.150      1.533      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1677E+05  6275.     -4763.    -0.9852E+05
                      -2.000     -5.545     -5.346     -8.056      8.471    
                      -14.37     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                      -2.550     -2.005      8.667      2.733      0.000    
                       0.000      9.205      9.124     0.2903E+05  1.000    
                     -0.5787    -0.7479      9.398      8.548      5555.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -4443.      1.000    -0.6904    -0.2373      10.12    
                       8.459      10.77      1.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    319.38
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:       86
neval is:      280
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       86      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:       87
neval is:      280


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      280     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.447127E-01  -3.10750      -2.10892       2.10892       324.352       326.461    
   2  0.682805     -0.381545     -0.258937      0.258937       326.457       326.716    
   3  0.699780     -0.356989     -0.242272      0.242272       327.638       327.881    
   4  0.515086     -0.663422     -0.450234      0.450234       333.149       333.599    
   5  0.402461     -0.910157     -0.617682      0.617682       334.032       334.650    
   6  0.652803     -0.426480     -0.289433      0.289433       333.153       333.442    
   7  0.483213     -0.727297     -0.493583      0.493583       334.508       335.002    
   8  0.873684     -0.135037     -0.916433E-01  0.916433E-01   336.329       336.420    
   9  0.142648      -1.94738      -1.32160       1.32160       337.249       338.570    
  10  0.844357     -0.169180     -0.114815      0.114815       338.524       338.639    
  11  0.154187      -1.86959      -1.26880       1.26880       338.856       340.124    
  12  0.437314E-01  -3.12969      -2.12398       2.12398       339.281       341.405    
  13  0.455393E-02  -5.39176      -3.65914       3.65914       340.367       344.026    
  14  0.236800      -1.44054     -0.977628      0.977628       340.410       341.387    
  15  0.660181     -0.415241     -0.281805      0.281805       341.103       341.384    
  16  0.652586     -0.426813     -0.289658      0.289658       342.779       343.069    
  17  0.153101      -1.87666      -1.27360       1.27360       340.722       341.996    
  18  0.753412     -0.283143     -0.192156      0.192156       345.084       345.277    
  19  0.240839      -1.42363     -0.966149      0.966149       345.818       346.785    
  20  0.684622     -0.378888     -0.257134      0.257134       347.298       347.555    
  21  0.243018      -1.41462     -0.960038      0.960038       346.390       347.350    
  22  0.815539     -0.203906     -0.138382      0.138382       347.058       347.196    
  23  0.589355     -0.528726     -0.358822      0.358822       350.361       350.720    
  24  0.243009      -1.41466     -0.960063      0.960063       351.138       352.098    
  25  0.821886     -0.196154     -0.133121      0.133121       351.812       351.945    
  26  0.261401      -1.34170     -0.910551      0.910551       352.327       353.238    
  27  0.571134     -0.560131     -0.380136      0.380136       352.637       353.017    
  28  0.406429E-01  -3.20293      -2.17368       2.17368       353.612       355.786    
  29  0.341463      -1.07451     -0.729224      0.729224       354.403       355.133    
  30  0.252643      -1.37578     -0.933678      0.933678       355.349       356.283    
  31  0.503366     -0.686439     -0.465855      0.465855       319.378       319.844    
loop,thermsimp(1:2)       87   2.10892      0.258937    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    282        350.74         73.69          0.99         38.70          0.76          0.05        114.20
Just calling func    0   0        114.20


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    350.74
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:       87
neval is:      281
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       87      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:       88
neval is:      281


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      281     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.471068     -0.752752     -0.510858      0.510858       319.378       319.889    
   2  0.531040     -0.632917     -0.429532      0.429532       324.352       324.781    
   3  0.592986E-01  -2.82517      -1.91731       1.91731       326.457       328.375    
   4  0.247694      -1.39556     -0.947105      0.947105       327.638       328.586    
   5  0.131832      -2.02623      -1.37511       1.37511       333.153       334.528    
   6  0.928797E-01  -2.37645      -1.61279       1.61279       333.149       334.762    
   7  0.638590     -0.448492     -0.304371      0.304371       334.032       334.336    
   8  0.220145      -1.51347      -1.02712       1.02712       334.508       335.535    
   9  0.764323     -0.268765     -0.182399      0.182399       336.329       336.511    
  10  0.223429      -1.49866      -1.01707       1.01707       337.249       338.266    
  11  0.705665     -0.348615     -0.236589      0.236589       338.524       338.761    
  12  0.812667     -0.207434     -0.140776      0.140776       338.856       338.996    
  13  0.344167      -1.06663     -0.723872      0.723872       341.103       341.827    
  14  0.691720     -0.368573     -0.250134      0.250134       340.410       340.660    
  15  0.601584     -0.508189     -0.344885      0.344885       339.281       339.626    
  16  0.323598      -1.12825     -0.765693      0.765693       340.722       341.488    
  17  0.536181     -0.623284     -0.422994      0.422994       342.779       343.202    
  18  0.224445      -1.49412      -1.01399       1.01399       340.367       341.381    
  19  0.967837     -0.326916E-01 -0.221863E-01  0.221863E-01   345.084       345.107    
  20  0.982234     -0.179257E-01 -0.121654E-01  0.121654E-01   345.818       345.831    
  21  0.656459     -0.420894     -0.285642      0.285642       347.058       347.343    
  22  0.138036      -1.98024      -1.34390       1.34390       346.390       347.734    
  23  0.698821     -0.358360     -0.243203      0.243203       347.298       347.541    
  24  0.603237     -0.505446     -0.343023      0.343023       350.361       350.704    
  25  0.253585      -1.37205     -0.931151      0.931151       351.812       352.743    
  26  0.404885     -0.904153     -0.613607      0.613607       351.138       351.752    
  27  0.802083     -0.220543     -0.149672      0.149672       352.637       352.787    
  28  0.756447     -0.279123     -0.189428      0.189428       352.327       352.517    
  29  0.390929     -0.939231     -0.637413      0.637413       354.403       355.041    
  30  0.260757      -1.34417     -0.912225      0.912225       353.612       354.525    
  31  0.177681      -1.72776      -1.17256       1.17256       350.741       351.913    
loop,thermsimp(1:2)       88  0.510858      0.429532    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    283        331.22         74.65          1.06         38.59          0.00          0.05        114.35
Just calling func    0   0        114.35


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    331.22
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:       88
neval is:      282
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       88      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:       89
neval is:      282


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      282     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.350369      -1.04877     -0.711752      0.711752       319.378       320.090    
   2  0.650675     -0.429745     -0.291648      0.291648       324.352       324.643    
   3  0.849247     -0.163405     -0.110896      0.110896       326.457       326.568    
   4  0.910703     -0.935381E-01 -0.634800E-01  0.634800E-01   327.638       327.702    
   5  0.188892      -1.66658      -1.13103       1.13103       334.032       335.163    
   6  0.256564      -1.36038     -0.923226      0.923226       333.153       334.076    
   7  0.465488E-01  -3.06725      -2.08160       2.08160       333.149       335.230    
   8  0.824855     -0.192548     -0.130674      0.130674       334.508       334.639    
   9  0.730565     -0.313937     -0.213054      0.213054       336.329       336.542    
  10  0.888077     -0.118697     -0.805541E-01  0.805541E-01   337.249       337.329    
  11  0.898172     -0.107394     -0.728835E-01  0.728835E-01   338.524       338.597    
  12  0.314974      -1.15527     -0.784026      0.784026       338.856       339.640    
  13  0.247979      -1.39441     -0.946323      0.946323       339.281       340.228    
  14  0.330032E-01  -3.41115      -2.31499       2.31499       340.410       342.725    
  15  0.570783E-01  -2.86333      -1.94321       1.94321       340.367       342.310    
  16  0.694187     -0.365014     -0.247718      0.247718       340.722       340.970    
  17  0.314834      -1.15571     -0.784327      0.784327       341.103       341.887    
  18  0.917621     -0.859711E-01 -0.583447E-01  0.583447E-01   342.779       342.837    
  19  0.613858     -0.487991     -0.331177      0.331177       345.084       345.416    
  20  0.744084E-01  -2.59819      -1.76327       1.76327       345.818       347.582    
  21  0.454198     -0.789221     -0.535608      0.535608       347.058       347.593    
  22  0.118203E-01  -4.43793      -3.01182       3.01182       347.298       350.310    
  23  0.746996     -0.291695     -0.197960      0.197960       346.390       346.588    
  24  0.416160     -0.876686     -0.594967      0.594967       350.361       350.956    
  25  0.339178E-01  -3.38381      -2.29644       2.29644       351.138       353.435    
  26  0.824080     -0.193487     -0.131311      0.131311       350.741       350.872    
  27  0.589652     -0.528223     -0.358481      0.358481       352.327       352.686    
  28  0.680293     -0.385231     -0.261439      0.261439       351.812       352.074    
  29  0.864872E-01  -2.44776      -1.66118       1.66118       352.637       354.298    
  30  0.672988     -0.396027     -0.268766      0.268766       353.612       353.881    
  31  0.797049E-01  -2.52942      -1.71660       1.71660       331.222       332.939    
loop,thermsimp(1:2)       89  0.711752      0.291648    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    284        326.04         74.88          1.07         38.43          0.02          0.04        114.45
Just calling func    0   0        114.45


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    326.04
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:       89
neval is:      283
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       89      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:       90
neval is:      283


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      283     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.131617      -2.02786      -1.37621       1.37621       319.378       320.755    
   2  0.314760      -1.15594     -0.784487      0.784487       324.352       325.136    
   3  0.748375     -0.289851     -0.196709      0.196709       326.457       326.654    
   4  0.632472     -0.458119     -0.310904      0.310904       327.638       327.949    
   5  0.677472     -0.389387     -0.264259      0.264259       331.222       331.487    
   6  0.433475     -0.835921     -0.567301      0.567301       333.153       333.720    
   7  0.458976     -0.778758     -0.528507      0.528507       334.508       335.037    
   8  0.411427E-02  -5.49329      -3.72805       3.72805       334.032       337.760    
   9  0.904989     -0.998322E-01 -0.677516E-01  0.677516E-01   333.149       333.217    
  10  0.480311     -0.733322     -0.497672      0.497672       336.329       336.826    
  11  0.277870      -1.28060     -0.869085      0.869085       337.249       338.118    
  12  0.958372     -0.425196E-01 -0.288561E-01  0.288561E-01   338.524       338.553    
  13  0.321639      -1.13432     -0.769814      0.769814       338.856       339.625    
  14  0.562333     -0.575660     -0.390674      0.390674       339.281       339.672    
  15  0.665565     -0.407119     -0.276293      0.276293       340.722       340.999    
  16  0.307614      -1.17891     -0.800073      0.800073       341.103       341.903    
  17  0.504790E-01  -2.98620      -2.02660       2.02660       340.367       342.394    
  18  0.361959      -1.01622     -0.689665      0.689665       340.410       341.099    
  19  0.470787     -0.753350     -0.511265      0.511265       342.779       343.290    
  20  0.312221      -1.16404     -0.789983      0.789983       345.084       345.874    
  21  0.156792      -1.85283      -1.25743       1.25743       346.390       347.647    
  22  0.445216     -0.809196     -0.549164      0.549164       345.818       346.368    
  23  0.999492     -0.508321E-03 -0.344975E-03  0.344975E-03   347.058       347.058    
  24  0.167067      -1.78936      -1.21436       1.21436       347.298       348.512    
  25  0.435083     -0.832219     -0.564789      0.564789       350.741       351.306    
  26  0.110403      -2.20362      -1.49549       1.49549       350.361       351.857    
  27  0.704194     -0.350701     -0.238005      0.238005       351.812       352.050    
  28  0.767816     -0.264205     -0.179304      0.179304       352.327       352.507    
  29  0.231293      -1.46407     -0.993597      0.993597       351.138       352.132    
  30  0.965513     -0.350953E-01 -0.238176E-01  0.238176E-01   353.612       353.636    
  31  0.674440     -0.393873     -0.267303      0.267303       326.040       326.308    
loop,thermsimp(1:2)       90   1.37621      0.784487    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    285        320.05         73.57          0.98         38.79          0.77          0.05        114.17
Just calling func    0   0        114.17


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    286        649.40         73.75          0.99         38.77          0.32          0.05        113.88
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    320.05
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:       90
neval is:      285
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       90      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:       91
neval is:      285


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      285     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.920377     -0.829717E-01 -0.563091E-01  0.563091E-01   319.378       319.435    
   2  0.393393     -0.932946     -0.633148      0.633148       324.352       324.985    
   3  0.317218      -1.14817     -0.779208      0.779208       326.040       326.820    
   4  0.324247      -1.12625     -0.764334      0.764334       326.457       327.222    
   5  0.515746E-01  -2.96473      -2.01202       2.01202       327.638       329.651    
   6  0.143224      -1.94335      -1.31886       1.31886       331.222       332.541    
   7  0.512136     -0.669164     -0.454131      0.454131       333.149       333.603    
   8  0.993896     -0.612239E-02 -0.415499E-02  0.415499E-02   333.153       333.157    
   9  0.440900     -0.818937     -0.555775      0.555775       334.508       335.064    
  10  0.861233     -0.149390     -0.101384      0.101384       336.329       336.430    
  11  0.690005     -0.371056     -0.251819      0.251819       334.032       334.284    
  12  0.192792      -1.64614      -1.11716       1.11716       337.249       338.366    
  13  0.975175     -0.251388E-01 -0.170605E-01  0.170605E-01   338.524       338.541    
  14  0.595327E-01  -2.82123      -1.91464       1.91464       338.856       340.770    
  15  0.142661      -1.94729      -1.32153       1.32153       339.281       340.603    
  16  0.141610      -1.95468      -1.32655       1.32655       340.722       342.049    
  17  0.976591     -0.236872E-01 -0.160754E-01  0.160754E-01   340.410       340.426    
  18  0.894748     -0.111213     -0.754755E-01  0.754755E-01   341.103       341.178    
  19  0.747310     -0.291275     -0.197675      0.197675       340.367       340.565    
  20  0.434887     -0.832670     -0.565095      0.565095       342.779       343.344    
  21  0.673581     -0.395146     -0.268168      0.268168       345.084       345.353    
  22  0.624944     -0.470094     -0.319031      0.319031       345.818       346.138    
  23  0.617967     -0.481321     -0.326651      0.326651       347.058       347.384    
  24  0.659853     -0.415739     -0.282143      0.282143       346.390       346.672    
  25  0.963159E-01  -2.34012      -1.58813       1.58813       347.298       348.886    
  26  0.179190      -1.71931      -1.16682       1.16682       350.741       351.908    
  27  0.251042      -1.38213     -0.937991      0.937991       350.361       351.299    
  28  0.116711      -2.14806      -1.45779       1.45779       351.812       353.270    
  29  0.890376     -0.116112     -0.787997E-01  0.787997E-01   351.138       351.217    
  30  0.880065E-02  -4.73293      -3.21202       3.21202       352.327       355.539    
  31  0.613810     -0.488070     -0.331231      0.331231       320.048       320.379    
loop,thermsimp(1:2)       91  0.563091E-01  0.633148    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    287        316.14         73.96          1.01         39.11          0.42          0.06        114.55
Just calling func    0   0        114.55


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    288        415.59         74.34          1.03         38.69          0.21          0.05        114.31
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    316.14
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:       91
neval is:      287
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       91      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:       92
neval is:      287


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      287     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.313932      -1.15858     -0.786274      0.786274       319.378       320.165    
   2  0.484866     -0.723883     -0.491266      0.491266       320.048       320.539    
   3  0.743257     -0.296713     -0.201366      0.201366       324.352       324.553    
   4  0.476659     -0.740953     -0.502851      0.502851       326.040       326.543    
   5  0.895662E-01  -2.41278      -1.63744       1.63744       326.457       328.095    
   6  0.100541      -2.29719      -1.55899       1.55899       327.638       329.197    
   7  0.394309     -0.930621     -0.631570      0.631570       331.222       331.854    
   8  0.856201     -0.155250     -0.105361      0.105361       333.153       333.258    
   9  0.903325     -0.101673     -0.690009E-01  0.690009E-01   333.149       333.218    
  10  0.849389     -0.163238     -0.110782      0.110782       334.032       334.143    
  11  0.245876      -1.40293     -0.952104      0.952104       334.508       335.460    
  12  0.535664     -0.624247     -0.423648      0.423648       336.329       336.752    
  13  0.509317     -0.674685     -0.457878      0.457878       337.249       337.707    
  14  0.103141      -2.27166      -1.54167       1.54167       338.524       340.066    
  15  0.822327     -0.195617     -0.132756      0.132756       340.410       340.542    
  16  0.293454      -1.22603     -0.832053      0.832053       340.367       341.199    
  17  0.610098E-01  -2.79672      -1.89801       1.89801       339.281       341.179    
  18  0.467864E-01  -3.06216      -2.07815       2.07815       338.856       340.934    
  19  0.888641     -0.118062     -0.801231E-01  0.801231E-01   341.103       341.183    
  20  0.371769     -0.989482     -0.671516      0.671516       340.722       341.394    
  21  0.770202     -0.261103     -0.177198      0.177198       342.779       342.956    
  22  0.752967E-01  -2.58632      -1.75522       1.75522       345.084       346.840    
  23  0.787365E-01  -2.54165      -1.72490       1.72490       345.818       347.543    
  24  0.516026     -0.661597     -0.448996      0.448996       346.390       346.839    
  25  0.133613      -2.01281      -1.36600       1.36600       347.058       348.424    
  26  0.705575     -0.348742     -0.236676      0.236676       347.298       347.535    
  27  0.747326     -0.291254     -0.197661      0.197661       351.138       351.336    
  28  0.941066E-01  -2.36333      -1.60388       1.60388       350.361       351.965    
  29  0.243001      -1.41469     -0.960085      0.960085       350.741       351.701    
  30  0.186020      -1.68190      -1.14143       1.14143       351.812       352.954    
  31  0.707073     -0.346621     -0.235236      0.235236       316.139       316.375    
loop,thermsimp(1:2)       92  0.786274      0.491266    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    289        327.18         74.23          1.01         38.85          0.31          0.05        114.45
Just calling func    0   0        114.44


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    327.18
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:       92
neval is:      288
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       92      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:       93
neval is:      288


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      288     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.642285E-02  -5.04789      -3.42577       3.42577       316.139       319.565    
   2  0.977343     -0.229176E-01 -0.155532E-01  0.155532E-01   319.378       319.394    
   3  0.515611     -0.662402     -0.449542      0.449542       320.048       320.497    
   4  0.985018     -0.150949E-01 -0.102443E-01  0.102443E-01   324.352       324.362    
   5  0.909744E-01  -2.39718      -1.62686       1.62686       326.040       327.667    
   6  0.163485      -1.81103      -1.22907       1.22907       326.457       327.687    
   7  0.709610     -0.343039     -0.232805      0.232805       327.638       327.871    
   8  0.639309     -0.447368     -0.303608      0.303608       331.222       331.526    
   9  0.500633     -0.691882     -0.469549      0.469549       333.149       333.618    
  10  0.623218     -0.472859     -0.320908      0.320908       333.153       333.473    
  11  0.974620     -0.257075E-01 -0.174465E-01  0.174465E-01   334.032       334.049    
  12  0.940866     -0.609540E-01 -0.413667E-01  0.413667E-01   334.508       334.550    
  13  0.268848      -1.31361     -0.891486      0.891486       336.329       337.220    
  14  0.131404      -2.02948      -1.37731       1.37731       337.249       338.626    
  15  0.242045      -1.41863     -0.962761      0.962761       338.524       339.487    
  16  0.333489      -1.09815     -0.745262      0.745262       340.410       341.155    
  17  0.540917     -0.614489     -0.417026      0.417026       338.856       339.273    
  18  0.935945     -0.661981E-01 -0.449257E-01  0.449257E-01   339.281       339.326    
  19  0.948265     -0.531218E-01 -0.360513E-01  0.360513E-01   341.103       341.139    
  20  0.306672      -1.18198     -0.802154      0.802154       340.367       341.169    
  21  0.674766E-01  -2.69597      -1.82963       1.82963       340.722       342.552    
  22  0.304885      -1.18782     -0.806121      0.806121       342.779       343.585    
  23  0.987276     -0.128055E-01 -0.869048E-02  0.869048E-02   346.390       346.398    
  24  0.866309     -0.143514     -0.973964E-01  0.973964E-01   345.084       345.182    
  25  0.325072      -1.12371     -0.762609      0.762609       347.298       348.061    
  26  0.882651     -0.124826     -0.847136E-01  0.847136E-01   345.818       345.903    
  27  0.608994E-02  -5.10112      -3.46190       3.46190       347.058       350.520    
  28  0.956776     -0.441859E-01 -0.299869E-01  0.299869E-01   351.138       351.168    
  29  0.680690E-01  -2.68723      -1.82370       1.82370       350.741       352.565    
  30  0.870194     -0.139039     -0.943594E-01  0.943594E-01   350.361       350.455    
  31  0.154954      -1.86463      -1.26544       1.26544       327.179       328.444    
loop,thermsimp(1:2)       93   3.42577      0.155532E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    290        342.60         74.51          1.04         38.62          0.24          0.05        114.46
Just calling func    0   0        114.46


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    342.60
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:       93
neval is:      289
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       93      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:       94
neval is:      289


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      289     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.415683     -0.877831     -0.595744      0.595744       319.378       319.974    
   2  0.262668E-01  -3.63945      -2.46993       2.46993       316.139       318.609    
   3  0.620248     -0.477636     -0.324150      0.324150       320.048       320.372    
   4  0.249183      -1.38957     -0.943036      0.943036       324.352       325.295    
   5  0.999872     -0.128438E-03 -0.871648E-04  0.871648E-04   326.040       326.041    
   6  0.933252     -0.690802E-01 -0.468816E-01  0.468816E-01   326.457       326.504    
   7  0.857047     -0.154263     -0.104691      0.104691       327.638       327.743    
   8  0.365787      -1.00570     -0.682525      0.682525       327.179       327.861    
   9  0.499682     -0.693784     -0.470840      0.470840       331.222       331.693    
  10  0.761560     -0.272387     -0.184856      0.184856       333.153       333.337    
  11  0.793904E-01  -2.53338      -1.71929       1.71929       333.149       334.868    
  12  0.514449     -0.664659     -0.451073      0.451073       334.032       334.483    
  13  0.678176     -0.388349     -0.263555      0.263555       334.508       334.772    
  14  0.257558      -1.35651     -0.920602      0.920602       336.329       337.249    
  15  0.832067E-01  -2.48643      -1.68742       1.68742       337.249       338.936    
  16  0.272851      -1.29883     -0.881457      0.881457       338.856       339.737    
  17  0.255245      -1.36553     -0.926724      0.926724       339.281       340.208    
  18  0.419883     -0.867779     -0.588922      0.588922       338.524       339.113    
  19  0.870346     -0.138865     -0.942412E-01  0.942412E-01   341.103       341.197    
  20  0.814510E-01  -2.50775      -1.70190       1.70190       340.410       342.111    
  21  0.560000     -0.579819     -0.393497      0.393497       340.367       340.761    
  22  0.860285     -0.150492     -0.102132      0.102132       340.722       340.824    
  23  0.538601     -0.618780     -0.419938      0.419938       342.779       343.199    
  24  0.542321     -0.611898     -0.415267      0.415267       345.084       345.500    
  25  0.836575     -0.178440     -0.121099      0.121099       345.818       345.940    
  26  0.705694     -0.348574     -0.236561      0.236561       346.390       346.626    
  27  0.301063      -1.20043     -0.814680      0.814680       347.298       348.113    
  28  0.125899      -2.07227      -1.40636       1.40636       350.361       351.767    
  29  0.476747     -0.740770     -0.502727      0.502727       347.058       347.560    
  30  0.676103     -0.391410     -0.265632      0.265632       351.138       351.404    
  31  0.385349     -0.953606     -0.647169      0.647169       342.600       343.247    
loop,thermsimp(1:2)       94  0.595744       2.46993    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    291        381.89         74.10          1.03         38.93          0.36          0.05        114.47
Just calling func    0   0        114.47


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    292        331.54         74.16          1.02         38.86          0.45          0.05        114.54
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    331.54
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:       94
neval is:      291
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       94      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:       95
neval is:      291


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      291     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.292887      -1.22797     -0.833367      0.833367       316.139       316.973    
   2  0.225242      -1.49058      -1.01159       1.01159       319.378       320.390    
   3  0.946430E-01  -2.35764      -1.60002       1.60002       320.048       321.648    
   4  0.371694     -0.989684     -0.671653      0.671653       324.352       325.023    
   5  0.933291     -0.690381E-01 -0.468530E-01  0.468530E-01   326.040       326.087    
   6  0.926571     -0.762651E-01 -0.517576E-01  0.517576E-01   326.457       326.509    
   7  0.138048      -1.98015      -1.34384       1.34384       327.638       328.982    
   8  0.113008E-01  -4.48288      -3.04233       3.04233       327.179       330.221    
   9  0.405736     -0.902053     -0.612182      0.612182       331.222       331.835    
  10  0.390885     -0.939341     -0.637488      0.637488       333.153       333.790    
  11  0.873008     -0.135810     -0.921681E-01  0.921681E-01   334.032       334.124    
  12  0.945037     -0.565316E-01 -0.383654E-01  0.383654E-01   334.508       334.547    
  13  0.642194E-01  -2.74545      -1.86321       1.86321       333.149       335.012    
  14  0.322052E-01  -3.43563      -2.33160       2.33160       336.329       338.660    
  15  0.521559     -0.650933     -0.441758      0.441758       337.249       337.691    
  16  0.271788      -1.30273     -0.884106      0.884106       338.524       339.409    
  17  0.153503      -1.87403      -1.27182       1.27182       338.856       340.127    
  18  0.219303      -1.51730      -1.02972       1.02972       339.281       340.311    
  19  0.476616     -0.741044     -0.502913      0.502913       340.367       340.870    
  20  0.510024     -0.673297     -0.456936      0.456936       340.722       341.179    
  21  0.393388     -0.932959     -0.633157      0.633157       341.103       341.736    
  22  0.947927     -0.534776E-01 -0.362928E-01  0.362928E-01   340.410       340.446    
  23  0.472009     -0.750758     -0.509505      0.509505       342.779       343.289    
  24  0.678717     -0.387551     -0.263013      0.263013       342.600       342.863    
  25  0.617620     -0.481882     -0.327032      0.327032       345.084       345.411    
  26  0.138594E-01  -4.27879      -2.90382       2.90382       345.818       348.722    
  27  0.588445     -0.530273     -0.359872      0.359872       346.390       346.750    
  28  0.950805     -0.504465E-01 -0.342357E-01  0.342357E-01   347.058       347.092    
  29  0.444108     -0.811687     -0.550855      0.550855       347.298       347.849    
  30  0.299195      -1.20666     -0.818905      0.818905       351.138       351.957    
  31  0.808517E-01  -2.51514      -1.70691       1.70691       331.538       333.245    
loop,thermsimp(1:2)       95  0.833367       1.01159    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    293        330.59         74.30          1.02         38.95          0.12          0.05        114.45
Just calling func    0   0        114.45


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    330.59
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:       95
neval is:      292
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       95      95
 right before GO TO 250



 right after: 250 IF (loop < nloop) CYCLE Main_loop 
loop,nloop:       95      95
loop was equal to nloop so did not start main cycle again, now will do the following: 




calculate mean & stdev of func values for current simplex (hmean,hstd)
 write hstd
 RMS of function values of last simplex =   8.42973    

hmean,hstd :    335.010       8.42973    


writing best so far by calling functn2 
 but just writing params not moments. see the change in functn2
hmean,hstd :    335.010       8.42973    
h(1),h(best1),h(np1) :    316.139       316.139       330.594    
htherm(1),htherm(best1),htherm(np1) :    316.973       316.973       351.957    


 CHECK hstd>?stopcr
---------> IF hstd>stopcr (and maxfn,neval.nevalp conditions as well) then set iflag and loop to zero and go to the start of the main cycle again 
---------> IF hstd<=stopcr then find the centroid of the current simplex and get the function value there 
 ............
 ............
 ............
 ............
  .NOT. (hstd > stopcr .AND. (((maxfn>=0).AND.(neval <= maxfn)).OR.((maxfn<0).AND.(nevalp <= -1*maxfn))  )) 
  so find the centroid of current simplex and get teh function value there 
  call functn(p,func) 
  neval = neval + 1
  nevalp = nevalp + 1
  IF ((iprint > 0).AND.(realrank==0)) THEN 
     IF (MOD(neval,iprint) == 0) WRITE (lout,5100) neval, func, p 
  END IF  
  CHECK wtr the no. of func values allowed, maxfn, has been overrun. if so, exit with ifault= 1 
  IF maxfn>0 check based on neval. if maxfn<0 check based on nevalp. 
  i.e.: ---->IF (((maxfn>=0).AND.(neval > maxfn)).OR.((maxfn<0).AND.(nevalp > -1*maxfn))) THEN
        ---->IF the above if statement true then something ... RETURN 
        ---->IF the above if statement not true then you get out of that if statement ... CONVGENCE CRTI SATISFIED - RETURN 
 ............
 ............
iter,obj,time:    294        325.82         74.23          0.99         38.93          0.42          0.05        114.62

 EVIDENCE OF CONVERGENCE
 Centroid of last simplex =
    1.9640      -1.1701       5.9274      -102.29       1.0533     -0.17763    
    3.8241      -100.19       4.0282       1.3241       1.7440      -1.0120    
    1.3961       0.0000       0.0000      -1.2218       0.0000       0.0000    
    0.0000      -1.2210      -2.5000       15218.       13544.      -3726.4    

   -53274.      -2.0000      -5.6453      -6.7449      -7.3108       2.9622    
   -13.541      -2.9431       1521.8       0.0000       2659.4       3281.5    
    4343.7       3225.9       5995.8       2193.2       2108.2      0.58158E-01
  -0.56419E-01   0.0000     -0.17093     -0.11303     -0.16811     -0.72237E-01

  -0.20206     -0.34079E-01  -1.5118      -1.0972       0.0000     -0.33624E-01
  -0.19330E-01  0.85411E-01  0.26888E-01 -0.34478E-01 -0.36012     -0.15909    
  -0.54354E-01 -0.77284E-01 -0.10804     -0.87040       0.0000      -1.9778    
   -1.8736       5.5136       1.9364       0.0000       0.0000       9.2048    

    9.1239       16326.       1.0000     -0.57872     -0.74786       9.3978    
    8.5477      -506.23       1.0000      0.68826E-01 -0.52042       8.7527    
    9.0278      -7128.6       1.0000     -0.69042     -0.23726       10.116    
    8.4594      -2990.2       1.0000    
 Function value at centroid =   325.823    

beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:        1
neval is:      293


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      293     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.195490      -1.63225      -1.10773       1.10773       316.139       317.247    
   2  0.313379      -1.16034     -0.787471      0.787471       319.378       320.166    
   3  0.769177     -0.262434     -0.178102      0.178102       320.048       320.226    
   4  0.884560E-01  -2.42525      -1.64591       1.64591       324.352       325.998    
   5  0.890596     -0.115865     -0.786322E-01  0.786322E-01   326.040       326.119    
   6  0.657268     -0.419664     -0.284807      0.284807       326.457       326.742    
   7  0.960898     -0.398874E-01 -0.270697E-01  0.270697E-01   327.638       327.666    
   8  0.613422E-01  -2.79129      -1.89432       1.89432       327.179       329.073    
   9  0.264483E-01  -3.63256      -2.46526       2.46526       331.222       333.688    
  10  0.304822      -1.18803     -0.806261      0.806261       331.538       332.345    
  11  0.977907     -0.223409E-01 -0.151617E-01  0.151617E-01   333.153       333.168    
  12  0.746737     -0.292042     -0.198196      0.198196       334.032       334.230    
  13  0.450918E-01  -3.09905      -2.10319       2.10319       334.508       336.611    
  14  0.625433     -0.469311     -0.318500      0.318500       333.149       333.467    
  15  0.990029     -0.100208E-01 -0.680064E-02  0.680064E-02   337.249       337.256    
  16  0.985060     -0.150527E-01 -0.102156E-01  0.102156E-01   336.329       336.339    
  17  0.691362     -0.369092     -0.250486      0.250486       338.524       338.775    
  18  0.864323E-02  -4.75098      -3.22427       3.22427       338.856       342.080    
  19  0.908027E-01  -2.39907      -1.62814       1.62814       339.281       340.910    
  20  0.500093     -0.692962     -0.470281      0.470281       340.410       340.880    
  21  0.806913     -0.214539     -0.145598      0.145598       340.367       340.513    
  22  0.317749      -1.14649     -0.778073      0.778073       340.722       341.500    
  23  0.753050     -0.283623     -0.192482      0.192482       341.103       341.295    
  24  0.850048     -0.162463     -0.110256      0.110256       342.600       342.710    
  25  0.346718      -1.05924     -0.718859      0.718859       342.779       343.498    
  26  0.731558     -0.312579     -0.212133      0.212133       345.084       345.297    
  27  0.226645      -1.48437      -1.00738       1.00738       346.390       347.397    
  28  0.887805     -0.119003     -0.807617E-01  0.807617E-01   347.058       347.138    
  29  0.277731      -1.28110     -0.869427      0.869427       347.298       348.168    
  30  0.914814     -0.890349E-01 -0.604239E-01  0.604239E-01   345.818       345.879    
  31  0.298911      -1.20761     -0.819550      0.819550       330.594       331.414    
loop,thermsimp(1:2)        1   1.10773      0.787471    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    295        320.29         74.01          1.00         39.02          0.46          0.05        114.54
Just calling func    0   0        114.54


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    320.29
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:        1
neval is:      294
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        1      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:        2
neval is:      294


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      294     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.233544      -1.45438     -0.987023      0.987023       316.139       317.126    
   2  0.293881      -1.22458     -0.831067      0.831067       319.378       320.210    
   3  0.833435     -0.182199     -0.123650      0.123650       320.048       320.171    
   4  0.931284     -0.711905E-01 -0.483137E-01  0.483137E-01   324.352       324.400    
   5  0.965536     -0.350722E-01 -0.238019E-01  0.238019E-01   326.040       326.064    
   6  0.534034     -0.627296     -0.425717      0.425717       326.457       326.883    
   7  0.975689     -0.246118E-01 -0.167029E-01  0.167029E-01   327.638       327.655    
   8  0.958131     -0.427704E-01 -0.290264E-01  0.290264E-01   327.179       327.208    
   9  0.487835     -0.717779     -0.487124      0.487124       330.594       331.082    
  10  0.941751     -0.600144E-01 -0.407290E-01  0.407290E-01   331.538       331.579    
  11  0.764698     -0.268274     -0.182065      0.182065       333.153       333.335    
  12  0.282403      -1.26442     -0.858104      0.858104       333.149       334.007    
  13  0.694349     -0.364781     -0.247560      0.247560       331.222       331.470    
  14  0.257622      -1.35626     -0.920433      0.920433       334.032       334.952    
  15  0.401572     -0.912369     -0.619183      0.619183       336.329       336.948    
  16  0.828654     -0.187952     -0.127554      0.127554       334.508       334.636    
  17  0.113844      -2.17292      -1.47466       1.47466       337.249       338.724    
  18  0.383967     -0.957199     -0.649607      0.649607       338.524       339.174    
  19  0.767294     -0.264886     -0.179766      0.179766       340.367       340.547    
  20  0.230085      -1.46930     -0.997150      0.997150       340.410       341.407    
  21  0.248551      -1.39211     -0.944760      0.944760       339.281       340.226    
  22  0.739043     -0.302399     -0.205224      0.205224       341.103       341.308    
  23  0.427702     -0.849328     -0.576400      0.576400       340.722       341.299    
  24  0.217549      -1.52533      -1.03517       1.03517       338.856       339.891    
  25  0.126759      -2.06546      -1.40174       1.40174       342.600       344.002    
  26  0.278624      -1.27789     -0.867248      0.867248       342.779       343.646    
  27  0.736668     -0.305618     -0.207409      0.207409       345.084       345.292    
  28  0.183809      -1.69386      -1.14954       1.14954       345.818       346.968    
  29  0.915242     -0.885666E-01 -0.601061E-01  0.601061E-01   347.058       347.118    
  30  0.864610     -0.145477     -0.987285E-01  0.987285E-01   346.390       346.488    
  31  0.996457     -0.354911E-02 -0.240862E-02  0.240862E-02   320.293       320.296    
loop,thermsimp(1:2)        2  0.987023      0.831067    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    296        318.42         73.99          0.99         38.87          0.74          0.05        114.64
Just calling func    0   0        114.64


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    318.42
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:        2
neval is:      295
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        2      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:        3
neval is:      295


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      295     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.402951     -0.908939     -0.616856      0.616856       316.139       316.756    
   2  0.995767     -0.424237E-02 -0.287910E-02  0.287910E-02   320.048       320.051    
   3  0.232708      -1.45797     -0.989458      0.989458       319.378       320.368    
   4  0.844104     -0.169480     -0.115018      0.115018       320.293       320.408    
   5  0.835080     -0.180228     -0.122312      0.122312       324.352       324.474    
   6  0.492927     -0.707395     -0.480077      0.480077       326.040       326.521    
   7  0.669838     -0.400719     -0.271949      0.271949       326.457       326.729    
   8  0.161727      -1.82184      -1.23640       1.23640       327.179       328.415    
   9  0.712877     -0.338447     -0.229688      0.229688       327.638       327.868    
  10  0.187101      -1.67610      -1.13750       1.13750       330.594       331.732    
  11  0.152475      -1.88075      -1.27638       1.27638       331.222       332.499    
  12  0.299805      -1.20462     -0.817522      0.817522       331.538       332.356    
  13  0.388928     -0.944360     -0.640894      0.640894       333.153       333.793    
  14  0.396030     -0.926264     -0.628613      0.628613       333.149       333.777    
  15  0.795332     -0.228996     -0.155409      0.155409       334.508       334.664    
  16  0.209301      -1.56398      -1.06140       1.06140       334.032       335.093    
  17  0.292717      -1.22855     -0.833761      0.833761       336.329       337.162    
  18  0.128603E-01  -4.35361      -2.95459       2.95459       337.249       340.203    
  19  0.386579E-01  -3.25301      -2.20767       2.20767       338.524       340.732    
  20  0.284417      -1.25731     -0.853282      0.853282       338.856       339.709    
  21  0.962037     -0.387027E-01 -0.262657E-01  0.262657E-01   339.281       339.308    
  22  0.340824      -1.07639     -0.730495      0.730495       340.367       341.098    
  23  0.463892     -0.768103     -0.521277      0.521277       340.722       341.244    
  24  0.772349     -0.258319     -0.175309      0.175309       341.103       341.278    
  25  0.580884     -0.543204     -0.368648      0.368648       340.410       340.778    
  26  0.519264     -0.655343     -0.444751      0.444751       342.779       343.224    
  27  0.336321      -1.08969     -0.739523      0.739523       342.600       343.340    
  28  0.975360     -0.249491E-01 -0.169318E-01  0.169318E-01   345.084       345.101    
  29  0.768530     -0.263276     -0.178673      0.178673       346.390       346.568    
  30  0.536540     -0.622614     -0.422539      0.422539       345.818       346.241    
  31  0.922732     -0.804161E-01 -0.545747E-01  0.545747E-01   318.423       318.478    
loop,thermsimp(1:2)        3  0.616856      0.287910E-02

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    297        331.49         73.88          0.98         39.00          0.73          0.05        114.65
Just calling func    0   0        114.65


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    331.49
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:        3
neval is:      296
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        3      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:        4
neval is:      296


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      296     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.344716      -1.06504     -0.722791      0.722791       316.139       316.862    
   2  0.337825      -1.08523     -0.736494      0.736494       318.423       319.159    
   3  0.129257      -2.04595      -1.38849       1.38849       320.048       321.436    
   4  0.218013      -1.52320      -1.03373       1.03373       319.378       320.412    
   5  0.764988     -0.267896     -0.181808      0.181808       320.293       320.475    
   6  0.134235      -2.00816      -1.36285       1.36285       324.352       325.715    
   7  0.921891     -0.813288E-01 -0.551941E-01  0.551941E-01   326.040       326.096    
   8  0.879140E-01  -2.43140      -1.65008       1.65008       326.457       328.108    
   9  0.853506     -0.158403     -0.107501      0.107501       327.638       327.746    
  10  0.781888     -0.246043     -0.166978      0.166978       327.179       327.346    
  11  0.572060     -0.558512     -0.379037      0.379037       330.594       330.974    
  12  0.370929     -0.991745     -0.673052      0.673052       331.538       332.211    
  13  0.659208     -0.416716     -0.282806      0.282806       331.222       331.505    
  14  0.192080      -1.64984      -1.11967       1.11967       333.149       334.269    
  15  0.834249     -0.181224     -0.122988      0.122988       333.153       333.275    
  16  0.275735      -1.28831     -0.874320      0.874320       334.508       335.382    
  17  0.899896     -0.105476     -0.715816E-01  0.715816E-01   334.032       334.104    
  18  0.263842      -1.33241     -0.904243      0.904243       336.329       337.233    
  19  0.542051     -0.612396     -0.415605      0.415605       339.281       339.697    
  20  0.883103     -0.124314     -0.843660E-01  0.843660E-01   338.856       338.940    
  21  0.603547     -0.504931     -0.342674      0.342674       337.249       337.592    
  22  0.461006     -0.774344     -0.525512      0.525512       338.524       339.050    
  23  0.640920     -0.444850     -0.301899      0.301899       340.410       340.711    
  24  0.787319     -0.239122     -0.162281      0.162281       340.367       340.529    
  25  0.258775E-01  -3.65438      -2.48006       2.48006       340.722       343.202    
  26  0.838926     -0.175633     -0.119194      0.119194       341.103       341.222    
  27  0.184807      -1.68845      -1.14587       1.14587       342.779       343.925    
  28  0.642750     -0.441999     -0.299965      0.299965       342.600       342.900    
  29  0.962815     -0.378938E-01 -0.257168E-01  0.257168E-01   345.084       345.110    
  30  0.866393     -0.143417     -0.973303E-01  0.973303E-01   345.818       345.916    
  31  0.652626     -0.426751     -0.289616      0.289616       331.494       331.784    
loop,thermsimp(1:2)        4  0.722791      0.736494    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    298        340.75         74.37          1.04         38.95          0.34          0.05        114.74
Just calling func    0   0        114.74


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    340.75
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:        4
neval is:      297
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        4      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:        5
neval is:      297


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      297     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.993880     -0.613850E-02 -0.416592E-02  0.416592E-02   316.139       316.143    
   2  0.544036     -0.608740     -0.413124      0.413124       318.423       318.836    
   3  0.752151     -0.284818     -0.193293      0.193293       319.378       319.572    
   4  0.128894      -2.04876      -1.39040       1.39040       320.293       321.684    
   5  0.954586     -0.464781E-01 -0.315425E-01  0.315425E-01   320.048       320.079    
   6  0.699109     -0.357949     -0.242924      0.242924       324.352       324.595    
   7  0.158831      -1.83992      -1.24867       1.24867       326.040       327.289    
   8  0.317803      -1.14632     -0.777957      0.777957       327.179       327.957    
   9  0.533633     -0.628047     -0.426227      0.426227       327.638       328.065    
  10  0.232061      -1.46076     -0.991349      0.991349       326.457       327.449    
  11  0.798671     -0.224806     -0.152565      0.152565       330.594       330.747    
  12  0.629719     -0.462482     -0.313865      0.313865       331.222       331.536    
  13  0.285415      -1.25381     -0.850904      0.850904       331.494       332.345    
  14  0.101345      -2.28923      -1.55359       1.55359       331.538       333.092    
  15  0.523846     -0.646557     -0.438789      0.438789       333.153       333.591    
  16  0.570798     -0.560721     -0.380536      0.380536       334.032       334.412    
  17  0.471006     -0.752884     -0.510948      0.510948       333.149       333.660    
  18  0.439034     -0.823179     -0.558654      0.558654       334.508       335.067    
  19  0.755118     -0.280881     -0.190621      0.190621       336.329       336.519    
  20  0.987033     -0.130515E-01 -0.885745E-02  0.885745E-02   337.249       337.258    
  21  0.800390E-01  -2.52524      -1.71377       1.71377       338.856       340.569    
  22  0.739282     -0.302075     -0.205005      0.205005       338.524       338.729    
  23  0.367536      -1.00093     -0.679288      0.679288       339.281       339.961    
  24  0.397431     -0.922735     -0.626218      0.626218       340.367       340.993    
  25  0.338773      -1.08242     -0.734592      0.734592       340.410       341.144    
  26  0.388721     -0.944893     -0.641256      0.641256       341.103       341.744    
  27  0.298998      -1.20732     -0.819351      0.819351       342.600       343.420    
  28  0.668470     -0.402763     -0.273337      0.273337       340.722       340.996    
  29  0.604587     -0.503210     -0.341506      0.341506       342.779       343.121    
  30  0.455577     -0.786190     -0.533552      0.533552       345.084       345.618    
  31  0.842360     -0.171548     -0.116422      0.116422       340.747       340.864    
loop,thermsimp(1:2)        5  0.416592E-02  0.413124    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    299        340.77         74.27          1.03         38.59          0.75          0.05        114.69
Just calling func    0   0        114.69


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    340.77
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:        5
neval is:      298
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        5      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:        6
neval is:      298


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      298     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.342475      -1.07156     -0.727217      0.727217       316.139       316.867    
   2  0.738210     -0.303527     -0.205990      0.205990       318.423       318.629    
   3  0.254388      -1.36889     -0.929006      0.929006       319.378       320.307    
   4  0.184184      -1.69182      -1.14816       1.14816       320.048       321.196    
   5  0.467311     -0.760760     -0.516293      0.516293       320.293       320.809    
   6  0.718957     -0.329953     -0.223924      0.223924       324.352       324.576    
   7  0.233172      -1.45598     -0.988105      0.988105       326.040       327.029    
   8  0.855319     -0.156281     -0.106061      0.106061       326.457       326.564    
   9  0.331323      -1.10466     -0.749683      0.749683       327.179       327.928    
  10  0.737635E-01  -2.60689      -1.76918       1.76918       327.638       329.408    
  11  0.960656     -0.401393E-01 -0.272407E-01  0.272407E-01   330.594       330.622    
  12  0.312287      -1.16383     -0.789840      0.789840       331.222       332.012    
  13  0.252190      -1.37757     -0.934894      0.934894       331.494       332.429    
  14  0.775876     -0.253763     -0.172217      0.172217       331.538       331.711    
  15  0.397248     -0.923194     -0.626530      0.626530       333.153       333.779    
  16  0.587084E-01  -2.83517      -1.92410       1.92410       333.149       335.073    
  17  0.923214     -0.798941E-01 -0.542204E-01  0.542204E-01   334.032       334.086    
  18  0.147001      -1.91731      -1.30119       1.30119       334.508       335.809    
  19  0.275551      -1.28898     -0.874774      0.874774       336.329       337.203    
  20  0.157032      -1.85131      -1.25640       1.25640       337.249       338.505    
  21  0.468534     -0.758146     -0.514519      0.514519       338.524       339.039    
  22  0.101055      -2.29209      -1.55554       1.55554       339.281       340.837    
  23  0.891765     -0.114553     -0.777416E-01  0.777416E-01   338.856       338.933    
  24  0.756241     -0.279395     -0.189613      0.189613       340.747       340.937    
  25  0.212181E-01  -3.85290      -2.61479       2.61479       340.367       342.982    
  26  0.807607     -0.213679     -0.145014      0.145014       340.722       340.867    
  27  0.233854      -1.45306     -0.986124      0.986124       340.410       341.396    
  28  0.622600     -0.473852     -0.321582      0.321582       341.103       341.424    
  29  0.188561      -1.66833      -1.13222       1.13222       342.779       343.911    
  30  0.938432E-01  -2.36613      -1.60578       1.60578       342.600       344.206    
  31  0.846333     -0.166843     -0.113228      0.113228       340.769       340.882    
loop,thermsimp(1:2)        6  0.727217      0.205990    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    300        352.86         73.42          1.00         38.62          0.64          0.05        113.73
Just calling func    0   0        113.74


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    301        330.34         73.56          0.95         38.59          0.74          0.05        113.88
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  300    330.34        1.940    -0.6726      6.305     -102.6      1.113    
                      0.1192      4.209     -100.3      4.404      1.245    
                       1.934     -1.056      1.148      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1579E+05 0.1439E+05 -4509.    -0.6197E+05
                      -2.000     -5.280     -6.976     -7.423     0.8700    
                      -14.31     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                      -2.210     -2.292      5.681      1.857      0.000    
                       0.000      9.205      9.124     0.1675E+05  1.000    
                     -0.5787    -0.7479      9.398      8.548      615.6    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -8147.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -3122.      1.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    330.34
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:        6
neval is:      300
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        6      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:        7
neval is:      300


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      300     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.667416     -0.404342     -0.274409      0.274409       316.139       316.414    
   2  0.361364E-01  -3.32046      -2.25344       2.25344       318.423       320.676    
   3  0.167171      -1.78874      -1.21393       1.21393       319.378       320.592    
   4  0.268590E-01  -3.61716      -2.45480       2.45480       320.293       322.748    
   5  0.979339     -0.208774E-01 -0.141685E-01  0.141685E-01   320.048       320.062    
   6  0.285956E-01  -3.55450      -2.41228       2.41228       324.352       326.764    
   7  0.614036     -0.487701     -0.330981      0.330981       326.457       326.788    
   8  0.291622      -1.23230     -0.836303      0.836303       326.040       326.877    
   9  0.495778     -0.701626     -0.476162      0.476162       327.179       327.655    
  10  0.289385      -1.24000     -0.841530      0.841530       327.638       328.480    
  11  0.601390     -0.508511     -0.345103      0.345103       330.594       330.940    
  12  0.868837     -0.140599     -0.954183E-01  0.954183E-01   331.538       331.634    
  13  0.289097E-01  -3.54358      -2.40486       2.40486       331.222       333.627    
  14  0.999895     -0.104574E-03 -0.709699E-04  0.709699E-04   331.494       331.494    
  15  0.547924     -0.601620     -0.408292      0.408292       333.153       333.561    
  16  0.562607     -0.575175     -0.390345      0.390345       334.032       334.422    
  17  0.422387     -0.861832     -0.584886      0.584886       333.149       333.734    
  18  0.934703     -0.675264E-01 -0.458271E-01  0.458271E-01   334.508       334.554    
  19  0.484044     -0.725579     -0.492417      0.492417       336.329       336.821    
  20  0.362136      -1.01574     -0.689333      0.689333       337.249       337.938    
  21  0.826677     -0.190341     -0.129176      0.129176       338.856       338.985    
  22  0.383965     -0.957204     -0.649611      0.649611       338.524       339.174    
  23  0.403854     -0.906702     -0.615337      0.615337       339.281       339.897    
  24  0.375365     -0.979857     -0.664984      0.664984       340.722       341.387    
  25  0.335540      -1.09201     -0.741100      0.741100       340.769       341.510    
  26  0.744256     -0.295370     -0.200454      0.200454       340.747       340.948    
  27  0.611040     -0.492593     -0.334300      0.334300       340.410       340.744    
  28  0.361728      -1.01686     -0.690098      0.690098       341.103       341.793    
  29  0.381582     -0.963430     -0.653836      0.653836       340.367       341.021    
  30  0.738884E-01  -2.60520      -1.76803       1.76803       342.779       344.547    
  31  0.185722E-01  -3.98609      -2.70518       2.70518       330.339       333.045    
loop,thermsimp(1:2)        7  0.274409       2.25344    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    302        319.66         73.91          0.98         38.71          0.88          0.05        114.52
Just calling func    0   0        114.52


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    319.66
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:        7
neval is:      301
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        7      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:        8
neval is:      301


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      301
neval,tstepnext:      301     301

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.832859     -0.182891     -0.124120      0.124120       316.139       316.263    
   2  0.610299     -0.493806     -0.335124      0.335124       320.048       320.383    
   3  0.652915     -0.426308     -0.289316      0.289316       319.378       319.668    
   4  0.273016      -1.29823     -0.881046      0.881046       318.423       319.304    
   5  0.570853     -0.560623     -0.380469      0.380469       320.293       320.674    
   6  0.107477E-01  -4.53306      -3.07638       3.07638       324.352       327.428    
   7  0.651717     -0.428145     -0.290562      0.290562       326.457       326.748    
   8  0.214404      -1.53989      -1.04506       1.04506       326.040       327.086    
   9  0.132680      -2.01982      -1.37076       1.37076       327.179       328.550    
  10  0.370727     -0.992290     -0.673422      0.673422       327.638       328.312    
  11  0.330444      -1.10732     -0.751486      0.751486       330.594       331.346    
  12  0.462713     -0.770647     -0.523003      0.523003       331.494       332.017    
  13  0.514022     -0.665489     -0.451637      0.451637       331.538       331.990    
  14  0.644984     -0.438530     -0.297611      0.297611       330.339       330.637    
  15  0.813975     -0.205826     -0.139685      0.139685       333.153       333.292    
  16  0.434803     -0.832863     -0.565226      0.565226       331.222       331.788    
  17  0.212985      -1.54653      -1.04956       1.04956       333.149       334.198    
  18  0.796179     -0.227931     -0.154686      0.154686       334.032       334.187    
  19  0.259948      -1.34727     -0.914333      0.914333       334.508       335.422    
  20  0.526723     -0.641081     -0.435073      0.435073       336.329       336.764    
  21  0.392691     -0.934731     -0.634359      0.634359       337.249       337.883    
  22  0.949472     -0.518494E-01 -0.351878E-01  0.351878E-01   338.856       338.891    
  23  0.665479E-01  -2.70983      -1.83904       1.83904       338.524       340.363    
  24  0.927466E-01  -2.37788      -1.61376       1.61376       339.281       340.895    
  25  0.630503     -0.461237     -0.313020      0.313020       340.410       340.723    
  26  0.714749     -0.335823     -0.227908      0.227908       340.747       340.975    
  27  0.450999     -0.796290     -0.540406      0.540406       340.367       340.908    
  28  0.184997      -1.68742      -1.14517       1.14517       340.722       341.868    
  29  0.989607     -0.104473E-01 -0.709012E-02  0.709012E-02   340.769       340.776    
  30  0.530766     -0.633434     -0.429883      0.429883       341.103       341.533    
  31  0.495227     -0.702738     -0.476916      0.476916       319.658       320.135    
loop,thermsimp(1:2)        8  0.124120      0.335124    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    303        327.80         74.02          0.99         38.73          0.62          0.05        114.40
Just calling func    0   0        114.40


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    327.80
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.678654               301
loop is:        8
neval is:      302
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        8      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.678654               301
loop is:        9
neval is:      302


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 




neval>tstepnex so lower away!t
---> lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
     new SAtemp,tstepnext are :   0.339327               331

 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      331
neval,tstepnext:      302     331

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.193078      -1.64466     -0.558078      0.558078       316.139       316.697    
   2  0.822950     -0.194860     -0.661213E-01  0.661213E-01   318.423       318.489    
   3  0.396787     -0.924357     -0.313659      0.313659       319.378       319.692    
   4  0.141060      -1.95857     -0.664596      0.664596       319.658       320.323    
   5  0.673747     -0.394901     -0.134001      0.134001       320.048       320.182    
   6  0.142835      -1.94606     -0.660352      0.660352       320.293       320.953    
   7  0.707555     -0.345940     -0.117387      0.117387       326.457       326.575    
   8  0.957483     -0.434474E-01 -0.147429E-01  0.147429E-01   326.040       326.055    
   9  0.524586     -0.645145     -0.218915      0.218915       324.352       324.571    
  10  0.692024     -0.368135     -0.124918      0.124918       327.638       327.763    
  11  0.936675E-01  -2.36800     -0.803528      0.803528       327.179       327.982    
  12  0.216270      -1.53123     -0.519587      0.519587       330.339       330.859    
  13  0.329369      -1.11058     -0.376849      0.376849       330.594       330.971    
  14  0.670774     -0.399323     -0.135501      0.135501       331.222       331.358    
  15  0.263445      -1.33391     -0.452632      0.452632       331.538       331.991    
  16  0.150248      -1.89547     -0.643184      0.643184       331.494       332.137    
  17  0.357034      -1.02992     -0.349481      0.349481       333.153       333.502    
  18  0.833286E-01  -2.48496     -0.843216      0.843216       334.032       334.875    
  19  0.431395     -0.840731     -0.285283      0.285283       333.149       333.434    
  20  0.304550      -1.18892     -0.403433      0.403433       334.508       334.912    
  21  0.930203     -0.723520E-01 -0.245510E-01  0.245510E-01   336.329       336.353    
  22  0.443091     -0.813979     -0.276205      0.276205       337.249       337.525    
  23  0.361548      -1.01736     -0.345218      0.345218       338.856       339.201    
  24  0.603851     -0.504427     -0.171166      0.171166       338.524       338.696    
  25  0.825014     -0.192355     -0.652712E-01  0.652712E-01   340.410       340.475    
  26  0.658742     -0.417424     -0.141643      0.141643       340.769       340.911    
  27  0.938632     -0.633319E-01 -0.214902E-01  0.214902E-01   339.281       339.303    
  28  0.264383E-01  -3.63294      -1.23276       1.23276       340.367       341.600    
  29  0.770543     -0.260660     -0.884491E-01  0.884491E-01   340.747       340.836    
  30  0.536385     -0.622903     -0.211368      0.211368       341.103       341.314    
  31  0.173997      -1.74872     -0.593388      0.593388       327.800       328.394    
loop,thermsimp(1:2)        9  0.558078      0.661213E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    304        332.32         74.03          0.99         38.73          0.80          0.05        114.60
Just calling func    0   0        114.60


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    332.32
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.339327               331
loop is:        9
neval is:      303
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        9      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.339327               331
loop is:       10
neval is:      303


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      331
neval,tstepnext:      303     331

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.516123     -0.661410     -0.224434      0.224434       316.139       316.364    
   2  0.677402     -0.389491     -0.132165      0.132165       318.423       318.555    
   3  0.899541     -0.105871     -0.359248E-01  0.359248E-01   319.378       319.414    
   4  0.235706      -1.44517     -0.490385      0.490385       320.048       320.538    
   5  0.194769      -1.63594     -0.555120      0.555120       319.658       320.213    
   6  0.814930     -0.204653     -0.694443E-01  0.694443E-01   320.293       320.363    
   7  0.727423E-01  -2.62083     -0.889320      0.889320       324.352       325.241    
   8  0.126759      -2.06547     -0.700870      0.700870       326.040       326.741    
   9  0.592876     -0.522770     -0.177390      0.177390       326.457       326.635    
  10  0.131380      -2.02966     -0.688720      0.688720       327.638       328.327    
  11  0.394760E-01  -3.23206      -1.09673       1.09673       327.179       328.275    
  12  0.539964     -0.616252     -0.209111      0.209111       327.800       328.009    
  13  0.127256      -2.06155     -0.699541      0.699541       330.339       331.039    
  14  0.245583      -1.40412     -0.476456      0.476456       330.594       331.071    
  15  0.236145E-01  -3.74590      -1.27108       1.27108       331.222       332.494    
  16  0.791943     -0.233266     -0.791534E-01  0.791534E-01   331.538       331.617    
  17  0.223014      -1.50052     -0.509168      0.509168       331.494       332.003    
  18  0.943370     -0.582970E-01 -0.197817E-01  0.197817E-01   333.149       333.169    
  19  0.844237     -0.169322     -0.574555E-01  0.574555E-01   333.153       333.210    
  20  0.600301     -0.510323     -0.173167      0.173167       334.032       334.205    
  21  0.742625E-01  -2.60015     -0.882301      0.882301       334.508       335.390    
  22  0.288925E-01  -3.54417      -1.20263       1.20263       336.329       337.531    
  23  0.325834      -1.12137     -0.380510      0.380510       337.249       337.629    
  24  0.317147      -1.14839     -0.389680      0.389680       338.524       338.914    
  25  0.655873     -0.421788     -0.143124      0.143124       338.856       338.999    
  26  0.259034      -1.35080     -0.458362      0.458362       339.281       339.740    
  27  0.639742E-01  -2.74927     -0.932904      0.932904       340.410       341.342    
  28  0.110416E-01  -4.50609      -1.52904       1.52904       340.747       342.276    
  29  0.768965E-01  -2.56529     -0.870474      0.870474       340.769       341.640    
  30  0.757182     -0.278151     -0.943843E-01  0.943843E-01   341.103       341.197    
  31  0.788615     -0.237477     -0.805823E-01  0.805823E-01   332.316       332.396    
loop,thermsimp(1:2)       10  0.224434      0.132165    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    305        308.31         73.60          0.97         38.90          0.68          0.06        114.22
Just calling func    0   0        114.22


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    306       5326.62         74.04          1.05         38.66          0.01          0.05        113.81
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    308.31
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.339327               331
loop is:       10
neval is:      305
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       10      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.339327               331
loop is:       11
neval is:      305


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      331
neval,tstepnext:      305     331

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.737263     -0.304811     -0.103431      0.103431       316.139       316.243    
   2  0.372515     -0.987477     -0.335078      0.335078       318.423       318.758    
   3  0.197611E-01  -3.92404      -1.33153       1.33153       319.378       320.710    
   4  0.939239     -0.626858E-01 -0.212710E-01  0.212710E-01   319.658       319.679    
   5  0.212506      -1.54879     -0.525545      0.525545       320.293       320.819    
   6  0.141762      -1.95360     -0.662911      0.662911       320.048       320.711    
   7  0.183632      -1.69482     -0.575100      0.575100       324.352       324.927    
   8  0.479067     -0.735915     -0.249716      0.249716       326.457       326.707    
   9  0.113189      -2.17870     -0.739291      0.739291       326.040       326.780    
  10  0.314091      -1.15807     -0.392965      0.392965       327.800       328.193    
  11  0.457761     -0.781409     -0.265153      0.265153       327.179       327.444    
  12  0.923744     -0.793200E-01 -0.269154E-01  0.269154E-01   327.638       327.665    
  13  0.805387     -0.216433     -0.734415E-01  0.734415E-01   330.339       330.413    
  14  0.979257     -0.209609E-01 -0.711259E-02  0.711259E-02   330.594       330.602    
  15  0.634716E-01  -2.75716     -0.935580      0.935580       331.538       332.474    
  16  0.502866     -0.687432     -0.233264      0.233264       331.494       331.727    
  17  0.844986     -0.168435     -0.571546E-01  0.571546E-01   332.316       332.373    
  18  0.548347     -0.600848     -0.203884      0.203884       331.222       331.426    
  19  0.825472     -0.191800     -0.650829E-01  0.650829E-01   333.149       333.214    
  20  0.806424     -0.215145     -0.730046E-01  0.730046E-01   333.153       333.226    
  21  0.497450E-01  -3.00085      -1.01827       1.01827       334.032       335.050    
  22  0.407289     -0.898233     -0.304795      0.304795       334.508       334.813    
  23  0.522833     -0.648493     -0.220051      0.220051       336.329       336.549    
  24  0.763038     -0.270448     -0.917704E-01  0.917704E-01   337.249       337.341    
  25  0.706120     -0.347970     -0.118076      0.118076       338.524       338.642    
  26  0.540862     -0.614591     -0.208547      0.208547       338.856       339.064    
  27  0.807340E-01  -2.51660     -0.853949      0.853949       339.281       340.135    
  28  0.310756      -1.16875     -0.396588      0.396588       341.103       341.499    
  29  0.689192     -0.372235     -0.126310      0.126310       340.410       340.536    
  30  0.634973     -0.454174     -0.154113      0.154113       340.769       340.923    
  31  0.598432     -0.513442     -0.174225      0.174225       308.311       308.485    
loop,thermsimp(1:2)       11  0.103431      0.335078    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    307        321.42         73.99          1.00         38.85          0.43          0.06        114.33
Just calling func    0   0        114.32


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    321.42
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.339327               331
loop is:       11
neval is:      306
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       11      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.339327               331
loop is:       12
neval is:      306


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      331
neval,tstepnext:      306     331

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.783491     -0.243995     -0.827942E-01  0.827942E-01   308.311       308.393    
   2  0.973841     -0.265069E-01 -0.899450E-02  0.899450E-02   316.139       316.148    
   3  0.294662      -1.22193     -0.414632      0.414632       318.423       318.838    
   4  0.702628     -0.352928     -0.119758      0.119758       319.658       319.778    
   5  0.763280     -0.270131     -0.916626E-01  0.916626E-01   319.378       319.470    
   6  0.578080E-01  -2.85063     -0.967296      0.967296       320.048       321.015    
   7  0.834037     -0.181478     -0.615804E-01  0.615804E-01   320.293       320.355    
   8  0.976312     -0.239730E-01 -0.813469E-02  0.813469E-02   324.352       324.360    
   9  0.603670     -0.504728     -0.171268      0.171268       326.457       326.629    
  10  0.458546     -0.779695     -0.264572      0.264572       326.040       326.305    
  11  0.201917      -1.59990     -0.542889      0.542889       327.179       327.722    
  12  0.362727      -1.01411     -0.344113      0.344113       327.638       327.983    
  13  0.466909E-01  -3.06421      -1.03977       1.03977       327.800       328.840    
  14  0.602192     -0.507180     -0.172100      0.172100       330.339       330.512    
  15  0.332545      -1.10098     -0.373593      0.373593       330.594       330.968    
  16  0.758378     -0.276574     -0.938490E-01  0.938490E-01   331.222       331.316    
  17  0.834950     -0.180384     -0.612092E-01  0.612092E-01   331.494       331.555    
  18  0.910410     -0.938599E-01 -0.318492E-01  0.318492E-01   332.316       332.348    
  19  0.825418E-01  -2.49445     -0.846435      0.846435       331.538       332.385    
  20  0.639611     -0.446894     -0.151643      0.151643       333.149       333.301    
  21  0.345418      -1.06300     -0.360705      0.360705       333.153       333.513    
  22  0.961674     -0.390802E-01 -0.132610E-01  0.132610E-01   334.508       334.521    
  23  0.274135      -1.29413     -0.439135      0.439135       334.032       334.471    
  24  0.275236      -1.29013     -0.437775      0.437775       336.329       336.766    
  25  0.373550     -0.984704     -0.334137      0.334137       337.249       337.583    
  26  0.407178     -0.898505     -0.304887      0.304887       338.524       338.829    
  27  0.908773     -0.956602E-01 -0.324601E-01  0.324601E-01   338.856       338.888    
  28  0.578518     -0.547286     -0.185709      0.185709       339.281       339.467    
  29  0.674288     -0.394098     -0.133728      0.133728       340.410       340.543    
  30  0.758166     -0.276853     -0.939437E-01  0.939437E-01   340.769       340.863    
  31  0.764349E-01  -2.57132     -0.872518      0.872518       321.418       322.291    
loop,thermsimp(1:2)       12  0.827942E-01  0.899450E-02

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    308        329.86         73.55          1.00         38.87          0.68          0.05        114.16
Just calling func    0   0        114.16


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    329.86
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.339327               331
loop is:       12
neval is:      307
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       12      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.339327               331
loop is:       13
neval is:      307


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      331
neval,tstepnext:      307     331

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.964298     -0.363545E-01 -0.123361E-01  0.123361E-01   308.311       308.323    
   2  0.963371     -0.373169E-01 -0.126626E-01  0.126626E-01   316.139       316.152    
   3  0.851172E-02  -4.76631      -1.61734       1.61734       318.423       320.040    
   4  0.731929E-01  -2.61466     -0.887224      0.887224       319.378       320.266    
   5  0.491869     -0.709543     -0.240767      0.240767       319.658       319.899    
   6  0.625436     -0.469306     -0.159248      0.159248       320.293       320.452    
   7  0.139469      -1.96991     -0.668446      0.668446       320.048       320.716    
   8  0.464987     -0.765746     -0.259839      0.259839       321.418       321.678    
   9  0.192956      -1.64529     -0.558293      0.558293       324.352       324.910    
  10  0.184589E-01  -3.99221      -1.35466       1.35466       326.040       327.395    
  11  0.327387      -1.11661     -0.378897      0.378897       326.457       326.836    
  12  0.447570     -0.803921     -0.272792      0.272792       327.179       327.452    
  13  0.282132      -1.26538     -0.429378      0.429378       327.638       328.068    
  14  0.991234     -0.880510E-02 -0.298781E-02  0.298781E-02   327.800       327.803    
  15  0.574009     -0.555110     -0.188364      0.188364       330.339       330.528    
  16  0.884017     -0.123279     -0.418318E-01  0.418318E-01   330.594       330.636    
  17  0.332578      -1.10088     -0.373559      0.373559       331.222       331.596    
  18  0.294524      -1.22240     -0.414792      0.414792       331.494       331.909    
  19  0.865605     -0.144326     -0.489739E-01  0.489739E-01   332.316       332.365    
  20  0.441883E-01  -3.11930      -1.05846       1.05846       331.538       332.597    
  21  0.652915     -0.426309     -0.144658      0.144658       333.149       333.294    
  22  0.712636E-01  -2.64137     -0.896289      0.896289       333.153       334.049    
  23  0.211397      -1.55402     -0.527320      0.527320       334.032       334.559    
  24  0.836672E-01  -2.48091     -0.841839      0.841839       334.508       335.350    
  25  0.397953     -0.921422     -0.312663      0.312663       336.329       336.641    
  26  0.545442     -0.606159     -0.205686      0.205686       337.249       337.455    
  27  0.628874     -0.463825     -0.157388      0.157388       338.524       338.682    
  28  0.243035      -1.41455     -0.479996      0.479996       338.856       339.336    
  29  0.700237     -0.356336     -0.120914      0.120914       339.281       339.402    
  30  0.887974     -0.118813     -0.403165E-01  0.403165E-01   340.410       340.450    
  31  0.354481      -1.03710     -0.351916      0.351916       329.862       330.213    
loop,thermsimp(1:2)       13  0.123361E-01  0.126626E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    309        324.83         74.12          1.02         38.91          0.25          0.05        114.36
Just calling func    0   0        114.37


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    324.83
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.339327               331
loop is:       13
neval is:      308
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       13      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.339327               331
loop is:       14
neval is:      308


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      331
neval,tstepnext:      308     331

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.536122     -0.623393     -0.211534      0.211534       308.311       308.522    
   2  0.902010     -0.103129     -0.349946E-01  0.349946E-01   316.139       316.174    
   3  0.918906     -0.845717E-01 -0.286975E-01  0.286975E-01   319.658       319.687    
   4  0.300977E-01  -3.50330      -1.18877       1.18877       318.423       319.612    
   5  0.180939      -1.70960     -0.580113      0.580113       319.378       319.959    
   6  0.996736     -0.326981E-02 -0.110953E-02  0.110953E-02   320.293       320.294    
   7  0.974749     -0.255749E-01 -0.867825E-02  0.867825E-02   320.048       320.056    
   8  0.259085      -1.35060     -0.458295      0.458295       321.418       321.877    
   9  0.237439      -1.43784     -0.487900      0.487900       324.352       324.840    
  10  0.733816     -0.309497     -0.105021      0.105021       326.457       326.563    
  11  0.458028     -0.780824     -0.264955      0.264955       326.040       326.305    
  12  0.623300     -0.472727     -0.160409      0.160409       327.179       327.339    
  13  0.789074     -0.236895     -0.803850E-01  0.803850E-01   327.800       327.881    
  14  0.718847     -0.330107     -0.112014      0.112014       327.638       327.751    
  15  0.414258     -0.881266     -0.299037      0.299037       329.862       330.161    
  16  0.121880E-01  -4.40730      -1.49552       1.49552       330.339       331.835    
  17  0.976927     -0.233433E-01 -0.792100E-02  0.792100E-02   330.594       330.602    
  18  0.998133     -0.186873E-02 -0.634111E-03  0.634111E-03   331.222       331.223    
  19  0.582806     -0.539901     -0.183203      0.183203       331.494       331.677    
  20  0.461010     -0.774335     -0.262753      0.262753       332.316       332.578    
  21  0.748404     -0.289812     -0.983410E-01  0.983410E-01   331.538       331.637    
  22  0.627394     -0.466180     -0.158187      0.158187       333.149       333.307    
  23  0.823247     -0.194499     -0.659990E-01  0.659990E-01   333.153       333.219    
  24  0.696302     -0.361971     -0.122827      0.122827       334.032       334.155    
  25  0.571207     -0.560004     -0.190025      0.190025       334.508       334.698    
  26  0.189272      -1.66457     -0.564834      0.564834       336.329       336.893    
  27  0.534816     -0.625833     -0.212362      0.212362       337.249       337.461    
  28  0.846241     -0.166951     -0.566511E-01  0.566511E-01   338.524       338.581    
  29  0.157466      -1.84855     -0.627262      0.627262       338.856       339.483    
  30  0.123756      -2.08945     -0.709006      0.709006       339.281       339.990    
  31  0.458067     -0.780739     -0.264926      0.264926       324.826       325.091    
loop,thermsimp(1:2)       14  0.211534      0.349946E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    310        316.87         73.59          0.97         39.01          0.55          0.05        114.18
Just calling func    0   0        114.18


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    316.87
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.339327               331
loop is:       14
neval is:      309
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       14      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.339327               331
loop is:       15
neval is:      309


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      331
neval,tstepnext:      309     331

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.210086      -1.56024     -0.529431      0.529431       308.311       308.840    
   2  0.682169     -0.382478     -0.129785      0.129785       316.139       316.269    
   3  0.831163     -0.184930     -0.627517E-01  0.627517E-01   318.423       318.486    
   4  0.625179     -0.469718     -0.159388      0.159388       319.658       319.817    
   5  0.907522     -0.970376E-01 -0.329275E-01  0.329275E-01   319.378       319.411    
   6  0.406703     -0.899672     -0.305283      0.305283       320.048       320.353    
   7  0.463060     -0.769899     -0.261248      0.261248       320.293       320.554    
   8  0.206056      -1.57961     -0.536004      0.536004       321.418       321.954    
   9  0.303716      -1.19166     -0.404364      0.404364       324.352       324.756    
  10  0.843889     -0.169734     -0.575955E-01  0.575955E-01   324.826       324.884    
  11  0.273678      -1.29580     -0.439701      0.439701       326.040       326.480    
  12  0.571842     -0.558892     -0.189647      0.189647       326.457       326.647    
  13  0.803131     -0.219238     -0.743934E-01  0.743934E-01   327.179       327.253    
  14  0.330375      -1.10753     -0.375814      0.375814       327.638       328.014    
  15  0.155557      -1.86074     -0.631401      0.631401       327.800       328.432    
  16  0.878823     -0.129172     -0.438316E-01  0.438316E-01   329.862       329.905    
  17  0.781654     -0.246343     -0.835909E-01  0.835909E-01   330.594       330.678    
  18  0.782655     -0.245064     -0.831567E-01  0.831567E-01   331.222       331.306    
  19  0.682155     -0.382499     -0.129792      0.129792       331.538       331.668    
  20  0.899702     -0.105691     -0.358639E-01  0.358639E-01   331.494       331.530    
  21  0.444808     -0.810113     -0.274893      0.274893       330.339       330.614    
  22  0.495252     -0.702688     -0.238441      0.238441       332.316       332.554    
  23  0.640834     -0.444984     -0.150995      0.150995       333.153       333.303    
  24  0.314465      -1.15688     -0.392562      0.392562       333.149       333.541    
  25  0.368564     -0.998140     -0.338696      0.338696       334.032       334.371    
  26  0.572254E-02  -5.16334      -1.75206       1.75206       334.508       336.260    
  27  0.468080E-01  -3.06170      -1.03892       1.03892       336.329       337.368    
  28  0.598693E-01  -2.81559     -0.955407      0.955407       337.249       338.204    
  29  0.658687     -0.417508     -0.141672      0.141672       338.524       338.666    
  30  0.449565     -0.799475     -0.271284      0.271284       338.856       339.127    
  31  0.799405     -0.223887     -0.759710E-01  0.759710E-01   316.867       316.943    
loop,thermsimp(1:2)       15  0.529431      0.129785    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    311        336.59         73.96          1.02         38.91          0.03          0.05        113.96
Just calling func    0   0        113.97


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    336.59
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.339327               331
loop is:       15
neval is:      310
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       15      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.339327               331
loop is:       16
neval is:      310


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      331
neval,tstepnext:      310     331

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.652831E-01  -2.72902     -0.926031      0.926031       308.311       309.237    
   2  0.388935     -0.944342     -0.320441      0.320441       316.139       316.460    
   3  0.716732     -0.333053     -0.113014      0.113014       316.867       316.980    
   4  0.375936     -0.978336     -0.331976      0.331976       318.423       318.755    
   5  0.518505E-01  -2.95939      -1.00420       1.00420       319.378       320.383    
   6  0.892279     -0.113976     -0.386752E-01  0.386752E-01   319.658       319.697    
   7  0.145412      -1.92818     -0.654285      0.654285       320.048       320.702    
   8  0.759376E-01  -2.57784     -0.874732      0.874732       320.293       321.168    
   9  0.799111     -0.224255     -0.760958E-01  0.760958E-01   321.418       321.494    
  10  0.566636     -0.568038     -0.192751      0.192751       324.352       324.544    
  11  0.957834     -0.430803E-01 -0.146183E-01  0.146183E-01   324.826       324.841    
  12  0.421133     -0.864808     -0.293453      0.293453       326.040       326.334    
  13  0.965171     -0.354495E-01 -0.120290E-01  0.120290E-01   326.457       326.470    
  14  0.527073     -0.640416     -0.217310      0.217310       327.179       327.396    
  15  0.221584      -1.50695     -0.511350      0.511350       327.638       328.150    
  16  0.675180     -0.392776     -0.133280      0.133280       327.800       327.934    
  17  0.462159     -0.771846     -0.261908      0.261908       329.862       330.123    
  18  0.134826      -2.00377     -0.679933      0.679933       330.339       331.019    
  19  0.869165     -0.140222     -0.475811E-01  0.475811E-01   330.594       330.642    
  20  0.898965     -0.106511     -0.361420E-01  0.361420E-01   331.222       331.259    
  21  0.174160      -1.74778     -0.593070      0.593070       331.494       332.087    
  22  0.463810     -0.768281     -0.260699      0.260699       331.538       331.799    
  23  0.145870      -1.92504     -0.653218      0.653218       332.316       332.969    
  24  0.525172     -0.644029     -0.218537      0.218537       333.153       333.371    
  25  0.667609     -0.404052     -0.137106      0.137106       333.149       333.286    
  26  0.964408     -0.362405E-01 -0.122974E-01  0.122974E-01   334.032       334.044    
  27  0.981636     -0.185350E-01 -0.628942E-02  0.628942E-02   334.508       334.514    
  28  0.585742     -0.534875     -0.181498      0.181498       336.329       336.510    
  29  0.956106     -0.448864E-01 -0.152312E-01  0.152312E-01   337.249       337.264    
  30  0.153686      -1.87284     -0.635507      0.635507       338.524       339.160    
  31  0.937356     -0.646920E-01 -0.219518E-01  0.219518E-01   336.585       336.607    
loop,thermsimp(1:2)       16  0.926031      0.320441    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    312        327.55         73.99          1.02         38.88          0.09          0.05        114.04
Just calling func    0   0        114.04


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    327.55
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.339327               331
loop is:       16
neval is:      311
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       16      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.339327               331
loop is:       17
neval is:      311


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      331
neval,tstepnext:      311     331

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.488972     -0.715450     -0.242772      0.242772       308.311       308.553    
   2  0.243137      -1.41413     -0.479852      0.479852       316.139       316.619    
   3  0.530653     -0.633646     -0.215013      0.215013       316.867       317.082    
   4  0.926282     -0.765763E-01 -0.259844E-01  0.259844E-01   318.423       318.449    
   5  0.374288     -0.982729     -0.333467      0.333467       319.658       319.991    
   6  0.675293     -0.392608     -0.133223      0.133223       319.378       319.512    
   7  0.605942     -0.500970     -0.169993      0.169993       320.048       320.218    
   8  0.280229      -1.27215     -0.431674      0.431674       320.293       320.725    
   9  0.297259      -1.21315     -0.411655      0.411655       321.418       321.830    
  10  0.697504E-01  -2.66283     -0.903571      0.903571       324.352       325.255    
  11  0.824348     -0.193163     -0.655455E-01  0.655455E-01   324.826       324.892    
  12  0.750452     -0.287080     -0.974140E-01  0.974140E-01   326.040       326.138    
  13  0.120595      -2.11532     -0.717785      0.717785       326.457       327.175    
  14  0.935324     -0.668625E-01 -0.226883E-01  0.226883E-01   327.179       327.201    
  15  0.215551      -1.53456     -0.520717      0.520717       327.800       328.321    
  16  0.708821     -0.344153     -0.116780      0.116780       327.638       327.755    
  17  0.402499     -0.910063     -0.308809      0.308809       329.862       330.170    
  18  0.836443     -0.178597     -0.606028E-01  0.606028E-01   330.594       330.655    
  19  0.969979E-01  -2.33307     -0.791673      0.791673       330.339       331.131    
  20  0.178795      -1.72152     -0.584157      0.584157       331.222       331.807    
  21  0.140077      -1.96556     -0.666968      0.666968       331.538       332.205    
  22  0.375507     -0.979479     -0.332364      0.332364       331.494       331.826    
  23  0.831487     -0.184540     -0.626193E-01  0.626193E-01   332.316       332.378    
  24  0.815951     -0.203401     -0.690194E-01  0.690194E-01   333.149       333.218    
  25  0.468603     -0.757998     -0.257209      0.257209       333.153       333.410    
  26  0.677551     -0.389270     -0.132090      0.132090       334.032       334.164    
  27  0.169538      -1.77468     -0.602196      0.602196       334.508       335.110    
  28  0.950448     -0.508223E-01 -0.172454E-01  0.172454E-01   336.329       336.346    
  29  0.981726     -0.184427E-01 -0.625812E-02  0.625812E-02   336.585       336.592    
  30  0.442406     -0.815527     -0.276731      0.276731       337.249       337.526    
  31  0.531953     -0.631200     -0.214183      0.214183       327.551       327.765    
loop,thermsimp(1:2)       17  0.242772      0.479852    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    313        314.04         73.98          0.98         38.92          0.23          0.05        114.15
Just calling func    0   0        114.15


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    314.04
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.339327               331
loop is:       17
neval is:      312
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       17      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.339327               331
loop is:       18
neval is:      312


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      331
neval,tstepnext:      312     331

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.490618     -0.712090     -0.241632      0.241632       308.311       308.552    
   2  0.486668     -0.720173     -0.244374      0.244374       316.139       316.384    
   3  0.319995E-01  -3.44203      -1.16798       1.16798       316.867       318.035    
   4  0.957863     -0.430503E-01 -0.146081E-01  0.146081E-01   318.423       318.438    
   5  0.713202E-01  -2.64058     -0.896019      0.896019       319.378       320.274    
   6  0.677570     -0.389242     -0.132080      0.132080       319.658       319.790    
   7  0.533853     -0.627634     -0.212973      0.212973       320.048       320.261    
   8  0.963967     -0.366984E-01 -0.124528E-01  0.124528E-01   320.293       320.306    
   9  0.590118     -0.527432     -0.178972      0.178972       321.418       321.597    
  10  0.102350      -2.27936     -0.773448      0.773448       324.826       325.600    
  11  0.313487      -1.16000     -0.393619      0.393619       324.352       324.745    
  12  0.876181     -0.132183     -0.448531E-01  0.448531E-01   326.040       326.085    
  13  0.780541     -0.247768     -0.840744E-01  0.840744E-01   326.457       326.542    
  14  0.222922      -1.50093     -0.509307      0.509307       327.179       327.688    
  15  0.913991     -0.899351E-01 -0.305174E-01  0.305174E-01   327.638       327.669    
  16  0.493176     -0.706888     -0.239866      0.239866       327.551       327.791    
  17  0.884766     -0.122432     -0.415445E-01  0.415445E-01   327.800       327.842    
  18  0.576549E-01  -2.85328     -0.968196      0.968196       329.862       330.830    
  19  0.398597     -0.919804     -0.312115      0.312115       330.594       330.907    
  20  0.980633     -0.195573E-01 -0.663632E-02  0.663632E-02   330.339       330.346    
  21  0.304985      -1.18749     -0.402948      0.402948       331.222       331.625    
  22  0.628666     -0.464156     -0.157501      0.157501       331.494       331.652    
  23  0.367895     -0.999957     -0.339313      0.339313       331.538       331.878    
  24  0.442302     -0.815762     -0.276810      0.276810       332.316       332.593    
  25  0.656121     -0.421410     -0.142996      0.142996       333.149       333.292    
  26  0.229893      -1.47014     -0.498858      0.498858       333.153       333.651    
  27  0.475469     -0.743453     -0.252274      0.252274       334.032       334.284    
  28  0.801985     -0.220665     -0.748777E-01  0.748777E-01   334.508       334.583    
  29  0.454630     -0.788272     -0.267482      0.267482       336.329       336.596    
  30  0.858022     -0.153126     -0.519597E-01  0.519597E-01   336.585       336.637    
  31  0.692704     -0.367153     -0.124585      0.124585       314.043       314.168    
loop,thermsimp(1:2)       18  0.241632      0.244374    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    314        330.80         73.98          0.98         39.06          0.32          0.05        114.40
Just calling func    0   0        114.40


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    330.80
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.339327               331
loop is:       18
neval is:      313
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       18      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.339327               331
loop is:       19
neval is:      313


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      331
neval,tstepnext:      313     331

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.155141      -1.86342     -0.632309      0.632309       308.311       308.943    
   2  0.881882     -0.125697     -0.426526E-01  0.426526E-01   314.043       314.086    
   3  0.908319     -0.961592E-01 -0.326294E-01  0.326294E-01   316.139       316.172    
   4  0.732380     -0.311455     -0.105685      0.105685       316.867       316.973    
   5  0.367412      -1.00127     -0.339758      0.339758       318.423       318.763    
   6  0.624330     -0.471077     -0.159849      0.159849       319.658       319.818    
   7  0.833858     -0.181693     -0.616533E-01  0.616533E-01   320.048       320.109    
   8  0.194603E-02  -6.24197      -2.11807       2.11807       319.378       321.497    
   9  0.995416     -0.459497E-02 -0.155920E-02  0.155920E-02   320.293       320.295    
  10  0.665599     -0.407068     -0.138129      0.138129       321.418       321.556    
  11  0.747574     -0.290922     -0.987178E-01  0.987178E-01   324.352       324.450    
  12  0.539692     -0.616756     -0.209282      0.209282       324.826       325.036    
  13  0.958323     -0.425700E-01 -0.144452E-01  0.144452E-01   326.040       326.055    
  14  0.111027      -2.19798     -0.745836      0.745836       326.457       327.203    
  15  0.520965     -0.652072     -0.221266      0.221266       327.638       327.860    
  16  0.177207E-01  -4.03302      -1.36851       1.36851       327.179       328.547    
  17  0.860365     -0.150398     -0.510343E-01  0.510343E-01   327.551       327.602    
  18  0.383700     -0.957895     -0.325040      0.325040       327.800       328.125    
  19  0.524904     -0.644539     -0.218710      0.218710       330.339       330.558    
  20  0.589629     -0.528262     -0.179254      0.179254       329.862       330.041    
  21  0.125125      -2.07844     -0.705272      0.705272       330.594       331.300    
  22  0.154207      -1.86946     -0.634359      0.634359       331.222       331.857    
  23  0.752747     -0.284026     -0.963779E-01  0.963779E-01   331.494       331.590    
  24  0.551286     -0.595501     -0.202070      0.202070       331.538       331.740    
  25  0.733343     -0.310142     -0.105240      0.105240       332.316       332.421    
  26  0.904985     -0.998368E-01 -0.338773E-01  0.338773E-01   333.149       333.183    
  27  0.987632     -0.124455E-01 -0.422311E-02  0.422311E-02   333.153       333.157    
  28  0.228587      -1.47584     -0.500792      0.500792       334.032       334.533    
  29  0.384883     -0.954815     -0.323995      0.323995       334.508       334.832    
  30  0.781910     -0.246015     -0.834797E-01  0.834797E-01   336.329       336.412    
  31  0.402051E-02  -5.51635      -1.87185       1.87185       330.797       332.669    
loop,thermsimp(1:2)       19  0.632309      0.426526E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    315        336.23         74.57          1.03         38.70          0.08          0.05        114.43
Just calling func    0   0        114.43


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    316        324.45         74.27          1.04         38.73          0.25          0.05        114.34
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    324.45
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.339327               331
loop is:       19
neval is:      315
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       19      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.339327               331
loop is:       20
neval is:      315


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      331
neval,tstepnext:      315     331

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.272787      -1.29906     -0.440807      0.440807       308.311       308.751    
   2  0.284829      -1.25587     -0.426149      0.426149       314.043       314.469    
   3  0.422534E-01  -3.16407      -1.07366       1.07366       316.139       317.213    
   4  0.788018E-01  -2.54082     -0.862169      0.862169       316.867       317.729    
   5  0.396626E-01  -3.22735      -1.09513       1.09513       318.423       319.518    
   6  0.412432     -0.885684     -0.300536      0.300536       319.658       319.958    
   7  0.390866     -0.939390     -0.318761      0.318761       320.048       320.366    
   8  0.853334     -0.158604     -0.538186E-01  0.538186E-01   320.293       320.347    
   9  0.506127     -0.680968     -0.231071      0.231071       319.378       319.610    
  10  0.254200      -1.36963     -0.464754      0.464754       321.418       321.883    
  11  0.643116     -0.441430     -0.149789      0.149789       324.352       324.501    
  12  0.897721     -0.107896     -0.366121E-01  0.366121E-01   324.826       324.863    
  13  0.830899     -0.185247     -0.628594E-01  0.628594E-01   326.040       326.103    
  14  0.357312      -1.02915     -0.349217      0.349217       326.457       326.807    
  15  0.525942     -0.642564     -0.218039      0.218039       327.551       327.769    
  16  0.742929     -0.297155     -0.100833      0.100833       327.638       327.739    
  17  0.970959     -0.294711E-01 -0.100004E-01  0.100004E-01   327.800       327.810    
  18  0.235894      -1.44437     -0.490115      0.490115       327.179       327.669    
  19  0.723381E-01  -2.62640     -0.891210      0.891210       329.862       330.753    
  20  0.190915      -1.65593     -0.561901      0.561901       330.339       330.901    
  21  0.524670     -0.644986     -0.218861      0.218861       330.594       330.813    
  22  0.536043     -0.623540     -0.211584      0.211584       331.494       331.706    
  23  0.281730      -1.26681     -0.429862      0.429862       331.538       331.968    
  24  0.747791     -0.290632     -0.986192E-01  0.986192E-01   331.222       331.321    
  25  0.255771      -1.36347     -0.462663      0.462663       332.316       332.778    
  26  0.194866      -1.63544     -0.554950      0.554950       330.797       331.352    
  27  0.639630     -0.446865     -0.151633      0.151633       333.153       333.304    
  28  0.485808     -0.721941     -0.244974      0.244974       333.149       333.394    
  29  0.659147     -0.416809     -0.141435      0.141435       334.032       334.173    
  30  0.196308      -1.62807     -0.552448      0.552448       334.508       335.061    
  31  0.308964      -1.17453     -0.398550      0.398550       324.446       324.844    
loop,thermsimp(1:2)       20  0.440807      0.426149    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    317        304.52         74.57          1.04         38.76          0.23          0.06        114.66
Just calling func    0   0        114.66


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    318        304.96         74.14          1.00         38.77          0.79          0.05        114.77
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    304.52
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.339327               331
loop is:       20
neval is:      317
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       20      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.339327               331
loop is:       21
neval is:      317


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      331
neval,tstepnext:      317     331

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.633870E-01  -2.75850     -0.936033      0.936033       308.311       309.247    
   2  0.713782     -0.337177     -0.114413      0.114413       314.043       314.157    
   3  0.851614     -0.160622     -0.545035E-01  0.545035E-01   316.139       316.194    
   4  0.721769     -0.326050     -0.110638      0.110638       316.867       316.978    
   5  0.954937     -0.461102E-01 -0.156464E-01  0.156464E-01   318.423       318.439    
   6  0.302532E-01  -3.49815      -1.18702       1.18702       319.378       320.565    
   7  0.942920E-01  -2.36136     -0.801273      0.801273       319.658       320.459    
   8  0.515750E-01  -2.96472      -1.00601       1.00601       320.293       321.299    
   9  0.612753     -0.489794     -0.166200      0.166200       320.048       320.214    
  10  0.758041     -0.277018     -0.939997E-01  0.939997E-01   321.418       321.512    
  11  0.530485E-01  -2.93655     -0.996451      0.996451       324.352       325.348    
  12  0.941175     -0.606258E-01 -0.205720E-01  0.205720E-01   324.446       324.466    
  13  0.167539      -1.78654     -0.606222      0.606222       324.826       325.433    
  14  0.738662E-01  -2.60550     -0.884117      0.884117       326.040       326.925    
  15  0.822155     -0.195827     -0.664494E-01  0.664494E-01   326.457       326.524    
  16  0.578765     -0.546859     -0.185564      0.185564       327.179       327.364    
  17  0.912739E-01  -2.39389     -0.812312      0.812312       327.638       328.451    
  18  0.949215     -0.521197E-01 -0.176856E-01  0.176856E-01   327.551       327.568    
  19  0.485124     -0.723351     -0.245453      0.245453       327.800       328.046    
  20  0.359009      -1.02441     -0.347610      0.347610       329.862       330.209    
  21  0.747559     -0.290942     -0.987247E-01  0.987247E-01   330.594       330.693    
  22  0.482847     -0.728056     -0.247049      0.247049       330.339       330.587    
  23  0.994301     -0.571526E-02 -0.193934E-02  0.193934E-02   331.222       331.224    
  24  0.937801     -0.642177E-01 -0.217908E-01  0.217908E-01   330.797       330.819    
  25  0.699033     -0.358058     -0.121499      0.121499       331.494       331.616    
  26  0.358162      -1.02677     -0.348411      0.348411       331.538       331.887    
  27  0.746418     -0.292470     -0.992429E-01  0.992429E-01   332.316       332.415    
  28  0.532195     -0.630744     -0.214029      0.214029       333.153       333.367    
  29  0.727066     -0.318738     -0.108157      0.108157       333.149       333.257    
  30  0.461510     -0.773252     -0.262385      0.262385       334.032       334.294    
  31  0.285112      -1.25487     -0.425813      0.425813       304.516       304.942    
loop,thermsimp(1:2)       21  0.936033      0.114413    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    319        319.49         73.74          0.97         39.04          0.23          0.05        114.03
Just calling func    0   0        114.03


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    319.49
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.339327               331
loop is:       21
neval is:      318
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       21      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.339327               331
loop is:       22
neval is:      318


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      331
neval,tstepnext:      318     331

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.434858     -0.832735     -0.282570      0.282570       304.516       304.798    
   2  0.380177E-01  -3.26970      -1.10950       1.10950       308.311       309.420    
   3  0.198795      -1.61548     -0.548177      0.548177       314.043       314.591    
   4  0.880944E-01  -2.42935     -0.824343      0.824343       316.139       316.964    
   5  0.279105      -1.27617     -0.433038      0.433038       316.867       317.300    
   6  0.379482     -0.968948     -0.328791      0.328791       318.423       318.752    
   7  0.510142     -0.673065     -0.228389      0.228389       320.048       320.276    
   8  0.869007     -0.140404     -0.476428E-01  0.476428E-01   319.658       319.706    
   9  0.905256     -0.995378E-01 -0.337759E-01  0.337759E-01   319.378       319.412    
  10  0.587200     -0.532390     -0.180654      0.180654       320.293       320.474    
  11  0.309008      -1.17439     -0.398502      0.398502       321.418       321.817    
  12  0.210718      -1.55723     -0.528412      0.528412       324.446       324.974    
  13  0.362152      -1.01569     -0.344652      0.344652       324.352       324.696    
  14  0.465452     -0.764747     -0.259499      0.259499       324.826       325.086    
  15  0.155270E-01  -4.16518      -1.41336       1.41336       326.457       327.871    
  16  0.632166     -0.458603     -0.155616      0.155616       326.040       326.196    
  17  0.171028      -1.76593     -0.599228      0.599228       327.179       327.778    
  18  0.926401     -0.764482E-01 -0.259409E-01  0.259409E-01   327.551       327.577    
  19  0.130449      -2.03678     -0.691133      0.691133       327.800       328.491    
  20  0.536069     -0.623492     -0.211568      0.211568       327.638       327.850    
  21  0.128128      -2.05472     -0.697224      0.697224       329.862       330.559    
  22  0.729730     -0.315081     -0.106916      0.106916       330.339       330.446    
  23  0.982387     -0.177702E-01 -0.602991E-02  0.602991E-02   330.594       330.601    
  24  0.707707     -0.345726     -0.117314      0.117314       330.797       330.914    
  25  0.643878     -0.440245     -0.149387      0.149387       331.222       331.372    
  26  0.136721      -1.98982     -0.675198      0.675198       331.494       332.169    
  27  0.146320      -1.92196     -0.652174      0.652174       331.538       332.190    
  28  0.214169      -1.54099     -0.522900      0.522900       332.316       332.839    
  29  0.774008     -0.256172     -0.869263E-01  0.869263E-01   333.149       333.236    
  30  0.487333     -0.718808     -0.243911      0.243911       333.153       333.396    
  31  0.594481E-01  -2.82265     -0.957803      0.957803       319.486       320.444    
loop,thermsimp(1:2)       22  0.282570       1.10950    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    320        302.16         74.27          1.03         38.81          0.34          0.06        114.51
Just calling func    0   0        114.51


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    321        312.50         73.84          1.02         38.74          0.46          0.05        114.12
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  320    312.50        1.500     -1.193      6.230     -103.4     0.3992E-01
                      0.3745E-01  3.738     -99.01      4.045     0.7211    
                       2.222     -1.502      1.516      0.000      0.000    
                      -1.222      0.000      0.000      0.000     -1.221    

                      -2.500     0.1887E+05 0.1273E+05 -3561.    -0.5121E+05
                      -2.000     -8.166     0.4550     -7.336      3.652    
                      -14.28     -2.943      1522.      0.000      2659.    

                       3281.      4344.      3226.      5996.      2193.    
                       2108.     0.5816E-01-0.5642E-01  0.000    -0.1709    
                     -0.1130    -0.1681    -0.7224E-01-0.2021    -0.3408E-01

                      -1.512     -1.097      0.000    -0.3362E-01-0.1933E-01
                      0.8541E-01 0.2689E-01-0.3448E-01-0.3601    -0.1591    
                     -0.5435E-01-0.7728E-01-0.1080    -0.8704      0.000    

                      -1.731     -1.307      5.714      2.705      0.000    
                       0.000      9.205      9.124     0.2737E+05  1.000    
                     -0.5787    -0.7479      9.398      8.548     -2688.    

                       1.000     0.6883E-01-0.5204      8.753      9.028    
                      -6520.      1.000    -0.6904    -0.2373      10.12    
                       8.459     -2290.      1.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    302.16
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.339327               331
loop is:       22
neval is:      320
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       22      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.339327               331
loop is:       23
neval is:      320


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      331
neval,tstepnext:      320     331

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.262849      -1.33618     -0.453401      0.453401       304.516       304.969    
   2  0.388449     -0.945595     -0.320866      0.320866       308.311       308.632    
   3  0.827051     -0.189889     -0.644346E-01  0.644346E-01   314.043       314.107    
   4  0.958395     -0.424951E-01 -0.144197E-01  0.144197E-01   316.139       316.154    
   5  0.125400      -2.07625     -0.704528      0.704528       316.867       317.572    
   6  0.524174     -0.645931     -0.219182      0.219182       318.423       318.642    
   7  0.783721     -0.243702     -0.826948E-01  0.826948E-01   319.378       319.461    
   8  0.183361      -1.69630     -0.575601      0.575601       319.658       320.234    
   9  0.122208      -2.10203     -0.713275      0.713275       320.048       320.761    
  10  0.913915     -0.900182E-01 -0.305456E-01  0.305456E-01   319.486       319.517    
  11  0.273776      -1.29545     -0.439580      0.439580       320.293       320.733    
  12  0.779874     -0.248622     -0.843643E-01  0.843643E-01   321.418       321.503    
  13  0.305314      -1.18641     -0.402582      0.402582       324.352       324.754    
  14  0.720732     -0.327488     -0.111126      0.111126       324.446       324.557    
  15  0.222329      -1.50360     -0.510211      0.510211       324.826       325.336    
  16  0.826299     -0.190798     -0.647430E-01  0.647430E-01   326.040       326.105    
  17  0.581574     -0.542017     -0.183921      0.183921       327.551       327.735    
  18  0.616258     -0.484089     -0.164265      0.164265       327.179       327.343    
  19  0.604230     -0.503801     -0.170953      0.170953       327.638       327.809    
  20  0.333333      -1.09861     -0.372790      0.372790       326.457       326.830    
  21  0.289888E-01  -3.54085      -1.20151       1.20151       327.800       329.002    
  22  0.396892     -0.924091     -0.313569      0.313569       330.339       330.653    
  23  0.910378     -0.938957E-01 -0.318614E-01  0.318614E-01   329.862       329.893    
  24  0.998355     -0.164683E-02 -0.558813E-03  0.558813E-03   330.594       330.595    
  25  0.735990     -0.306539     -0.104017      0.104017       330.797       330.901    
  26  0.779044     -0.249688     -0.847260E-01  0.847260E-01   331.222       331.307    
  27  0.498268     -0.696618     -0.236381      0.236381       331.494       331.730    
  28  0.693129     -0.366539     -0.124377      0.124377       331.538       331.663    
  29  0.691370     -0.369080     -0.125239      0.125239       332.316       332.441    
  30  0.519398     -0.655086     -0.222288      0.222288       333.149       333.371    
  31  0.365801      -1.00567     -0.341250      0.341250       302.165       302.506    
loop,thermsimp(1:2)       23  0.453401      0.320866    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    322        304.04         74.11          1.00         38.92          0.69          0.05        114.77
Just calling func    0   0        114.77


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    304.04
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.339327               331
loop is:       23
neval is:      321
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       23      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.339327               331
loop is:       24
neval is:      321


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      331
neval,tstepnext:      321     331

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.562447     -0.575458     -0.195269      0.195269       302.165       302.360    
   2  0.429755     -0.844539     -0.286575      0.286575       304.516       304.802    
   3  0.598807     -0.512815     -0.174012      0.174012       308.311       308.485    
   4  0.757798     -0.277339     -0.941086E-01  0.941086E-01   314.043       314.137    
   5  0.954130E-01  -2.34954     -0.797263      0.797263       316.139       316.937    
   6  0.968708E-01  -2.33438     -0.792118      0.792118       316.867       317.659    
   7  0.196924      -1.62494     -0.551385      0.551385       318.423       318.974    
   8  0.616654     -0.483447     -0.164047      0.164047       319.378       319.543    
   9  0.181969      -1.70392     -0.578186      0.578186       319.486       320.064    
  10  0.383918     -0.957326     -0.324847      0.324847       319.658       319.983    
  11  0.377012     -0.975478     -0.331006      0.331006       320.293       320.624    
  12  0.899192     -0.106259     -0.360564E-01  0.360564E-01   320.048       320.084    
  13  0.409833     -0.892005     -0.302681      0.302681       321.418       321.721    
  14  0.728621     -0.316601     -0.107431      0.107431       324.446       324.553    
  15  0.568233     -0.565224     -0.191796      0.191796       324.352       324.543    
  16  0.647091     -0.435269     -0.147699      0.147699       324.826       324.974    
  17  0.118896      -2.12951     -0.722599      0.722599       326.040       326.763    
  18  0.910801     -0.934313E-01 -0.317038E-01  0.317038E-01   326.457       326.489    
  19  0.484176     -0.725308     -0.246117      0.246117       327.179       327.425    
  20  0.327343      -1.11675     -0.378943      0.378943       327.551       327.930    
  21  0.674995     -0.393050     -0.133373      0.133373       327.638       327.772    
  22  0.234857      -1.44878     -0.491610      0.491610       327.800       328.292    
  23  0.800837     -0.222098     -0.753639E-01  0.753639E-01   329.862       329.937    
  24  0.619975     -0.478077     -0.162224      0.162224       330.594       330.757    
  25  0.578519     -0.547284     -0.185708      0.185708       330.339       330.525    
  26  0.837214     -0.177675     -0.602901E-01  0.602901E-01   330.797       330.857    
  27  0.935915     -0.662302E-01 -0.224737E-01  0.224737E-01   331.222       331.245    
  28  0.779751     -0.248781     -0.844181E-01  0.844181E-01   331.538       331.623    
  29  0.801557     -0.221199     -0.750589E-01  0.750589E-01   331.494       331.569    
  30  0.827533E-01  -2.49189     -0.845566      0.845566       332.316       333.161    
  31  0.640581     -0.445379     -0.151129      0.151129       304.044       304.195    
loop,thermsimp(1:2)       24  0.195269      0.286575    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    323        323.97         74.06          1.03         38.92          0.08          0.05        114.14
Just calling func    0   0        114.14


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    323.97
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.339327               331
loop is:       24
neval is:      322
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       24      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.339327               331
loop is:       25
neval is:      322


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      331
neval,tstepnext:      322     331

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.756122     -0.279553     -0.948599E-01  0.948599E-01   302.165       302.260    
   2  0.693006     -0.366716     -0.124437      0.124437       304.044       304.168    
   3  0.647780     -0.434203     -0.147337      0.147337       304.516       304.663    
   4  0.895769     -0.110072     -0.373506E-01  0.373506E-01   308.311       308.348    
   5  0.775956     -0.253659     -0.860733E-01  0.860733E-01   314.043       314.129    
   6  0.891264     -0.115114     -0.390614E-01  0.390614E-01   316.139       316.178    
   7  0.553736     -0.591068     -0.200565      0.200565       316.867       317.068    
   8  0.646797     -0.435723     -0.147853      0.147853       318.423       318.571    
   9  0.646048     -0.436881     -0.148246      0.148246       319.378       319.527    
  10  0.160937      -1.82675     -0.619864      0.619864       319.658       320.278    
  11  0.840732     -0.173482     -0.588671E-01  0.588671E-01   319.486       319.545    
  12  0.377447     -0.974325     -0.330615      0.330615       320.048       320.378    
  13  0.214649      -1.53875     -0.522140      0.522140       320.293       320.815    
  14  0.424093     -0.857804     -0.291076      0.291076       321.418       321.709    
  15  0.693510     -0.365990     -0.124190      0.124190       324.352       324.476    
  16  0.252894      -1.37478     -0.466501      0.466501       324.446       324.912    
  17  0.765441     -0.267303     -0.907032E-01  0.907032E-01   324.826       324.917    
  18  0.481029     -0.731828     -0.248329      0.248329       326.457       326.706    
  19  0.211808      -1.55207     -0.526661      0.526661       326.040       326.567    
  20  0.616599E-01  -2.78612     -0.945407      0.945407       327.179       328.124    
  21  0.110259      -2.20492     -0.748189      0.748189       327.638       328.387    
  22  0.475319     -0.743769     -0.252381      0.252381       327.551       327.803    
  23  0.500411E-01  -2.99491      -1.01625       1.01625       327.800       328.817    
  24  0.126445      -2.06795     -0.701711      0.701711       329.862       330.563    
  25  0.693760     -0.365629     -0.124068      0.124068       330.339       330.464    
  26  0.876607E-01  -2.43428     -0.826018      0.826018       330.594       331.421    
  27  0.564718     -0.571429     -0.193901      0.193901       330.797       330.991    
  28  0.572706     -0.557383     -0.189135      0.189135       331.222       331.412    
  29  0.739618     -0.301621     -0.102348      0.102348       331.494       331.596    
  30  0.428028     -0.848566     -0.287942      0.287942       331.538       331.826    
  31  0.864224     -0.145923     -0.495156E-01  0.495156E-01   323.971       324.020    
loop,thermsimp(1:2)       25  0.948599E-01  0.124437    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    324        326.71         74.67          1.05         38.70          0.02          0.05        114.50
Just calling func    0   0        114.50


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    326.71
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.339327               331
loop is:       25
neval is:      323
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       25      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.339327               331
loop is:       26
neval is:      323


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      331
neval,tstepnext:      323     331

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.409890     -0.891867     -0.302635      0.302635       302.165       302.467    
   2  0.389332     -0.943323     -0.320095      0.320095       304.044       304.364    
   3  0.765657     -0.267021     -0.906075E-01  0.906075E-01   304.516       304.606    
   4  0.505025     -0.683148     -0.231811      0.231811       308.311       308.542    
   5  0.681598     -0.383316     -0.130069      0.130069       314.043       314.173    
   6  0.895525     -0.110345     -0.374430E-01  0.374430E-01   316.139       316.177    
   7  0.540074     -0.616050     -0.209042      0.209042       316.867       317.076    
   8  0.125370      -2.07648     -0.704607      0.704607       318.423       319.128    
   9  0.306095      -1.18386     -0.401716      0.401716       319.378       319.780    
  10  0.898677     -0.106831     -0.362508E-01  0.362508E-01   319.486       319.522    
  11  0.355276      -1.03486     -0.351156      0.351156       319.658       320.009    
  12  0.855641     -0.155905     -0.529027E-01  0.529027E-01   320.048       320.101    
  13  0.894333E-01  -2.41426     -0.819225      0.819225       320.293       321.112    
  14  0.291038      -1.23430     -0.418833      0.418833       321.418       321.837    
  15  0.848476E-01  -2.46690     -0.837086      0.837086       323.971       324.808    
  16  0.655469     -0.422404     -0.143333      0.143333       324.352       324.495    
  17  0.181028      -1.70910     -0.579945      0.579945       324.446       325.026    
  18  0.801189     -0.221659     -0.752149E-01  0.752149E-01   324.826       324.902    
  19  0.659702     -0.415967     -0.141149      0.141149       326.040       326.182    
  20  0.500397     -0.692354     -0.234934      0.234934       326.457       326.692    
  21  0.901964     -0.103181     -0.350122E-01  0.350122E-01   327.551       327.586    
  22  0.331186      -1.10508     -0.374982      0.374982       327.179       327.554    
  23  0.572805E-01  -2.85979     -0.970406      0.970406       327.638       328.609    
  24  0.511624     -0.670164     -0.227405      0.227405       327.800       328.028    
  25  0.953295     -0.478312E-01 -0.162304E-01  0.162304E-01   330.339       330.356    
  26  0.454382     -0.788818     -0.267667      0.267667       329.862       330.129    
  27  0.697217E-01  -2.66324     -0.903711      0.903711       330.797       331.701    
  28  0.269239      -1.31216     -0.445251      0.445251       331.222       331.668    
  29  0.855725     -0.155806     -0.528693E-01  0.528693E-01   330.594       330.647    
  30  0.408332E-02  -5.50085      -1.86659       1.86659       331.494       333.361    
  31  0.926366     -0.764862E-01 -0.259539E-01  0.259539E-01   326.706       326.732    
loop,thermsimp(1:2)       26  0.302635      0.320095    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    325        321.35         74.77          1.06         38.39          0.46          0.05        114.73
Just calling func    0   0        114.73


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    321.35
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.339327               331
loop is:       26
neval is:      324
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       26      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    173.736      0.500000    
T0,tstep,tfreq (these do not change):             30
current SAtemp,tstepnext are:   0.339327               331
loop is:       27
neval is:      324


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      331
neval,tstepnext:      324     331

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.478820     -0.736431     -0.249891      0.249891       302.165       302.415    
   2  0.431280     -0.840999     -0.285374      0.285374       304.044       304.329    
   3  0.231120      -1.46482     -0.497053      0.497053       304.516       305.013    
   4  0.306155      -1.18366     -0.401649      0.401649       308.311       308.712    
   5  0.514107     -0.665324     -0.225762      0.225762       314.043       314.269    
   6  0.784944E-01  -2.54473     -0.863495      0.863495       316.139       317.003    
   7  0.767893     -0.264105     -0.896180E-01  0.896180E-01   316.867       316.957    
   8  0.240450E-02  -6.03041      -2.04628       2.04628       318.423       320.469    
   9  0.185505      -1.68467     -0.571655      0.571655       319.486       320.058    
  10  0.405909     -0.901627     -0.305947      0.305947       319.378       319.684    
  11  0.681143     -0.383983     -0.130296      0.130296       319.658       319.788    
  12  0.529175     -0.636436     -0.215960      0.215960       320.048       320.264    
  13  0.873060     -0.135751     -0.460641E-01  0.460641E-01   320.293       320.339    
  14  0.457661     -0.781625     -0.265227      0.265227       321.418       321.683    
  15  0.564230     -0.572293     -0.194195      0.194195       324.352       324.546    
  16  0.949800     -0.515039E-01 -0.174767E-01  0.174767E-01   323.971       323.988    
  17  0.581003E-01  -2.84558     -0.965584      0.965584       324.826       325.792    
  18  0.180069      -1.71442     -0.581748      0.581748       324.446       325.027    
  19  0.222412      -1.50322     -0.510084      0.510084       326.040       326.551    
  20  0.821703     -0.196377     -0.666360E-01  0.666360E-01   326.457       326.524    
  21  0.948363     -0.530176E-01 -0.179903E-01  0.179903E-01   326.706       326.724    
  22  0.796186     -0.227922     -0.773401E-01  0.773401E-01   327.179       327.256    
  23  0.881546     -0.126078     -0.427816E-01  0.427816E-01   327.551       327.593    
  24  0.702001     -0.353821     -0.120061      0.120061       327.800       327.920    
  25  0.878483     -0.129559     -0.439630E-01  0.439630E-01   327.638       327.682    
  26  0.158251      -1.84358     -0.625575      0.625575       329.862       330.487    
  27  0.759310E-02  -4.88052      -1.65609       1.65609       330.339       331.996    
  28  0.549090     -0.599492     -0.203424      0.203424       330.594       330.798    
  29  0.294083      -1.22389     -0.415300      0.415300       331.222       331.638    
  30  0.358851      -1.02485     -0.347759      0.347759       330.797       331.145    
  31  0.591031E-01  -2.82847     -0.959778      0.959778       321.346       322.306    
loop,thermsimp(1:2)       27  0.249891      0.285374    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
