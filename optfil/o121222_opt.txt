nop,maxfn,iprint,nloop,iquad:   938000  20  95   0
stopcr,simp:    5.00000       0.00000    
T0,Tstep:    35.9111      0.500000    
Tfreq:   45
nop,maxfn,iprint,nloop,iquad:   938000  20  95   0
stopcr,simp:    5.00000       0.00000    
T0,Tstep:    35.9111      0.500000    
Tfreq:   45
 Estimating   45 parameters on   1 communicators
 Progress Report every  20 function evaluations
 EVAL.   FUNC.VALUE.          PARAMETER VALUES
iter,obj,time:      2        119.70         72.54          1.14         41.99          0.93          0.04        116.64
iter,obj,time:      3        125.09         67.37          1.12         41.87          0.98          0.05        111.39
iter,obj,time:      4        119.99         67.39          1.14         41.85          0.94          0.05        111.38
iter,obj,time:      5        129.72         67.39          1.13         42.00          0.90          0.05        111.47
iter,obj,time:      6        118.73         67.45          1.14         41.96          0.92          0.05        111.52
iter,obj,time:      7        142.91         67.31          1.11         42.28          0.91          0.05        111.66
iter,obj,time:      8        127.91         67.45          1.14         41.93          0.89          0.05        111.45
iter,obj,time:      9        124.47         67.42          1.13         41.98          0.83          0.05        111.41
iter,obj,time:     10        128.36         67.38          1.14         42.21          0.76          0.05        111.54
iter,obj,time:     11        122.71         67.45          1.15         41.95          0.89          0.05        111.48
iter,obj,time:     12        119.28         67.42          1.14         42.10          0.49          0.05        111.20
iter,obj,time:     13        235.73         67.45          1.13         42.05          0.62          0.05        111.30
iter,obj,time:     14        121.02         67.41          1.13         42.00          0.95          0.05        111.54
iter,obj,time:     15        123.18         67.38          1.14         41.87          1.02          0.05        111.45
iter,obj,time:     16        122.38         67.41          1.13         41.98          0.93          0.05        111.49
iter,obj,time:     17        119.06         67.49          1.14         42.07          0.52          0.05        111.26
iter,obj,time:     18        121.68         67.41          1.14         41.93          0.98          0.05        111.52
iter,obj,time:     19        152.48         67.41          1.14         42.41          0.59          0.05        111.59
iter,obj,time:     20        119.71         67.44          1.14         42.06          0.75          0.05        111.43
iter,obj,time:     21        119.65         67.44          1.14         41.98          0.61          0.05        111.21
iter,obj,time:     22        119.71         67.46          1.14         42.14          0.68          0.05        111.46
iter,obj,time:     23        134.55         67.65          1.15         42.41          0.53          0.05        111.79
iter,obj,time:     24        120.88         67.39          1.14         42.05          0.96          0.05        111.59
iter,obj,time:     25        124.02         67.38          1.14         42.03          0.62          0.05        111.21
iter,obj,time:     26        119.10         67.75          1.20         41.87          0.38          0.05        111.24
iter,obj,time:     27        121.00         67.45          1.14         42.04          0.42          0.05        111.11
iter,obj,time:     28        187.38         67.34          1.12         42.19          0.54          0.05        111.24
iter,obj,time:     29        147.50         67.34          1.12         42.16          0.68          0.05        111.36
iter,obj,time:     30        145.12         67.46          1.12         42.02          0.99          0.05        111.64
iter,obj,time:     31        808.02         67.50          1.12         41.96          0.79          0.05        111.42
iter,obj,time:     32        125.75         67.44          1.14         42.08          0.82          0.05        111.54
iter,obj,time:     33        123.81         67.23          1.09         41.77          1.46          0.05        111.59
iter,obj,time:     34        132.72         67.38          1.13         41.89          1.00          0.05        111.45
iter,obj,time:     35        124.89         67.75          1.13         41.75          1.14          0.05        111.83
iter,obj,time:     36        121.02         67.46          1.12         42.03          0.93          0.05        111.59
iter,obj,time:     37        119.66         67.39          1.12         41.84          0.98          0.05        111.39
iter,obj,time:     38        122.11         67.36          1.13         41.83          0.94          0.05        111.31
iter,obj,time:     39        121.13         67.50          1.14         41.91          0.80          0.05        111.41
iter,obj,time:     40        124.41         67.40          1.11         42.27          1.04          0.05        111.87
iter,obj,time:     41        119.93         67.59          1.11         41.48          1.13          0.05        111.36
iter,obj,time:     42        125.05         67.62          1.15         41.71          1.07          0.05        111.59
iter,obj,time:     43        130.29         67.64          1.14         41.70          1.05          0.05        111.59
iter,obj,time:     44        118.37         67.59          1.14         41.71          0.97          0.05        111.46
iter,obj,time:     45        120.84         67.60          1.11         41.58          1.12          0.05        111.46
iter,obj,time:     46        122.02         67.64          1.13         41.68          0.77          0.05        111.28
iter,obj,time:     47        120.35         67.62          1.12         41.54          1.12          0.05        111.45

    1    119.70        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

    2    125.09      -0.6850     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

    3    119.99        1.315     -4.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

    4    129.72        1.315     -2.102      1.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

    5    118.73        1.315     -2.102      3.011     -102.6    -0.9390    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

    6    142.91        1.315     -2.102      3.011     -102.6      1.061    
                      -1.148      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

    7    127.91        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518    -0.5920     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

    8    124.47        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      1.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

    9    128.36        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     -1.541    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   10    122.71        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                      0.1570     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   11    119.28        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -3.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   12    235.73        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540     0.1050E+05  7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   13    121.02        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                       1.001      0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   14    123.18        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -1.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   15    122.38        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      2355.    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   16    119.06        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       2.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   17    121.68        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500    -0.9650     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   18    152.48        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965      1.382     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   19    119.71        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -3.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   20    119.65        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      11.41    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   21    119.71        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -9.390     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   22    134.55        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39      1.051      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   23    120.88        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                      0.4970E-01-0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   24    124.02        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.1701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   25    119.10        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.3074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   26    121.00        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074    -0.9290      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   27    187.38        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                     -0.2390     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   28    147.50        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239    -0.1590     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   29    145.12        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -1.642     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   30    808.02        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.482    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   31    125.75        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.504      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   32    123.81        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      9.020    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   33    132.72        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.2172E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   34    124.89        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -4.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   35    121.02        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                      0.5712     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   36    119.66        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -1.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   37    122.11        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.654      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   38    121.13        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      9.108    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   39    124.41        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000      1.585    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   40    119.93        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846     0.6307      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   41    125.05        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      9.165      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   42    130.29        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.357    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   43    118.37        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000     0.3511    -0.6332      9.076    

                       8.777    -0.1891E+05 -6.000    

   44    120.84        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489     0.3668      9.076    

                       8.777    -0.1891E+05 -6.000    

   45    122.02        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.376    

                       8.777    -0.1891E+05 -6.000    

   46    120.35        1.315     -2.102      3.011     -102.6      1.061    
                      0.8518      1.408     -99.70      3.552     0.4588    

                       2.157     -1.951      1.540      7000.      7000.    

                      0.1097E-02  0.000      0.000      0.000     -1.221    



                      -2.000      0.000      0.000      7000.      354.6    

                       1.500     -5.965     -3.618     -8.632      6.413    

                      -14.39     -3.949      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4503    -0.6701      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6074     -1.229      7000.    



                      -1.239     -1.159     -2.142     -1.982    -0.3807    

                     -0.3252      9.204      8.720    -0.1672E+05 -6.000    

                     -0.4288     -2.381      9.354      8.808    -0.1969E+05



                      -6.000     0.5846    -0.3693      8.865      9.057    

                     -0.1944E+05 -6.000    -0.6489    -0.6332      9.076    

                       9.077    -0.1891E+05 -6.000    
 finished setting up initial simplex
 count number of function evaluations which here is neval=np1          46          46

beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:        1
neval is:       46


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       46      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.228570      -1.47591      -53.0017       53.0017       119.704       172.705    
   2  0.709707     -0.342904      -12.3140       12.3140       125.093       137.407    
   3  0.151889      -1.88460      -67.6781       67.6781       119.994       187.672    
   4  0.456170E-01  -3.08747      -110.874       110.874       129.721       240.595    
   5  0.882557     -0.124932      -4.48643       4.48643       118.731       123.218    
   6  0.711292     -0.340672      -12.2339       12.2339       142.906       155.140    
   7  0.241669      -1.42019      -51.0004       51.0004       127.913       178.914    
   8  0.682871     -0.381450      -13.6983       13.6983       124.467       138.165    
   9  0.500657     -0.691834      -24.8445       24.8445       128.361       153.206    
  10  0.494633     -0.703939      -25.2792       25.2792       122.710       147.989    
  11  0.437126     -0.827535      -29.7177       29.7177       119.277       148.995    
  12  0.462981     -0.770069      -27.6540       27.6540       235.734       263.388    
  13  0.988878     -0.111840E-01 -0.401629      0.401629       121.019       121.421    
  14  0.878158     -0.129929      -4.66589       4.66589       123.179       127.845    
  15  0.825605     -0.191638      -6.88194       6.88194       122.382       129.264    
  16  0.966665     -0.339033E-01  -1.21750       1.21750       119.057       120.275    
  17  0.340930      -1.07608      -38.6431       38.6431       121.677       160.320    
  18  0.288920      -1.24161      -44.5874       44.5874       152.479       197.066    
  19  0.442843     -0.814539      -29.2510       29.2510       119.707       148.958    
  20  0.878635     -0.129386      -4.64638       4.64638       119.649       124.296    
  21  0.198777E-01  -3.91816      -140.705       140.705       119.714       260.419    
  22  0.315829      -1.15255      -41.3894       41.3894       134.553       175.943    
  23  0.208690      -1.56690      -56.2692       56.2692       120.876       177.145    
  24  0.849393     -0.163234      -5.86189       5.86189       124.017       129.879    
  25  0.945818     -0.557056E-01  -2.00045       2.00045       119.097       121.097    
  26  0.567839     -0.565917      -20.3227       20.3227       121.000       141.323    
  27  0.718388     -0.330745      -11.8774       11.8774       187.378       199.255    
  28  0.115406      -2.15930      -77.5426       77.5426       147.503       225.045    
  29  0.659869E-01  -2.71830      -97.6170       97.6170       145.121       242.738    
  30  0.171393      -1.76380      -63.3398       63.3398       808.024       871.363    
  31  0.161953      -1.82045      -65.3743       65.3743       125.752       191.126    
  32  0.455406     -0.786566      -28.2464       28.2464       123.809       152.056    
  33  0.788693     -0.237378      -8.52448       8.52448       132.716       141.240    
  34  0.157754      -1.84672      -66.3176       66.3176       124.892       191.210    
  35  0.126279      -2.06926      -74.3093       74.3093       121.024       195.333    
  36  0.646962     -0.435467      -15.6381       15.6381       119.663       135.301    
  37  0.730769     -0.313658      -11.2638       11.2638       122.108       133.371    
  38  0.443446E-01  -3.11577      -111.890       111.890       121.129       233.020    
  39  0.219048      -1.51847      -54.5297       54.5297       124.411       178.941    
  40  0.311223E-01  -3.46983      -124.605       124.605       119.932       244.537    
  41  0.864417     -0.145700      -5.23225       5.23225       125.047       130.279    
  42  0.372606     -0.987233      -35.4526       35.4526       130.292       165.745    
  43  0.599250E-01  -2.81466      -101.077       101.077       118.368       219.446    
  44  0.250528      -1.38418      -49.7075       49.7075       120.842       170.550    
  45  0.404968E-01  -3.20653      -115.150       115.150       122.019       237.169    
  46  0.792822     -0.232156      -8.33697       8.33697       120.348       128.685    
loop,thermsimp(1:2)        1   53.0017       12.3140    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     48        160.91         67.73          1.14         41.77          0.93          0.05        111.61
Just calling func    0   0        111.61


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    160.91
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:        1
neval is:       47
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        1      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:        2
neval is:       47


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       47      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.352733      -1.04204      -37.4209       37.4209       119.057       156.478    
   2  0.440787     -0.819193      -29.4181       29.4181       119.097       148.515    
   3  0.685789     -0.377185      -13.5451       13.5451       121.019       134.565    
   4  0.673104     -0.395856      -14.2156       14.2156       118.731       132.947    
   5  0.655536     -0.422301      -15.1653       15.1653       119.649       134.814    
   6  0.422838     -0.860766      -30.9110       30.9110       123.179       154.090    
   7  0.300870      -1.20108      -43.1320       43.1320       120.348       163.480    
   8  0.776987     -0.252331      -9.06148       9.06148       122.382       131.443    
   9  0.170551      -1.76872      -63.5166       63.5166       124.017       187.534    
  10  0.587497     -0.531884      -19.1005       19.1005       125.047       144.147    
  11  0.250425      -1.38459      -49.7222       49.7222       122.108       171.830    
  12  0.776362E-01  -2.55572      -91.7787       91.7787       119.663       211.441    
  13  0.766647     -0.265729      -9.54261       9.54261       125.093       134.636    
  14  0.480193     -0.733568      -26.3432       26.3432       124.467       150.810    
  15  0.434643     -0.833231      -29.9222       29.9222       132.716       162.638    
  16  0.815924E-01  -2.50602      -89.9938       89.9938       121.000       210.994    
  17  0.724257E-01  -2.62519      -94.2735       94.2735       122.710       216.983    
  18  0.573795     -0.555483      -19.9480       19.9480       119.707       139.655    
  19  0.196096      -1.62915      -58.5045       58.5045       119.277       177.782    
  20  0.240673      -1.42432      -51.1487       51.1487       123.809       174.958    
  21  0.194228      -1.63872      -58.8483       58.8483       128.361       187.210    
  22  0.236387      -1.44229      -51.7940       51.7940       142.906       194.700    
  23  0.261662      -1.34070      -48.1460       48.1460       121.677       169.823    
  24  0.146321      -1.92195      -69.0194       69.0194       130.292       199.311    
  25  0.169637      -1.77410      -63.7097       63.7097       120.842       184.552    
  26  0.886717     -0.120229      -4.31756       4.31756       119.704       124.021    
  27  0.253412      -1.37274      -49.2965       49.2965       134.553       183.850    
  28  0.470820     -0.753279      -27.0510       27.0510       120.876       147.927    
  29  0.329871      -1.10905      -39.8273       39.8273       127.913       167.741    
  30  0.726784     -0.319126      -11.4601       11.4601       124.411       135.871    
  31  0.612351     -0.490450      -17.6126       17.6126       119.994       137.607    
  32  0.146573      -1.92023      -68.9576       68.9576       125.752       194.709    
  33  0.812633     -0.207476      -7.45067       7.45067       124.892       132.343    
  34  0.486789     -0.719925      -25.8533       25.8533       121.024       146.877    
  35  0.653508     -0.425400      -15.2766       15.2766       152.479       167.756    
  36  0.180127      -1.71409      -61.5549       61.5549       187.378       248.933    
  37  0.155218      -1.86292      -66.8996       66.8996       118.368       185.268    
  38  0.830615     -0.185589      -6.66469       6.66469       147.503       154.168    
  39  0.728345     -0.316980      -11.3831       11.3831       121.129       132.512    
  40  0.262318      -1.33820      -48.0561       48.0561       122.019       170.075    
  41  0.234222      -1.45148      -52.1243       52.1243       129.721       181.845    
  42  0.250201      -1.38549      -49.7545       49.7545       145.121       194.876    
  43  0.898433     -0.107103      -3.84620       3.84620       119.932       123.778    
  44  0.580277     -0.544250      -19.5446       19.5446       119.714       139.259    
  45  0.823617     -0.194050      -6.96852       6.96852       235.734       242.703    
  46  0.820676     -0.197627      -7.09699       7.09699       160.912       168.009    
loop,thermsimp(1:2)        2   37.4209       29.4181    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     49        117.53         67.82          1.13         41.70          0.85          0.05        111.55
Just calling func    0   0        111.55


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     50        130.20         67.74          1.13         41.57          1.03          0.05        111.53
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    117.53
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:        2
neval is:       49
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        2      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:        3
neval is:       49


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       49      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.167898      -1.78440      -64.0797       64.0797       119.932       184.012    
   2  0.274399      -1.29317      -46.4392       46.4392       119.704       166.143    
   3  0.597410E-01  -2.81774      -101.188       101.188       122.382       223.570    
   4  0.283115E-01  -3.56449      -128.004       128.004       124.892       252.897    
   5  0.901069     -0.104174      -3.74100       3.74100       121.129       124.870    
   6  0.717939     -0.331371      -11.8999       11.8999       118.731       130.631    
   7  0.294866      -1.22123      -43.8558       43.8558       121.019       164.875    
   8  0.935651     -0.665127E-01  -2.38854       2.38854       125.093       127.482    
   9  0.314362      -1.15721      -41.5566       41.5566       119.649       161.206    
  10  0.807729     -0.213529      -7.66806       7.66806       124.411       132.079    
  11  0.757191     -0.278140      -9.98829       9.98829       119.994       129.982    
  12  0.508654     -0.675987      -24.2754       24.2754       119.714       143.990    
  13  0.722060     -0.325647      -11.6943       11.6943       119.707       131.401    
  14  0.424032     -0.857947      -30.8098       30.8098       125.047       155.857    
  15  0.786154     -0.240602      -8.64029       8.64029       121.024       129.664    
  16  0.399894     -0.916557      -32.9145       32.9145       120.876       153.791    
  17  0.757416     -0.277843      -9.97765       9.97765       119.097       129.074    
  18  0.637270     -0.450563      -16.1802       16.1802       124.467       140.647    
  19  0.586055     -0.534342      -19.1888       19.1888       123.179       142.368    
  20  0.821724     -0.196351      -7.05118       7.05118       147.503       154.554    
  21  0.921558     -0.816897E-01  -2.93356       2.93356       119.057       121.991    
  22  0.985596     -0.145083E-01 -0.521010      0.521010       132.716       133.237    
  23  0.257194      -1.35793      -48.7645       48.7645       120.348       169.112    
  24  0.921438E-01  -2.38440      -85.6265       85.6265       127.913       213.540    
  25  0.114653      -2.16584      -77.7777       77.7777       152.479       230.257    
  26  0.379827     -0.968040      -34.7634       34.7634       160.912       195.675    
  27  0.541451     -0.613503      -22.0315       22.0315       121.677       143.709    
  28  0.544274     -0.608302      -21.8448       21.8448       122.019       143.864    
  29  0.934365     -0.678883E-01  -2.43794       2.43794       122.108       124.546    
  30  0.266419E-01  -3.62527      -130.187       130.187       123.809       253.997    
  31  0.919572     -0.838466E-01  -3.01102       3.01102       119.277       122.288    
  32  0.864639     -0.145444      -5.22304       5.22304       129.721       134.944    
  33  0.341156      -1.07542      -38.6193       38.6193       134.553       173.173    
  34  0.803175     -0.219182      -7.87107       7.87107       120.842       128.713    
  35  0.699424     -0.357498      -12.8381       12.8381       118.368       131.207    
  36  0.223868E-01  -3.79928      -136.436       136.436       128.361       264.798    
  37  0.605689     -0.501389      -18.0054       18.0054       124.017       142.023    
  38  0.312349      -1.16363      -41.7873       41.7873       142.906       184.693    
  39  0.437501     -0.826675      -29.6868       29.6868       125.752       155.438    
  40  0.303330      -1.19293      -42.8395       42.8395       145.121       187.961    
  41  0.129735      -2.04226      -73.3397       73.3397       130.292       203.632    
  42  0.954352     -0.467224E-01  -1.67785       1.67785       121.000       122.678    
  43  0.519807     -0.654297      -23.4965       23.4965       119.663       143.159    
  44  0.950560     -0.507036E-01  -1.82082       1.82082       122.710       124.530    
  45  0.443941     -0.812064      -29.1621       29.1621       235.734       264.896    
  46  0.911446     -0.927229E-01  -3.32978       3.32978       117.527       120.857    
loop,thermsimp(1:2)        3   64.0797       46.4392    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     51        203.36         67.73          1.12         41.83          0.88          0.05        111.60
Just calling func    0   0        111.60


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     52        376.18         67.72          1.12         41.79          0.94          0.05        111.61
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    203.36
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:        3
neval is:       51
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        3      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:        4
neval is:       51


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       51      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.883237     -0.124162      -4.45879       4.45879       117.527       121.986    
   2  0.114178      -2.16999      -77.9268       77.9268       119.057       196.984    
   3  0.217017      -1.52778      -54.8641       54.8641       119.277       174.142    
   4  0.138317      -1.97821      -71.0395       71.0395       121.000       192.040    
   5  0.832728     -0.183048      -6.57345       6.57345       122.710       129.283    
   6  0.390825     -0.939496      -33.7383       33.7383       122.108       155.846    
   7  0.283633      -1.26007      -45.2506       45.2506       121.129       166.380    
   8  0.725809     -0.320468      -11.5084       11.5084       125.093       136.602    
   9  0.506121     -0.680979      -24.4547       24.4547       120.842       145.297    
  10  0.216234      -1.53139      -54.9940       54.9940       119.097       174.091    
  11  0.637942     -0.449509      -16.1423       16.1423       121.024       137.166    
  12  0.536707     -0.622302      -22.3475       22.3475       119.994       142.342    
  13  0.231844      -1.46169      -52.4909       52.4909       118.731       171.222    
  14  0.491379     -0.710540      -25.5163       25.5163       118.368       143.885    
  15  0.825774     -0.191434      -6.87461       6.87461       119.707       126.582    
  16  0.671593     -0.398102      -14.2963       14.2963       124.411       138.707    
  17  0.549103     -0.599470      -21.5276       21.5276       132.716       154.243    
  18  0.659287     -0.416597      -14.9604       14.9604       129.721       144.681    
  19  0.205012      -1.58469      -56.9078       56.9078       124.467       181.374    
  20  0.400541E-02  -5.52011      -198.233       198.233       124.017       322.250    
  21  0.750831     -0.286575      -10.2912       10.2912       123.179       133.470    
  22  0.619921     -0.478162      -17.1713       17.1713       119.663       136.834    
  23  0.435226     -0.831889      -29.8740       29.8740       121.677       151.551    
  24  0.460974     -0.774414      -27.8100       27.8100       122.019       149.829    
  25  0.891582E-01  -2.41734      -86.8093       86.8093       119.714       206.524    
  26  0.589618E-01  -2.83087      -101.659       101.659       120.876       222.536    
  27  0.541391     -0.613613      -22.0355       22.0355       147.503       169.538    
  28  0.545108E-01  -2.90936      -104.478       104.478       125.752       230.230    
  29  0.744722     -0.294744      -10.5846       10.5846       125.047       135.631    
  30  0.712477     -0.339008      -12.1741       12.1741       119.649       131.823    
  31  0.563836     -0.572992      -20.5767       20.5767       121.019       141.596    
  32  0.161455      -1.82353      -65.4848       65.4848       119.704       185.188    
  33  0.640738     -0.445135      -15.9853       15.9853       120.348       136.333    
  34  0.157494      -1.84837      -66.3768       66.3768       134.553       200.930    
  35  0.695323     -0.363378      -13.0493       13.0493       119.932       132.981    
  36  0.792798     -0.232186      -8.33806       8.33806       142.906       151.244    
  37  0.940634     -0.612017E-01  -2.19782       2.19782       145.121       147.319    
  38  0.750008     -0.287672      -10.3306       10.3306       160.912       171.242    
  39  0.298939E-01  -3.51010      -126.051       126.051       130.292       256.343    
  40  0.633510     -0.456480      -16.3927       16.3927       127.913       144.306    
  41  0.465723     -0.764164      -27.4419       27.4419       122.382       149.824    
  42  0.916259     -0.874560E-01  -3.14064       3.14064       152.479       155.620    
  43  0.451376     -0.795456      -28.5657       28.5657       124.892       153.458    
  44  0.414090     -0.881672      -31.6618       31.6618       123.809       155.471    
  45  0.273092      -1.29795      -46.6107       46.6107       128.361       174.972    
  46  0.361379      -1.01783      -36.5513       36.5513       203.360       239.911    
loop,thermsimp(1:2)        4   4.45879       77.9268    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     53        125.53         67.73          1.13         41.63          0.63          0.05        111.19
Just calling func    0   0        111.19


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     54        135.36         67.73          1.15         41.70          0.81          0.05        111.44
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    125.53
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:        4
neval is:       53
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        4      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:        5
neval is:       53


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       53      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.968189     -0.323278E-01  -1.16093       1.16093       117.527       118.688    
   2  0.384676     -0.955353      -34.3077       34.3077       119.707       154.015    
   3  0.472770     -0.749146      -26.9026       26.9026       122.710       149.612    
   4  0.131186      -2.03114      -72.9403       72.9403       119.649       192.589    
   5  0.387497     -0.948046      -34.0453       34.0453       119.932       153.977    
   6  0.474858     -0.744739      -26.7444       26.7444       123.179       149.923    
   7  0.654056     -0.424563      -15.2465       15.2465       125.047       140.293    
   8  0.375266     -0.980119      -35.1971       35.1971       120.348       155.545    
   9  0.605577     -0.501574      -18.0120       18.0120       125.093       143.105    
  10  0.485605     -0.722360      -25.9407       25.9407       119.663       145.603    
  11  0.503843     -0.685490      -24.6167       24.6167       121.024       145.641    
  12  0.374521     -0.982108      -35.2685       35.2685       124.411       159.679    
  13  0.955542E-01  -2.34806      -84.3214       84.3214       121.019       205.341    
  14  0.902567     -0.102512      -3.68132       3.68132       119.994       123.675    
  15  0.347215      -1.05781      -37.9871       37.9871       118.368       156.355    
  16  0.893138     -0.113014      -4.05846       4.05846       127.913       131.972    
  17  0.561145     -0.577776      -20.7485       20.7485       129.721       150.469    
  18  0.667287     -0.404536      -14.5273       14.5273       120.842       135.370    
  19  0.601102     -0.508991      -18.2784       18.2784       145.121       163.400    
  20  0.569928     -0.562245      -20.1908       20.1908       122.382       142.572    
  21  0.655926     -0.421708      -15.1440       15.1440       122.019       137.163    
  22  0.355892      -1.03313      -37.1007       37.1007       142.906       180.006    
  23  0.208013      -1.57015      -56.3859       56.3859       121.677       178.063    
  24  0.879772     -0.128093      -4.59995       4.59995       124.892       129.492    
  25  0.114206E-01  -4.47233      -160.606       160.606       132.716       293.322    
  26  0.950245     -0.510357E-01  -1.83274       1.83274       123.809       125.642    
  27  0.321268      -1.13548      -40.7763       40.7763       152.479       193.255    
  28  0.379005     -0.970207      -34.8412       34.8412       122.108       156.949    
  29  0.117960      -2.13741      -76.7567       76.7567       121.129       197.886    
  30  0.822558     -0.195337      -7.01475       7.01475       147.503       154.518    
  31  0.671085     -0.398860      -14.3235       14.3235       118.731       133.055    
  32  0.220279      -1.51286      -54.3284       54.3284       160.912       215.240    
  33  0.836335     -0.178727      -6.41826       6.41826       119.097       125.515    
  34  0.982442E-01  -2.32030      -83.3244       83.3244       119.277       202.602    
  35  0.912526     -0.915389E-01  -3.28726       3.28726       128.361       131.649    
  36  0.758802     -0.276015      -9.91197       9.91197       124.467       134.379    
  37  0.562651     -0.575096      -20.6523       20.6523       119.704       140.356    
  38  0.248142      -1.39375      -50.0512       50.0512       121.000       171.052    
  39  0.864881     -0.145163      -5.21296       5.21296       119.057       124.270    
  40  0.495151     -0.702893      -25.2416       25.2416       134.553       159.795    
  41  0.112352E-01  -4.48870      -161.194       161.194       119.714       280.908    
  42  0.745500     -0.293700      -10.5471       10.5471       120.876       131.423    
  43  0.405071     -0.903693      -32.4526       32.4526       125.752       158.204    
  44  0.617259     -0.482466      -17.3259       17.3259       203.360       220.686    
  45  0.992755     -0.727089E-02 -0.261105      0.261105       130.292       130.553    
  46  0.888739     -0.117952      -4.23579       4.23579       125.529       129.765    
loop,thermsimp(1:2)        5   1.16093       34.3077    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     55        135.32         67.73          1.14         41.66          0.98          0.05        111.55
Just calling func    0   0        111.55


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    135.32
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:        5
neval is:       54
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        5      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:        6
neval is:       54


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       54      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.806234     -0.215382      -7.73459       7.73459       117.527       125.261    
   2  0.337878      -1.08507      -38.9661       38.9661       119.994       158.960    
   3  0.930612     -0.719127E-01  -2.58246       2.58246       119.057       121.640    
   4  0.843645     -0.170024      -6.10573       6.10573       119.097       125.202    
   5  0.757799     -0.277337      -9.95945       9.95945       123.809       133.769    
   6  0.627925     -0.465335      -16.7107       16.7107       124.892       141.603    
   7  0.412314     -0.885971      -31.8161       31.8161       125.529       157.345    
   8  0.282274      -1.26488      -45.4231       45.4231       130.292       175.715    
   9  0.426609E-01  -3.15447      -113.280       113.280       120.876       234.157    
  10  0.484876     -0.723862      -25.9946       25.9946       128.361       154.356    
  11  0.372210     -0.988296      -35.4908       35.4908       127.913       163.404    
  12  0.740507     -0.300421      -10.7884       10.7884       118.731       129.520    
  13  0.361519      -1.01744      -36.5374       36.5374       124.467       161.004    
  14  0.421034     -0.865042      -31.0646       31.0646       120.842       151.907    
  15  0.780595     -0.247699      -8.89515       8.89515       122.019       130.914    
  16  0.758410     -0.276531      -9.93052       9.93052       125.047       134.977    
  17  0.522921E-01  -2.95091      -105.970       105.970       119.704       225.674    
  18  0.609673     -0.494833      -17.7700       17.7700       122.382       140.152    
  19  0.204029      -1.58949      -57.0803       57.0803       125.093       182.174    
  20  0.516385     -0.660902      -23.7337       23.7337       119.663       143.396    
  21  0.323918      -1.12726      -40.4812       40.4812       121.024       161.505    
  22  0.671820     -0.397765      -14.2842       14.2842       122.710       136.994    
  23  0.850344     -0.162114      -5.82168       5.82168       123.179       129.001    
  24  0.515631     -0.662364      -23.7862       23.7862       129.721       153.507    
  25  0.919408     -0.840249E-01  -3.01742       3.01742       119.932       122.950    
  26  0.516519     -0.660643      -23.7244       23.7244       119.707       143.431    
  27  0.986900     -0.131869E-01 -0.473554      0.473554       147.503       147.976    
  28  0.127351      -2.06081      -74.0058       74.0058       120.348       194.354    
  29  0.775028E-01  -2.55744      -91.8404       91.8404       118.368       210.209    
  30  0.778307     -0.250634      -9.00053       9.00053       122.108       131.108    
  31  0.548570     -0.600441      -21.5625       21.5625       125.752       147.314    
  32  0.191672      -1.65197      -59.3240       59.3240       124.411       183.735    
  33  0.593733     -0.521326      -18.7214       18.7214       134.553       153.275    
  34  0.612853     -0.489631      -17.5832       17.5832       145.121       162.704    
  35  0.872749     -0.136107      -4.88774       4.88774       121.000       125.888    
  36  0.291105E-01  -3.53666      -127.005       127.005       121.677       248.682    
  37  0.310804      -1.16859      -41.9654       41.9654       142.906       184.871    
  38  0.238051      -1.43527      -51.5421       51.5421       119.649       171.191    
  39  0.600295     -0.510334      -18.3266       18.3266       152.479       170.806    
  40  0.856575     -0.154813      -5.55951       5.55951       121.129       126.689    
  41  0.127990      -2.05580      -73.8261       73.8261       119.277       193.104    
  42  0.390396E-01  -3.24318      -116.466       116.466       121.019       237.485    
  43  0.469298E-01  -3.05910      -109.856       109.856       160.912       270.767    
  44  0.170208      -1.77073      -63.5889       63.5889       203.360       266.949    
  45  0.457801     -0.781320      -28.0580       28.0580       119.714       147.772    
  46  0.451589     -0.794982      -28.5487       28.5487       135.320       163.868    
loop,thermsimp(1:2)        6   7.73459       38.9661    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     56        810.30         67.71          1.10         41.62          0.96          0.05        111.45
Just calling func    0   0        111.45


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     57        143.78         67.72          1.10         41.62          0.77          0.05        111.27
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    143.78
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:        6
neval is:       56
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        6      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:        7
neval is:       56


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       56      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.117714      -2.13949      -76.8315       76.8315       119.057       195.889    
   2  0.421875     -0.863045      -30.9929       30.9929       119.932       150.925    
   3  0.700103     -0.356528      -12.8033       12.8033       119.097       131.900    
   4  0.209367      -1.56367      -56.1529       56.1529       117.527       173.680    
   5  0.117251      -2.14344      -76.9731       76.9731       121.000       197.973    
   6  0.898330     -0.107218      -3.85030       3.85030       121.129       124.979    
   7  0.209806      -1.56157      -56.0777       56.0777       123.179       179.257    
   8  0.917155     -0.864790E-01  -3.10555       3.10555       118.731       121.837    
   9  0.120514E-01  -4.41857      -158.676       158.676       122.019       280.695    
  10  0.189983      -1.66082      -59.6419       59.6419       122.108       181.750    
  11  0.257131      -1.35817      -48.7733       48.7733       123.809       172.583    
  12  0.913158E-01  -2.39343      -85.9507       85.9507       125.047       210.998    
  13  0.336531      -1.08906      -39.1094       39.1094       122.710       161.819    
  14  0.318351      -1.14460      -41.1038       41.1038       122.382       163.485    
  15  0.919606     -0.838101E-01  -3.00971       3.00971       124.892       127.902    
  16  0.719771E-01  -2.63141      -94.4966       94.4966       119.663       214.159    
  17  0.788730E-01  -2.53992      -91.2111       91.2111       119.707       210.918    
  18  0.905929     -0.987941E-01  -3.54780       3.54780       125.752       129.299    
  19  0.665501     -0.407215      -14.6235       14.6235       119.714       134.338    
  20  0.812159     -0.208059      -7.47164       7.47164       147.503       154.974    
  21  0.412726E-01  -3.18756      -114.469       114.469       120.842       235.311    
  22  0.256064      -1.36233      -48.9226       48.9226       134.553       183.476    
  23  0.277519      -1.28187      -46.0332       46.0332       129.721       175.754    
  24  0.279550      -1.27457      -45.7713       45.7713       128.361       174.133    
  25  0.857884     -0.153286      -5.50467       5.50467       125.529       131.034    
  26  0.205158      -1.58398      -56.8822       56.8822       119.994       176.876    
  27  0.482085     -0.729635      -26.2020       26.2020       124.467       150.669    
  28  0.494966E-01  -3.00585      -107.943       107.943       121.024       228.967    
  29  0.338791      -1.08237      -38.8691       38.8691       145.121       183.990    
  30  0.249491E-01  -3.69092      -132.545       132.545       127.913       260.458    
  31  0.480710     -0.732491      -26.3045       26.3045       135.320       161.624    
  32  0.908951E-01  -2.39805      -86.1165       86.1165       152.479       238.595    
  33  0.283223      -1.26152      -45.3026       45.3026       119.649       164.952    
  34  0.277734      -1.28109      -46.0053       46.0053       130.292       176.297    
  35  0.504407     -0.684372      -24.5765       24.5765       125.093       149.670    
  36  0.251881      -1.37880      -49.5141       49.5141       124.411       173.925    
  37  0.568193     -0.565294      -20.3003       20.3003       142.906       163.206    
  38  0.186135      -1.68128      -60.3766       60.3766       119.277       179.654    
  39  0.964582     -0.360604E-01  -1.29497       1.29497       120.348       121.643    
  40  0.493045     -0.707155      -25.3947       25.3947       118.368       143.763    
  41  0.477950     -0.738248      -26.5113       26.5113       119.704       146.215    
  42  0.114879      -2.16388      -77.7071       77.7071       120.876       198.583    
  43  0.324003      -1.12700      -40.4718       40.4718       121.019       161.491    
  44  0.720573     -0.327708      -11.7684       11.7684       121.677       133.446    
  45  0.934913     -0.673019E-01  -2.41688       2.41688       203.360       205.777    
  46  0.516467     -0.660745      -23.7280       23.7280       143.778       167.506    
loop,thermsimp(1:2)        7   76.8315       30.9929    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     58        119.61         67.73          1.16         41.68          0.74          0.05        111.35
Just calling func    0   0        111.36


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     59        128.93         67.86          1.16         41.80          0.45          0.05        111.33
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    119.61
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:        7
neval is:       58
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        7      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:        8
neval is:       58


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       58      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.487401     -0.718668      -25.8081       25.8081       120.348       146.156    
   2  0.568497     -0.564760      -20.2811       20.2811       118.731       139.012    
   3  0.632037E-01  -2.76139      -99.1645       99.1645       121.129       220.294    
   4  0.184325      -1.69105      -60.7275       60.7275       124.892       185.620    
   5  0.949772     -0.515332E-01  -1.85061       1.85061       125.752       127.602    
   6  0.512179     -0.669081      -24.0274       24.0274       125.529       149.557    
   7  0.573767     -0.555532      -19.9497       19.9497       119.097       139.046    
   8  0.590189     -0.527312      -18.9363       18.9363       121.677       140.614    
   9  0.323917      -1.12727      -40.4814       40.4814       119.714       160.196    
  10  0.246420E-01  -3.70330      -132.990       132.990       118.368       251.358    
  11  0.923153E-01  -2.38255      -85.5597       85.5597       119.704       205.263    
  12  0.236043      -1.44374      -51.8463       51.8463       125.093       176.940    
  13  0.885388     -0.121730      -4.37144       4.37144       124.467       128.838    
  14  0.617726     -0.481710      -17.2987       17.2987       119.932       137.231    
  15  0.349992      -1.04985      -37.7011       37.7011       147.503       185.204    
  16  0.892028     -0.114257      -4.10310       4.10310       121.019       125.123    
  17  0.382423     -0.961227      -34.5187       34.5187       135.320       169.838    
  18  0.850527     -0.161899      -5.81398       5.81398       122.710       128.524    
  19  0.653461     -0.425472      -15.2791       15.2791       142.906       158.185    
  20  0.413959     -0.881988      -31.6731       31.6731       122.382       154.055    
  21  0.807813     -0.213424      -7.66430       7.66430       119.649       127.313    
  22  0.348045      -1.05542      -37.9014       37.9014       143.778       181.680    
  23  0.435267     -0.831795      -29.8706       29.8706       123.809       153.680    
  24  0.434284     -0.834056      -29.9518       29.9518       117.527       147.479    
  25  0.983564     -0.165728E-01 -0.595148      0.595148       124.411       125.006    
  26  0.545923     -0.605277      -21.7361       21.7361       128.361       150.097    
  27  0.227140      -1.48219      -53.2269       53.2269       129.721       182.948    
  28  0.965085     -0.355395E-01  -1.27626       1.27626       130.292       131.568    
  29  0.183882      -1.69346      -60.8139       60.8139       119.994       180.808    
  30  0.187300E-02  -6.28022      -225.529       225.529       123.179       348.708    
  31  0.428736     -0.846914      -30.4136       30.4136       119.277       149.691    
  32  0.459764     -0.777041      -27.9044       27.9044       122.108       150.012    
  33  0.914786     -0.890649E-01  -3.19841       3.19841       134.553       137.752    
  34  0.872236     -0.136696      -4.90888       4.90888       145.121       150.030    
  35  0.789367     -0.236524      -8.49383       8.49383       119.057       127.551    
  36  0.619233E-01  -2.78186      -99.8995       99.8995       121.000       220.900    
  37  0.138004E-01  -4.28306      -153.809       153.809       120.876       274.685    
  38  0.287035      -1.24815      -44.8224       44.8224       203.360       248.183    
  39  0.138758E-01  -4.27761      -153.613       153.613       119.707       273.320    
  40  0.593330     -0.522005      -18.7458       18.7458       125.047       143.793    
  41  0.399445     -0.917679      -32.9548       32.9548       119.663       152.618    
  42  0.982947     -0.172001E-01 -0.617676      0.617676       121.024       121.642    
  43  0.259534      -1.34887      -48.4392       48.4392       120.842       169.281    
  44  0.816592E-01  -2.50520      -89.9644       89.9644       152.479       242.443    
  45  0.166083      -1.79527      -64.4699       64.4699       127.913       192.383    
  46  0.967370     -0.331741E-01  -1.19132       1.19132       119.611       120.803    
loop,thermsimp(1:2)        8   25.8081       20.2811    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     60        119.69         67.77          1.12         41.74          0.67          0.05        111.36
Just calling func    0   0        111.36


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     61        125.39         67.72          1.07         42.11          0.90          0.05        111.84
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

   60    125.39        1.089     -2.328      2.785     -102.6     0.8352    
                      0.6260      1.182     -99.70      3.326     0.2330    

                       1.931     -2.177      1.540      6646.      7000.    

                      0.1140      0.000      0.000      0.000     -1.221    



                      -4.976      0.000      0.000      7000.      580.4    

                       1.613     -5.400     -3.053     -8.067      6.978    

                      -13.83     -3.384      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.3938    -0.7161      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.5735     -1.195      7000.    



                      -1.350     -1.046     -2.086     -1.968    -0.3807    

                     -0.3252      9.238      8.754    -0.1630E+05 -5.774    

                     -0.3159     -2.268      9.388      8.842    -0.1969E+05



                      -6.000     0.6975    -0.2564      8.899      9.091    

                     -0.1944E+05 -6.000    -0.5360    -0.5203      9.055    

                       8.811    -0.1891E+05 -6.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    119.69
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:        8
neval is:       60
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        8      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:        9
neval is:       60


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       60      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.878288E-01  -2.43237      -87.3489       87.3489       119.611       206.960    
   2  0.192227      -1.64908      -59.2202       59.2202       121.024       180.244    
   3  0.872733     -0.136126      -4.88843       4.88843       124.411       129.299    
   4  0.444113     -0.811675      -29.1481       29.1481       121.019       150.168    
   5  0.194382      -1.63793      -58.8198       58.8198       119.649       178.469    
   6  0.358074      -1.02702      -36.8813       36.8813       119.057       155.938    
   7  0.461693     -0.772855      -27.7540       27.7540       125.752       153.506    
   8  0.180202      -1.71368      -61.5400       61.5400       122.710       184.250    
   9  0.944954     -0.566187E-01  -2.03324       2.03324       124.467       126.500    
  10  0.738770     -0.302769      -10.8727       10.8727       130.292       141.165    
  11  0.822491E-01  -2.49800      -89.7059       89.7059       119.932       209.638    
  12  0.313602      -1.15963      -41.6435       41.6435       134.553       176.197    
  13  0.978185     -0.220567E-01 -0.792079      0.792079       118.731       119.523    
  14  0.540591E-01  -2.91768      -104.777       104.777       119.097       223.874    
  15  0.872885     -0.135951      -4.88215       4.88215       121.677       126.559    
  16  0.209079      -1.56504      -56.2023       56.2023       125.047       181.249    
  17  0.789205E-01  -2.53931      -91.1894       91.1894       120.348       211.537    
  18  0.746404     -0.292489      -10.5036       10.5036       117.527       128.030    
  19  0.110219      -2.20529      -79.1943       79.1943       125.529       204.724    
  20  0.656016     -0.421570      -15.1390       15.1390       119.277       134.416    
  21  0.665675     -0.406953      -14.6141       14.6141       122.108       136.722    
  22  0.563292     -0.573957      -20.6114       20.6114       145.121       165.733    
  23  0.615044     -0.486062      -17.4550       17.4550       128.361       145.816    
  24  0.128081      -2.05509      -73.8005       73.8005       119.663       193.463    
  25  0.459916     -0.776711      -27.8925       27.8925       123.809       151.702    
  26  0.433297     -0.836332      -30.0336       30.0336       122.382       152.415    
  27  0.225675      -1.48866      -53.4594       53.4594       142.906       196.365    
  28  0.808805     -0.212197      -7.62023       7.62023       119.714       127.335    
  29  0.578238     -0.547770      -19.6710       19.6710       120.842       140.513    
  30  0.569572     -0.562871      -20.2133       20.2133       135.320       155.533    
  31  0.291272      -1.23350      -44.2962       44.2962       125.093       169.389    
  32  0.144426      -1.93499      -69.4874       69.4874       119.994       189.481    
  33  0.908321     -0.961572E-01  -3.45311       3.45311       143.778       147.231    
  34  0.593166     -0.522281      -18.7557       18.7557       129.721       148.476    
  35  0.327630      -1.11587      -40.0721       40.0721       147.503       187.575    
  36  0.823214E-01  -2.49712      -89.6744       89.6744       124.892       214.567    
  37  0.742531     -0.297691      -10.6904       10.6904       127.913       138.604    
  38  0.476201E-01  -3.04450      -109.331       109.331       119.704       229.035    
  39  0.183829      -1.69375      -60.8244       60.8244       121.129       181.954    
  40  0.417257     -0.874053      -31.3882       31.3882       121.000       152.388    
  41  0.647723E-01  -2.73688      -98.2842       98.2842       152.479       250.763    
  42  0.123950E-01  -4.39046      -157.666       157.666       203.360       361.026    
  43  0.281372E-01  -3.57066      -128.226       128.226       118.368       246.595    
  44  0.883044     -0.124380      -4.46662       4.46662       119.707       124.174    
  45  0.445413     -0.808754      -29.0432       29.0432       120.876       149.919    
  46  0.418101     -0.872031      -31.3156       31.3156       119.694       151.009    
loop,thermsimp(1:2)        9   87.3489       59.2202    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     62        217.53         67.74          1.14         41.71          0.62          0.05        111.27
Just calling func    0   0        111.26


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    217.53
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:        9
neval is:       61
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        9      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:       10
neval is:       61


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       61      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.611807     -0.491339      -17.6445       17.6445       118.731       136.376    
   2  0.877337     -0.130865      -4.69949       4.69949       119.707       124.406    
   3  0.821280     -0.196891      -7.07058       7.07058       124.467       131.537    
   4  0.989636     -0.104181E-01 -0.374125      0.374125       121.677       122.051    
   5  0.492813     -0.707625      -25.4116       25.4116       119.714       145.126    
   6  0.904083     -0.100835      -3.62108       3.62108       117.527       121.148    
   7  0.490620     -0.712086      -25.5718       25.5718       124.411       149.983    
   8  0.572439     -0.557850      -20.0330       20.0330       119.277       139.310    
   9  0.588753     -0.529749      -19.0239       19.0239       122.108       141.132    
  10  0.341799      -1.07353      -38.5517       38.5517       127.913       166.465    
  11  0.449605     -0.799385      -28.7068       28.7068       120.842       149.549    
  12  0.740720     -0.300132      -10.7781       10.7781       130.292       141.070    
  13  0.173164E-01  -4.05610      -145.659       145.659       128.361       274.020    
  14  0.828389     -0.188272      -6.76105       6.76105       143.778       150.539    
  15  0.110451      -2.20318      -79.1187       79.1187       129.721       208.839    
  16  0.646816     -0.435693      -15.6462       15.6462       120.876       136.522    
  17  0.857676     -0.153529      -5.51337       5.51337       121.019       126.533    
  18  0.691202E-02  -4.97449      -178.639       178.639       119.694       298.333    
  19  0.530885     -0.633210      -22.7392       22.7392       123.809       146.549    
  20  0.742957     -0.297117      -10.6698       10.6698       121.000       131.670    
  21  0.883526E-01  -2.42642      -87.1353       87.1353       122.382       209.517    
  22  0.599138     -0.512263      -18.3959       18.3959       125.752       144.148    
  23  0.476407     -0.741482      -26.6274       26.6274       135.320       161.947    
  24  0.509994E-01  -2.97594      -106.869       106.869       119.057       225.926    
  25  0.669768     -0.400824      -14.3940       14.3940       145.121       159.515    
  26  0.874430     -0.134183      -4.81865       4.81865       125.093       129.912    
  27  0.830739     -0.185440      -6.65933       6.65933       134.553       141.213    
  28  0.166673      -1.79172      -64.3427       64.3427       119.649       183.992    
  29  0.578742     -0.546898      -19.6397       19.6397       121.024       140.664    
  30  0.433531     -0.835791      -30.0142       30.0142       125.047       155.061    
  31  0.979127     -0.210935E-01 -0.757490      0.757490       121.129       121.887    
  32  0.310252      -1.17037      -42.0293       42.0293       122.710       164.739    
  33  0.686879     -0.375597      -13.4881       13.4881       147.503       160.991    
  34  0.243104      -1.41427      -50.7878       50.7878       119.994       170.782    
  35  0.459407     -0.777818      -27.9323       27.9323       119.663       147.595    
  36  0.332163      -1.10213      -39.5786       39.5786       142.906       182.484    
  37  0.512243     -0.668956      -24.0229       24.0229       125.529       149.552    
  38  0.323240      -1.12936      -40.5565       40.5565       119.611       160.168    
  39  0.667455     -0.404284      -14.5183       14.5183       119.932       134.450    
  40  0.460037     -0.776449      -27.8831       27.8831       120.348       148.231    
  41  0.227415      -1.48098      -53.1834       53.1834       124.892       178.076    
  42  0.636494     -0.451780      -16.2239       16.2239       119.097       135.321    
  43  0.432078     -0.839149      -30.1347       30.1347       119.704       149.838    
  44  0.609015     -0.495913      -17.8088       17.8088       118.368       136.177    
  45  0.427755     -0.849205      -30.4958       30.4958       152.479       182.975    
  46  0.496712     -0.699745      -25.1286       25.1286       217.526       242.654    
loop,thermsimp(1:2)       10   17.6445       4.69949    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     63        125.77         67.71          1.17         41.59          0.87          0.05        111.38
Just calling func    0   0        111.39


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     64        140.49         67.70          1.18         41.67          0.63          0.05        111.24
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    125.77
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:       10
neval is:       63
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       10      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:       11
neval is:       63


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       63      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.356780      -1.03064      -37.0113       37.0113       117.527       154.538    
   2  0.318207      -1.14505      -41.1201       41.1201       121.129       162.249    
   3  0.410972E-01  -3.19181      -114.621       114.621       121.677       236.299    
   4  0.217948      -1.52350      -54.7104       54.7104       119.707       174.417    
   5  0.460755     -0.774888      -27.8271       27.8271       121.019       148.847    
   6  0.694214     -0.364975      -13.1066       13.1066       125.093       138.200    
   7  0.237764      -1.43648      -51.5854       51.5854       124.467       176.052    
   8  0.635477     -0.453379      -16.2813       16.2813       121.000       137.282    
   9  0.882831E-01  -2.42721      -87.1635       87.1635       119.932       207.096    
  10  0.889613     -0.116969      -4.20048       4.20048       119.097       123.297    
  11  0.236395      -1.44225      -51.7928       51.7928       118.368       170.161    
  12  0.785560     -0.241359      -8.66744       8.66744       118.731       127.399    
  13  0.253594      -1.37202      -49.2708       49.2708       120.876       170.147    
  14  0.767743     -0.264300      -9.49131       9.49131       119.277       128.769    
  15  0.425111     -0.855405      -30.7185       30.7185       121.024       151.742    
  16  0.334680E-01  -3.39717      -121.996       121.996       130.292       252.288    
  17  0.737903     -0.303943      -10.9149       10.9149       122.108       133.023    
  18  0.530906     -0.633170      -22.7378       22.7378       134.553       157.291    
  19  0.811772     -0.208536      -7.48876       7.48876       125.752       133.240    
  20  0.781494     -0.246548      -8.85380       8.85380       119.714       128.568    
  21  0.668871     -0.402164      -14.4422       14.4422       123.809       138.251    
  22  0.609633     -0.494898      -17.7723       17.7723       119.663       137.435    
  23  0.732795E-01  -2.61347      -93.8526       93.8526       120.348       214.201    
  24  0.999755     -0.244962E-03 -0.879685E-02  0.879685E-02   120.842       120.851    
  25  0.556911     -0.585350      -21.0206       21.0206       125.529       146.550    
  26  0.381942     -0.962485      -34.5639       34.5639       119.704       154.267    
  27  0.230973      -1.46546      -52.6261       52.6261       124.411       177.037    
  28  0.791084     -0.234351      -8.41581       8.41581       143.778       152.194    
  29  0.122039      -2.10341      -75.5358       75.5358       125.047       200.583    
  30  0.411383     -0.888231      -31.8973       31.8973       145.121       177.019    
  31  0.753656     -0.282819      -10.1563       10.1563       119.611       129.768    
  32  0.846821     -0.166266      -5.97080       5.97080       147.503       153.474    
  33  0.577745     -0.548622      -19.7016       19.7016       135.320       155.021    
  34  0.859903     -0.150936      -5.42027       5.42027       122.710       128.130    
  35  0.915816     -0.879395E-01  -3.15800       3.15800       127.913       131.071    
  36  0.220499      -1.51186      -54.2925       54.2925       119.994       174.287    
  37  0.539962     -0.616256      -22.1304       22.1304       124.892       147.023    
  38  0.810725     -0.209827      -7.53510       7.53510       142.906       150.441    
  39  0.901567     -0.103621      -3.72113       3.72113       152.479       156.200    
  40  0.196148      -1.62888      -58.4950       58.4950       119.649       178.144    
  41  0.413437     -0.883250      -31.7184       31.7184       129.721       161.439    
  42  0.192892      -1.64562      -59.0961       59.0961       122.382       181.478    
  43  0.194290      -1.63840      -58.8368       58.8368       119.057       177.894    
  44  0.988313     -0.117563E-01 -0.422181      0.422181       217.526       217.948    
  45  0.917980     -0.855792E-01  -3.07324       3.07324       128.361       131.435    
  46  0.136083      -1.99449      -71.6242       71.6242       125.771       197.395    
loop,thermsimp(1:2)       11   37.0113       41.1201    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     65        124.14         67.76          1.15         41.83          0.78          0.04        111.55
Just calling func    0   0        111.56


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    124.14
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:       11
neval is:       64
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       11      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:       12
neval is:       64


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       64      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.759790E-01  -2.57730      -92.5535       92.5535       120.842       213.396    
   2  0.804470     -0.217571      -7.81321       7.81321       119.097       126.910    
   3  0.984017     -0.161120E-01 -0.578599      0.578599       118.731       119.310    
   4  0.587639     -0.531643      -19.0919       19.0919       122.710       141.802    
   5  0.523810     -0.646626      -23.2210       23.2210       119.714       142.935    
   6  0.930607     -0.719181E-01  -2.58265       2.58265       119.277       121.860    
   7  0.360114E-01  -3.32392      -119.366       119.366       119.611       238.977    
   8  0.963815     -0.368556E-01  -1.32352       1.32352       127.913       129.237    
   9  0.201264E-01  -3.90572      -140.259       140.259       128.361       268.620    
  10  0.954897     -0.461522E-01  -1.65738       1.65738       122.108       123.765    
  11  0.374160     -0.983071      -35.3031       35.3031       125.752       161.055    
  12  0.174967      -1.74316      -62.5986       62.5986       121.000       183.599    
  13  0.381618     -0.963335      -34.5944       34.5944       119.663       154.257    
  14  0.191097      -1.65498      -59.4320       59.4320       125.093       184.525    
  15  0.425287     -0.854991      -30.7036       30.7036       123.809       154.513    
  16  0.426180     -0.852893      -30.6283       30.6283       125.529       156.158    
  17  0.615671     -0.485042      -17.4184       17.4184       124.892       142.311    
  18  0.787264     -0.239192      -8.58963       8.58963       121.019       129.609    
  19  0.812636     -0.207472      -7.45054       7.45054       142.906       150.356    
  20  0.917241E-01  -2.38897      -85.7904       85.7904       121.024       206.814    
  21  0.671310     -0.398525      -14.3114       14.3114       143.778       158.090    
  22  0.548174     -0.601162      -21.5884       21.5884       147.503       169.091    
  23  0.134851      -2.00359      -71.9509       71.9509       119.704       191.654    
  24  0.373236     -0.985545      -35.3920       35.3920       117.527       152.919    
  25  0.578774     -0.546843      -19.6377       19.6377       135.320       154.957    
  26  0.910021     -0.942872E-01  -3.38595       3.38595       152.479       155.865    
  27  0.192323      -1.64858      -59.2022       59.2022       134.553       193.755    
  28  0.366342      -1.00419      -36.0615       36.0615       129.721       165.782    
  29  0.686994     -0.375430      -13.4821       13.4821       121.129       134.611    
  30  0.486551     -0.720414      -25.8708       25.8708       120.876       146.747    
  31  0.256801      -1.35945      -48.8194       48.8194       118.368       167.188    
  32  0.284977      -1.25535      -45.0809       45.0809       119.994       165.075    
  33  0.903072     -0.101953      -3.66122       3.66122       119.707       123.368    
  34  0.226450      -1.48523      -53.3362       53.3362       124.467       177.803    
  35  0.446078     -0.807261      -28.9896       28.9896       145.121       174.111    
  36  0.152634      -1.87971      -67.5025       67.5025       124.411       191.913    
  37  0.511955     -0.669518      -24.0431       24.0431       119.057       143.100    
  38  0.513138     -0.667210      -23.9602       23.9602       119.649       143.609    
  39  0.637309     -0.450501      -16.1780       16.1780       122.382       138.560    
  40  0.861477     -0.149107      -5.35459       5.35459       125.771       131.125    
  41  0.817364     -0.201671      -7.24221       7.24221       125.047       132.289    
  42  0.793820     -0.230898      -8.29179       8.29179       119.932       128.224    
  43  0.253309      -1.37315      -49.3111       49.3111       120.348       169.659    
  44  0.702532     -0.353065      -12.6789       12.6789       217.526       230.205    
  45  0.822324     -0.195620      -7.02493       7.02493       121.677       128.702    
  46  0.720485     -0.327831      -11.7728       11.7728       124.136       135.908    
loop,thermsimp(1:2)       12   92.5535       7.81321    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     66        118.47         67.70          1.14         41.65          0.91          0.05        111.44
Just calling func    0   0        111.44


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     67        118.95         67.79          1.13         41.59          0.96          0.05        111.53
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    118.47
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:       12
neval is:       66
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       12      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:       13
neval is:       66


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       66      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.872435     -0.136467      -4.90066       4.90066       118.731       123.632    
   2  0.311340      -1.16687      -41.9035       41.9035       119.277       161.181    
   3  0.293828      -1.22476      -43.9825       43.9825       119.707       163.689    
   4  0.586668     -0.533296      -19.1512       19.1512       122.108       141.259    
   5  0.360311      -1.02079      -36.6576       36.6576       119.097       155.754    
   6  0.315643      -1.15314      -41.4106       41.4106       119.932       161.343    
   7  0.481464     -0.730923      -26.2482       26.2482       121.677       147.925    
   8  0.720279     -0.328116      -11.7830       11.7830       127.913       139.696    
   9  0.551471     -0.595166      -21.3730       21.3730       121.019       142.393    
  10  0.524434     -0.645435      -23.1783       23.1783       125.771       148.949    
  11  0.781600     -0.246412      -8.84891       8.84891       125.047       133.896    
  12  0.353648      -1.03945      -37.3278       37.3278       121.129       158.457    
  13  0.451044     -0.796190      -28.5920       28.5920       124.136       152.728    
  14  0.325353      -1.12284      -40.3225       40.3225       122.382       162.704    
  15  0.312157      -1.16425      -41.8094       41.8094       122.710       164.519    
  16  0.432418     -0.838362      -30.1065       30.1065       124.892       154.999    
  17  0.296543      -1.21556      -43.6521       43.6521       119.714       163.366    
  18  0.705416     -0.348967      -12.5318       12.5318       119.057       131.589    
  19  0.146505      -1.92069      -68.9741       68.9741       119.649       188.623    
  20  0.471608     -0.751607      -26.9910       26.9910       120.876       147.867    
  21  0.633095     -0.457134      -16.4162       16.4162       142.906       159.322    
  22  0.754855     -0.281230      -10.0993       10.0993       117.527       127.626    
  23  0.444501E-01  -3.11339      -111.805       111.805       119.663       231.468    
  24  0.160973      -1.82652      -65.5922       65.5922       123.809       189.401    
  25  0.943694     -0.579536E-01  -2.08117       2.08117       135.320       137.401    
  26  0.187304      -1.67502      -60.1519       60.1519       152.479       212.631    
  27  0.840922     -0.173257      -6.22183       6.22183       125.529       131.751    
  28  0.888648     -0.118054      -4.23944       4.23944       143.778       148.018    
  29  0.920614E-01  -2.38530      -85.6586       85.6586       125.752       211.410    
  30  0.906493     -0.981722E-01  -3.52547       3.52547       119.994       123.519    
  31  0.221761      -1.50616      -54.0877       54.0877       129.721       183.808    
  32  0.248725      -1.39141      -49.9669       49.9669       118.368       168.335    
  33  0.315928      -1.15224      -41.3782       41.3782       147.503       188.881    
  34  0.949967     -0.513283E-01  -1.84326       1.84326       120.348       122.191    
  35  0.802748     -0.219715      -7.89019       7.89019       145.121       153.011    
  36  0.558987     -0.581628      -20.8869       20.8869       124.467       145.354    
  37  0.638133     -0.449209      -16.1316       16.1316       121.000       137.132    
  38  0.637852     -0.449648      -16.1473       16.1473       125.093       141.241    
  39  0.382908     -0.959961      -34.4732       34.4732       119.704       154.177    
  40  0.982834     -0.173149E-01 -0.621798      0.621798       124.411       125.033    
  41  0.497022     -0.699120      -25.1061       25.1061       134.553       159.659    
  42  0.263620      -1.33325      -47.8783       47.8783       121.024       168.902    
  43  0.296939      -1.21423      -43.6043       43.6043       120.842       164.447    
  44  0.784161     -0.243141      -8.73146       8.73146       217.526       226.257    
  45  0.545321     -0.606380      -21.7758       21.7758       119.611       141.387    
  46  0.770080     -0.261260      -9.38214       9.38214       118.469       127.851    
loop,thermsimp(1:2)       13   4.90066       41.9035    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     68        120.91         67.69          1.14         41.90          0.71          0.05        111.49
Just calling func    0   0        111.49


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     69        120.25         67.80          1.16         41.75          0.60          0.05        111.35
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    120.25
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:       13
neval is:       68
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       13      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:       14
neval is:       68


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       68      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.344597      -1.06538      -38.2589       38.2589       120.348       158.607    
   2  0.267720      -1.31781      -47.3241       47.3241       119.994       167.318    
   3  0.279825      -1.27359      -45.7360       45.7360       118.731       164.467    
   4  0.281095      -1.26906      -45.5734       45.5734       124.411       169.984    
   5  0.245867      -1.40297      -50.3820       50.3820       117.527       167.909    
   6  0.914239     -0.896636E-01  -3.21991       3.21991       118.469       121.688    
   7  0.180116      -1.71415      -61.5571       61.5571       119.057       180.614    
   8  0.567917     -0.565780      -20.3178       20.3178       125.529       145.847    
   9  0.431941     -0.839465      -30.1461       30.1461       125.047       155.193    
  10  0.877920     -0.130199      -4.67560       4.67560       121.000       125.676    
  11  0.280355      -1.27170      -45.6680       45.6680       135.320       180.988    
  12  0.486947     -0.719601      -25.8416       25.8416       127.913       153.755    
  13  0.216546      -1.52995      -54.9422       54.9422       125.093       180.035    
  14  0.483718E-02  -5.33142      -191.457       191.457       122.108       313.565    
  15  0.785152E-03  -7.14963      -256.751       256.751       119.611       376.362    
  16  0.300781      -1.20137      -43.1425       43.1425       121.019       164.162    
  17  0.869691     -0.139618      -5.01382       5.01382       124.467       129.481    
  18  0.694261E-01  -2.66749      -95.7925       95.7925       120.876       216.669    
  19  0.635475     -0.453382      -16.2814       16.2814       121.677       137.959    
  20  0.894977     -0.110958      -3.98460       3.98460       143.778       147.763    
  21  0.442267     -0.815841      -29.2977       29.2977       125.771       155.068    
  22  0.283362      -1.26103      -45.2849       45.2849       124.136       169.421    
  23  0.518611     -0.656601      -23.5792       23.5792       145.121       168.700    
  24  0.858122E-01  -2.45559      -88.1830       88.1830       119.704       207.887    
  25  0.461153     -0.774026      -27.7961       27.7961       124.892       152.688    
  26  0.180026      -1.71465      -61.5751       61.5751       119.097       180.672    
  27  0.446938E-01  -3.10792      -111.609       111.609       121.129       232.738    
  28  0.152352      -1.88156      -67.5688       67.5688       142.906       210.475    
  29  0.163937E-01  -4.11086      -147.625       147.625       134.553       282.179    
  30  0.721347     -0.326635      -11.7298       11.7298       119.277       131.007    
  31  0.813323     -0.206626      -7.42017       7.42017       119.932       127.352    
  32  0.569343     -0.563273      -20.2277       20.2277       122.382       142.609    
  33  0.275899      -1.28772      -46.2434       46.2434       119.714       165.958    
  34  0.933187     -0.691492E-01  -2.48322       2.48322       119.707       122.190    
  35  0.716570     -0.333279      -11.9684       11.9684       120.842       132.811    
  36  0.405413     -0.902848      -32.4222       32.4222       122.710       155.132    
  37  0.907528     -0.970314E-01  -3.48450       3.48450       118.368       121.853    
  38  0.554651     -0.589416      -21.1665       21.1665       121.024       142.190    
  39  0.419962     -0.867592      -31.1561       31.1561       129.721       160.877    
  40  0.824173     -0.193375      -6.94430       6.94430       119.649       126.593    
  41  0.865647     -0.144278      -5.18119       5.18119       147.503       152.684    
  42  0.300944      -1.20083      -43.1232       43.1232       123.809       166.932    
  43  0.339688      -1.07973      -38.7742       38.7742       125.752       164.526    
  44  0.217032      -1.52771      -54.8618       54.8618       152.479       207.341    
  45  0.792618E-01  -2.53500      -91.0345       91.0345       217.526       308.560    
  46  0.997677     -0.232582E-02 -0.835226E-01  0.835226E-01   120.246       120.329    
loop,thermsimp(1:2)       14   38.2589       47.3241    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     70        120.10         67.73          1.14         41.52          1.04          0.05        111.48
Just calling func    0   0        111.48


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     71        134.00         67.69          1.14         41.68          0.75          0.05        111.31
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    120.10
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:       14
neval is:       70
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       14      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:       15
neval is:       70


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       70      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.229949      -1.46990      -52.7856       52.7856       120.246       173.031    
   2  0.322822      -1.13066      -40.6030       40.6030       118.469       159.072    
   3  0.327586      -1.11601      -40.0769       40.0769       118.368       158.445    
   4  0.799078     -0.224296      -8.05472       8.05472       119.707       127.762    
   5  0.698072     -0.359433      -12.9076       12.9076       121.000       133.908    
   6  0.733871     -0.309421      -11.1117       11.1117       119.649       130.761    
   7  0.823872     -0.193740      -6.95742       6.95742       119.932       126.890    
   8  0.800045     -0.223087      -8.01129       8.01129       124.467       132.478    
   9  0.162010      -1.82010      -65.3616       65.3616       119.277       184.639    
  10  0.113138      -2.17915      -78.2555       78.2555       120.842       199.098    
  11  0.973966     -0.263784E-01 -0.947275      0.947275       121.677       122.624    
  12  0.998107     -0.189521E-02 -0.680588E-01  0.680588E-01   121.024       121.092    
  13  0.631351     -0.459893      -16.5152       16.5152       122.382       138.897    
  14  0.698229     -0.359208      -12.8996       12.8996       125.529       138.429    
  15  0.359252      -1.02373      -36.7633       36.7633       143.778       180.541    
  16  0.936266     -0.658562E-01  -2.36496       2.36496       147.503       149.868    
  17  0.843107     -0.170662      -6.12864       6.12864       124.892       131.021    
  18  0.181284      -1.70769      -61.3250       61.3250       127.913       189.239    
  19  0.354246      -1.03777      -37.2672       37.2672       125.771       163.038    
  20  0.981540     -0.186324E-01 -0.669109      0.669109       122.710       123.379    
  21  0.582284E-01  -2.84338      -102.109       102.109       125.047       227.156    
  22  0.935088     -0.671143E-01  -2.41015       2.41015       120.348       122.758    
  23  0.682144     -0.382515      -13.7365       13.7365       129.721       143.457    
  24  0.441439     -0.817715      -29.3650       29.3650       121.019       150.384    
  25  0.325829      -1.12138      -40.2700       40.2700       118.731       159.001    
  26  0.956968E-01  -2.34657      -84.2678       84.2678       125.752       210.020    
  27  0.465124E-01  -3.06804      -110.176       110.176       119.714       229.891    
  28  0.645503     -0.437726      -15.7192       15.7192       123.809       139.529    
  29  0.184751      -1.68875      -60.6446       60.6446       119.994       180.639    
  30  0.676303     -0.391115      -14.0453       14.0453       117.527       131.572    
  31  0.408248     -0.895880      -32.1720       32.1720       145.121       177.293    
  32  0.215511      -1.53474      -55.1143       55.1143       124.136       179.250    
  33  0.762109     -0.271666      -9.75582       9.75582       124.411       134.167    
  34  0.445022     -0.809632      -29.0747       29.0747       125.093       154.168    
  35  0.667113     -0.404797      -14.5367       14.5367       119.057       133.594    
  36  0.995785     -0.422376E-02 -0.151680      0.151680       119.097       119.248    
  37  0.278840      -1.27712      -45.8627       45.8627       135.320       181.182    
  38  0.624255     -0.471196      -16.9211       16.9211       152.479       169.400    
  39  0.368212     -0.999097      -35.8786       35.8786       119.704       155.582    
  40  0.330266      -1.10786      -39.7844       39.7844       142.906       182.690    
  41  0.969155     -0.313304E-01  -1.12511       1.12511       120.876       122.001    
  42  0.686816     -0.375688      -13.4914       13.4914       121.129       134.621    
  43  0.201053      -1.60419      -57.6080       57.6080       134.553       192.161    
  44  0.481166     -0.731544      -26.2705       26.2705       217.526       243.796    
  45  0.992829     -0.719725E-02 -0.258461      0.258461       122.108       122.366    
  46  0.665697     -0.406921      -14.6130       14.6130       120.104       134.717    
loop,thermsimp(1:2)       15   52.7856       40.6030    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     72        202.06         67.69          1.12         42.12          0.77          0.05        111.75
Just calling func    0   0        111.75


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    202.06
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:       15
neval is:       71
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       15      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:       16
neval is:       71


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       71      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.557805     -0.583747      -20.9630       20.9630       119.097       140.060    
   2  0.850944     -0.161409      -5.79637       5.79637       121.024       126.820    
   3  0.343999      -1.06712      -38.3213       38.3213       120.876       159.197    
   4  0.481777E-02  -5.33544      -191.601       191.601       122.108       313.709    
   5  0.146991      -1.91738      -68.8552       68.8552       121.677       190.532    
   6  0.545677     -0.605728      -21.7523       21.7523       120.348       142.100    
   7  0.761940     -0.271888      -9.76378       9.76378       122.710       132.473    
   8  0.944477     -0.571238E-01  -2.05138       2.05138       119.932       121.983    
   9  0.965249     -0.353688E-01  -1.27013       1.27013       119.707       120.977    
  10  0.634176     -0.455429      -16.3550       16.3550       119.649       136.004    
  11  0.793205     -0.231673      -8.31964       8.31964       124.892       133.212    
  12  0.743605     -0.296246      -10.6385       10.6385       117.527       128.165    
  13  0.983069E-01  -2.31966      -83.3015       83.3015       124.467       207.768    
  14  0.618437     -0.480560      -17.2574       17.2574       119.057       136.315    
  15  0.429182     -0.845875      -30.3763       30.3763       121.000       151.377    
  16  0.771528     -0.259382      -9.31468       9.31468       124.411       133.726    
  17  0.218286      -1.52195      -54.6547       54.6547       121.129       175.784    
  18  0.556408     -0.586254      -21.0530       21.0530       120.104       141.157    
  19  0.526292     -0.641899      -23.0513       23.0513       125.529       148.581    
  20  0.665532     -0.407169      -14.6219       14.6219       122.382       137.003    
  21  0.261756      -1.34034      -48.1332       48.1332       123.809       171.942    
  22  0.975508     -0.247971E-01 -0.890490      0.890490       129.721       130.611    
  23  0.257613      -1.35630      -48.7060       48.7060       147.503       196.209    
  24  0.981555E-01  -2.32120      -83.3568       83.3568       121.019       204.376    
  25  0.955054     -0.459870E-01  -1.65144       1.65144       125.093       126.745    
  26  0.887906     -0.118890      -4.26946       4.26946       119.704       123.973    
  27  0.407043     -0.898837      -32.2782       32.2782       118.368       150.647    
  28  0.876870     -0.131396      -4.71858       4.71858       118.731       123.450    
  29  0.957152     -0.437935E-01  -1.57267       1.57267       118.469       120.041    
  30  0.827730     -0.189068      -6.78962       6.78962       125.771       132.560    
  31  0.289027      -1.24124      -44.5741       44.5741       152.479       197.053    
  32  0.125230      -2.07760      -74.6089       74.6089       120.246       194.855    
  33  0.242443      -1.41699      -50.8856       50.8856       145.121       196.007    
  34  0.654103     -0.424490      -15.2439       15.2439       124.136       139.380    
  35  0.811871     -0.208414      -7.48435       7.48435       143.778       151.263    
  36  0.145201E-01  -4.23222      -151.984       151.984       119.994       271.977    
  37  0.344449      -1.06581      -38.2743       38.2743       135.320       173.594    
  38  0.265532      -1.32602      -47.6187       47.6187       142.906       190.524    
  39  0.811851     -0.208438      -7.48524       7.48524       119.277       126.763    
  40  0.983290E-01  -2.31944      -83.2934       83.2934       127.913       211.207    
  41  0.347314      -1.05753      -37.9769       37.9769       134.553       172.530    
  42  0.923773     -0.792888E-01  -2.84734       2.84734       120.842       123.690    
  43  0.690375     -0.370520      -13.3058       13.3058       125.752       139.057    
  44  0.227523      -1.48051      -53.1665       53.1665       125.047       178.213    
  45  0.652275     -0.427289      -15.3444       15.3444       119.714       135.059    
  46  0.669640     -0.401014      -14.4008       14.4008       202.062       216.463    
loop,thermsimp(1:2)       16   20.9630       5.79637    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     73        121.29         67.70          1.09         41.96          0.56          0.05        111.38
Just calling func    0   0        111.38


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     74        127.11         67.81          1.11         41.87          0.77          0.05        111.62
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    121.29
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:       16
neval is:       73
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       16      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:       17
neval is:       73


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       73      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.739792     -0.301387      -10.8231       10.8231       118.469       129.292    
   2  0.527958     -0.638738      -22.9378       22.9378       119.707       142.645    
   3  0.326119      -1.12049      -40.2381       40.2381       119.932       160.170    
   4  0.647061     -0.435314      -15.6326       15.6326       118.731       134.364    
   5  0.419805     -0.867966      -31.1696       31.1696       120.842       152.012    
   6  0.218417      -1.52135      -54.6332       54.6332       119.704       174.337    
   7  0.168864      -1.77866      -63.8737       63.8737       125.093       188.967    
   8  0.761417     -0.272575      -9.78844       9.78844       119.277       129.066    
   9  0.383989     -0.957143      -34.3720       34.3720       121.024       155.396    
  10  0.104774      -2.25595      -81.0136       81.0136       117.527       198.540    
  11  0.167912      -1.78432      -64.0767       64.0767       129.721       193.797    
  12  0.997930     -0.207190E-02 -0.744041E-01  0.744041E-01   122.710       122.784    
  13  0.493294     -0.706650      -25.3766       25.3766       125.771       151.147    
  14  0.483048     -0.727639      -26.1303       26.1303       124.892       151.023    
  15  0.715967     -0.334121      -11.9987       11.9987       124.411       136.409    
  16  0.595423E-01  -2.82107      -101.308       101.308       119.714       221.022    
  17  0.636569     -0.451662      -16.2197       16.2197       119.649       135.869    
  18  0.482980     -0.727779      -26.1353       26.1353       119.057       145.193    
  19  0.500121     -0.692905      -24.8830       24.8830       122.382       147.265    
  20  0.426980     -0.851018      -30.5609       30.5609       125.752       156.313    
  21  0.546576     -0.604082      -21.6932       21.6932       124.136       145.829    
  22  0.142720      -1.94687      -69.9143       69.9143       119.097       189.011    
  23  0.473622     -0.747346      -26.8380       26.8380       120.104       146.942    
  24  0.892718E-01  -2.41607      -86.7636       86.7636       120.348       207.112    
  25  0.660659     -0.414518      -14.8858       14.8858       125.529       140.415    
  26  0.328755      -1.11244      -39.9490       39.9490       118.368       158.317    
  27  0.544150     -0.608530      -21.8530       21.8530       143.778       165.631    
  28  0.199068      -1.61411      -57.9644       57.9644       121.000       178.965    
  29  0.685070     -0.378234      -13.5828       13.5828       120.876       134.459    
  30  0.500258     -0.692632      -24.8731       24.8731       123.809       148.682    
  31  0.130607      -2.03556      -73.0992       73.0992       134.553       207.652    
  32  0.982013E-01  -2.32074      -83.3401       83.3401       135.320       218.660    
  33  0.581494E-01  -2.84474      -102.158       102.158       121.129       223.287    
  34  0.841391     -0.172699      -6.20181       6.20181       125.047       131.249    
  35  0.838937E-01  -2.47820      -88.9949       88.9949       142.906       231.901    
  36  0.729848     -0.314919      -11.3091       11.3091       121.677       132.986    
  37  0.748292     -0.289962      -10.4128       10.4128       120.246       130.659    
  38  0.229216      -1.47309      -52.9002       52.9002       145.121       198.021    
  39  0.710713     -0.341487      -12.2632       12.2632       147.503       159.766    
  40  0.511506     -0.670395      -24.0746       24.0746       152.479       176.554    
  41  0.106756      -2.23721      -80.3404       80.3404       121.019       201.360    
  42  0.583466     -0.538770      -19.3478       19.3478       124.467       143.815    
  43  0.993140E-01  -2.30947      -82.9355       82.9355       127.913       210.849    
  44  0.461224     -0.773871      -27.7905       27.7905       202.062       229.853    
  45  0.574465     -0.554316      -19.9061       19.9061       119.994       139.900    
  46  0.715977     -0.334107      -11.9982       11.9982       121.289       133.288    
loop,thermsimp(1:2)       17   10.8231       22.9378    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     75        122.56         67.80          1.11         41.95          0.85          0.05        111.77
Just calling func    0   0        111.78


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     76        126.77         67.88          1.12         42.01          0.80          0.05        111.86
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    122.56
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:       17
neval is:       75
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       17      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:       18
neval is:       75


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       75      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.382860     -0.960086      -34.4777       34.4777       122.710       157.187    
   2  0.293468      -1.22599      -44.0265       44.0265       119.277       163.304    
   3  0.954036     -0.470539E-01  -1.68975       1.68975       118.469       120.158    
   4  0.452934     -0.792010      -28.4419       28.4419       120.246       148.688    
   5  0.251692      -1.37955      -49.5411       49.5411       125.047       174.588    
   6  0.881081     -0.126605      -4.54654       4.54654       121.677       126.224    
   7  0.855311     -0.156290      -5.61253       5.61253       121.289       126.902    
   8  0.576474     -0.550824      -19.7807       19.7807       118.731       138.512    
   9  0.433835     -0.835090      -29.9890       29.9890       120.876       150.865    
  10  0.298626      -1.20856      -43.4008       43.4008       119.649       163.050    
  11  0.269991      -1.30937      -47.0208       47.0208       124.411       171.432    
  12  0.884826     -0.122364      -4.39422       4.39422       119.994       124.388    
  13  0.664124     -0.409287      -14.6979       14.6979       125.529       140.227    
  14  0.580836     -0.543287      -19.5100       19.5100       119.707       139.217    
  15  0.285501      -1.25351      -45.0148       45.0148       124.467       169.482    
  16  0.690757     -0.369967      -13.2859       13.2859       119.057       132.343    
  17  0.578320     -0.547628      -19.6659       19.6659       124.136       143.802    
  18  0.563230     -0.574067      -20.6154       20.6154       120.104       140.720    
  19  0.681565     -0.383363      -13.7670       13.7670       122.382       136.149    
  20  0.453362     -0.791065      -28.4080       28.4080       123.809       152.217    
  21  0.645457     -0.437797      -15.7218       15.7218       124.892       140.614    
  22  0.982222E-01  -2.32052      -83.3325       83.3325       125.771       209.103    
  23  0.843064     -0.170712      -6.13046       6.13046       120.842       126.973    
  24  0.505683     -0.681845      -24.4858       24.4858       121.024       145.510    
  25  0.350376      -1.04875      -37.6617       37.6617       125.752       163.413    
  26  0.367167      -1.00194      -35.9807       35.9807       118.368       154.349    
  27  0.268175      -1.31611      -47.2630       47.2630       147.503       194.766    
  28  0.989085E-01  -2.31356      -83.0824       83.0824       119.932       203.014    
  29  0.349392      -1.05156      -37.7627       37.7627       143.778       181.541    
  30  0.945468     -0.560755E-01  -2.01373       2.01373       119.704       121.717    
  31  0.305400      -1.18613      -42.5952       42.5952       152.479       195.074    
  32  0.942706     -0.590006E-01  -2.11878       2.11878       121.000       123.119    
  33  0.778346     -0.250584      -8.99874       8.99874       125.093       134.092    
  34  0.256449      -1.36083      -48.8687       48.8687       119.097       167.965    
  35  0.338120      -1.08436      -38.9403       38.9403       129.721       168.661    
  36  0.644609     -0.439112      -15.7690       15.7690       145.121       160.890    
  37  0.420837     -0.865509      -31.0813       31.0813       117.527       148.608    
  38  0.793406     -0.231421      -8.31056       8.31056       121.019       129.330    
  39  0.685561     -0.377517      -13.5570       13.5570       120.348       133.905    
  40  0.278740      -1.27748      -45.8755       45.8755       134.553       180.429    
  41  0.414078     -0.881700      -31.6628       31.6628       127.913       159.576    
  42  0.999720     -0.280334E-03 -0.100671E-01  0.100671E-01   135.320       135.330    
  43  0.714259     -0.336509      -12.0844       12.0844       119.714       131.799    
  44  0.713371     -0.337753      -12.1291       12.1291       121.129       133.258    
  45  0.451360     -0.795490      -28.5669       28.5669       202.062       230.629    
  46  0.887280     -0.119595      -4.29479       4.29479       122.555       126.850    
loop,thermsimp(1:2)       18   34.4777       44.0265    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     77        212.76         67.80          1.12         41.89          0.64          0.05        111.49
Just calling func    0   0        111.50


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    212.76
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:       18
neval is:       76
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       18      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:       19
neval is:       76


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       76      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.352992      -1.04131      -37.3945       37.3945       118.469       155.863    
   2  0.270835E-01  -3.60883      -129.597       129.597       119.704       249.300    
   3  0.923755     -0.793087E-01  -2.84806       2.84806       121.000       123.848    
   4  0.535520     -0.624517      -22.4271       22.4271       119.994       142.421    
   5  0.629344     -0.463078      -16.6296       16.6296       121.677       138.307    
   6  0.572648E-01  -2.86007      -102.708       102.708       122.555       225.264    
   7  0.353113E-01  -3.34355      -120.071       120.071       121.289       241.360    
   8  0.580838     -0.543283      -19.5099       19.5099       120.842       140.352    
   9  0.370403     -0.993164      -35.6656       35.6656       121.019       156.685    
  10  0.443010     -0.814162      -29.2374       29.2374       119.714       148.952    
  11  0.188704      -1.66757      -59.8844       59.8844       119.057       178.942    
  12  0.177608      -1.72818      -62.0607       62.0607       121.129       183.190    
  13  0.694998     -0.363847      -13.0661       13.0661       120.348       133.414    
  14  0.160742      -1.82796      -65.6438       65.6438       125.093       190.737    
  15  0.290050      -1.23770      -44.4472       44.4472       135.320       179.767    
  16  0.441138E-01  -3.12098      -112.078       112.078       122.382       234.459    
  17  0.372461     -0.987622      -35.4666       35.4666       118.731       154.198    
  18  0.652779     -0.426517      -15.3167       15.3167       119.707       135.024    
  19  0.998108     -0.189387E-02 -0.680110E-01  0.680110E-01   125.529       125.597    
  20  0.741140     -0.299566      -10.7577       10.7577       124.892       135.650    
  21  0.623042     -0.473141      -16.9910       16.9910       120.104       137.095    
  22  0.504617     -0.683955      -24.5616       24.5616       124.136       148.697    
  23  0.872499     -0.136394      -4.89806       4.89806       121.024       125.922    
  24  0.142620      -1.94757      -69.9393       69.9393       117.527       187.466    
  25  0.580285     -0.544236      -19.5441       19.5441       120.246       139.790    
  26  0.860063E-01  -2.45334      -88.1019       88.1019       120.876       208.978    
  27  0.401846     -0.911687      -32.7396       32.7396       123.809       156.549    
  28  0.161242      -1.82485      -65.5324       65.5324       118.368       183.901    
  29  0.550753     -0.596469      -21.4198       21.4198       122.710       144.129    
  30  0.815012     -0.204553      -7.34570       7.34570       127.913       135.259    
  31  0.438663     -0.824024      -29.5916       29.5916       145.121       174.713    
  32  0.542283     -0.611968      -21.9764       21.9764       119.649       141.626    
  33  0.943132E-01  -2.36113      -84.7908       84.7908       119.277       204.068    
  34  0.236587      -1.44144      -51.7636       51.7636       125.752       177.515    
  35  0.283068      -1.26207      -45.3222       45.3222       119.097       164.419    
  36  0.973178     -0.271886E-01 -0.976371      0.976371       129.721       130.697    
  37  0.596723     -0.516302      -18.5409       18.5409       124.467       143.008    
  38  0.595114     -0.519003      -18.6379       18.6379       124.411       143.049    
  39  0.948736     -0.526250E-01  -1.88982       1.88982       125.047       126.937    
  40  0.216072E-01  -3.83473      -137.709       137.709       134.553       272.262    
  41  0.440213     -0.820496      -29.4649       29.4649       143.778       173.243    
  42  0.905197     -0.996023E-01  -3.57683       3.57683       147.503       151.080    
  43  0.158396      -1.84266      -66.1719       66.1719       152.479       218.651    
  44  0.287789      -1.24553      -44.7282       44.7282       119.932       164.660    
  45  0.238244      -1.43446      -51.5130       51.5130       125.771       177.284    
  46  0.363881      -1.01093      -36.3035       36.3035       212.758       249.061    
loop,thermsimp(1:2)       19   37.3945       129.597    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     78        119.34         67.88          1.14         41.92          0.53          0.05        111.52
Just calling func    0   0        111.52


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     79        117.75         67.73          1.12         41.95          0.41          0.05        111.26
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    117.75
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:       19
neval is:       78
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       19      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:       20
neval is:       78


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       78      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.534746     -0.625963      -22.4790       22.4790       121.000       143.479    
   2  0.288348      -1.24359      -44.6586       44.6586       125.529       170.188    
   3  0.910112E-01  -2.39677      -86.0707       86.0707       121.024       207.095    
   4  0.213812      -1.54266      -55.3985       55.3985       125.047       180.445    
   5  0.575222     -0.552999      -19.8588       19.8588       129.721       149.580    
   6  0.855707     -0.155827      -5.59592       5.59592       120.348       125.944    
   7  0.818692     -0.200047      -7.18392       7.18392       119.707       126.891    
   8  0.309911      -1.17147      -42.0688       42.0688       127.913       169.982    
   9  0.773438     -0.256910      -9.22590       9.22590       124.892       134.118    
  10  0.440502E-01  -3.12243      -112.130       112.130       120.104       232.234    
  11  0.211655      -1.55280      -55.7626       55.7626       121.677       177.440    
  12  0.713577     -0.337465      -12.1187       12.1187       120.246       132.365    
  13  0.927405     -0.753650E-01  -2.70644       2.70644       120.842       123.549    
  14  0.360229      -1.02101      -36.6657       36.6657       119.649       156.315    
  15  0.911872     -0.922553E-01  -3.31299       3.31299       119.994       123.307    
  16  0.800691     -0.222280      -7.98232       7.98232       124.467       132.449    
  17  0.169830      -1.77296      -63.6689       63.6689       124.411       188.080    
  18  0.581014     -0.542980      -19.4990       19.4990       122.710       142.209    
  19  0.869395     -0.139958      -5.02603       5.02603       124.136       129.162    
  20  0.773880     -0.256338      -9.20538       9.20538       119.714       128.920    
  21  0.496085     -0.701008      -25.1740       25.1740       147.503       172.677    
  22  0.530037     -0.634809      -22.7967       22.7967       118.731       141.528    
  23  0.239414      -1.42956      -51.3371       51.3371       118.469       169.806    
  24  0.595728     -0.517972      -18.6009       18.6009       123.809       142.410    
  25  0.170793      -1.76730      -63.4658       63.4658       121.019       184.485    
  26  0.983027     -0.171183E-01 -0.614736      0.614736       119.097       119.711    
  27  0.608714     -0.496407      -17.8265       17.8265       119.932       137.759    
  28  0.518727     -0.656378      -23.5712       23.5712       143.778       167.349    
  29  0.887918     -0.118876      -4.26896       4.26896       145.121       149.390    
  30  0.140498      -1.96256      -70.4777       70.4777       125.771       196.248    
  31  0.256308      -1.36138      -48.8884       48.8884       125.752       174.640    
  32  0.887238     -0.119642      -4.29646       4.29646       119.057       123.354    
  33  0.306042      -1.18403      -42.5199       42.5199       135.320       177.839    
  34  0.993873     -0.614632E-02 -0.220721      0.220721       121.129       121.350    
  35  0.275412E-01  -3.59207      -128.995       128.995       118.368       247.364    
  36  0.698960     -0.358161      -12.8619       12.8619       117.527       130.389    
  37  0.268424      -1.31519      -47.2297       47.2297       125.093       172.323    
  38  0.580935E-01  -2.84570      -102.192       102.192       119.277       221.470    
  39  0.242705      -1.41591      -50.8468       50.8468       120.876       171.723    
  40  0.443517     -0.813019      -29.1964       29.1964       152.479       181.675    
  41  0.904179     -0.100728      -3.61724       3.61724       122.555       126.173    
  42  0.454025     -0.789603      -28.3555       28.3555       122.382       150.737    
  43  0.592994     -0.522572      -18.7661       18.7661       121.289       140.056    
  44  0.401796     -0.911812      -32.7441       32.7441       212.758       245.502    
  45  0.130776      -2.03427      -73.0528       73.0528       119.704       192.756    
  46  0.709753     -0.342839      -12.3117       12.3117       117.750       130.062    
loop,thermsimp(1:2)       20   22.4790       44.6586    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     80        121.16         67.72          1.11         42.00          0.51          0.05        111.38
Just calling func    0   0        111.39


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     81        117.45         67.70          1.11         42.05          0.48          0.05        111.39
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

   80    117.45        1.015     -2.402      2.711     -102.6     0.7606    
                      0.9648      1.108     -99.70      3.252     0.6531    

                       1.857     -2.251      1.540      7404.      7000.    

                      0.1513      0.000      0.000      0.000     -1.221    



                      -1.861      0.000      0.000      7000.      655.0    

                       1.650     -5.214     -2.867     -7.881      7.164    

                      -13.64     -5.015      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.3752    -0.7428      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.5623     -1.184      7000.    



                      -1.387     -1.009     -2.067     -1.956    -0.3807    

                     -0.3252      9.249      8.765    -0.1606E+05 -5.700    

                     -0.2786     -2.685      9.334      8.853    -0.1969E+05



                      -6.000     0.7348    -0.2191      8.910      9.025    

                     -0.1944E+05 -6.000     -3.588    -0.4830      9.105    

                       8.822    -0.1891E+05 -6.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    117.45
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:       20
neval is:       80
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       20      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:       21
neval is:       80


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       80      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.297422      -1.21260      -43.5459       43.5459       119.097       162.643    
   2  0.663536     -0.410173      -14.7297       14.7297       121.129       135.859    
   3  0.263982      -1.33188      -47.8291       47.8291       119.994       167.823    
   4  0.792402     -0.232686      -8.35601       8.35601       119.057       127.413    
   5  0.624731     -0.470434      -16.8938       16.8938       120.842       137.736    
   6  0.170977      -1.76622      -63.4270       63.4270       120.348       183.775    
   7  0.362487      -1.01477      -36.4414       36.4414       122.555       158.997    
   8  0.659245     -0.416659      -14.9627       14.9627       119.707       134.670    
   9  0.746481E-03  -7.20014      -258.565       258.565       119.714       378.279    
  10  0.690046     -0.370998      -13.3229       13.3229       124.136       137.459    
  11  0.905636     -0.991173E-01  -3.55941       3.55941       117.750       121.310    
  12  0.317643      -1.14683      -41.1838       41.1838       117.527       158.711    
  13  0.321948      -1.13336      -40.7003       40.7003       120.246       160.946    
  14  0.293974      -1.22426      -43.9646       43.9646       124.467       168.431    
  15  0.679275     -0.386729      -13.8878       13.8878       124.892       138.780    
  16  0.180340      -1.71291      -61.5125       61.5125       119.932       181.445    
  17  0.539600     -0.616927      -22.1545       22.1545       121.289       143.444    
  18  0.260315      -1.34586      -48.3313       48.3313       118.731       167.062    
  19  0.256777      -1.35955      -48.8228       48.8228       122.710       171.532    
  20  0.518851     -0.656138      -23.5626       23.5626       123.809       147.372    
  21  0.485887     -0.721780      -25.9199       25.9199       121.000       146.920    
  22  0.562814     -0.574805      -20.6419       20.6419       145.121       165.763    
  23  0.906369     -0.983082E-01  -3.53035       3.53035       129.721       133.251    
  24  0.332143      -1.10219      -39.5808       39.5808       122.382       161.962    
  25  0.912001E-01  -2.39470      -85.9962       85.9962       119.649       205.645    
  26  0.302569      -1.19545      -42.9297       42.9297       143.778       186.708    
  27  0.362040      -1.01600      -36.4856       36.4856       118.469       154.954    
  28  0.630870     -0.460656      -16.5426       16.5426       127.913       144.456    
  29  0.685312     -0.377881      -13.5701       13.5701       125.529       139.099    
  30  0.329910      -1.10894      -39.8231       39.8231       120.876       160.699    
  31  0.906630E-01  -2.40061      -86.2083       86.2083       125.093       211.301    
  32  0.339749      -1.07955      -38.7678       38.7678       147.503       186.271    
  33  0.783039     -0.244573      -8.78286       8.78286       125.752       134.535    
  34  0.322673      -1.13112      -40.6196       40.6196       121.677       162.297    
  35  0.255311      -1.36527      -49.0283       49.0283       135.320       184.348    
  36  0.645921     -0.437078      -15.6959       15.6959       125.047       140.743    
  37  0.240122      -1.42661      -51.2310       51.2310       152.479       203.710    
  38  0.224638      -1.49326      -53.6247       53.6247       121.019       174.644    
  39  0.682659     -0.381760      -13.7094       13.7094       124.411       138.120    
  40  0.533856     -0.627629      -22.5388       22.5388       119.704       142.242    
  41  0.439620E-02  -5.42701      -194.890       194.890       125.771       320.661    
  42  0.409891     -0.891863      -32.0277       32.0277       121.024       153.052    
  43  0.379406     -0.969149      -34.8032       34.8032       119.277       154.081    
  44  0.982111     -0.180514E-01 -0.648245      0.648245       120.104       120.753    
  45  0.243530      -1.41251      -50.7249       50.7249       212.758       263.482    
  46  0.709323     -0.343445      -12.3335       12.3335       117.452       129.785    
loop,thermsimp(1:2)       21   43.5459       14.7297    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     82        120.01         67.77          1.11         42.09          0.55          0.05        111.56
Just calling func    0   0        111.56


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     83        116.61         67.79          1.12         41.89          0.71          0.05        111.55
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    116.61
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:       21
neval is:       82
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       21      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:       22
neval is:       82


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       82      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.383671     -0.957969      -34.4017       34.4017       120.104       154.506    
   2  0.741480     -0.299107      -10.7412       10.7412       117.750       128.491    
   3  0.138898      -1.97401      -70.8889       70.8889       119.057       189.946    
   4  0.751974E-01  -2.58764      -92.9249       92.9249       117.452       210.376    
   5  0.824485     -0.192996      -6.93069       6.93069       129.721       136.651    
   6  0.982900     -0.172482E-01 -0.619402      0.619402       125.752       126.371    
   7  0.693409     -0.366136      -13.1483       13.1483       119.707       132.855    
   8  0.941572     -0.602045E-01  -2.16201       2.16201       121.129       123.291    
   9  0.812713     -0.207378      -7.44716       7.44716       124.136       131.583    
  10  0.879507     -0.128393      -4.61074       4.61074       120.842       125.453    
  11  0.418958     -0.869984      -31.2420       31.2420       124.411       155.653    
  12  0.314952      -1.15533      -41.4893       41.4893       124.892       166.382    
  13  0.812426     -0.207731      -7.45984       7.45984       125.529       132.989    
  14  0.213788      -1.54277      -55.4025       55.4025       125.047       180.449    
  15  0.521629     -0.650798      -23.3708       23.3708       119.704       143.074    
  16  0.287143      -1.24777      -44.8089       44.8089       121.289       166.098    
  17  0.518340     -0.657125      -23.5980       23.5980       127.913       151.512    
  18  0.712802E-02  -4.94372      -177.534       177.534       121.000       298.535    
  19  0.579935     -0.544838      -19.5657       19.5657       123.809       143.375    
  20  0.508101E-02  -5.28224      -189.691       189.691       121.024       310.715    
  21  0.984466     -0.156557E-01 -0.562214      0.562214       119.277       119.840    
  22  0.394325     -0.930579      -33.4181       33.4181       118.469       151.887    
  23  0.837309     -0.177562      -6.37644       6.37644       117.527       123.903    
  24  0.683519     -0.380501      -13.6642       13.6642       122.555       136.220    
  25  0.892337     -0.113912      -4.09069       4.09069       120.876       124.967    
  26  0.297675      -1.21175      -43.5154       43.5154       120.246       163.761    
  27  0.566054     -0.569065      -20.4357       20.4357       122.382       142.817    
  28  0.325499E-01  -3.42498      -122.995       122.995       121.677       244.672    
  29  0.721169     -0.326882      -11.7387       11.7387       119.097       130.835    
  30  0.370449     -0.993040      -35.6611       35.6611       145.121       180.782    
  31  0.398952     -0.918913      -32.9992       32.9992       118.731       151.730    
  32  0.942469     -0.592518E-01  -2.12780       2.12780       119.994       122.122    
  33  0.379045     -0.970101      -34.8374       34.8374       124.467       159.304    
  34  0.218373      -1.52155      -54.6405       54.6405       122.710       177.350    
  35  0.413944     -0.882024      -31.6744       31.6744       121.019       152.694    
  36  0.452532     -0.792896      -28.4737       28.4737       119.932       148.406    
  37  0.938896     -0.630505E-01  -2.26421       2.26421       120.348       122.612    
  38  0.389299     -0.943409      -33.8788       33.8788       135.320       169.198    
  39  0.943794     -0.578471E-01  -2.07735       2.07735       147.503       149.580    
  40  0.706887     -0.346884      -12.4570       12.4570       143.778       156.235    
  41  0.274873      -1.29145      -46.3772       46.3772       152.479       198.856    
  42  0.343864      -1.06751      -38.3354       38.3354       119.649       157.985    
  43  0.869527E-01  -2.44239      -87.7089       87.7089       125.093       212.802    
  44  0.859615     -0.151271      -5.43229       5.43229       212.758       218.190    
  45  0.264079      -1.33151      -47.8158       47.8158       125.771       173.587    
  46  0.494871     -0.703457      -25.2619       25.2619       116.607       141.869    
loop,thermsimp(1:2)       22   34.4017       10.7412    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     84        120.66         67.74          1.12         42.03          0.27          0.05        111.21
Just calling func    0   0        111.21


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     85        118.11         67.77          1.12         42.54          0.38          0.05        111.86
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    118.11
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:       22
neval is:       84
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       22      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:       23
neval is:       84


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       84      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.327656      -1.11579      -40.0693       40.0693       119.277       159.347    
   2  0.736029     -0.306486      -11.0062       11.0062       119.994       131.000    
   3  0.608436     -0.496864      -17.8429       17.8429       120.348       138.191    
   4  0.584882     -0.536346      -19.2608       19.2608       121.129       140.390    
   5  0.617514     -0.482053      -17.3110       17.3110       117.527       134.838    
   6  0.376473     -0.976909      -35.0818       35.0818       120.876       155.958    
   7  0.535145     -0.625218      -22.4523       22.4523       120.842       143.294    
   8  0.341783      -1.07358      -38.5534       38.5534       125.752       164.305    
   9  0.804208E-01  -2.52048      -90.5132       90.5132       117.750       208.263    
  10  0.660499     -0.414760      -14.8945       14.8945       119.097       133.991    
  11  0.739860E-01  -2.60388      -93.5081       93.5081       124.136       217.644    
  12  0.203251      -1.59331      -57.2175       57.2175       119.707       176.924    
  13  0.637025     -0.450946      -16.1939       16.1939       125.529       141.723    
  14  0.687460     -0.374752      -13.4577       13.4577       122.555       136.013    
  15  0.663581     -0.410105      -14.7273       14.7273       129.721       144.448    
  16  0.579690     -0.545263      -19.5810       19.5810       116.607       136.188    
  17  0.775653     -0.254050      -9.12322       9.12322       122.382       131.505    
  18  0.284124      -1.25834      -45.1885       45.1885       119.704       164.892    
  19  0.317710      -1.14662      -41.1762       41.1762       123.809       164.985    
  20  0.958871     -0.419990E-01  -1.50823       1.50823       119.932       121.440    
  21  0.582932     -0.539685      -19.3807       19.3807       147.503       166.883    
  22  0.905476     -0.992942E-01  -3.56576       3.56576       127.913       131.479    
  23  0.225214      -1.49070      -53.5327       53.5327       118.731       172.264    
  24  0.618260     -0.480846      -17.2677       17.2677       118.469       135.736    
  25  0.608706     -0.496420      -17.8270       17.8270       121.019       138.846    
  26  0.651052     -0.429165      -15.4118       15.4118       120.104       135.516    
  27  0.138439E-02  -6.58249      -236.384       236.384       124.411       360.795    
  28  0.157375      -1.84913      -66.4040       66.4040       143.778       210.182    
  29  0.168063      -1.78342      -64.0444       64.0444       119.649       183.694    
  30  0.924354     -0.786598E-01  -2.82476       2.82476       124.467       127.291    
  31  0.985585     -0.145204E-01 -0.521443      0.521443       120.246       120.767    
  32  0.540844E-01  -2.91721      -104.760       104.760       121.289       226.050    
  33  0.535345     -0.624843      -22.4388       22.4388       124.892       147.331    
  34  0.736351     -0.306048      -10.9905       10.9905       135.320       146.310    
  35  0.283062E-01  -3.56467      -128.011       128.011       125.771       253.782    
  36  0.690743     -0.369987      -13.2866       13.2866       122.710       135.996    
  37  0.260994      -1.34326      -48.2377       48.2377       125.047       173.285    
  38  0.243637      -1.41208      -50.7092       50.7092       145.121       195.830    
  39  0.850226     -0.162253      -5.82668       5.82668       119.057       124.884    
  40  0.589307     -0.528809      -18.9901       18.9901       152.479       171.469    
  41  0.515087     -0.663420      -23.8241       23.8241       117.452       141.276    
  42  0.348855      -1.05310      -37.8179       37.8179       125.093       162.911    
  43  0.791407     -0.233943      -8.40115       8.40115       212.758       221.159    
  44  0.370775     -0.992160      -35.6295       35.6295       121.677       157.307    
  45  0.676021     -0.391531      -14.0603       14.0603       121.000       135.061    
  46  0.125601      -2.07465      -74.5027       74.5027       118.108       192.610    
loop,thermsimp(1:2)       23   40.0693       11.0062    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     86        120.81         67.73          1.15         41.98          0.46          0.05        111.37
Just calling func    0   0        111.37


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     87        123.82         67.81          1.20         42.27          0.17          0.05        111.49
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    120.81
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:       23
neval is:       86
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       23      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:       24
neval is:       86


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       86      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.291502      -1.23271      -44.2678       44.2678       120.246       164.514    
   2  0.991852     -0.818183E-02 -0.293818      0.293818       119.932       120.226    
   3  0.317368      -1.14769      -41.2149       41.2149       119.057       160.272    
   4  0.737330     -0.304720      -10.9428       10.9428       124.467       135.410    
   5  0.834641     -0.180753      -6.49103       6.49103       119.994       126.485    
   6  0.464401     -0.767007      -27.5441       27.5441       127.913       155.458    
   7  0.592116     -0.524053      -18.8193       18.8193       122.382       141.201    
   8  0.464372     -0.767069      -27.5462       27.5462       119.097       146.643    
   9  0.636055E-01  -2.75505      -98.9369       98.9369       117.527       216.464    
  10  0.712927     -0.338376      -12.1514       12.1514       121.000       133.152    
  11  0.265597      -1.32578      -47.6100       47.6100       120.104       167.714    
  12  0.152318      -1.88178      -67.5768       67.5768       118.469       186.045    
  13  0.629580     -0.462703      -16.6161       16.6161       122.710       139.326    
  14  0.849464     -0.163150      -5.85887       5.85887       122.555       128.414    
  15  0.487816     -0.717817      -25.7776       25.7776       116.607       142.385    
  16  0.374667     -0.981718      -35.2545       35.2545       120.348       155.602    
  17  0.657383     -0.419488      -15.0643       15.0643       121.019       136.084    
  18  0.846901     -0.166172      -5.96740       5.96740       121.129       127.097    
  19  0.201185      -1.60353      -57.5845       57.5845       117.452       175.036    
  20  0.771980     -0.258797      -9.29367       9.29367       125.529       134.823    
  21  0.507739     -0.677788      -24.3401       24.3401       120.842       145.182    
  22  0.280262      -1.27203      -45.6800       45.6800       129.721       175.401    
  23  0.285359      -1.25401      -45.0327       45.0327       135.320       180.352    
  24  0.246191      -1.40165      -50.3346       50.3346       124.892       175.227    
  25  0.559989E-01  -2.88242      -103.511       103.511       120.876       224.387    
  26  0.330462      -1.10726      -39.7630       39.7630       121.677       161.440    
  27  0.899405     -0.106022      -3.80737       3.80737       119.277       123.085    
  28  0.637003     -0.450981      -16.1952       16.1952       125.093       141.288    
  29  0.699726E-01  -2.65965      -95.5109       95.5109       125.752       221.263    
  30  0.677191     -0.389802      -13.9982       13.9982       119.704       133.702    
  31  0.649507     -0.431542      -15.4971       15.4971       123.809       139.306    
  32  0.527986     -0.638685      -22.9359       22.9359       147.503       170.439    
  33  0.374870E-01  -3.28376      -117.923       117.923       152.479       270.402    
  34  0.448697     -0.801407      -28.7794       28.7794       118.731       147.511    
  35  0.809612     -0.211200      -7.58441       7.58441       125.047       132.631    
  36  0.836235     -0.178846      -6.42254       6.42254       119.707       126.129    
  37  0.198161      -1.61867      -58.1283       58.1283       119.649       177.777    
  38  0.222702      -1.50192      -53.9355       53.9355       118.108       172.043    
  39  0.888863     -0.117812      -4.23075       4.23075       145.121       149.352    
  40  0.868267     -0.141256      -5.07265       5.07265       117.750       122.823    
  41  0.164066      -1.80749      -64.9088       64.9088       143.778       208.687    
  42  0.163797      -1.80912      -64.9676       64.9676       124.136       189.103    
  43  0.883498     -0.123867      -4.44818       4.44818       212.758       217.206    
  44  0.749983     -0.287705      -10.3318       10.3318       121.289       131.621    
  45  0.666691     -0.405428      -14.5593       14.5593       125.771       140.330    
  46  0.978530     -0.217038E-01 -0.779405      0.779405       120.806       121.585    
loop,thermsimp(1:2)       24   44.2678      0.293818    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     88        119.77         67.71          1.11         41.98          0.70          0.05        111.55
Just calling func    0   0        111.55


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     89        117.63         67.72          1.09         41.91          0.84          0.05        111.61
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    117.63
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:       24
neval is:       88
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       24      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:       25
neval is:       88


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       88      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.145902      -1.92482      -69.1224       69.1224       119.932       189.054    
   2  0.438196     -0.825090      -29.6299       29.6299       120.806       150.436    
   3  0.637359     -0.450422      -16.1751       16.1751       117.750       133.925    
   4  0.122813      -2.09709      -75.3088       75.3088       119.277       194.586    
   5  0.926899     -0.759107E-01  -2.72603       2.72603       119.707       122.433    
   6  0.456580     -0.783992      -28.1540       28.1540       119.994       148.148    
   7  0.988763     -0.113008E-01 -0.405825      0.405825       121.129       121.535    
   8  0.499609     -0.693930      -24.9198       24.9198       122.555       147.475    
   9  0.432617     -0.837902      -30.0899       30.0899       121.289       151.379    
  10  0.403570     -0.907406      -32.5859       32.5859       125.047       157.633    
  11  0.435824     -0.830517      -29.8247       29.8247       121.000       150.825    
  12  0.504807     -0.683579      -24.5480       24.5480       119.704       144.252    
  13  0.778763     -0.250048      -8.97950       8.97950       125.529       134.509    
  14  0.429140     -0.845972      -30.3797       30.3797       124.467       154.846    
  15  0.597763     -0.514562      -18.4784       18.4784       121.019       139.498    
  16  0.425932     -0.853476      -30.6492       30.6492       123.809       154.459    
  17  0.825778     -0.191430      -6.87445       6.87445       122.710       129.584    
  18  0.448772     -0.801241      -28.7734       28.7734       125.771       154.544    
  19  0.701335     -0.354770      -12.7402       12.7402       122.382       135.122    
  20  0.425857     -0.853651      -30.6555       30.6555       125.093       155.749    
  21  0.800815     -0.222126      -7.97677       7.97677       116.607       124.584    
  22  0.724239     -0.322634      -11.5861       11.5861       120.842       132.428    
  23  0.312194      -1.16413      -41.8052       41.8052       119.097       160.902    
  24  0.796592     -0.227412      -8.16662       8.16662       118.731       126.898    
  25  0.164146      -1.80700      -64.8913       64.8913       145.121       210.013    
  26  0.503041     -0.687083      -24.6739       24.6739       127.913       152.587    
  27  0.640838     -0.444978      -15.9796       15.9796       120.348       136.328    
  28  0.327752      -1.11550      -40.0587       40.0587       119.057       159.116    
  29  0.720325     -0.328053      -11.7807       11.7807       121.677       133.458    
  30  0.447570     -0.803922      -28.8697       28.8697       120.246       149.115    
  31  0.377461     -0.974289      -34.9878       34.9878       120.104       155.092    
  32  0.951264     -0.499633E-01  -1.79424       1.79424       147.503       149.297    
  33  0.610405     -0.493632      -17.7269       17.7269       118.108       135.835    
  34  0.564697     -0.571466      -20.5219       20.5219       117.452       137.973    
  35  0.993998     -0.601974E-02 -0.216175      0.216175       124.892       125.109    
  36  0.908032     -0.964757E-01  -3.46454       3.46454       129.721       133.185    
  37  0.731210     -0.313055      -11.2421       11.2421       119.649       130.891    
  38  0.818812     -0.199901      -7.17866       7.17866       135.320       142.498    
  39  0.423172     -0.859976      -30.8827       30.8827       118.469       149.351    
  40  0.554414     -0.589843      -21.1819       21.1819       124.136       145.318    
  41  0.244903E-01  -3.70948      -133.211       133.211       143.778       276.989    
  42  0.337898      -1.08501      -38.9639       38.9639       117.527       156.491    
  43  0.634521E-01  -2.75747      -99.0237       99.0237       212.758       311.781    
  44  0.824978     -0.192398      -6.90923       6.90923       125.752       132.661    
  45  0.954123     -0.469622E-01  -1.68646       1.68646       120.876       122.563    
  46  0.807852     -0.213376      -7.66256       7.66256       117.629       125.292    
loop,thermsimp(1:2)       25   69.1224       29.6299    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     90        199.17         67.65          1.09         42.44          0.70          0.05        111.92
Just calling func    0   0        111.92


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    199.17
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:       25
neval is:       89
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       25      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:       26
neval is:       89


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       89      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.781042     -0.247126      -8.87455       8.87455       121.129       130.004    
   2  0.928800     -0.738619E-01  -2.65246       2.65246       119.707       122.359    
   3  0.727994     -0.317462      -11.4004       11.4004       120.876       132.277    
   4  0.109723E-01  -4.51238      -162.044       162.044       116.607       278.652    
   5  0.160096      -1.83198      -65.7883       65.7883       124.892       190.681    
   6  0.497079     -0.699006      -25.1021       25.1021       117.629       142.731    
   7  0.789473     -0.236389      -8.48898       8.48898       118.731       127.220    
   8  0.763780     -0.269476      -9.67716       9.67716       122.710       132.387    
   9  0.217288      -1.52653      -54.8194       54.8194       119.649       174.469    
  10  0.867642     -0.141976      -5.09853       5.09853       120.842       125.941    
  11  0.740966     -0.299800      -10.7661       10.7661       125.752       136.518    
  12  0.999757     -0.242662E-03 -0.871425E-02  0.871425E-02   129.721       129.729    
  13  0.587476     -0.531920      -19.1018       19.1018       121.677       140.779    
  14  0.703619     -0.351518      -12.6234       12.6234       117.750       130.373    
  15  0.740946     -0.299828      -10.7671       10.7671       125.529       136.296    
  16  0.335927      -1.09086      -39.1740       39.1740       122.382       161.556    
  17  0.736553     -0.305774      -10.9807       10.9807       118.108       129.088    
  18  0.597397     -0.515174      -18.5004       18.5004       120.348       138.848    
  19  0.126601      -2.06672      -74.2181       74.2181       117.452       191.670    
  20  0.990194     -0.985477E-02 -0.353895      0.353895       121.019       121.373    
  21  0.716453     -0.333443      -11.9743       11.9743       135.320       147.294    
  22  0.279233E-01  -3.57829      -128.500       128.500       119.704       248.204    
  23  0.413932     -0.882054      -31.6755       31.6755       124.136       155.811    
  24  0.109516      -2.21168      -79.4239       79.4239       122.555       201.979    
  25  0.440749     -0.819279      -29.4212       29.4212       119.994       149.415    
  26  0.412115     -0.886453      -31.8335       31.8335       120.246       152.079    
  27  0.146963      -1.91758      -68.8622       68.8622       147.503       216.365    
  28  0.345919      -1.06155      -38.1214       38.1214       118.469       156.590    
  29  0.343614      -1.06824      -38.3615       38.3615       120.806       159.167    
  30  0.600334E-01  -2.81285      -101.013       101.013       121.000       222.013    
  31  0.751538     -0.285634      -10.2574       10.2574       121.289       131.547    
  32  0.878119     -0.129973      -4.66748       4.66748       127.913       132.581    
  33  0.544046     -0.608721      -21.8598       21.8598       123.809       145.669    
  34  0.931023     -0.714714E-01  -2.56662       2.56662       125.771       128.337    
  35  0.131968      -2.02520      -72.7270       72.7270       124.467       197.194    
  36  0.826694E-01  -2.49291      -89.5229       89.5229       120.104       209.627    
  37  0.174702E-02  -6.34984      -228.030       228.030       125.093       353.123    
  38  0.233470      -1.45470      -52.2400       52.2400       117.527       169.767    
  39  0.232927      -1.45703      -52.3235       52.3235       125.047       177.370    
  40  0.958279     -0.426163E-01  -1.53040       1.53040       119.057       120.588    
  41  0.820100     -0.198330      -7.12222       7.12222       119.097       126.219    
  42  0.305797      -1.18483      -42.5487       42.5487       119.932       162.481    
  43  0.260853      -1.34380      -48.2572       48.2572       119.277       167.535    
  44  0.960408     -0.403967E-01  -1.45069       1.45069       145.121       146.572    
  45  0.318957      -1.14270      -41.0355       41.0355       143.778       184.814    
  46  0.146887      -1.91809      -68.8807       68.8807       199.167       268.047    
loop,thermsimp(1:2)       26   8.87455       2.65246    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     91        119.85         67.68          1.09         41.98          0.57          0.05        111.38
Just calling func    0   0        111.37


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     92        122.75         67.77          1.12         42.27          0.28          0.05        111.48
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    119.85
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:       26
neval is:       91
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       26      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:       27
neval is:       91


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:       91
neval,tstepnext:       91      91

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.818509     -0.200271      -7.19195       7.19195       119.057       126.249    
   2  0.309452      -1.17295      -42.1220       42.1220       121.019       163.141    
   3  0.303638      -1.19192      -42.8031       42.8031       119.707       162.510    
   4  0.754457     -0.281757      -10.1182       10.1182       120.842       130.960    
   5  0.623133     -0.472996      -16.9858       16.9858       119.097       136.082    
   6  0.989422E-01  -2.31322      -83.0702       83.0702       118.731       201.801    
   7  0.695126     -0.363662      -13.0595       13.0595       125.771       138.830    
   8  0.832210E-01  -2.48626      -89.2841       89.2841       118.108       207.392    
   9  0.869521     -0.139813      -5.02084       5.02084       129.721       134.742    
  10  0.488136     -0.717160      -25.7540       25.7540       121.129       146.883    
  11  0.579877     -0.544940      -19.5694       19.5694       117.750       137.319    
  12  0.480435     -0.733064      -26.3251       26.3251       121.289       147.615    
  13  0.792626     -0.232404      -8.34588       8.34588       120.876       129.222    
  14  0.870230     -0.138998      -4.99156       4.99156       122.710       127.701    
  15  0.886361     -0.120631      -4.33198       4.33198       127.913       132.245    
  16  0.358181      -1.02672      -36.8705       36.8705       125.529       162.400    
  17  0.560125     -0.579594      -20.8139       20.8139       125.752       146.566    
  18  0.546151     -0.604859      -21.7211       21.7211       120.348       142.069    
  19  0.732086     -0.311858      -11.1991       11.1991       121.677       132.876    
  20  0.590102     -0.527460      -18.9416       18.9416       117.629       136.571    
  21  0.867355     -0.142307      -5.11041       5.11041       123.809       128.920    
  22  0.749758     -0.288005      -10.3426       10.3426       145.121       155.464    
  23  0.721970     -0.325772      -11.6988       11.6988       135.320       147.018    
  24  0.596865     -0.516065      -18.5324       18.5324       119.994       138.526    
  25  0.878161     -0.129925      -4.66574       4.66574       120.246       124.912    
  26  0.558752E-01  -2.88463      -103.590       103.590       124.136       227.726    
  27  0.555543     -0.587810      -21.1089       21.1089       118.469       139.577    
  28  0.597562     -0.514897      -18.4905       18.4905       120.806       139.296    
  29  0.995329     -0.468202E-02 -0.168136      0.168136       122.382       122.550    
  30  0.206787      -1.57606      -56.5982       56.5982       119.932       176.530    
  31  0.645457     -0.437797      -15.7218       15.7218       119.277       134.999    
  32  0.871352     -0.137710      -4.94530       4.94530       117.527       122.472    
  33  0.701360     -0.354733      -12.7388       12.7388       119.649       132.388    
  34  0.936151     -0.659784E-01  -2.36936       2.36936       125.047       127.416    
  35  0.590091     -0.527478      -18.9423       18.9423       143.778       162.720    
  36  0.750433     -0.287105      -10.3102       10.3102       124.892       135.203    
  37  0.326255      -1.12007      -40.2231       40.2231       117.452       157.675    
  38  0.873133     -0.135668      -4.87198       4.87198       124.467       129.339    
  39  0.621627     -0.475415      -17.0726       17.0726       122.555       139.628    
  40  0.153041      -1.87705      -67.4068       67.4068       120.104       187.511    
  41  0.196696      -1.62610      -58.3948       58.3948       147.503       205.898    
  42  0.365028      -1.00778      -36.1905       36.1905       121.000       157.191    
  43  0.398429     -0.920226      -33.0463       33.0463       119.704       152.750    
  44  0.549691     -0.598399      -21.4892       21.4892       199.167       220.656    
  45  0.994179     -0.583795E-02 -0.209647      0.209647       116.607       116.817    
  46  0.147335E-01  -4.21763      -151.460       151.460       119.849       271.308    
loop,thermsimp(1:2)       27   7.19195       42.1220    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     93        125.09         67.73          1.09         41.95          0.54          0.05        111.37
Just calling func    0   0        111.37


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     94        143.16         67.84          1.11         41.92          0.55          0.05        111.47
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    125.09
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    35.9111                91
loop is:       27
neval is:       93
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       27      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    35.9111                91
loop is:       28
neval is:       93


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 




neval>tstepnex so lower away!t
---> lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
     new SAtemp,tstepnext are :    17.9555               136

 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:       93     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.808657     -0.212380      -3.81340       3.81340       116.607       120.421    
   2  0.162004E-01  -4.12272      -74.0256       74.0256       117.527       191.552    
   3  0.446841E-01  -3.10814      -55.8082       55.8082       122.382       178.190    
   4  0.757954     -0.277132      -4.97606       4.97606       120.246       125.222    
   5  0.525315     -0.643757      -11.5590       11.5590       119.057       130.616    
   6  0.229940      -1.46994      -26.3935       26.3935       125.047       151.440    
   7  0.273310E-01  -3.59973      -64.6351       64.6351       122.710       187.345    
   8  0.228047      -1.47820      -26.5419       26.5419       123.809       150.351    
   9  0.963384E-01  -2.33989      -42.0139       42.0139       120.876       162.890    
  10  0.495504     -0.702179      -12.6080       12.6080       124.467       137.075    
  11  0.930436     -0.721018E-01  -1.29463       1.29463       120.842       122.137    
  12  0.138744      -1.97513      -35.4645       35.4645       127.913       163.378    
  13  0.676381     -0.390999      -7.02059       7.02059       119.649       126.670    
  14  0.763696     -0.269586      -4.84056       4.84056       121.677       126.518    
  15  0.282468      -1.26419      -22.6992       22.6992       129.721       152.420    
  16  0.359172      -1.02395      -18.3856       18.3856       119.277       137.663    
  17  0.392258     -0.935834      -16.8034       16.8034       124.892       141.696    
  18  0.524686     -0.644955      -11.5805       11.5805       119.097       130.677    
  19  0.850465     -0.161972      -2.90829       2.90829       117.629       120.538    
  20  0.227056      -1.48256      -26.6201       26.6201       117.750       144.370    
  21  0.942039     -0.597082E-01  -1.07209       1.07209       119.994       121.066    
  22  0.807336     -0.214016      -3.84277       3.84277       125.771       129.613    
  23  0.345853      -1.06174      -19.0641       19.0641       120.806       139.870    
  24  0.762940     -0.270575      -4.85833       4.85833       118.469       123.327    
  25  0.589959     -0.527702      -9.47516       9.47516       122.555       132.031    
  26  0.563539     -0.573518      -10.2978       10.2978       120.348       130.646    
  27  0.812044     -0.208201      -3.73836       3.73836       125.752       129.490    
  28  0.735850     -0.306729      -5.50749       5.50749       121.129       126.637    
  29  0.396292     -0.925605      -16.6197       16.6197       135.320       151.939    
  30  0.623568     -0.472298      -8.48036       8.48036       121.289       129.770    
  31  0.925937     -0.769486E-01  -1.38165       1.38165       119.704       121.085    
  32  0.880074     -0.127749      -2.29381       2.29381       145.121       147.415    
  33  0.379958     -0.967693      -17.3754       17.3754       121.000       138.376    
  34  0.842940E-01  -2.47344      -44.4120       44.4120       117.452       161.864    
  35  0.199092      -1.61399      -28.9800       28.9800       125.529       154.509    
  36  0.625899     -0.468566      -8.41335       8.41335       119.707       128.120    
  37  0.888337     -0.118405      -2.12602       2.12602       143.778       145.904    
  38  0.959633     -0.412048E-01 -0.739854      0.739854       121.019       121.759    
  39  0.289813      -1.23852      -22.2383       22.2383       119.932       142.170    
  40  0.889440     -0.117163      -2.10373       2.10373       120.104       122.208    
  41  0.797260     -0.226575      -4.06827       4.06827       118.731       122.799    
  42  0.451097     -0.796073      -14.2939       14.2939       147.503       161.797    
  43  0.609578     -0.494989      -8.88778       8.88778       118.108       126.996    
  44  0.910850     -0.933770E-01  -1.67663       1.67663       199.167       200.843    
  45  0.448191     -0.802536      -14.4100       14.4100       124.136       138.546    
  46  0.831229     -0.184850      -3.31907       3.31907       125.093       128.412    
loop,thermsimp(1:2)       28   3.81340       74.0256    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     95        212.76         67.79          1.12         42.04          0.48          0.05        111.48
Just calling func    0   0        111.47


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     96        134.83         67.83          1.13         42.20          0.65          0.05        111.85
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    134.83
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       28
neval is:       95
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       28      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       29
neval is:       95


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:       95     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.115886      -2.15515      -38.6969       38.6969       116.607       155.304    
   2  0.685048     -0.378267      -6.79198       6.79198       117.629       124.421    
   3  0.739526     -0.301746      -5.41801       5.41801       119.994       125.412    
   4  0.161448      -1.82357      -32.7432       32.7432       119.704       152.447    
   5  0.819608     -0.198929      -3.57188       3.57188       121.019       124.591    
   6  0.750679     -0.286777      -5.14923       5.14923       120.842       125.991    
   7  0.797409     -0.226388      -4.06491       4.06491       120.104       124.169    
   8  0.193123      -1.64443      -29.5266       29.5266       118.731       148.258    
   9  0.189346E-01  -3.96676      -71.2253       71.2253       118.469       189.694    
  10  0.715264     -0.335103      -6.01695       6.01695       120.246       126.263    
  11  0.384856     -0.954886      -17.1455       17.1455       121.677       138.823    
  12  0.268023      -1.31668      -23.6418       23.6418       121.129       144.771    
  13  0.777164     -0.252104      -4.52666       4.52666       119.649       124.176    
  14  0.707495E-01  -2.64861      -47.5572       47.5572       118.108       165.665    
  15  0.233610      -1.45410      -26.1092       26.1092       119.707       145.816    
  16  0.193057      -1.64477      -29.5328       29.5328       125.093       154.626    
  17  0.486879     -0.719739      -12.9233       12.9233       125.752       138.675    
  18  0.735370     -0.307381      -5.51920       5.51920       125.771       131.290    
  19  0.147509      -1.91387      -34.3645       34.3645       121.289       155.654    
  20  0.739111     -0.302308      -5.42809       5.42809       119.057       124.485    
  21  0.886241     -0.120766      -2.16842       2.16842       120.348       122.516    
  22  0.158672      -1.84092      -33.0546       33.0546       119.097       152.151    
  23  0.143658      -1.94032      -34.8395       34.8395       122.555       157.395    
  24  0.637431E-02  -5.05548      -90.7738       90.7738       124.467       215.241    
  25  0.753372     -0.283196      -5.08494       5.08494       119.277       124.362    
  26  0.555831     -0.587292      -10.5451       10.5451       121.000       131.545    
  27  0.280013      -1.27292      -22.8559       22.8559       124.136       146.992    
  28  0.811304     -0.209112      -3.75473       3.75473       120.806       124.560    
  29  0.972296E-02  -4.63327      -83.1927       83.1927       124.892       208.085    
  30  0.713459     -0.337631      -6.06234       6.06234       119.932       125.994    
  31  0.194621      -1.63670      -29.3878       29.3878       117.750       147.138    
  32  0.492587     -0.708083      -12.7140       12.7140       143.778       156.492    
  33  0.759094E-01  -2.57821      -46.2932       46.2932       145.121       191.414    
  34  0.494544     -0.704119      -12.6428       12.6428       123.809       136.452    
  35  0.297023      -1.21395      -21.7971       21.7971       125.047       146.844    
  36  0.429878E-01  -3.14684      -56.5032       56.5032       135.320       191.823    
  37  0.490931     -0.711452      -12.7745       12.7745       129.721       142.495    
  38  0.534417     -0.626578      -11.2505       11.2505       125.529       136.780    
  39  0.254967      -1.36662      -24.5384       24.5384       147.503       172.041    
  40  0.995945     -0.406335E-02 -0.729596E-01  0.729596E-01   117.452       117.525    
  41  0.428814E-01  -3.14932      -56.5476       56.5476       120.876       177.424    
  42  0.332915      -1.09987      -19.7487       19.7487       127.913       147.662    
  43  0.657266     -0.419666      -7.53532       7.53532       122.382       129.917    
  44  0.301071      -1.20041      -21.5540       21.5540       122.710       144.264    
  45  0.998178     -0.182349E-02 -0.327418E-01  0.327418E-01   117.527       117.560    
  46  0.533372     -0.628536      -11.2857       11.2857       134.834       146.120    
loop,thermsimp(1:2)       29   38.6969       6.79198    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     97        119.62         67.77          1.12         42.07          0.60          0.05        111.62
Just calling func    0   0        111.61


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:     98        117.79         67.78          1.12         41.98          0.62          0.05        111.55
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    117.79
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       29
neval is:       97
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       29      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       30
neval is:       97


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:       97     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.396389E-01  -3.22794      -57.9595       57.9595       117.452       175.411    
   2  0.712690     -0.338709      -6.08170       6.08170       117.527       123.609    
   3  0.284498      -1.25703      -22.5706       22.5706       120.348       142.919    
   4  0.132414      -2.02182      -36.3029       36.3029       120.104       156.407    
   5  0.868558     -0.140920      -2.53030       2.53030       119.649       122.179    
   6  0.695240     -0.363498      -6.52680       6.52680       119.277       125.804    
   7  0.777362     -0.251849      -4.52208       4.52208       117.629       122.151    
   8  0.302494      -1.19569      -21.4693       21.4693       119.057       140.527    
   9  0.710188     -0.342225      -6.14484       6.14484       120.806       126.951    
  10  0.884530     -0.122698      -2.20311       2.20311       121.019       123.223    
  11  0.146421E-01  -4.22386      -75.8416       75.8416       119.994       195.836    
  12  0.834801     -0.180562      -3.24208       3.24208       120.842       124.084    
  13  0.414011     -0.881863      -15.8343       15.8343       119.932       135.766    
  14  0.655777     -0.421935      -7.57607       7.57607       120.246       127.822    
  15  0.530106     -0.634679      -11.3960       11.3960       122.382       133.778    
  16  0.325231      -1.12322      -20.1680       20.1680       125.771       145.939    
  17  0.293550      -1.22571      -22.0082       22.0082       121.000       143.009    
  18  0.194161      -1.63907      -29.4304       29.4304       123.809       153.240    
  19  0.589029E-01  -2.83186      -50.8476       50.8476       125.529       176.377    
  20  0.385142     -0.954143      -17.1321       17.1321       125.752       142.884    
  21  0.287461      -1.24667      -22.3846       22.3846       121.677       144.062    
  22  0.528518     -0.637678      -11.4498       11.4498       129.721       141.171    
  23  0.517042     -0.659630      -11.8440       11.8440       122.710       134.554    
  24  0.453375     -0.791035      -14.2034       14.2034       121.129       135.333    
  25  0.695596     -0.362986      -6.51760       6.51760       119.707       126.225    
  26  0.645178     -0.438228      -7.86862       7.86862       134.834       142.703    
  27  0.696076     -0.362297      -6.50523       6.50523       125.047       131.552    
  28  0.483522     -0.726659      -13.0475       13.0475       124.136       137.183    
  29  0.155396E-01  -4.16436      -74.7733       74.7733       117.750       192.523    
  30  0.883154     -0.124256      -2.23108       2.23108       127.913       130.145    
  31  0.525944     -0.642561      -11.5375       11.5375       118.731       130.269    
  32  0.746799     -0.291959      -5.24227       5.24227       119.097       124.339    
  33  0.458658     -0.779449      -13.9954       13.9954       119.704       133.699    
  34  0.614284     -0.487298      -8.74970       8.74970       125.093       133.843    
  35  0.581412     -0.542295      -9.73720       9.73720       116.607       126.345    
  36  0.820935     -0.197312      -3.54284       3.54284       121.289       124.832    
  37  0.852366     -0.159739      -2.86820       2.86820       143.778       146.646    
  38  0.527059     -0.640443      -11.4995       11.4995       122.555       134.055    
  39  0.376404     -0.977092      -17.5442       17.5442       118.108       135.652    
  40  0.729525E-01  -2.61795      -47.0066       47.0066       147.503       194.509    
  41  0.342258      -1.07219      -19.2517       19.2517       120.876       140.128    
  42  0.955065     -0.459761E-01 -0.825525      0.825525       118.469       119.294    
  43  0.508654E-01  -2.97857      -53.4818       53.4818       145.121       198.603    
  44  0.471716     -0.751379      -13.4914       13.4914       135.320       148.811    
  45  0.137118      -1.98691      -35.6761       35.6761       124.892       160.568    
  46  0.844826     -0.168625      -3.02774       3.02774       117.794       120.822    
loop,thermsimp(1:2)       30   57.9595       6.08170    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:     99        144.27         67.63          1.12         42.06          0.24          0.05        111.10
Just calling func    0   0        111.10


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    144.27
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       30
neval is:       98
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       30      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       31
neval is:       98


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:       98     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.248581      -1.39199      -24.9939       24.9939       118.469       143.462    
   2  0.247647      -1.39575      -25.0615       25.0615       117.794       142.856    
   3  0.396263     -0.925678      -16.6210       16.6210       117.629       134.250    
   4  0.386461     -0.950723      -17.0707       17.0707       119.649       136.720    
   5  0.729285     -0.315691      -5.66839       5.66839       121.019       126.688    
   6  0.665866     -0.406667      -7.30193       7.30193       117.527       124.829    
   7  0.385122     -0.954194      -17.1331       17.1331       120.842       137.975    
   8  0.625701     -0.468883      -8.41904       8.41904       119.097       127.516    
   9  0.392668     -0.934792      -16.7847       16.7847       121.289       138.074    
  10  0.698356     -0.359026      -6.44651       6.44651       119.277       125.724    
  11  0.537534E-01  -2.92335      -52.4903       52.4903       119.707       172.197    
  12  0.289307      -1.24027      -22.2697       22.2697       116.607       138.877    
  13  0.138460E-01  -4.27976      -76.8454       76.8454       120.806       197.651    
  14  0.824110     -0.193451      -3.47351       3.47351       120.246       123.719    
  15  0.560983     -0.578065      -10.3795       10.3795       127.913       138.293    
  16  0.116087E-01  -4.45600      -80.0099       80.0099       118.731       198.741    
  17  0.218033      -1.52311      -27.3482       27.3482       125.047       152.395    
  18  0.893705E-01  -2.41497      -43.3620       43.3620       119.704       163.066    
  19  0.304886      -1.18782      -21.3279       21.3279       122.382       143.709    
  20  0.179833      -1.71573      -30.8068       30.8068       125.093       155.900    
  21  0.867378     -0.142281      -2.55473       2.55473       122.555       125.110    
  22  0.243287      -1.41351      -25.3804       25.3804       122.710       148.090    
  23  0.772489     -0.258138      -4.63500       4.63500       121.129       125.764    
  24  0.321011      -1.13628      -20.4025       20.4025       118.108       138.510    
  25  0.499417     -0.694314      -12.4668       12.4668       119.932       132.399    
  26  0.396806     -0.924307      -16.5964       16.5964       124.136       140.732    
  27  0.580203E-01  -2.84696      -51.1187       51.1187       120.876       171.995    
  28  0.854206     -0.157583      -2.82948       2.82948       119.057       121.887    
  29  0.914649     -0.892145E-01  -1.60189       1.60189       129.721       131.323    
  30  0.167601      -1.78617      -32.0716       32.0716       134.834       166.906    
  31  0.350137      -1.04943      -18.8431       18.8431       125.752       144.595    
  32  0.522932     -0.648304      -11.6406       11.6406       120.348       131.989    
  33  0.538779     -0.618450      -11.1046       11.1046       121.000       132.105    
  34  0.693066     -0.366629      -6.58303       6.58303       121.677       128.260    
  35  0.361961      -1.01622      -18.2467       18.2467       125.771       144.017    
  36  0.310665      -1.16904      -20.9907       20.9907       143.778       164.769    
  37  0.818669     -0.200076      -3.59247       3.59247       135.320       138.912    
  38  0.582861     -0.539807      -9.69252       9.69252       123.809       133.502    
  39  0.401728     -0.911979      -16.3751       16.3751       120.104       136.479    
  40  0.171089      -1.76557      -31.7018       31.7018       124.892       156.594    
  41  0.980174     -0.200248E-01 -0.359556      0.359556       117.452       117.811    
  42  0.495496     -0.702196      -12.6083       12.6083       125.529       138.138    
  43  0.436683     -0.828549      -14.8770       14.8770       117.750       132.627    
  44  0.910411     -0.938588E-01  -1.68528       1.68528       147.503       149.188    
  45  0.649932     -0.430887      -7.73681       7.73681       119.994       127.731    
  46  0.755226     -0.280738      -5.04080       5.04080       144.270       149.311    
loop,thermsimp(1:2)       31   24.9939       25.0615    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    100        141.53         67.66          1.07         42.06          0.60          0.05        111.44
Just calling func    0   0        111.44


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    141.53
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       31
neval is:       99
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       31      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       32
neval is:       99


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:       99     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.996070     -0.393760E-02 -0.707017E-01  0.707017E-01   117.452       117.522    
   2  0.758684E-02  -4.88134      -87.6470       87.6470       119.057       206.704    
   3  0.404439     -0.905254      -16.2543       16.2543       120.246       136.500    
   4  0.947917E-01  -2.35607      -42.3045       42.3045       117.527       159.831    
   5  0.834417     -0.181022      -3.25035       3.25035       122.555       125.806    
   6  0.891274     -0.115104      -2.06675       2.06675       119.277       121.344    
   7  0.744451     -0.295108      -5.29883       5.29883       121.129       126.428    
   8  0.559638     -0.580466      -10.4226       10.4226       121.019       131.442    
   9  0.821724     -0.196351      -3.52558       3.52558       119.097       122.622    
  10  0.847292     -0.165710      -2.97540       2.97540       119.994       122.969    
  11  0.661676     -0.412979      -7.41526       7.41526       121.677       129.092    
  12  0.993427     -0.659478E-02 -0.118413      0.118413       129.721       129.839    
  13  0.425996     -0.853326      -15.3219       15.3219       120.348       135.670    
  14  0.673132     -0.395813      -7.10703       7.10703       121.000       128.107    
  15  0.234810      -1.44898      -26.0172       26.0172       119.932       145.949    
  16  0.122926      -2.09617      -37.6379       37.6379       117.750       155.388    
  17  0.523553     -0.647118      -11.6193       11.6193       123.809       135.429    
  18  0.959317     -0.415333E-01 -0.745753      0.745753       117.629       118.375    
  19  0.321726      -1.13406      -20.3626       20.3626       120.104       140.467    
  20  0.493112     -0.707018      -12.6949       12.6949       119.649       132.344    
  21  0.416134     -0.876748      -15.7425       15.7425       120.842       136.585    
  22  0.409432     -0.892985      -16.0340       16.0340       121.289       137.324    
  23  0.657956     -0.418617      -7.51649       7.51649       125.529       133.046    
  24  0.904324     -0.100567      -1.80574       1.80574       127.913       129.719    
  25  0.714426     -0.336276      -6.03802       6.03802       118.108       124.146    
  26  0.150521      -1.89365      -34.0015       34.0015       116.607       150.609    
  27  0.758740     -0.276096      -4.95745       4.95745       135.320       140.277    
  28  0.359105      -1.02414      -18.3890       18.3890       124.136       142.525    
  29  0.666937     -0.405060      -7.27306       7.27306       117.794       125.068    
  30  0.343213      -1.06940      -19.2017       19.2017       118.469       137.670    
  31  0.484849     -0.723918      -12.9983       12.9983       122.382       135.380    
  32  0.874661     -0.133919      -2.40459       2.40459       125.771       128.175    
  33  0.994710     -0.530415E-02 -0.952388E-01  0.952388E-01   125.752       125.847    
  34  0.821923     -0.196109      -3.52124       3.52124       122.710       126.231    
  35  0.954096E-02  -4.65216      -83.5320       83.5320       147.503       231.035    
  36  0.240030      -1.42699      -25.6224       25.6224       144.270       169.893    
  37  0.279003      -1.27653      -22.9208       22.9208       125.047       147.968    
  38  0.553830     -0.590898      -10.6099       10.6099       125.093       135.703    
  39  0.400809     -0.914271      -16.4162       16.4162       124.892       141.309    
  40  0.146125      -1.92330      -34.5338       34.5338       119.704       154.237    
  41  0.811879     -0.208403      -3.74199       3.74199       143.778       147.520    
  42  0.349149      -1.05226      -18.8938       18.8938       134.834       153.728    
  43  0.897422     -0.108229      -1.94331       1.94331       120.876       122.819    
  44  0.114492      -2.16725      -38.9141       38.9141       119.707       158.621    
  45  0.831901E-01  -2.48663      -44.6487       44.6487       120.806       165.454    
  46  0.721169     -0.326882      -5.86934       5.86934       141.529       147.399    
loop,thermsimp(1:2)       32  0.707017E-01   87.6470    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    101        114.13         67.80          1.12         42.02          0.48          0.05        111.48
Just calling func    0   0        111.49


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    102        110.50         67.77          1.11         42.27          0.20          0.05        111.41
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  100    114.13        1.051     -2.366      2.747     -102.6     0.9786    
                      0.9473      1.144     -99.70      3.684     0.6304    

                       1.893     -2.215      1.540      7263.      7000.    

                      0.1331      0.000      0.000      0.000     -1.221    



                      -1.875      0.000      0.000      7000.      618.7    

                       1.632     -5.305     -4.049     -7.972      7.073    

                      -15.08     -4.891      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.3843    -0.7328      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.5678     -1.189      7000.    



                      -1.369     -2.071     -2.123     -1.960    -0.3807    

                     -0.3252      9.244      8.760    -0.1615E+05 -5.736    

                     -0.5450     -2.649      9.337      8.848    -0.1969E+05



                      -6.000     0.5978    -0.2372      8.905      9.028    

                     -0.1944E+05 -6.000    -0.8112    -0.5011      9.102    

                       8.817    -0.1891E+05 -6.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    110.50
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       32
neval is:      101
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       32      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       33
neval is:      101


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      101     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.455591     -0.786160      -14.1159       14.1159       117.452       131.567    
   2  0.588265E-01  -2.83316      -50.8709       50.8709       117.629       168.500    
   3  0.787103E-01  -2.54198      -45.6426       45.6426       119.277       164.920    
   4  0.597713     -0.514644      -9.24070       9.24070       119.097       128.337    
   5  0.110741      -2.20056      -39.5123       39.5123       120.876       160.388    
   6  0.677861     -0.388813      -6.98134       6.98134       119.994       126.975    
   7  0.307724      -1.17855      -21.1615       21.1615       118.108       139.269    
   8  0.550587     -0.596770      -10.7153       10.7153       117.794       128.510    
   9  0.601295     -0.508669      -9.13342       9.13342       122.555       131.689    
  10  0.487121     -0.719243      -12.9144       12.9144       125.752       138.666    
  11  0.146295      -1.92213      -34.5128       34.5128       122.710       157.222    
  12  0.714050     -0.336802      -6.04745       6.04745       121.129       127.177    
  13  0.723089     -0.324223      -5.82160       5.82160       121.000       126.822    
  14  0.805432     -0.216376      -3.88515       3.88515       125.771       129.656    
  15  0.123280      -2.09329      -37.5862       37.5862       121.677       159.263    
  16  0.853039     -0.158950      -2.85404       2.85404       127.913       130.768    
  17  0.288289      -1.24379      -22.3329       22.3329       129.721       152.054    
  18  0.705126     -0.349379      -6.27329       6.27329       121.019       127.293    
  19  0.772420     -0.258227      -4.63660       4.63660       119.649       124.286    
  20  0.962845     -0.378631E-01 -0.679853      0.679853       125.529       126.209    
  21  0.245802      -1.40323      -25.1957       25.1957       122.382       147.577    
  22  0.752702     -0.284087      -5.10092       5.10092       123.809       128.910    
  23  0.729896     -0.314853      -5.65335       5.65335       120.348       126.001    
  24  0.869278     -0.140092      -2.51543       2.51543       125.093       127.609    
  25  0.597817E-01  -2.81706      -50.5817       50.5817       120.246       170.828    
  26  0.984108     -0.160195E-01 -0.287639      0.287639       120.842       121.130    
  27  0.278288      -1.27910      -22.9669       22.9669       121.289       144.256    
  28  0.588278     -0.530555      -9.52640       9.52640       118.469       127.995    
  29  0.807614     -0.213671      -3.83658       3.83658       135.320       139.156    
  30  0.428679     -0.847047      -15.2092       15.2092       120.104       135.313    
  31  0.452991     -0.791883      -14.2187       14.2187       124.892       139.111    
  32  0.678742     -0.387514      -6.95802       6.95802       124.136       131.094    
  33  0.504500     -0.684188      -12.2850       12.2850       119.932       132.217    
  34  0.894800     -0.111155      -1.99585       1.99585       141.529       143.525    
  35  0.854311     -0.157461      -2.82729       2.82729       143.778       146.605    
  36  0.756230     -0.279410      -5.01695       5.01695       125.047       130.064    
  37  0.744369     -0.295219      -5.30081       5.30081       116.607       121.908    
  38  0.435758     -0.830668      -14.9151       14.9151       134.834       149.749    
  39  0.677387     -0.389513      -6.99391       6.99391       119.704       126.697    
  40  0.504989     -0.683219      -12.2676       12.2676       117.750       130.018    
  41  0.325676      -1.12185      -20.1434       20.1434       119.707       139.850    
  42  0.147207      -1.91591      -34.4012       34.4012       117.527       151.928    
  43  0.432041     -0.839234      -15.0689       15.0689       120.806       135.875    
  44  0.615972     -0.484555      -8.70043       8.70043       144.270       152.971    
  45  0.150867      -1.89136      -33.9603       33.9603       119.057       153.018    
  46  0.464307     -0.767210      -13.7757       13.7757       110.504       124.280    
loop,thermsimp(1:2)       33   14.1159       50.8709    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    103        120.68         67.77          1.09         42.45          0.34          0.05        111.72
Just calling func    0   0        111.72


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    104        127.22         67.78          1.06         41.95          0.55          0.05        111.39
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    120.68
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       33
neval is:      103
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       33      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       34
neval is:      103


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      103     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.961594E-01  -2.34175      -42.0473       42.0473       120.842       162.890    
   2  0.298819      -1.20792      -21.6888       21.6888       116.607       138.296    
   3  0.706385     -0.347595      -6.24126       6.24126       110.504       116.745    
   4  0.958764     -0.421100E-01 -0.756106      0.756106       119.649       120.405    
   5  0.306496      -1.18255      -21.2333       21.2333       120.348       141.581    
   6  0.905447     -0.993270E-01  -1.78347       1.78347       125.529       127.313    
   7  0.234113      -1.45195      -26.0705       26.0705       119.704       145.774    
   8  0.704141     -0.350777      -6.29838       6.29838       121.000       127.299    
   9  0.908200     -0.962902E-01  -1.72894       1.72894       119.994       121.723    
  10  0.656383     -0.421011      -7.55948       7.55948       121.129       128.689    
  11  0.967894     -0.326327E-01 -0.585938      0.585938       121.019       121.605    
  12  0.754670     -0.281475      -5.05403       5.05403       125.093       130.147    
  13  0.488960     -0.715475      -12.8467       12.8467       118.469       131.315    
  14  0.451577     -0.795009      -14.2748       14.2748       119.097       133.372    
  15  0.387599E-01  -3.25037      -58.3621       58.3621       117.794       176.157    
  16  0.210942E-02  -6.16134      -110.630       110.630       123.809       234.439    
  17  0.656530     -0.420787      -7.55545       7.55545       125.771       133.326    
  18  0.181246      -1.70790      -30.6663       30.6663       117.750       148.416    
  19  0.758879     -0.275913      -4.95416       4.95416       125.047       130.001    
  20  0.392052     -0.936362      -16.8129       16.8129       127.913       144.726    
  21  0.406710     -0.899654      -16.1538       16.1538       124.136       140.289    
  22  0.830107     -0.186201      -3.34333       3.34333       117.452       120.795    
  23  0.311833      -1.16529      -20.9234       20.9234       122.555       143.479    
  24  0.945407     -0.561396E-01  -1.00802       1.00802       119.932       120.940    
  25  0.303319      -1.19297      -21.4204       21.4204       120.104       141.525    
  26  0.284230      -1.25797      -22.5875       22.5875       120.806       143.393    
  27  0.292492      -1.22932      -22.0730       22.0730       125.752       147.825    
  28  0.401496     -0.912557      -16.3854       16.3854       124.892       141.278    
  29  0.379648     -0.968510      -17.3901       17.3901       135.320       152.710    
  30  0.723496E-01  -2.62625      -47.1556       47.1556       118.108       165.263    
  31  0.940338     -0.615157E-01  -1.10455       1.10455       119.707       120.811    
  32  0.766237     -0.266264      -4.78090       4.78090       141.529       146.310    
  33  0.984920     -0.151946E-01 -0.272827      0.272827       121.289       121.562    
  34  0.552546     -0.593218      -10.6516       10.6516       143.778       154.430    
  35  0.735557     -0.307128      -5.51464       5.51464       122.382       127.896    
  36  0.142195      -1.95056      -35.0233       35.0233       134.834       169.857    
  37  0.304783      -1.18816      -21.3340       21.3340       117.527       138.861    
  38  0.868582     -0.140894      -2.52982       2.52982       129.721       132.251    
  39  0.382741     -0.960397      -17.2444       17.2444       144.270       161.515    
  40  0.273812      -1.29531      -23.2580       23.2580       119.057       142.315    
  41  0.601920     -0.507631      -9.11479       9.11479       122.710       131.824    
  42  0.827744     -0.189051      -3.39452       3.39452       121.677       125.072    
  43  0.881186E-01  -2.42907      -43.6153       43.6153       120.876       164.491    
  44  0.386744     -0.949994      -17.0576       17.0576       119.277       136.335    
  45  0.852312     -0.159803      -2.86935       2.86935       117.629       120.499    
  46  0.830189     -0.186102      -3.34157       3.34157       120.680       124.022    
loop,thermsimp(1:2)       34   42.0473       21.6888    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    105        119.40         67.84          1.14         41.94          0.33          0.05        111.30
Just calling func    0   0        111.30


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    106        129.91         68.20          1.23         41.88          0.00          0.05        111.36
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    119.40
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       34
neval is:      105
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       34      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       35
neval is:      105


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      105     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.348096      -1.05528      -18.9481       18.9481       110.504       129.452    
   2  0.175000      -1.74297      -31.2960       31.2960       119.649       150.945    
   3  0.131587      -2.02809      -36.4154       36.4154       117.629       154.045    
   4  0.301717      -1.19826      -21.5155       21.5155       117.452       138.967    
   5  0.166877      -1.79050      -32.1494       32.1494       119.707       151.856    
   6  0.481073     -0.731736      -13.1387       13.1387       119.932       133.071    
   7  0.706381     -0.347600      -6.24135       6.24135       121.289       127.531    
   8  0.702617     -0.352943      -6.33728       6.33728       121.019       127.357    
   9  0.552795     -0.592767      -10.6435       10.6435       119.994       130.637    
  10  0.495420     -0.702349      -12.6111       12.6111       120.680       133.291    
  11  0.479343     -0.735339      -13.2034       13.2034       121.677       134.881    
  12  0.462659     -0.770765      -13.8395       13.8395       121.000       134.840    
  13  0.631315E-01  -2.76253      -49.6028       49.6028       125.529       175.132    
  14  0.785681     -0.241205      -4.33096       4.33096       122.382       126.713    
  15  0.767932     -0.264055      -4.74124       4.74124       121.129       125.870    
  16  0.262689E-01  -3.63937      -65.3468       65.3468       125.047       190.394    
  17  0.871353     -0.137708      -2.47262       2.47262       125.093       127.566    
  18  0.618350     -0.480701      -8.63124       8.63124       118.469       127.100    
  19  0.196090      -1.62918      -29.2529       29.2529       122.710       151.963    
  20  0.925050     -0.779078E-01  -1.39888       1.39888       129.721       131.120    
  21  0.903269     -0.101735      -1.82671       1.82671       125.771       127.597    
  22  0.958828     -0.420436E-01 -0.754915      0.754915       119.097       119.852    
  23  0.969274     -0.312081E-01 -0.560358      0.560358       119.277       119.838    
  24  0.313932      -1.15858      -20.8029       20.8029       116.607       137.410    
  25  0.106324      -2.24126      -40.2431       40.2431       117.527       157.770    
  26  0.718705     -0.330304      -5.93079       5.93079       124.136       130.066    
  27  0.751116     -0.286195      -5.13878       5.13878       124.892       130.031    
  28  0.996391     -0.361592E-02 -0.649257E-01  0.649257E-01   120.104       120.169    
  29  0.313387      -1.16032      -20.8341       20.8341       120.348       141.182    
  30  0.305057      -1.18726      -21.3178       21.3178       119.057       140.375    
  31  0.408833     -0.894447      -16.0603       16.0603       120.806       136.866    
  32  0.589856     -0.527877      -9.47832       9.47832       122.555       132.034    
  33  0.808683     -0.212349      -3.81283       3.81283       127.913       131.726    
  34  0.481635     -0.730569      -13.1178       13.1178       119.704       132.821    
  35  0.677481     -0.389374      -6.99141       6.99141       141.529       148.521    
  36  0.673605     -0.395111      -7.09442       7.09442       125.752       132.846    
  37  0.409374E-01  -3.19571      -57.3807       57.3807       117.750       175.131    
  38  0.362144      -1.01571      -18.2377       18.2377       135.320       153.557    
  39  0.364718E-01  -3.31122      -59.4546       59.4546       143.778       203.233    
  40  0.280272      -1.27199      -22.8393       22.8393       144.270       167.110    
  41  0.532528     -0.630120      -11.3141       11.3141       120.842       132.156    
  42  0.901591     -0.103595      -1.86010       1.86010       120.876       122.736    
  43  0.262858      -1.33614      -23.9911       23.9911       118.108       142.099    
  44  0.168755      -1.77931      -31.9485       31.9485       134.834       166.783    
  45  0.504619     -0.683952      -12.2807       12.2807       117.794       130.075    
  46  0.900650     -0.104639      -1.87884       1.87884       119.396       121.275    
loop,thermsimp(1:2)       35   18.9481       31.2960    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    107        145.31         67.81          1.13         41.99          0.56          0.05        111.55
Just calling func    0   0        111.55


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    145.31
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       35
neval is:      106
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       35      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       36
neval is:      106


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      106     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.757905E-01  -2.57978      -46.3214       46.3214       119.277       165.599    
   2  0.962370     -0.383559E-01 -0.688700      0.688700       119.097       119.785    
   3  0.356737      -1.03076      -18.5078       18.5078       120.104       138.612    
   4  0.884319     -0.122937      -2.20740       2.20740       119.396       121.603    
   5  0.919725E-01  -2.38627      -42.8467       42.8467       120.876       163.723    
   6  0.900184     -0.105156      -1.88813       1.88813       121.129       123.017    
   7  0.390055     -0.941468      -16.9046       16.9046       122.382       139.286    
   8  0.263976      -1.33190      -23.9149       23.9149       118.469       142.383    
   9  0.898455     -0.107078      -1.92265       1.92265       121.019       122.942    
  10  0.697674E-01  -2.66259      -47.8082       47.8082       121.289       169.098    
  11  0.888938     -0.117727      -2.11386       2.11386       125.093       127.207    
  12  0.824147     -0.193406      -3.47271       3.47271       125.771       129.243    
  13  0.941109     -0.606968E-01  -1.08984       1.08984       110.504       111.594    
  14  0.885654     -0.121429      -2.18032       2.18032       124.892       127.073    
  15  0.798208     -0.225386      -4.04692       4.04692       124.136       128.183    
  16  0.365331      -1.00695      -18.0804       18.0804       117.794       135.875    
  17  0.519490     -0.654907      -11.7592       11.7592       119.994       131.753    
  18  0.922741     -0.804065E-01  -1.44374       1.44374       129.721       131.165    
  19  0.877443     -0.130744      -2.34757       2.34757       127.913       130.261    
  20  0.584844     -0.536410      -9.63153       9.63153       122.555       132.187    
  21  0.671390     -0.398406      -7.15359       7.15359       120.842       127.996    
  22  0.203335      -1.59290      -28.6014       28.6014       119.704       148.305    
  23  0.330236E-01  -3.41053      -61.2380       61.2380       125.752       186.990    
  24  0.879725     -0.128146      -2.30094       2.30094       119.932       122.233    
  25  0.833976     -0.181550      -3.25984       3.25984       120.680       123.940    
  26  0.901698     -0.103475      -1.85795       1.85795       121.000       122.858    
  27  0.692847     -0.366946      -6.58871       6.58871       121.677       128.266    
  28  0.550572     -0.596797      -10.7158       10.7158       120.806       131.522    
  29  0.158383E-01  -4.14532      -74.4314       74.4314       116.607       191.039    
  30  0.503246     -0.686677      -12.3296       12.3296       117.452       129.781    
  31  0.648812     -0.432612      -7.76778       7.76778       119.057       126.825    
  32  0.306980      -1.18097      -21.2050       21.2050       120.348       141.553    
  33  0.205188      -1.58383      -28.4385       28.4385       118.108       146.546    
  34  0.265146      -1.32748      -23.8355       23.8355       141.529       165.365    
  35  0.272730E-01  -3.60186      -64.6733       64.6733       119.649       184.322    
  36  0.262990E-01  -3.63823      -65.3263       65.3263       119.707       185.033    
  37  0.492753     -0.707748      -12.7080       12.7080       122.710       135.418    
  38  0.255065      -1.36624      -24.5315       24.5315       135.320       159.851    
  39  0.623259     -0.472794      -8.48926       8.48926       117.629       126.118    
  40  0.949296     -0.520343E-01 -0.934304      0.934304       117.527       118.461    
  41  0.982394     -0.177630E-01 -0.318944      0.318944       134.834       135.153    
  42  0.566450     -0.568366      -10.2053       10.2053       144.270       154.476    
  43  0.557613     -0.584090      -10.4876       10.4876       117.750       128.238    
  44  0.900731     -0.104549      -1.87723       1.87723       125.529       127.407    
  45  0.671339     -0.398481      -7.15493       7.15493       125.047       132.202    
  46  0.650454     -0.430084      -7.72239       7.72239       145.311       153.034    
loop,thermsimp(1:2)       36   46.3214      0.688700    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    108        124.60         67.80          1.15         42.35          0.38          0.05        111.74
Just calling func    0   0        111.74


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    109        167.80         67.88          1.13         42.30          0.31          0.05        111.67
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    124.60
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       36
neval is:      108
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       36      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       37
neval is:      108


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      108     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.939165     -0.627646E-01  -1.12697       1.12697       110.504       111.631    
   2  0.112532E-01  -4.48710      -80.5683       80.5683       117.527       198.095    
   3  0.907929     -0.965891E-01  -1.73431       1.73431       119.097       120.831    
   4  0.478640     -0.736807      -13.2298       13.2298       119.396       132.626    
   5  0.737686     -0.304237      -5.46274       5.46274       119.932       125.395    
   6  0.114880      -2.16387      -38.8534       38.8534       121.000       159.854    
   7  0.309837      -1.17171      -21.0387       21.0387       121.019       142.058    
   8  0.469091     -0.756958      -13.5916       13.5916       121.129       134.721    
   9  0.721151     -0.326907      -5.86978       5.86978       120.680       126.550    
  10  0.557251     -0.584740      -10.4993       10.4993       117.629       128.129    
  11  0.581534     -0.542085      -9.73343       9.73343       119.057       128.791    
  12  0.501412     -0.690326      -12.3952       12.3952       124.892       137.288    
  13  0.783062     -0.244543      -4.39090       4.39090       125.093       129.484    
  14  0.571322     -0.559803      -10.0516       10.0516       125.529       135.581    
  15  0.902729E-01  -2.40492      -43.1816       43.1816       120.842       164.024    
  16  0.695403E-01  -2.66585      -47.8667       47.8667       124.136       172.002    
  17  0.128872      -2.04894      -36.7898       36.7898       117.750       154.540    
  18  0.940828E-01  -2.36358      -42.4393       42.4393       121.677       164.117    
  19  0.326350      -1.11979      -20.1063       20.1063       125.771       145.877    
  20  0.102915      -2.27385      -40.8283       40.8283       117.452       158.280    
  21  0.324524      -1.12540      -20.2071       20.2071       127.913       148.121    
  22  0.259454      -1.34918      -24.2252       24.2252       129.721       153.946    
  23  0.782812     -0.244863      -4.39664       4.39664       120.806       125.202    
  24  0.383591     -0.958178      -17.2046       17.2046       119.994       137.199    
  25  0.626880     -0.466999      -8.38522       8.38522       122.555       130.941    
  26  0.292269      -1.23008      -22.0867       22.0867       125.047       147.134    
  27  0.448852     -0.801062      -14.3835       14.3835       134.834       149.218    
  28  0.685432     -0.377706      -6.78192       6.78192       122.710       129.492    
  29  0.995399     -0.461118E-02 -0.827962E-01  0.827962E-01   117.794       117.877    
  30  0.163323      -1.81203      -32.5359       32.5359       120.104       152.640    
  31  0.952940     -0.482038E-01 -0.865524      0.865524       122.382       123.247    
  32  0.861306     -0.149306      -2.68086       2.68086       120.348       123.029    
  33  0.587276     -0.532261      -9.55703       9.55703       118.469       128.026    
  34  0.908704     -0.957357E-01  -1.71899       1.71899       118.108       119.827    
  35  0.585935     -0.534546      -9.59805       9.59805       119.704       129.302    
  36  0.429836     -0.844352      -15.1608       15.1608       145.311       160.472    
  37  0.726203     -0.319926      -5.74445       5.74445       144.270       150.015    
  38  0.151145E-01  -4.19210      -75.2713       75.2713       135.320       210.591    
  39  0.927869     -0.748646E-01  -1.34423       1.34423       120.876       122.220    
  40  0.961645     -0.391099E-01 -0.702239      0.702239       141.529       142.231    
  41  0.253977      -1.37051      -24.6082       24.6082       119.277       143.886    
  42  0.768038     -0.263917      -4.73876       4.73876       121.289       126.028    
  43  0.569441E-01  -2.86569      -51.4549       51.4549       119.649       171.104    
  44  0.103919      -2.26415      -40.6539       40.6539       119.707       160.361    
  45  0.312226      -1.16403      -20.9007       20.9007       125.752       146.652    
  46  0.473636E-02  -5.35249      -96.1067       96.1067       124.604       220.711    
loop,thermsimp(1:2)       37   1.12697       80.5683    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    110        116.61         67.76          1.10         42.52          0.17          0.05        111.61
Just calling func    0   0        111.61


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    116.61
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       37
neval is:      109
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       37      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       38
neval is:      109


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      109     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.371753     -0.989525      -17.7674       17.7674       110.504       128.272    
   2  0.687927     -0.374072      -6.71666       6.71666       117.794       124.511    
   3  0.288957      -1.24148      -22.2914       22.2914       118.108       140.399    
   4  0.192838      -1.64590      -29.5531       29.5531       119.097       148.650    
   5  0.369869     -0.994607      -17.8587       17.8587       120.876       138.735    
   6  0.735973     -0.306562      -5.50448       5.50448       120.348       125.852    
   7  0.637144     -0.450760      -8.09363       8.09363       122.382       130.475    
   8  0.703934     -0.351071      -6.30366       6.30366       120.806       127.109    
   9  0.864279     -0.145859      -2.61898       2.61898       119.932       122.551    
  10  0.473452     -0.747705      -13.4254       13.4254       121.289       134.715    
  11  0.242010      -1.41877      -25.4749       25.4749       120.680       146.155    
  12  0.510769     -0.671838      -12.0632       12.0632       118.469       130.532    
  13  0.829624     -0.186782      -3.35378       3.35378       117.629       120.983    
  14  0.228911      -1.47442      -26.4741       26.4741       119.057       145.531    
  15  0.310006      -1.17116      -21.0289       21.0289       119.704       140.732    
  16  0.248341      -1.39295      -25.0112       25.0112       125.093       150.104    
  17  0.723214     -0.324050      -5.81849       5.81849       122.710       128.528    
  18  0.420900     -0.865360      -15.5380       15.5380       122.555       138.093    
  19  0.133903      -2.01064      -36.1020       36.1020       119.396       155.498    
  20  0.571916     -0.558763      -10.0329       10.0329       121.129       131.162    
  21  0.609104     -0.495766      -8.90173       8.90173       125.529       134.431    
  22  0.582057     -0.541186      -9.71728       9.71728       119.994       129.711    
  23  0.440731     -0.819321      -14.7114       14.7114       124.892       139.604    
  24  0.211006      -1.55587      -27.9365       27.9365       121.019       148.956    
  25  0.665769     -0.406813      -7.30454       7.30454       141.529       148.834    
  26  0.766062     -0.266493      -4.78502       4.78502       119.277       124.062    
  27  0.321416E-01  -3.43760      -61.7240       61.7240       125.771       187.495    
  28  0.165897E-01  -4.09897      -73.5992       73.5992       125.752       199.351    
  29  0.634553     -0.454835      -8.16680       8.16680       125.047       133.214    
  30  0.981834     -0.183335E-01 -0.329188      0.329188       127.913       128.243    
  31  0.511720     -0.669978      -12.0298       12.0298       134.834       146.864    
  32  0.426358     -0.852477      -15.3067       15.3067       144.270       159.577    
  33  0.500527     -0.692094      -12.4269       12.4269       120.104       132.531    
  34  0.100483      -2.29777      -41.2577       41.2577       129.721       170.978    
  35  0.837324     -0.177545      -3.18791       3.18791       117.750       120.938    
  36  0.257741      -1.35580      -24.3441       24.3441       117.452       141.796    
  37  0.437184     -0.827401      -14.8564       14.8564       121.000       135.857    
  38  0.707529     -0.345976      -6.21219       6.21219       119.707       125.919    
  39  0.538379     -0.619193      -11.1179       11.1179       145.311       156.429    
  40  0.611820     -0.491317      -8.82185       8.82185       120.842       129.664    
  41  0.404533     -0.905022      -16.2501       16.2501       121.677       137.927    
  42  0.902499     -0.102588      -1.84203       1.84203       119.649       121.491    
  43  0.704299     -0.350552      -6.29435       6.29435       124.136       130.430    
  44  0.511818     -0.669786      -12.0264       12.0264       117.527       129.553    
  45  0.748131     -0.290178      -5.21030       5.21030       135.320       140.530    
  46  0.296598      -1.21538      -21.8228       21.8228       116.607       138.430    
loop,thermsimp(1:2)       38   17.7674       6.71666    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    111        121.88         67.80          1.12         42.25          0.23          0.05        111.45
Just calling func    0   0        111.45


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    112        139.60         67.96          1.16         42.39          0.00          0.05        111.56
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    121.88
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       38
neval is:      111
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       38      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       39
neval is:      111


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      111     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.724264     -0.322600      -5.79245       5.79245       117.750       123.543    
   2  0.309663      -1.17227      -21.0487       21.0487       117.629       138.678    
   3  0.688114     -0.373801      -6.71179       6.71179       119.649       126.361    
   4  0.677876     -0.388791      -6.98095       6.98095       119.932       126.913    
   5  0.283701      -1.25984      -22.6210       22.6210       119.277       141.898    
   6  0.183733      -1.69427      -30.4215       30.4215       117.794       148.216    
   7  0.243414      -1.41299      -25.3710       25.3710       120.348       145.719    
   8  0.785389     -0.241576      -4.33762       4.33762       119.707       124.045    
   9  0.258033      -1.35467      -24.3238       24.3238       120.806       145.130    
  10  0.137887      -1.98132      -35.5757       35.5757       127.913       163.489    
  11  0.386520     -0.950573      -17.0680       17.0680       110.504       127.572    
  12  0.882934     -0.124505      -2.23556       2.23556       122.710       124.945    
  13  0.395106     -0.928602      -16.6735       16.6735       117.527       134.200    
  14  0.107633      -2.22903      -40.0235       40.0235       120.842       160.866    
  15  0.434094     -0.834495      -14.9838       14.9838       119.994       134.978    
  16  0.558484     -0.582529      -10.4596       10.4596       124.136       134.595    
  17  0.102706      -2.27589      -40.8648       40.8648       122.382       163.246    
  18  0.325804      -1.12146      -20.1364       20.1364       118.469       138.605    
  19  0.693871     -0.365469      -6.56218       6.56218       121.129       127.691    
  20  0.832622     -0.183176      -3.28902       3.28902       120.104       123.393    
  21  0.691207     -0.369316      -6.63126       6.63126       125.047       131.678    
  22  0.903946     -0.100985      -1.81324       1.81324       125.529       127.343    
  23  0.258785E-01  -3.65434      -65.6156       65.6156       121.289       186.905    
  24  0.247338      -1.39700      -25.0839       25.0839       121.000       146.084    
  25  0.861464     -0.149122      -2.67757       2.67757       121.677       124.355    
  26  0.954919     -0.461290E-01 -0.828270      0.828270       122.555       123.384    
  27  0.579638     -0.545352      -9.79209       9.79209       116.607       126.400    
  28  0.537182     -0.621418      -11.1579       11.1579       120.876       132.034    
  29  0.407710     -0.897199      -16.1097       16.1097       124.892       141.002    
  30  0.958466     -0.424211E-01 -0.761693      0.761693       118.108       118.869    
  31  0.884674     -0.122536      -2.20020       2.20020       135.320       137.520    
  32  0.395055     -0.928731      -16.6759       16.6759       119.704       136.379    
  33  0.325425      -1.12262      -20.1573       20.1573       117.452       137.609    
  34  0.679842     -0.385895      -6.92895       6.92895       119.057       125.986    
  35  0.765292     -0.267498      -4.80306       4.80306       120.680       125.483    
  36  0.217460      -1.52574      -27.3955       27.3955       134.834       162.230    
  37  0.181189      -1.70822      -30.6719       30.6719       119.097       149.769    
  38  0.518456     -0.656899      -11.7950       11.7950       141.529       153.324    
  39  0.249864E-01  -3.68942      -66.2456       66.2456       121.019       187.265    
  40  0.336654      -1.08870      -19.5482       19.5482       125.093       144.641    
  41  0.873801     -0.134903      -2.42225       2.42225       119.396       121.818    
  42  0.478904     -0.736255      -13.2198       13.2198       145.311       158.531    
  43  0.819950     -0.198512      -3.56439       3.56439       144.270       147.835    
  44  0.966813     -0.337500E-01 -0.606000      0.606000       129.721       130.327    
  45  0.514109     -0.665319      -11.9462       11.9462       125.771       137.717    
  46  0.483734     -0.726221      -13.0397       13.0397       121.881       134.920    
loop,thermsimp(1:2)       39   5.79245       21.0487    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    113        120.18         67.79          1.12         42.03          0.67          0.05        111.66
Just calling func    0   0        111.66


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    114        132.38         67.87          1.13         41.98          0.60          0.05        111.63
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    120.18
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       39
neval is:      113
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       39      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       40
neval is:      113


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      113     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.954632     -0.464296E-01 -0.833668      0.833668       118.108       118.941    
   2  0.450411     -0.797594      -14.3212       14.3212       119.396       133.717    
   3  0.691912E-01  -2.67088      -47.9571       47.9571       122.555       170.513    
   4  0.740935     -0.299842      -5.38382       5.38382       120.104       125.488    
   5  0.452531     -0.792898      -14.2369       14.2369       117.750       131.987    
   6  0.461330     -0.773642      -13.8912       13.8912       119.707       133.598    
   7  0.102999      -2.27303      -40.8135       40.8135       121.677       162.491    
   8  0.475106     -0.744217      -13.3628       13.3628       122.710       136.072    
   9  0.240275      -1.42597      -25.6040       25.6040       120.680       146.284    
  10  0.276707E-01  -3.58738      -64.4133       64.4133       119.057       183.471    
  11  0.132701E-01  -4.32224      -77.6081       77.6081       119.649       197.257    
  12  0.997219     -0.278509E-02 -0.500077E-01  0.500077E-01   116.607       116.657    
  13  0.563305     -0.573934      -10.3053       10.3053       119.932       130.237    
  14  0.347949      -1.05570      -18.9557       18.9557       125.529       144.485    
  15  0.546018     -0.605103      -10.8649       10.8649       110.504       121.369    
  16  0.343968      -1.06721      -19.1623       19.1623       121.129       140.291    
  17  0.945234     -0.563230E-01  -1.01131       1.01131       129.721       130.732    
  18  0.346208      -1.06072      -19.0457       19.0457       125.047       144.093    
  19  0.406433     -0.900337      -16.1660       16.1660       120.876       137.042    
  20  0.632259     -0.458455      -8.23181       8.23181       117.527       125.759    
  21  0.983930     -0.162002E-01 -0.290883      0.290883       124.136       124.427    
  22  0.200798      -1.60546      -28.8268       28.8268       121.881       150.708    
  23  0.223962      -1.49628      -26.8665       26.8665       119.994       146.860    
  24  0.594322     -0.520335      -9.34289       9.34289       119.704       129.046    
  25  0.875298     -0.133191      -2.39151       2.39151       135.320       137.711    
  26  0.327822      -1.11529      -20.0255       20.0255       117.452       137.477    
  27  0.215105      -1.53663      -27.5910       27.5910       125.771       153.362    
  28  0.905181     -0.996198E-01  -1.78873       1.78873       118.469       120.257    
  29  0.699086     -0.357981      -6.42775       6.42775       117.629       124.057    
  30  0.747401     -0.291154      -5.22782       5.22782       124.892       130.120    
  31  0.699189     -0.357834      -6.42509       6.42509       119.277       125.703    
  32  0.563488     -0.573610      -10.2995       10.2995       125.093       135.393    
  33  0.155576      -1.86062      -33.4085       33.4085       120.806       154.214    
  34  0.380593     -0.966025      -17.3455       17.3455       120.348       137.693    
  35  0.626112     -0.468226      -8.40724       8.40724       121.000       129.408    
  36  0.372369     -0.987870      -17.7377       17.7377       144.270       162.008    
  37  0.517531     -0.658686      -11.8271       11.8271       117.794       129.622    
  38  0.673247     -0.395643      -7.10397       7.10397       119.097       126.201    
  39  0.741527     -0.299044      -5.36949       5.36949       141.529       146.899    
  40  0.280982      -1.26947      -22.7939       22.7939       145.311       168.105    
  41  0.331745      -1.10339      -19.8119       19.8119       120.842       140.654    
  42  0.712030     -0.339635      -6.09833       6.09833       134.834       140.932    
  43  0.200581      -1.60654      -28.8462       28.8462       122.382       151.228    
  44  0.989915     -0.101357E-01 -0.181992      0.181992       127.913       128.095    
  45  0.808031     -0.213155      -3.82732       3.82732       121.289       125.117    
  46  0.893446     -0.112670      -2.02305       2.02305       120.175       122.198    
loop,thermsimp(1:2)       40  0.833668       14.3212    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    115        118.16         67.76          1.12         42.01          0.50          0.05        111.44
Just calling func    0   0        111.44


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    116        118.31         67.66          1.13         42.63          0.39          0.05        111.88
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    118.16
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       40
neval is:      115
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       40      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       41
neval is:      115


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      115     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.357965      -1.02732      -18.4461       18.4461       116.607       135.054    
   2  0.414955     -0.879585      -15.7934       15.7934       118.108       133.901    
   3  0.407443     -0.897854      -16.1214       16.1214       118.469       134.590    
   4  0.883897     -0.123414      -2.21597       2.21597       110.504       112.720    
   5  0.520045     -0.653840      -11.7401       11.7401       120.175       131.915    
   6  0.634521     -0.454885      -8.16769       8.16769       117.629       125.797    
   7  0.344406      -1.06594      -19.1394       19.1394       124.136       143.275    
   8  0.545595     -0.605879      -10.8789       10.8789       121.289       132.168    
   9  0.766876     -0.265430      -4.76593       4.76593       120.104       124.870    
  10  0.639043     -0.447783      -8.04018       8.04018       119.277       127.318    
  11  0.850701     -0.161694      -2.90331       2.90331       117.527       120.430    
  12  0.832060     -0.183851      -3.30114       3.30114       119.097       122.398    
  13  0.728209     -0.317167      -5.69489       5.69489       127.913       133.608    
  14  0.531327     -0.632378      -11.3547       11.3547       119.704       131.058    
  15  0.188974E-01  -3.96873      -71.2606       71.2606       121.000       192.261    
  16  0.246817      -1.39911      -25.1217       25.1217       117.794       142.916    
  17  0.935336     -0.668496E-01  -1.20032       1.20032       124.892       126.093    
  18  0.730823     -0.313585      -5.63058       5.63058       119.932       125.563    
  19  0.482288     -0.729213      -13.0934       13.0934       129.721       142.814    
  20  0.782974E-04  -9.45500      -169.769       169.769       117.750       287.520    
  21  0.258744      -1.35192      -24.2744       24.2744       119.707       143.981    
  22  0.389044     -0.944063      -16.9511       16.9511       119.396       136.347    
  23  0.611459E-01  -2.79449      -50.1766       50.1766       125.093       175.270    
  24  0.124922      -2.08006      -37.3487       37.3487       122.710       160.058    
  25  0.253683      -1.37167      -24.6291       24.6291       120.876       145.505    
  26  0.781437     -0.246621      -4.42821       4.42821       117.452       121.880    
  27  0.835634     -0.179565      -3.22418       3.22418       120.348       123.572    
  28  0.542030     -0.612434      -10.9966       10.9966       135.320       146.316    
  29  0.463443     -0.769071      -13.8091       13.8091       121.129       134.938    
  30  0.120587      -2.11538      -37.9828       37.9828       120.842       158.825    
  31  0.733316     -0.310178      -5.56941       5.56941       134.834       140.403    
  32  0.955530     -0.454889E-01 -0.816777      0.816777       125.047       125.864    
  33  0.419735     -0.868132      -15.5878       15.5878       125.529       141.117    
  34  0.284829      -1.25587      -22.5497       22.5497       120.680       143.230    
  35  0.924079     -0.789582E-01  -1.41774       1.41774       119.994       121.412    
  36  0.432674     -0.837770      -15.0426       15.0426       141.529       156.572    
  37  0.155293      -1.86244      -33.4411       33.4411       121.881       155.322    
  38  0.634342     -0.455168      -8.17278       8.17278       122.382       130.554    
  39  0.935635     -0.665293E-01  -1.19457       1.19457       125.771       126.965    
  40  0.931832     -0.706024E-01  -1.26770       1.26770       120.806       122.073    
  41  0.875970     -0.132424      -2.37774       2.37774       144.270       146.648    
  42  0.273544      -1.29629      -23.2756       23.2756       121.677       144.953    
  43  0.799596     -0.223649      -4.01574       4.01574       145.311       149.327    
  44  0.772883     -0.257628      -4.62584       4.62584       122.555       127.181    
  45  0.274276      -1.29362      -23.2277       23.2277       119.057       142.285    
  46  0.116034      -2.15387      -38.6739       38.6739       118.163       156.837    
loop,thermsimp(1:2)       41   18.4461       15.7934    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    117        159.84         67.95          1.12         42.16          0.33          0.05        111.60
Just calling func    0   0        111.60


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    159.84
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       41
neval is:      116
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       41      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       42
neval is:      116


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      116     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.559413E-01  -2.88345      -51.7739       51.7739       110.504       162.278    
   2  0.688513     -0.373221      -6.70139       6.70139       117.527       124.228    
   3  0.530653     -0.633647      -11.3775       11.3775       119.994       131.371    
   4  0.542886     -0.610856      -10.9682       10.9682       117.452       128.420    
   5  0.603382     -0.505205      -9.07122       9.07122       120.806       129.877    
   6  0.478412     -0.737283      -13.2383       13.2383       119.097       132.335    
   7  0.809657     -0.211144      -3.79121       3.79121       120.348       124.139    
   8  0.764585     -0.268422      -4.81966       4.81966       120.104       124.924    
   9  0.228600      -1.47578      -26.4984       26.4984       119.932       146.431    
  10  0.495526     -0.702136      -12.6072       12.6072       117.629       130.236    
  11  0.368264     -0.998954      -17.9368       17.9368       125.047       142.984    
  12  0.407647     -0.897355      -16.1125       16.1125       124.892       141.005    
  13  0.316165      -1.15149      -20.6756       20.6756       125.771       146.446    
  14  0.458518     -0.779756      -14.0009       14.0009       122.555       136.556    
  15  0.643610     -0.440663      -7.91233       7.91233       119.277       127.190    
  16  0.316553E-01  -3.45285      -61.9977       61.9977       122.382       184.379    
  17  0.570171     -0.561819      -10.0878       10.0878       119.704       129.791    
  18  0.448642E-01  -3.10412      -55.7360       55.7360       120.175       175.911    
  19  0.128957      -2.04828      -36.7779       36.7779       121.289       158.067    
  20  0.159422      -1.83620      -32.9700       32.9700       127.913       160.883    
  21  0.154083      -1.87026      -33.5815       33.5815       118.108       151.689    
  22  0.696997     -0.360974      -6.48148       6.48148       118.469       124.950    
  23  0.579421     -0.545727      -9.79881       9.79881       121.129       130.928    
  24  0.528206     -0.638269      -11.4605       11.4605       116.607       128.068    
  25  0.322914      -1.13037      -20.2964       20.2964       119.396       139.692    
  26  0.369562     -0.995437      -17.8736       17.8736       134.834       152.708    
  27  0.134248      -2.00806      -36.0559       36.0559       125.529       161.585    
  28  0.950150     -0.511358E-01 -0.918170      0.918170       119.057       119.975    
  29  0.138040      -1.98021      -35.5558       35.5558       129.721       165.277    
  30  0.316838      -1.14936      -20.6374       20.6374       117.794       138.432    
  31  0.151783      -1.88530      -33.8516       33.8516       120.680       154.532    
  32  0.338674      -1.08272      -19.4408       19.4408       124.136       143.576    
  33  0.814165     -0.205592      -3.69152       3.69152       119.707       123.398    
  34  0.578183     -0.547865      -9.83720       9.83720       121.677       131.514    
  35  0.208707      -1.56682      -28.1331       28.1331       120.876       149.009    
  36  0.540561     -0.615147      -11.0453       11.0453       135.320       146.365    
  37  0.910129     -0.941686E-01  -1.69085       1.69085       144.270       145.961    
  38  0.907740     -0.967972E-01  -1.73804       1.73804       145.311       147.049    
  39  0.549661     -0.598453      -10.7455       10.7455       121.881       132.626    
  40  0.193889      -1.64047      -29.4555       29.4555       141.529       170.985    
  41  0.807651     -0.213625      -3.83575       3.83575       118.163       121.999    
  42  0.613777     -0.488124      -8.76452       8.76452       120.842       129.607    
  43  0.664452     -0.408793      -7.34009       7.34009       122.710       130.050    
  44  0.584630     -0.536776      -9.63809       9.63809       125.093       134.731    
  45  0.618915     -0.479787      -8.61484       8.61484       121.000       129.615    
  46  0.542097     -0.612311      -10.9944       10.9944       159.844       170.838    
loop,thermsimp(1:2)       42   51.7739       6.70139    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    118        122.94         67.81          1.12         42.33          0.44          0.05        111.75
Just calling func    0   0        111.75


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    119        129.72         67.84          1.13         42.05          0.52          0.05        111.60
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    122.94
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       42
neval is:      118
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       42      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       43
neval is:      118


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      118     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.788601     -0.237495      -4.26434       4.26434       119.057       123.322    
   2  0.796559     -0.227454      -4.08406       4.08406       118.163       122.247    
   3  0.784232     -0.243051      -4.36410       4.36410       119.707       124.071    
   4  0.503549     -0.686074      -12.3188       12.3188       120.348       132.667    
   5  0.468337     -0.758566      -13.6205       13.6205       117.527       131.147    
   6  0.198518      -1.61688      -29.0319       29.0319       120.104       149.136    
   7  0.857529     -0.153700      -2.75976       2.75976       118.469       121.228    
   8  0.845427     -0.167913      -3.01497       3.01497       119.277       122.292    
   9  0.710919     -0.341197      -6.12637       6.12637       116.607       122.734    
  10  0.934107     -0.681640E-01  -1.22392       1.22392       117.452       118.675    
  11  0.565087     -0.570775      -10.2486       10.2486       120.842       131.091    
  12  0.147377      -1.91476      -34.3805       34.3805       121.000       155.381    
  13  0.471965     -0.750851      -13.4819       13.4819       119.704       133.185    
  14  0.287319      -1.24716      -22.3934       22.3934       120.806       143.199    
  15  0.526906     -0.640733      -11.5047       11.5047       122.710       134.214    
  16  0.176999      -1.73161      -31.0920       31.0920       117.629       148.721    
  17  0.868579     -0.140897      -2.52987       2.52987       121.129       123.659    
  18  0.621282     -0.475971      -8.54631       8.54631       119.994       128.540    
  19  0.181881      -1.70440      -30.6035       30.6035       121.677       152.281    
  20  0.565209     -0.570560      -10.2447       10.2447       119.097       129.341    
  21  0.927617     -0.751364E-01  -1.34911       1.34911       121.881       123.230    
  22  0.296120      -1.21699      -21.8517       21.8517       125.093       146.945    
  23  0.152389      -1.88132      -33.7800       33.7800       122.555       156.336    
  24  0.508731     -0.675835      -12.1350       12.1350       117.794       129.929    
  25  0.389654     -0.942496      -16.9230       16.9230       119.396       136.319    
  26  0.770754     -0.260386      -4.67537       4.67537       124.892       129.568    
  27  0.144347      -1.93554      -34.7536       34.7536       125.047       159.800    
  28  0.690124     -0.370884      -6.65942       6.65942       124.136       130.795    
  29  0.882429     -0.125077      -2.24583       2.24583       144.270       146.516    
  30  0.781105     -0.247045      -4.43583       4.43583       135.320       139.755    
  31  0.331946      -1.10278      -19.8010       19.8010       119.932       139.733    
  32  0.157011      -1.85144      -33.2435       33.2435       125.771       159.014    
  33  0.734200     -0.308973      -5.54778       5.54778       145.311       150.859    
  34  0.563390     -0.573784      -10.3026       10.3026       120.876       131.179    
  35  0.349498      -1.05126      -18.8759       18.8759       118.108       136.984    
  36  0.256822      -1.35937      -24.4082       24.4082       134.834       159.242    
  37  0.563556     -0.573488      -10.2973       10.2973       120.680       130.977    
  38  0.945419E-01  -2.35871      -42.3519       42.3519       121.289       163.641    
  39  0.571450     -0.559577      -10.0475       10.0475       127.913       137.961    
  40  0.583029E-01  -2.84210      -51.0315       51.0315       125.529       176.561    
  41  0.428808     -0.846746      -15.2038       15.2038       110.504       125.708    
  42  0.628450     -0.464499      -8.34032       8.34032       129.721       138.061    
  43  0.152789      -1.87869      -33.7330       33.7330       159.844       193.577    
  44  0.787004E-01  -2.54211      -45.6449       45.6449       141.529       187.174    
  45  0.170927E-01  -4.06911      -73.0629       73.0629       120.175       193.238    
  46  0.531078     -0.632847      -11.3631       11.3631       122.940       134.303    
loop,thermsimp(1:2)       43   4.26434       4.08406    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    120        119.55         67.81          1.12         42.05          0.34          0.05        111.38
Just calling func    0   0        111.38


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    121        124.23         67.77          1.09         42.11          0.42          0.05        111.43
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  120    124.23       0.7883     -2.629      2.484     -102.6     0.3012    
                       1.017     0.8813     -99.70      2.517     0.7901    

                       1.630     -2.478      1.540      7802.      7000.    

                      0.3506      0.000      0.000      0.000     -1.221    



                      -1.759      0.000      0.000      7000.      517.9    

                       1.763     -4.648    -0.9018     -7.315      8.142    

                      -11.34     -47.47      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.3186    -0.8008      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.5284     -1.150      7000.    



                      -1.503    -0.6816     -1.949     -1.912    -0.3807    

                     -0.3252      9.310      8.828    -0.1552E+05 -5.473    

                      0.1529     -3.188      9.325      8.887    -0.1969E+05



                      -6.000      1.000    -0.1059      8.944      9.002    

                     -0.1944E+05 -6.000    -0.8145E-02-0.3698      9.121    

                       8.856    -0.1891E+05 -6.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    119.55
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       43
neval is:      120
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       43      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       44
neval is:      120


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      120     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.104987      -2.25392      -40.4703       40.4703       117.452       157.922    
   2  0.780131E-01  -2.55088      -45.8024       45.8024       118.469       164.271    
   3  0.723689     -0.323394      -5.80671       5.80671       118.163       123.970    
   4  0.439896     -0.821218      -14.7454       14.7454       119.277       134.023    
   5  0.967364     -0.331803E-01 -0.595770      0.595770       116.607       117.203    
   6  0.235884      -1.44441      -25.9352       25.9352       121.881       147.816    
   7  0.311956      -1.16489      -20.9163       20.9163       119.057       139.974    
   8  0.600573     -0.509870      -9.15499       9.15499       121.129       130.284    
   9  0.781739     -0.246234      -4.42127       4.42127       119.707       124.128    
  10  0.505036     -0.683126      -12.2659       12.2659       110.504       122.770    
  11  0.896130     -0.109670      -1.96919       1.96919       119.994       121.963    
  12  0.545040     -0.606897      -10.8972       10.8972       119.097       129.994    
  13  0.338019      -1.08465      -19.4755       19.4755       124.892       144.368    
  14  0.200467      -1.60711      -28.8564       28.8564       117.794       146.651    
  15  0.548763     -0.600089      -10.7749       10.7749       124.136       134.911    
  16  0.897241     -0.108431      -1.94693       1.94693       120.680       122.627    
  17  0.229905      -1.47009      -26.3962       26.3962       120.842       147.238    
  18  0.387828     -0.947193      -17.0074       17.0074       117.527       134.534    
  19  0.789400     -0.236482      -4.24616       4.24616       120.876       125.122    
  20  0.495667     -0.701851      -12.6021       12.6021       120.348       132.950    
  21  0.818926     -0.199761      -3.58682       3.58682       119.704       123.290    
  22  0.181319      -1.70750      -30.6590       30.6590       122.710       153.369    
  23  0.901986     -0.103156      -1.85223       1.85223       122.940       124.792    
  24  0.933790E-01  -2.37109      -42.5741       42.5741       119.396       161.970    
  25  0.171523      -1.76304      -31.6563       31.6563       118.108       149.764    
  26  0.648450     -0.433170      -7.77779       7.77779       127.913       135.691    
  27  0.777448     -0.251739      -4.52010       4.52010       129.721       134.241    
  28  0.777670     -0.251453      -4.51497       4.51497       119.932       124.447    
  29  0.972420     -0.279672E-01 -0.502167      0.502167       135.320       135.822    
  30  0.825305     -0.192002      -3.44749       3.44749       120.806       124.253    
  31  0.470649     -0.753642      -13.5320       13.5320       144.270       157.803    
  32  0.263953      -1.33198      -23.9164       23.9164       125.093       149.010    
  33  0.857551     -0.153675      -2.75932       2.75932       117.629       120.389    
  34  0.950157     -0.511279E-01 -0.918028      0.918028       120.104       121.022    
  35  0.866482     -0.143314      -2.57328       2.57328       145.311       147.884    
  36  0.904889     -0.999433E-01  -1.79453       1.79453       121.677       123.472    
  37  0.297565      -1.21212      -21.7643       21.7643       121.000       142.765    
  38  0.902696     -0.102369      -1.83809       1.83809       122.555       124.394    
  39  0.800054     -0.223076      -4.00545       4.00545       125.771       129.776    
  40  0.534162     -0.627057      -11.2591       11.2591       134.834       146.093    
  41  0.593018     -0.522530      -9.38230       9.38230       125.047       134.429    
  42  0.682417E-01  -2.68470      -48.2052       48.2052       121.289       169.495    
  43  0.336048      -1.09050      -19.5805       19.5805       125.529       145.110    
  44  0.576540     -0.550710      -9.88829       9.88829       141.529       151.417    
  45  0.217955      -1.52347      -27.3547       27.3547       120.175       147.530    
  46  0.281607      -1.26724      -22.7540       22.7540       119.547       142.301    
loop,thermsimp(1:2)       44   40.4703       45.8024    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    122        122.12         67.79          1.12         42.05          0.59          0.05        111.60
Just calling func    0   0        111.60


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    123        132.87         67.85          1.17         42.42          0.50          0.05        111.99
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    122.12
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       44
neval is:      122
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       44      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       45
neval is:      122


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      122     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.872614     -0.136261      -2.44665       2.44665       116.607       119.054    
   2  0.990306     -0.974175E-02 -0.174918      0.174918       117.629       117.804    
   3  0.488656     -0.716096      -12.8579       12.8579       120.104       132.962    
   4  0.865115E-01  -2.44748      -43.9458       43.9458       119.994       163.940    
   5  0.234262      -1.45132      -26.0592       26.0592       120.680       146.739    
   6  0.906541     -0.981186E-01  -1.76177       1.76177       110.504       112.266    
   7  0.680454     -0.384995      -6.91279       6.91279       119.704       126.616    
   8  0.575574     -0.552388      -9.91842       9.91842       121.677       131.596    
   9  0.537443E-02  -5.22610      -93.8374       93.8374       118.163       212.000    
  10  0.421676     -0.863518      -15.5049       15.5049       119.707       135.212    
  11  0.297588      -1.21204      -21.7629       21.7629       120.806       142.569    
  12  0.119337      -2.12581      -38.1700       38.1700       122.555       160.725    
  13  0.958276     -0.426192E-01 -0.765250      0.765250       119.932       120.697    
  14  0.115549      -2.15806      -38.7491       38.7491       122.940       161.689    
  15  0.104220      -2.26125      -40.6020       40.6020       120.876       161.478    
  16  0.719503     -0.329194      -5.91085       5.91085       125.771       131.682    
  17  0.875656     -0.132782      -2.38417       2.38417       119.097       121.481    
  18  0.578760     -0.546868      -9.81930       9.81930       121.129       130.948    
  19  0.923704     -0.793639E-01  -1.42502       1.42502       120.348       121.773    
  20  0.457980     -0.780930      -14.0220       14.0220       119.277       133.299    
  21  0.783173     -0.244401      -4.38835       4.38835       129.721       134.109    
  22  0.764479     -0.268561      -4.82215       4.82215       125.047       129.869    
  23  0.496891     -0.699384      -12.5578       12.5578       117.527       130.085    
  24  0.554859     -0.589041      -10.5765       10.5765       124.136       134.712    
  25  0.734503E-02  -4.91373      -88.2287       88.2287       127.913       216.142    
  26  0.117643      -2.14010      -38.4267       38.4267       135.320       173.746    
  27  0.145440      -1.92799      -34.6181       34.6181       119.057       153.675    
  28  0.375449     -0.979633      -17.5898       17.5898       119.547       137.137    
  29  0.954324E-01  -2.34934      -42.1836       42.1836       121.000       163.184    
  30  0.449085     -0.800543      -14.3742       14.3742       124.892       139.267    
  31  0.354483      -1.03709      -18.6216       18.6216       125.529       144.151    
  32  0.153971      -1.87099      -33.5946       33.5946       134.834       168.429    
  33  0.871598     -0.137427      -2.46757       2.46757       117.794       120.262    
  34  0.633061     -0.457188      -8.20905       8.20905       120.842       129.051    
  35  0.947022E-01  -2.35702      -42.3215       42.3215       120.175       162.497    
  36  0.793812     -0.230909      -4.14609       4.14609       121.881       126.027    
  37  0.760585     -0.273667      -4.91384       4.91384       145.311       150.225    
  38  0.124312      -2.08496      -37.4366       37.4366       125.093       162.530    
  39  0.961605E-03  -6.94691      -124.735       124.735       118.108       242.843    
  40  0.672529     -0.396710      -7.12314       7.12314       141.529       148.652    
  41  0.749847E-01  -2.59047      -46.5133       46.5133       122.710       169.223    
  42  0.982441     -0.177147E-01 -0.318077      0.318077       144.270       144.589    
  43  0.340727      -1.07667      -19.3322       19.3322       117.452       136.784    
  44  0.915043     -0.887846E-01  -1.59418       1.59418       119.396       120.990    
  45  0.150614      -1.89303      -33.9904       33.9904       118.469       152.459    
  46  0.892785     -0.113409      -2.03632       2.03632       122.117       124.153    
loop,thermsimp(1:2)       45   2.44665      0.174918    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    124        139.77         67.73          1.08         41.84          0.78          0.05        111.48
Just calling func    0   0        111.48


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    125        202.01         67.70          1.05         41.62          0.84          0.05        111.26
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    139.77
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       45
neval is:      124
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       45      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       46
neval is:      124


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      124     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.880559E-01  -2.42978      -43.6280       43.6280       110.504       154.132    
   2  0.312747      -1.16236      -20.8708       20.8708       117.629       138.500    
   3  0.317683      -1.14670      -20.5896       20.5896       116.607       137.197    
   4  0.693053     -0.366649      -6.58338       6.58338       117.794       124.378    
   5  0.361881      -1.01644      -18.2507       18.2507       119.932       138.183    
   6  0.127478      -2.05981      -36.9850       36.9850       119.396       156.381    
   7  0.718706     -0.330302      -5.93075       5.93075       119.097       125.027    
   8  0.609419E-01  -2.79783      -50.2366       50.2366       120.348       170.584    
   9  0.320798      -1.13695      -20.4145       20.4145       122.117       142.531    
  10  0.343503      -1.06856      -19.1866       19.1866       121.881       141.067    
  11  0.671828     -0.397753      -7.14187       7.14187       119.704       126.845    
  12  0.616702     -0.483369      -8.67915       8.67915       120.842       129.521    
  13  0.806358E-01  -2.51781      -45.2087       45.2087       125.047       170.256    
  14  0.997284     -0.271972E-02 -0.488341E-01  0.488341E-01   117.527       117.576    
  15  0.554344     -0.589969      -10.5932       10.5932       121.129       131.722    
  16  0.411057     -0.889023      -15.9629       15.9629       121.677       137.640    
  17  0.846258E-01  -2.46952      -44.3415       44.3415       125.771       170.112    
  18  0.737439     -0.304571      -5.46874       5.46874       120.104       125.573    
  19  0.393790     -0.931939      -16.7335       16.7335       119.277       136.011    
  20  0.965947     -0.346467E-01 -0.622100      0.622100       129.721       130.343    
  21  0.150166      -1.89601      -34.0439       34.0439       124.136       158.180    
  22  0.212005      -1.55114      -27.8516       27.8516       119.707       147.559    
  23  0.615060     -0.486036      -8.72703       8.72703       117.452       126.179    
  24  0.382142     -0.961962      -17.2725       17.2725       119.547       136.820    
  25  0.249044      -1.39013      -24.9605       24.9605       124.892       149.853    
  26  0.245943      -1.40266      -25.1854       25.1854       120.806       145.991    
  27  0.108882      -2.21749      -39.8163       39.8163       125.529       165.346    
  28  0.199835      -1.61026      -28.9131       28.9131       144.270       173.184    
  29  0.863954     -0.146235      -2.62574       2.62574       120.680       123.306    
  30  0.392842     -0.934347      -16.7767       16.7767       141.529       158.306    
  31  0.770596     -0.260592      -4.67906       4.67906       145.311       149.990    
  32  0.149868      -1.89800      -34.0796       34.0796       118.469       152.548    
  33  0.234154      -1.45178      -26.0674       26.0674       119.057       145.125    
  34  0.611512     -0.491821      -8.83090       8.83090       122.555       131.386    
  35  0.518093E-01  -2.96019      -53.1517       53.1517       120.876       174.028    
  36  0.567953     -0.565716      -10.1577       10.1577       122.940       133.098    
  37  0.190847      -1.65628      -29.7395       29.7395       120.175       149.915    
  38  0.104561      -2.25798      -40.5433       40.5433       125.093       165.636    
  39  0.135276      -2.00044      -35.9189       35.9189       121.000       156.919    
  40  0.262364      -1.33802      -24.0249       24.0249       119.994       144.019    
  41  0.463951     -0.767976      -13.7894       13.7894       134.834       148.624    
  42  0.419672     -0.868282      -15.5905       15.5905       122.710       138.300    
  43  0.897011     -0.108687      -1.95153       1.95153       135.320       137.271    
  44  0.818933     -0.199754      -3.58668       3.58668       118.163       121.750    
  45  0.136906      -1.98846      -35.7039       35.7039       127.913       163.617    
  46  0.561722     -0.576748      -10.3558       10.3558       139.770       150.125    
loop,thermsimp(1:2)       46   43.6280       20.8708    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    126        118.68         67.80          1.12         42.07          0.47          0.05        111.51
Just calling func    0   0        111.51


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    127        121.75         67.82          1.11         42.12          0.33          0.05        111.43
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    118.68
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       46
neval is:      126
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       46      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       47
neval is:      126


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      126     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.419083E-01  -3.17227      -56.9598       56.9598       117.527       174.487    
   2  0.581082     -0.542864      -9.74741       9.74741       118.163       127.910    
   3  0.690143     -0.370857      -6.65893       6.65893       120.680       127.339    
   4  0.958690     -0.421877E-01 -0.757502      0.757502       117.794       118.552    
   5  0.947492     -0.539367E-01 -0.968463      0.968463       119.097       120.065    
   6  0.253816E-01  -3.67373      -65.9638       65.9638       120.104       186.068    
   7  0.811950     -0.208316      -3.74042       3.74042       117.452       121.192    
   8  0.448512     -0.801821      -14.3971       14.3971       119.704       134.101    
   9  0.625244     -0.469613      -8.43216       8.43216       120.842       129.274    
  10  0.557627     -0.584065      -10.4872       10.4872       129.721       140.208    
  11  0.762657     -0.270947      -4.86500       4.86500       122.555       127.420    
  12  0.579328     -0.545887      -9.80169       9.80169       121.129       130.931    
  13  0.168395      -1.78144      -31.9868       31.9868       122.940       154.927    
  14  0.993282     -0.674111E-02 -0.121040      0.121040       119.277       119.399    
  15  0.573458     -0.556070      -9.98454       9.98454       119.547       129.532    
  16  0.900456     -0.104854      -1.88270       1.88270       116.607       118.490    
  17  0.961937     -0.388068E-01 -0.696796      0.696796       135.320       136.016    
  18  0.685702     -0.377312      -6.77484       6.77484       121.677       128.452    
  19  0.335644      -1.09171      -19.6021       19.6021       119.932       139.534    
  20  0.726392     -0.319666      -5.73977       5.73977       122.710       128.449    
  21  0.523515     -0.647189      -11.6206       11.6206       117.629       129.250    
  22  0.877914     -0.130206      -2.33793       2.33793       121.881       124.219    
  23  0.893563     -0.112539      -2.02070       2.02070       122.117       124.137    
  24  0.829449     -0.186994      -3.35758       3.35758       119.994       123.352    
  25  0.454457     -0.788653      -14.1607       14.1607       119.057       133.218    
  26  0.261407      -1.34168      -24.0905       24.0905       120.806       144.896    
  27  0.144225      -1.93638      -34.7688       34.7688       119.707       154.476    
  28  0.963744     -0.369299E-01 -0.663095      0.663095       134.834       135.497    
  29  0.267843      -1.31735      -23.6538       23.6538       124.892       148.546    
  30  0.251943E-01  -3.68114      -66.0968       66.0968       120.175       186.272    
  31  0.321532      -1.13466      -20.3734       20.3734       145.311       165.685    
  32  0.440903     -0.818930      -14.7043       14.7043       139.770       154.474    
  33  0.214416      -1.53984      -27.6486       27.6486       118.469       146.117    
  34  0.212185      -1.55030      -27.8364       27.8364       110.504       138.341    
  35  0.948253E-01  -2.35572      -42.2982       42.2982       119.396       161.694    
  36  0.507627     -0.678008      -12.1740       12.1740       121.000       133.174    
  37  0.415074     -0.879299      -15.7883       15.7883       124.136       139.924    
  38  0.768069     -0.263876      -4.73804       4.73804       141.529       146.267    
  39  0.462999E-01  -3.07261      -55.1704       55.1704       127.913       183.084    
  40  0.835390     -0.179856      -3.22942       3.22942       125.529       128.759    
  41  0.678734     -0.387526      -6.95824       6.95824       125.093       132.051    
  42  0.363569      -1.01179      -18.1671       18.1671       125.771       143.938    
  43  0.677161     -0.389846      -6.99989       6.99989       125.047       132.047    
  44  0.506668     -0.679899      -12.2079       12.2079       120.348       132.556    
  45  0.875658     -0.132779      -2.38412       2.38412       144.270       146.655    
  46  0.924863     -0.781102E-01  -1.40251       1.40251       118.681       120.084    
loop,thermsimp(1:2)       47   56.9598       9.74741    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    128        121.53         67.75          1.12         42.11          0.30          0.05        111.33
Just calling func    0   0        111.33


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    129        134.54         67.73          1.12         42.04          0.41          0.05        111.34
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    121.53
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       47
neval is:      128
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       47      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       48
neval is:      128


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      128     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.566816     -0.567720      -10.1937       10.1937       116.607       126.801    
   2  0.216137      -1.53184      -27.5050       27.5050       117.794       145.299    
   3  0.476425     -0.741444      -13.3130       13.3130       119.277       132.590    
   4  0.184047      -1.69256      -30.3909       30.3909       119.097       149.488    
   5  0.722630     -0.324858      -5.83300       5.83300       118.681       124.514    
   6  0.887750     -0.119065      -2.13787       2.13787       117.452       119.589    
   7  0.236344      -1.44247      -25.9003       25.9003       119.994       145.894    
   8  0.798055     -0.225578      -4.05036       4.05036       122.117       126.167    
   9  0.425454     -0.854597      -15.3448       15.3448       121.881       137.226    
  10  0.605701     -0.501368      -9.00233       9.00233       120.680       129.683    
  11  0.742456     -0.297792      -5.34702       5.34702       122.555       127.902    
  12  0.378462E-01  -3.27423      -58.7905       58.7905       118.163       176.953    
  13  0.341910      -1.07321      -19.2700       19.2700       122.710       141.980    
  14  0.794971E-01  -2.53203      -45.4640       45.4640       121.677       167.141    
  15  0.586423     -0.533715      -9.58313       9.58313       125.529       135.112    
  16  0.990523     -0.952170E-02 -0.170967      0.170967       117.629       117.800    
  17  0.348475      -1.05419      -18.9285       18.9285       120.842       139.771    
  18  0.998034     -0.196755E-02 -0.353284E-01  0.353284E-01   119.547       119.583    
  19  0.616072     -0.484391      -8.69750       8.69750       121.129       129.827    
  20  0.427239     -0.850411      -15.2696       15.2696       125.047       140.316    
  21  0.598160     -0.513898      -9.22730       9.22730       125.093       134.321    
  22  0.642831     -0.441873      -7.93406       7.93406       120.348       128.282    
  23  0.392766     -0.934541      -16.7802       16.7802       121.000       137.780    
  24  0.738407     -0.303260      -5.44520       5.44520       119.057       124.502    
  25  0.334341      -1.09559      -19.6720       19.6720       119.704       139.375    
  26  0.997912     -0.208996E-02 -0.375263E-01  0.375263E-01   134.834       134.872    
  27  0.492305E-01  -3.01124      -54.0685       54.0685       135.320       189.388    
  28  0.304734      -1.18832      -21.3368       21.3368       110.504       131.841    
  29  0.159886      -1.83330      -32.9178       32.9178       119.932       152.850    
  30  0.991331     -0.870666E-02 -0.156333      0.156333       124.136       124.292    
  31  0.735164     -0.307662      -5.52424       5.52424       129.721       135.245    
  32  0.279948      -1.27315      -22.8601       22.8601       125.771       148.631    
  33  0.457260     -0.782502      -14.0502       14.0502       120.806       134.856    
  34  0.678170     -0.388358      -6.97317       6.97317       118.469       125.442    
  35  0.689603     -0.371639      -6.67298       6.67298       141.529       148.202    
  36  0.468470     -0.758283      -13.6154       13.6154       144.270       157.886    
  37  0.937429     -0.646141E-01  -1.16018       1.16018       124.892       126.053    
  38  0.115915      -2.15490      -38.6923       38.6923       139.770       178.462    
  39  0.125789      -2.07315      -37.2244       37.2244       119.707       156.931    
  40  0.137562      -1.98368      -35.6181       35.6181       122.940       158.558    
  41  0.273901      -1.29499      -23.2522       23.2522       119.396       142.648    
  42  0.934963     -0.672484E-01  -1.20748       1.20748       145.311       146.519    
  43  0.450296     -0.797850      -14.3258       14.3258       117.527       131.853    
  44  0.681645     -0.383246      -6.88139       6.88139       127.913       134.795    
  45  0.282914E-01  -3.56520      -64.0150       64.0150       120.104       184.119    
  46  0.962226     -0.385062E-01 -0.691399      0.691399       121.529       122.221    
loop,thermsimp(1:2)       48   10.1937       27.5050    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    130        140.43         67.79          1.13         41.99          0.57          0.05        111.54
Just calling func    0   0        111.53


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    140.43
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       48
neval is:      129
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       48      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       49
neval is:      129


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      129     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.180970      -1.70942      -30.6936       30.6936       117.629       148.323    
   2  0.335083      -1.09338      -19.6322       19.6322       119.547       139.179    
   3  0.585160     -0.535871      -9.62184       9.62184       117.452       127.073    
   4  0.445729     -0.808044      -14.5089       14.5089       121.529       136.038    
   5  0.963605     -0.370741E-01 -0.665684      0.665684       124.136       124.801    
   6  0.538074     -0.619758      -11.1281       11.1281       119.057       130.185    
   7  0.971443     -0.289729E-01 -0.520224      0.520224       118.681       119.202    
   8  0.817136     -0.201950      -3.62612       3.62612       118.469       122.095    
   9  0.216943      -1.52812      -27.4382       27.4382       124.892       152.331    
  10  0.572311     -0.558074      -10.0205       10.0205       122.117       132.137    
  11  0.511761     -0.669897      -12.0283       12.0283       116.607       128.636    
  12  0.331920E-01  -3.40545      -61.1466       61.1466       122.555       183.702    
  13  0.662680     -0.411462      -7.38802       7.38802       120.348       127.736    
  14  0.578679     -0.547007      -9.82180       9.82180       120.680       130.502    
  15  0.473979     -0.746592      -13.4055       13.4055       121.129       134.535    
  16  0.243750      -1.41161      -25.3463       25.3463       110.504       135.850    
  17  0.784227     -0.243057      -4.36422       4.36422       117.527       121.891    
  18  0.215065      -1.53682      -27.5943       27.5943       119.277       146.872    
  19  0.813272     -0.206689      -3.71122       3.71122       125.093       128.804    
  20  0.877336     -0.130865      -2.34975       2.34975       127.913       130.263    
  21  0.911070     -0.931357E-01  -1.67230       1.67230       120.806       122.478    
  22  0.424500     -0.856844      -15.3851       15.3851       134.834       150.219    
  23  0.122508      -2.09958      -37.6991       37.6991       125.529       163.228    
  24  0.173199      -1.75331      -31.4817       31.4817       129.721       161.202    
  25  0.243010      -1.41465      -25.4009       25.4009       121.881       147.282    
  26  0.618804     -0.479966      -8.61805       8.61805       121.000       129.618    
  27  0.365303      -1.00703      -18.0817       18.0817       119.704       137.785    
  28  0.178054      -1.72567      -30.9853       30.9853       120.842       151.828    
  29  0.416122     -0.876776      -15.7430       15.7430       125.047       140.790    
  30  0.789287     -0.236625      -4.24873       4.24873       122.710       126.958    
  31  0.786736     -0.239863      -4.30687       4.30687       119.396       123.703    
  32  0.295880      -1.21780      -21.8662       21.8662       117.794       139.661    
  33  0.418649     -0.870722      -15.6343       15.6343       119.994       135.628    
  34  0.706992     -0.346736      -6.22583       6.22583       145.311       151.537    
  35  0.281863      -1.26633      -22.7377       22.7377       141.529       164.267    
  36  0.357290      -1.02921      -18.4800       18.4800       125.771       144.251    
  37  0.174180      -1.74767      -31.3803       31.3803       119.097       150.477    
  38  0.190924      -1.65588      -29.7322       29.7322       119.932       149.664    
  39  0.630369     -0.461449      -8.28556       8.28556       119.707       127.993    
  40  0.252261      -1.37729      -24.7300       24.7300       144.270       169.000    
  41  0.359213      -1.02384      -18.3836       18.3836       122.940       141.324    
  42  0.740344     -0.300640      -5.39816       5.39816       121.677       127.075    
  43  0.283211      -1.26156      -22.6520       22.6520       118.163       140.815    
  44  0.965119     -0.355039E-01 -0.637491      0.637491       139.770       140.407    
  45  0.389600     -0.942634      -16.9255       16.9255       120.104       137.030    
  46  0.598383     -0.513525      -9.22061       9.22061       140.434       149.655    
loop,thermsimp(1:2)       49   30.6936       19.6322    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    131        136.91         67.75          1.12         42.55          0.10          0.05        111.59
Just calling func    0   0        111.59


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    136.91
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       49
neval is:      130
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       49      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       50
neval is:      130


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      130     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.317228E-01  -3.45072      -61.9595       61.9595       118.681       180.641    
   2  0.601445     -0.508421      -9.12897       9.12897       117.527       126.656    
   3  0.651191     -0.428952      -7.70205       7.70205       118.469       126.171    
   4  0.187303      -1.67503      -30.0760       30.0760       120.806       150.882    
   5  0.664603     -0.408566      -7.33601       7.33601       119.396       126.732    
   6  0.945236     -0.563208E-01  -1.01127       1.01127       124.136       125.147    
   7  0.865870     -0.144020      -2.58595       2.58595       122.710       125.296    
   8  0.674117     -0.394351      -7.08078       7.08078       117.452       124.532    
   9  0.959689E-01  -2.34373      -42.0829       42.0829       121.677       163.760    
  10  0.663337     -0.410472      -7.37024       7.37024       120.348       127.718    
  11  0.384854     -0.954891      -17.1456       17.1456       119.707       136.853    
  12  0.892338     -0.113910      -2.04532       2.04532       116.607       118.653    
  13  0.470837     -0.753243      -13.5249       13.5249       125.093       138.618    
  14  0.262618      -1.33706      -24.0075       24.0075       121.000       145.008    
  15  0.877143     -0.131085      -2.35370       2.35370       119.057       121.411    
  16  0.262102      -1.33902      -24.0429       24.0429       127.913       151.956    
  17  0.306130      -1.18375      -21.2548       21.2548       120.680       141.935    
  18  0.251844      -1.37895      -24.7597       24.7597       122.117       146.876    
  19  0.371147     -0.991157      -17.7968       17.7968       121.129       138.926    
  20  0.244393E-01  -3.71156      -66.6431       66.6431       119.994       186.637    
  21  0.550903     -0.596197      -10.7050       10.7050       110.504       121.209    
  22  0.509078     -0.675154      -12.1228       12.1228       121.529       133.652    
  23  0.741178     -0.299515      -5.37795       5.37795       120.104       125.482    
  24  0.585965     -0.534496      -9.59716       9.59716       119.704       129.301    
  25  0.602491     -0.506683      -9.09776       9.09776       119.547       128.645    
  26  0.532366     -0.630423      -11.3196       11.3196       117.794       129.114    
  27  0.264247      -1.33087      -23.8965       23.8965       139.770       163.666    
  28  0.468512     -0.758194      -13.6138       13.6138       125.047       138.661    
  29  0.338122      -1.08435      -19.4701       19.4701       118.163       137.633    
  30  0.815455     -0.204008      -3.66308       3.66308       122.940       126.603    
  31  0.126007      -2.07142      -37.1934       37.1934       125.771       162.964    
  32  0.391435     -0.937937      -16.8412       16.8412       119.277       136.119    
  33  0.477179     -0.739864      -13.2847       13.2847       121.881       135.165    
  34  0.926058     -0.768180E-01  -1.37931       1.37931       117.629       119.009    
  35  0.305992E-01  -3.48678      -62.6070       62.6070       140.434       203.041    
  36  0.142122      -1.95107      -35.0325       35.0325       119.932       154.965    
  37  0.934627E-01  -2.37019      -42.5581       42.5581       134.834       177.392    
  38  0.933240     -0.690924E-01  -1.24059       1.24059       119.097       120.337    
  39  0.551354     -0.595378      -10.6903       10.6903       145.311       156.001    
  40  0.167646      -1.78590      -32.0668       32.0668       120.842       152.909    
  41  0.657770     -0.418900      -7.52158       7.52158       124.892       132.414    
  42  0.937012     -0.650587E-01  -1.16816       1.16816       129.721       130.889    
  43  0.435130     -0.832109      -14.9410       14.9410       125.529       140.470    
  44  0.346278E-01  -3.36310      -60.3862       60.3862       141.529       201.915    
  45  0.529273     -0.636251      -11.4242       11.4242       144.270       155.695    
  46  0.543808     -0.609159      -10.9378       10.9378       136.909       147.847    
loop,thermsimp(1:2)       50   61.9595       9.12897    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    132        134.30         67.74          1.11         42.19          0.26          0.05        111.34
Just calling func    0   0        111.34


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    134.30
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       50
neval is:      131
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       50      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       51
neval is:      131


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      131     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.929295     -0.733287E-01  -1.31666       1.31666       116.607       117.924    
   2  0.669511     -0.401208      -7.20390       7.20390       117.629       124.833    
   3  0.863337E-01  -2.44954      -43.9827       43.9827       119.097       163.079    
   4  0.279945      -1.27316      -22.8603       22.8603       110.504       133.364    
   5  0.832640     -0.183154      -3.28863       3.28863       119.057       122.346    
   6  0.848933     -0.163775      -2.94067       2.94067       117.452       120.392    
   7  0.141794      -1.95338      -35.0740       35.0740       124.136       159.210    
   8  0.208764      -1.56655      -28.1283       28.1283       122.710       150.838    
   9  0.755787     -0.279996      -5.02748       5.02748       120.104       125.132    
  10  0.177416      -1.72926      -31.0498       31.0498       118.469       149.518    
  11  0.405148     -0.903503      -16.2229       16.2229       122.940       139.163    
  12  0.640380     -0.445693      -8.00265       8.00265       117.527       125.529    
  13  0.548060     -0.601370      -10.7979       10.7979       119.396       130.194    
  14  0.773287     -0.257105      -4.61645       4.61645       120.348       124.964    
  15  0.180768      -1.71054      -30.7137       30.7137       119.547       150.261    
  16  0.135846      -1.99624      -35.8435       35.8435       117.794       153.638    
  17  0.601016     -0.509133      -9.14176       9.14176       119.704       128.845    
  18  0.302263      -1.19646      -21.4830       21.4830       129.721       151.204    
  19  0.189428      -1.66374      -29.8734       29.8734       124.892       154.766    
  20  0.737158     -0.304953      -5.47559       5.47559       121.529       127.005    
  21  0.790680     -0.234862      -4.21707       4.21707       121.881       126.098    
  22  0.177192E-01  -4.03310      -72.4165       72.4165       119.277       191.694    
  23  0.236042      -1.44375      -25.9232       25.9232       119.707       145.630    
  24  0.459229     -0.778206      -13.9731       13.9731       118.163       132.136    
  25  0.586479E-01  -2.83620      -50.9255       50.9255       125.093       176.019    
  26  0.263766      -1.33269      -23.9292       23.9292       125.047       148.976    
  27  0.942550     -0.591663E-01  -1.06236       1.06236       121.129       122.192    
  28  0.106855      -2.23628      -40.1536       40.1536       125.529       165.683    
  29  0.710700     -0.341505      -6.13190       6.13190       120.680       126.812    
  30  0.207109E-01  -3.87709      -69.6153       69.6153       121.000       190.616    
  31  0.901203     -0.104025      -1.86782       1.86782       122.117       123.985    
  32  0.949751     -0.515555E-01 -0.925707      0.925707       136.909       137.835    
  33  0.343487      -1.06861      -19.1874       19.1874       120.806       139.993    
  34  0.875043     -0.133483      -2.39675       2.39675       127.913       130.310    
  35  0.122447E-01  -4.40266      -79.0521       79.0521       120.842       199.894    
  36  0.820650     -0.197659      -3.54907       3.54907       119.932       123.481    
  37  0.748866     -0.289195      -5.19265       5.19265       144.270       149.463    
  38  0.594525     -0.519992      -9.33673       9.33673       145.311       154.648    
  39  0.927863E-01  -2.37746      -42.6885       42.6885       125.771       168.459    
  40  0.631335     -0.459918      -8.25808       8.25808       139.770       148.028    
  41  0.282620      -1.26365      -22.6896       22.6896       121.677       144.367    
  42  0.707811     -0.345578      -6.20503       6.20503       134.834       141.039    
  43  0.930463     -0.720730E-01  -1.29411       1.29411       118.681       119.975    
  44  0.988563     -0.115032E-01 -0.206547      0.206547       119.994       120.201    
  45  0.869439     -0.139907      -2.51211       2.51211       141.529       144.041    
  46  0.693921     -0.365397      -6.56090       6.56090       134.295       140.856    
loop,thermsimp(1:2)       51   1.31666       7.20390    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    133        119.45         67.75          1.14         42.12          0.20          0.05        111.26
Just calling func    0   0        111.26


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    119.45
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       51
neval is:      132
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       51      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       52
neval is:      132


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      132     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.658032     -0.418502      -7.51443       7.51443       116.607       124.122    
   2  0.385391     -0.953496      -17.1205       17.1205       118.681       135.802    
   3  0.323679      -1.12800      -20.2539       20.2539       119.994       140.248    
   4  0.402516E-01  -3.21260      -57.6840       57.6840       117.452       175.136    
   5  0.866022     -0.143846      -2.58282       2.58282       121.129       123.712    
   6  0.560147     -0.579555      -10.4062       10.4062       119.057       129.463    
   7  0.389098     -0.943925      -16.9487       16.9487       119.932       136.881    
   8  0.470755     -0.753417      -13.5280       13.5280       122.117       135.645    
   9  0.794299     -0.230295      -4.13507       4.13507       117.629       121.764    
  10  0.897132     -0.108553      -1.94912       1.94912       120.348       122.297    
  11  0.359474      -1.02311      -18.3706       18.3706       120.104       138.475    
  12  0.604694     -0.503032      -9.03221       9.03221       117.527       126.559    
  13  0.101554      -2.28717      -41.0673       41.0673       121.881       162.948    
  14  0.274480      -1.29288      -23.2143       23.2143       120.680       143.894    
  15  0.916086     -0.876445E-01  -1.57370       1.57370       121.529       123.103    
  16  0.820070E-01  -2.50095      -44.9059       44.9059       119.704       164.609    
  17  0.975902     -0.243929E-01 -0.437988      0.437988       119.396       119.834    
  18  0.131665      -2.02750      -36.4048       36.4048       127.913       164.318    
  19  0.751313     -0.285933      -5.13408       5.13408       118.163       123.297    
  20  0.775324     -0.254475      -4.56923       4.56923       110.504       115.073    
  21  0.237000      -1.43969      -25.8505       25.8505       136.909       162.760    
  22  0.113641      -2.17471      -39.0480       39.0480       122.940       161.988    
  23  0.762281     -0.271440      -4.87384       4.87384       120.806       125.680    
  24  0.783730     -0.243690      -4.37559       4.37559       134.295       138.671    
  25  0.492891     -0.707468      -12.7030       12.7030       134.834       147.537    
  26  0.471904     -0.750980      -13.4843       13.4843       141.529       155.013    
  27  0.855781     -0.155740      -2.79640       2.79640       121.677       124.474    
  28  0.636473     -0.451814      -8.11255       8.11255       119.707       127.820    
  29  0.433340     -0.836232      -15.0150       15.0150       139.770       154.785    
  30  0.482236     -0.729321      -13.0953       13.0953       125.047       138.142    
  31  0.855143E-01  -2.45907      -44.1539       44.1539       144.270       188.424    
  32  0.916579     -0.871071E-01  -1.56405       1.56405       118.469       120.033    
  33  0.232519      -1.45878      -26.1932       26.1932       119.547       145.741    
  34  0.283977      -1.25886      -22.6035       22.6035       122.710       145.313    
  35  0.401228E-01  -3.21581      -57.7416       57.7416       129.721       187.462    
  36  0.235231      -1.44719      -25.9850       25.9850       117.794       143.779    
  37  0.233426      -1.45489      -26.1233       26.1233       145.311       171.434    
  38  0.903594     -0.101376      -1.82025       1.82025       124.892       126.713    
  39  0.857571     -0.153651      -2.75888       2.75888       124.136       126.895    
  40  0.444085     -0.811739      -14.5752       14.5752       119.097       133.672    
  41  0.151055      -1.89011      -33.9380       33.9380       125.529       159.467    
  42  0.745694     -0.293440      -5.26887       5.26887       125.771       131.040    
  43  0.470647E-01  -3.05623      -54.8763       54.8763       125.093       179.969    
  44  0.344459      -1.06578      -19.1367       19.1367       121.000       140.137    
  45  0.592738     -0.523004      -9.39081       9.39081       119.277       128.668    
  46  0.754292     -0.281975      -5.06301       5.06301       119.449       124.512    
loop,thermsimp(1:2)       52   7.51443       17.1205    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    134        137.59         67.81          1.12         41.96          0.40          0.05        111.34
Just calling func    0   0        111.34


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    137.59
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       52
neval is:      133
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       52      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       53
neval is:      133


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      133     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.581749     -0.541717      -9.72681       9.72681       110.504       120.231    
   2  0.307993      -1.17768      -21.1458       21.1458       119.396       140.542    
   3  0.551684     -0.594779      -10.6796       10.6796       118.469       129.148    
   4  0.969976     -0.304835E-01 -0.547348      0.547348       117.629       118.177    
   5  0.401714     -0.912015      -16.3757       16.3757       120.348       136.724    
   6  0.336211      -1.09002      -19.5718       19.5718       121.529       141.101    
   7  0.649191     -0.432028      -7.75729       7.75729       118.163       125.920    
   8  0.426986     -0.851005      -15.2802       15.2802       121.129       136.409    
   9  0.479997     -0.733976      -13.1789       13.1789       116.607       129.786    
  10  0.441527     -0.817516      -14.6789       14.6789       121.677       136.356    
  11  0.218988      -1.51874      -27.2698       27.2698       119.449       146.718    
  12  0.935549     -0.666221E-01  -1.19624       1.19624       120.806       122.002    
  13  0.159996      -1.83261      -32.9055       32.9055       117.527       150.432    
  14  0.486870     -0.719759      -12.9236       12.9236       124.892       137.816    
  15  0.835520     -0.179701      -3.22662       3.22662       124.136       127.362    
  16  0.643759     -0.440431      -7.90817       7.90817       119.707       127.615    
  17  0.177188      -1.73054      -31.0728       31.0728       119.277       150.350    
  18  0.408356     -0.895617      -16.0813       16.0813       119.057       135.138    
  19  0.463768     -0.768371      -13.7965       13.7965       125.771       139.567    
  20  0.616820     -0.483178      -8.67571       8.67571       119.097       127.772    
  21  0.377083     -0.975289      -17.5118       17.5118       122.117       139.629    
  22  0.278016      -1.28008      -22.9845       22.9845       118.681       141.666    
  23  0.746435     -0.292446      -5.25103       5.25103       119.932       125.183    
  24  0.872234     -0.136697      -2.45447       2.45447       125.047       127.501    
  25  0.887073E-01  -2.42241      -43.4957       43.4957       120.104       163.600    
  26  0.124913      -2.08014      -37.3500       37.3500       134.295       171.645    
  27  0.918160     -0.853835E-01  -1.53311       1.53311       121.000       122.533    
  28  0.924603     -0.783912E-01  -1.40756       1.40756       119.994       121.402    
  29  0.863214     -0.147092      -2.64112       2.64112       117.794       120.436    
  30  0.823499E-02  -4.79936      -86.1751       86.1751       120.680       206.855    
  31  0.548113     -0.601275      -10.7962       10.7962       122.710       133.506    
  32  0.800553     -0.222452      -3.99424       3.99424       119.547       123.542    
  33  0.180829      -1.71020      -30.7076       30.7076       134.834       165.542    
  34  0.968975E-01  -2.33410      -41.9100       41.9100       139.770       181.680    
  35  0.749847     -0.287886      -5.16915       5.16915       141.529       146.698    
  36  0.902028     -0.103110      -1.85139       1.85139       125.529       127.381    
  37  0.312083      -1.16449      -20.9090       20.9090       122.940       143.849    
  38  0.472691     -0.749313      -13.4543       13.4543       136.909       150.364    
  39  0.970346     -0.301026E-01 -0.540508      0.540508       121.881       122.421    
  40  0.485853     -0.721850      -12.9612       12.9612       127.913       140.875    
  41  0.604658     -0.503092      -9.03329       9.03329       119.704       128.737    
  42  0.172238      -1.75888      -31.5816       31.5816       145.311       176.893    
  43  0.359079E-01  -3.32680      -59.7344       59.7344       117.452       177.186    
  44  0.464923     -0.765884      -13.7519       13.7519       125.093       138.845    
  45  0.293512      -1.22584      -22.0106       22.0106       129.721       151.731    
  46  0.572788     -0.557239      -10.0055       10.0055       137.587       147.592    
loop,thermsimp(1:2)       53   9.72681       21.1458    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    135        120.64         67.84          1.13         42.44          0.09          0.05        111.55
Just calling func    0   0        111.55


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    136        122.71         67.82          1.10         42.00          0.48          0.05        111.45
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    120.64
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       53
neval is:      135
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       53      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       54
neval is:      135


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      136
neval,tstepnext:      135     136

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.565968     -0.569218      -10.2206       10.2206       117.629       127.850    
   2  0.698829     -0.358349      -6.43435       6.43435       110.504       116.938    
   3  0.550231     -0.597418      -10.7269       10.7269       117.794       128.521    
   4  0.844966     -0.168459      -3.02477       3.02477       119.994       123.019    
   5  0.139804      -1.96751      -35.3277       35.3277       120.806       156.133    
   6  0.119451      -2.12485      -38.1528       38.1528       121.881       160.034    
   7  0.474112     -0.746312      -13.4004       13.4004       121.000       134.401    
   8  0.293024      -1.22750      -22.0404       22.0404       119.547       141.588    
   9  0.760137     -0.274256      -4.92441       4.92441       119.932       124.857    
  10  0.216376      -1.53074      -27.4852       27.4852       118.163       145.648    
  11  0.837069     -0.177849      -3.19337       3.19337       124.136       127.329    
  12  0.969258     -0.312245E-01 -0.560653      0.560653       125.529       126.090    
  13  0.335918      -1.09089      -19.5875       19.5875       125.047       144.634    
  14  0.966643     -0.339265E-01 -0.609169      0.609169       119.707       120.316    
  15  0.723887     -0.323119      -5.80178       5.80178       119.097       124.898    
  16  0.459929E-01  -3.07927      -55.2899       55.2899       119.704       174.993    
  17  0.536724     -0.622271      -11.1732       11.1732       118.469       129.642    
  18  0.432574     -0.838001      -15.0468       15.0468       116.607       131.654    
  19  0.160308      -1.83066      -32.8704       32.8704       122.710       155.580    
  20  0.885158     -0.121989      -2.19038       2.19038       119.057       121.248    
  21  0.753783     -0.282650      -5.07514       5.07514       121.677       126.752    
  22  0.135562      -1.99832      -35.8810       35.8810       121.129       157.010    
  23  0.817964     -0.200937      -3.60793       3.60793       120.348       123.956    
  24  0.286617      -1.24961      -22.4374       22.4374       124.892       147.330    
  25  0.319126      -1.14217      -20.5083       20.5083       125.093       145.601    
  26  0.104479E-01  -4.56135      -81.9015       81.9015       125.771       207.672    
  27  0.671407     -0.398379      -7.15311       7.15311       122.117       129.270    
  28  0.782955     -0.244680      -4.39337       4.39337       119.396       123.789    
  29  0.186689      -1.67831      -30.1350       30.1350       127.913       158.048    
  30  0.462519     -0.771067      -13.8449       13.8449       121.529       135.374    
  31  0.203171      -1.59371      -28.6158       28.6158       118.681       147.297    
  32  0.851762E-01  -2.46303      -44.2251       44.2251       122.940       167.165    
  33  0.702824     -0.352649      -6.33199       6.33199       141.529       147.861    
  34  0.747923     -0.290456      -5.21529       5.21529       119.449       124.664    
  35  0.224450      -1.49410      -26.8274       26.8274       137.587       164.414    
  36  0.243563E-02  -6.01755      -108.048       108.048       119.277       227.326    
  37  0.160790      -1.82766      -32.8166       32.8166       136.909       169.726    
  38  0.880431     -0.127343      -2.28652       2.28652       117.527       119.813    
  39  0.507306     -0.678640      -12.1853       12.1853       129.721       141.906    
  40  0.266019      -1.32419      -23.7765       23.7765       120.104       143.881    
  41  0.310751      -1.16876      -20.9858       20.9858       134.834       155.820    
  42  0.945006     -0.565640E-01  -1.01564       1.01564       134.295       135.311    
  43  0.265699E-01  -3.62797      -65.1422       65.1422       145.311       210.453    
  44  0.652842     -0.426420      -7.65659       7.65659       117.452       125.108    
  45  0.799409     -0.223882      -4.01992       4.01992       139.770       143.790    
  46  0.543529     -0.609672      -10.9470       10.9470       120.640       131.587    
loop,thermsimp(1:2)       54   10.2206       6.43435    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    137        119.49         67.81          1.12         42.16          0.38          0.05        111.52
Just calling func    0   0        111.52


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    138        127.56         67.82          1.13         42.10          0.37          0.05        111.47
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    119.49
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    17.9555               136
loop is:       54
neval is:      137
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       54      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    17.9555               136
loop is:       55
neval is:      137


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 




neval>tstepnex so lower away!t
---> lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
     new SAtemp,tstepnext are :    8.97776               181

 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      137     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.194359      -1.63805      -14.7060       14.7060       110.504       125.210    
   2  0.875287     -0.133204      -1.19587       1.19587       117.527       118.723    
   3  0.103612      -2.26710      -20.3535       20.3535       119.707       140.060    
   4  0.159072      -1.83840      -16.5047       16.5047       119.057       135.562    
   5  0.118738      -2.13084      -19.1302       19.1302       119.994       139.124    
   6  0.294105      -1.22382      -10.9871       10.9871       119.396       130.383    
   7  0.967643     -0.328919E-01 -0.295296      0.295296       120.348       120.643    
   8  0.675183     -0.392772      -3.52622       3.52622       119.449       122.975    
   9  0.170112      -1.77130      -15.9023       15.9023       119.932       135.834    
  10  0.990992     -0.904902E-02 -0.812399E-01  0.812399E-01   119.097       119.178    
  11  0.198513      -1.61690      -14.5162       14.5162       117.452       131.968    
  12  0.404817E-01  -3.20690      -28.7908       28.7908       125.529       154.320    
  13  0.834933E-01  -2.48299      -22.2917       22.2917       121.677       143.969    
  14  0.458935     -0.778848      -6.99231       6.99231       124.136       131.128    
  15  0.929311     -0.733118E-01 -0.658176      0.658176       117.629       118.287    
  16  0.593071     -0.522440      -4.69035       4.69035       117.794       122.485    
  17  0.963359E-01  -2.33991      -21.0072       21.0072       122.117       143.124    
  18  0.383119E-01  -3.26200      -29.2854       29.2854       118.469       147.754    
  19  0.841843     -0.172161      -1.54562       1.54562       120.640       122.186    
  20  0.874261     -0.134376      -1.20640       1.20640       116.607       117.814    
  21  0.706443     -0.347513      -3.11989       3.11989       121.000       124.120    
  22  0.423649E-01  -3.16143      -28.3826       28.3826       134.295       162.678    
  23  0.904835     -0.100003     -0.897803      0.897803       121.529       122.427    
  24  0.728800     -0.316356      -2.84017       2.84017       119.547       122.387    
  25  0.764304     -0.268790      -2.41314       2.41314       129.721       132.134    
  26  0.578519     -0.547284      -4.91339       4.91339       139.770       144.683    
  27  0.321737      -1.13402      -10.1810       10.1810       120.104       130.285    
  28  0.592944     -0.522656      -4.69228       4.69228       125.047       129.739    
  29  0.159596      -1.83511      -16.4752       16.4752       125.093       141.568    
  30  0.797332     -0.226484      -2.03332       2.03332       118.163       120.196    
  31  0.263979      -1.33189      -11.9574       11.9574       118.681       130.639    
  32  0.449355     -0.799942      -7.18169       7.18169       124.892       132.074    
  33  0.859901     -0.150938      -1.35508       1.35508       141.529       142.884    
  34  0.730093     -0.314584      -2.82426       2.82426       122.710       125.534    
  35  0.484666     -0.724295      -6.50255       6.50255       134.834       141.337    
  36  0.180217      -1.71359      -15.3842       15.3842       120.806       136.190    
  37  0.857397     -0.153854      -1.38127       1.38127       121.129       122.510    
  38  0.502370     -0.688418      -6.18046       6.18046       127.913       134.094    
  39  0.245408      -1.40484      -12.6123       12.6123       121.881       134.493    
  40  0.134540      -2.00590      -18.0085       18.0085       137.587       155.595    
  41  0.468137     -0.758995      -6.81408       6.81408       122.940       129.754    
  42  0.864548E-01  -2.44813      -21.9788       21.9788       136.909       158.888    
  43  0.178791      -1.72154      -15.4556       15.4556       119.704       135.159    
  44  0.690351     -0.370555      -3.32675       3.32675       125.771       129.097    
  45  0.731648     -0.312455      -2.80515       2.80515       145.311       148.116    
  46  0.857623     -0.153591      -1.37890       1.37890       119.493       120.871    
loop,thermsimp(1:2)       55   14.7060       1.19587    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    139        135.76         67.83          1.15         42.02          0.43          0.05        111.48
Just calling func    0   0        111.48


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    135.76
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       55
neval is:      138
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       55      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       56
neval is:      138


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      138     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.141299      -1.95688      -17.5684       17.5684       116.607       134.176    
   2  0.197548      -1.62177      -14.5599       14.5599       117.629       132.189    
   3  0.774000     -0.256183      -2.29995       2.29995       117.527       119.827    
   4  0.170284      -1.77029      -15.8932       15.8932       119.097       134.990    
   5  0.250636      -1.38376      -12.4230       12.4230       118.163       130.586    
   6  0.907951     -0.965652E-01 -0.866939      0.866939       120.348       121.215    
   7  0.611678     -0.491549      -4.41301       4.41301       119.493       123.906    
   8  0.735945E-02  -4.91177      -44.0967       44.0967       120.640       164.737    
   9  0.309131      -1.17399      -10.5398       10.5398       119.547       130.087    
  10  0.577854     -0.548434      -4.92371       4.92371       121.529       126.453    
  11  0.931529     -0.709274E-01 -0.636770      0.636770       117.794       118.431    
  12  0.665703     -0.406912      -3.65316       3.65316       121.129       124.782    
  13  0.585695     -0.534955      -4.80270       4.80270       119.449       124.251    
  14  0.295001      -1.22078      -10.9598       10.9598       121.000       131.960    
  15  0.317712E-01  -3.44920      -30.9661       30.9661       110.504       141.470    
  16  0.222963      -1.50075      -13.4734       13.4734       122.710       136.183    
  17  0.325931      -1.12107      -10.0647       10.0647       125.771       135.835    
  18  0.785098     -0.241947      -2.17214       2.17214       125.047       127.219    
  19  0.550467     -0.596988      -5.35962       5.35962       122.940       128.300    
  20  0.780222     -0.248176      -2.22807       2.22807       120.104       122.332    
  21  0.130712      -2.03476      -18.2676       18.2676       119.396       137.664    
  22  0.873397     -0.135365      -1.21527       1.21527       118.681       119.897    
  23  0.366975      -1.00246      -8.99986       8.99986       124.136       133.136    
  24  0.813244     -0.206724      -1.85592       1.85592       117.452       119.307    
  25  0.782660E-01  -2.54764      -22.8721       22.8721       124.892       147.765    
  26  0.700327     -0.356208      -3.19795       3.19795       129.721       132.919    
  27  0.437766     -0.826071      -7.41627       7.41627       127.913       135.330    
  28  0.508966E-01  -2.97796      -26.7354       26.7354       121.881       148.616    
  29  0.276850      -1.28428      -11.5299       11.5299       119.704       131.233    
  30  0.792031     -0.233154      -2.09320       2.09320       119.057       121.150    
  31  0.174747      -1.74441      -15.6609       15.6609       119.932       135.593    
  32  0.469718     -0.755623      -6.78381       6.78381       120.806       127.590    
  33  0.252316      -1.37707      -12.3630       12.3630       119.994       132.357    
  34  0.980061     -0.201409E-01 -0.180820      0.180820       119.707       119.888    
  35  0.838300     -0.176379      -1.58349       1.58349       134.834       136.418    
  36  0.369385     -0.995915      -8.94109       8.94109       125.093       134.034    
  37  0.923139     -0.799751E-01 -0.717997      0.717997       141.529       142.247    
  38  0.592446     -0.523496      -4.69983       4.69983       122.117       126.817    
  39  0.348787      -1.05329      -9.45621       9.45621       121.677       131.133    
  40  0.569584     -0.562850      -5.05313       5.05313       139.770       144.823    
  41  0.543034E-01  -2.91317      -26.1537       26.1537       118.469       144.622    
  42  0.582662     -0.540148      -4.84932       4.84932       145.311       150.160    
  43  0.702825     -0.352648      -3.16599       3.16599       125.529       128.695    
  44  0.941375     -0.604140E-01 -0.542383      0.542383       137.587       138.129    
  45  0.258857      -1.35148      -12.1333       12.1333       136.909       149.043    
  46  0.116535      -2.14956      -19.2983       19.2983       135.764       155.062    
loop,thermsimp(1:2)       56   17.5684       14.5599    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    140        120.37         67.76          1.09         42.09          0.31          0.05        111.30
Just calling func    0   0        111.31


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    141        131.49         67.70          1.05         41.90          0.48          0.05        111.18
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  140    131.49        1.511     -1.906      3.207     -102.6      1.577    
                       1.961      1.604     -99.70      4.472     0.4456    

                       2.353     -1.375      1.540      6544.      7000.    

                     -0.7501E-01  0.000      0.000      0.000     -1.221    



                      -2.084      0.000      0.000      7000.      369.6    

                       1.402     -6.455     -6.101     -9.122      6.453    

                      -17.52     -7.637      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4550    -0.6230      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.6368     -1.258      7000.    



                      -1.148     -1.550     -2.313     -1.968    -0.3807    

                     -0.3252      9.207      8.726    -0.1800E+05 -6.196    

                      -1.266      6.087      9.181      8.779    -0.1969E+05



                      -6.000     0.2696    -0.4674      8.836      9.060    

                     -0.1944E+05 -6.000     -1.321    -0.6544      9.209    

                       8.748    -0.1891E+05 -6.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    120.37
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       56
neval is:      140
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       56      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       57
neval is:      140


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      140     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.662269     -0.412083      -3.69958       3.69958       117.794       121.494    
   2  0.724212     -0.322671      -2.89687       2.89687       117.452       120.348    
   3  0.633711     -0.456163      -4.09532       4.09532       117.527       121.622    
   4  0.448566     -0.801700      -7.19748       7.19748       119.707       126.904    
   5  0.964228     -0.364273E-01 -0.327036      0.327036       118.681       119.008    
   6  0.714306     -0.336444      -3.02052       3.02052       119.057       122.078    
   7  0.528330     -0.638035      -5.72812       5.72812       120.348       126.076    
   8  0.654127     -0.424453      -3.81064       3.81064       120.104       123.915    
   9  0.368899     -0.997232      -8.95291       8.95291       119.493       128.445    
  10  0.227697      -1.47974      -13.2848       13.2848       119.449       132.733    
  11  0.612266     -0.490588      -4.40438       4.40438       121.129       125.534    
  12  0.313777      -1.15907      -10.4059       10.4059       121.529       131.935    
  13  0.258526      -1.35276      -12.1448       12.1448       122.117       134.261    
  14  0.119298      -2.12613      -19.0879       19.0879       125.047       144.135    
  15  0.213331      -1.54491      -13.8698       13.8698       120.806       134.676    
  16  0.294218      -1.22343      -10.9837       10.9837       122.940       133.924    
  17  0.352988      -1.04132      -9.34874       9.34874       125.529       134.878    
  18  0.348706      -1.05353      -9.45831       9.45831       119.547       129.006    
  19  0.449249     -0.800179      -7.18382       7.18382       118.163       125.347    
  20  0.879121     -0.128833      -1.15663       1.15663       121.677       122.834    
  21  0.464081     -0.767695      -6.89219       6.89219       119.704       126.596    
  22  0.497582     -0.697995      -6.26644       6.26644       121.000       127.267    
  23  0.920207     -0.831566E-01 -0.746561      0.746561       117.629       118.376    
  24  0.811773     -0.208535      -1.87218       1.87218       119.994       121.866    
  25  0.190651      -1.65731      -14.8789       14.8789       129.721       144.600    
  26  0.645174     -0.438235      -3.93437       3.93437       124.136       128.070    
  27  0.668343     -0.402954      -3.61763       3.61763       125.093       128.711    
  28  0.765111     -0.267735      -2.40366       2.40366       116.607       119.011    
  29  0.991779     -0.825499E-02 -0.741114E-01  0.741114E-01   119.097       119.171    
  30  0.136888      -1.98859      -17.8531       17.8531       127.913       145.767    
  31  0.645145E-01  -2.74086      -24.6068       24.6068       119.932       144.539    
  32  0.408515E-01  -3.19781      -28.7092       28.7092       125.771       154.480    
  33  0.264109      -1.33140      -11.9530       11.9530       122.710       134.663    
  34  0.382737     -0.960407      -8.62230       8.62230       134.834       143.456    
  35  0.402738E-02  -5.51464      -49.5091       49.5091       119.396       168.905    
  36  0.318074      -1.14547      -10.2838       10.2838       137.587       147.870    
  37  0.245237      -1.40553      -12.6185       12.6185       110.504       123.123    
  38  0.519766     -0.654377      -5.87484       5.87484       141.529       147.404    
  39  0.255147      -1.36592      -12.2629       12.2629       118.469       130.731    
  40  0.833841     -0.181712      -1.63137       1.63137       139.770       141.401    
  41  0.696242E-01  -2.66464      -23.9225       23.9225       124.892       148.815    
  42  0.487295     -0.718886      -6.45399       6.45399       121.881       128.335    
  43  0.276229E-01  -3.58911      -32.2222       32.2222       136.909       169.132    
  44  0.638327     -0.448905      -4.03016       4.03016       145.311       149.341    
  45  0.206684      -1.57657      -14.1540       14.1540       135.764       149.918    
  46  0.736003     -0.306521      -2.75188       2.75188       120.373       123.125    
loop,thermsimp(1:2)       57   3.69958       2.89687    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    142        120.86         67.85          1.13         42.45          0.11          0.05        111.59
Just calling func    0   0        111.60


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    143        146.49         67.88          1.11         42.17          0.74          0.05        111.95
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    120.86
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       57
neval is:      142
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       57      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       58
neval is:      142


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      142     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.584865E-01  -2.83896      -25.4875       25.4875       117.629       143.117    
   2  0.104884      -2.25490      -20.2440       20.2440       118.681       138.925    
   3  0.784254     -0.243023      -2.18180       2.18180       116.607       118.789    
   4  0.813133     -0.206861      -1.85715       1.85715       119.097       120.954    
   5  0.490778     -0.711764      -6.39005       6.39005       117.452       123.842    
   6  0.168573      -1.78039      -15.9839       15.9839       117.794       133.778    
   7  0.450161     -0.798149      -7.16559       7.16559       117.527       124.692    
   8  0.828233     -0.188461      -1.69196       1.69196       119.994       121.686    
   9  0.994731     -0.528342E-02 -0.474333E-01  0.474333E-01   119.057       119.105    
  10  0.813340     -0.206606      -1.85486       1.85486       121.677       123.532    
  11  0.776133     -0.253432      -2.27525       2.27525       110.504       112.779    
  12  0.729556     -0.315319      -2.83086       2.83086       120.373       123.204    
  13  0.530451     -0.634028      -5.69215       5.69215       120.104       125.796    
  14  0.752564E-01  -2.58685      -23.2242       23.2242       118.163       141.387    
  15  0.918457     -0.850597E-01 -0.763646      0.763646       121.129       121.893    
  16  0.162642      -1.81621      -16.3055       16.3055       120.348       136.653    
  17  0.725851     -0.320411      -2.87657       2.87657       119.704       122.580    
  18  0.322292      -1.13230      -10.1655       10.1655       119.707       129.872    
  19  0.838064     -0.176661      -1.58602       1.58602       121.000       122.586    
  20  0.346062E-01  -3.36372      -30.1987       30.1987       124.136       154.334    
  21  0.442915     -0.814377      -7.31129       7.31129       121.881       129.192    
  22  0.143708      -1.93997      -17.4166       17.4166       119.493       136.909    
  23  0.940845     -0.609769E-01 -0.547437      0.547437       125.093       125.641    
  24  0.972503     -0.278816E-01 -0.250315      0.250315       119.547       119.798    
  25  0.291831      -1.23158      -11.0568       11.0568       118.469       129.525    
  26  0.211976      -1.55128      -13.9271       13.9271       121.529       135.456    
  27  0.695427     -0.363229      -3.26099       3.26099       119.449       122.710    
  28  0.982540E-01  -2.32020      -20.8302       20.8302       122.940       143.770    
  29  0.730742     -0.313695      -2.81628       2.81628       122.117       124.933    
  30  0.417794     -0.872766      -7.83549       7.83549       122.710       130.545    
  31  0.868385     -0.141121      -1.26695       1.26695       120.806       122.073    
  32  0.300897      -1.20099      -10.7822       10.7822       125.529       136.311    
  33  0.917219     -0.864093E-01 -0.775762      0.775762       139.770       140.545    
  34  0.304394      -1.18943      -10.6784       10.6784       134.834       145.513    
  35  0.856500     -0.154901      -1.39067       1.39067       125.047       126.438    
  36  0.310652      -1.16908      -10.4957       10.4957       119.932       130.428    
  37  0.846275     -0.166911      -1.49849       1.49849       129.721       131.219    
  38  0.206825      -1.57588      -14.1479       14.1479       127.913       142.061    
  39  0.606376     -0.500256      -4.49118       4.49118       141.529       146.020    
  40  0.840015     -0.174336      -1.56514       1.56514       137.587       139.152    
  41  0.348835      -1.05315      -9.45498       9.45498       124.892       134.347    
  42  0.857325     -0.153939      -1.38203       1.38203       145.311       146.693    
  43  0.308035E-01  -3.48013      -31.2438       31.2438       135.764       167.008    
  44  0.400632     -0.914711      -8.21206       8.21206       125.771       133.983    
  45  0.242237      -1.41784      -12.7290       12.7290       119.396       132.125    
  46  0.407771     -0.897050      -8.05351       8.05351       120.857       128.910    
loop,thermsimp(1:2)       58   25.4875       20.2440    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    144        135.70         67.76          1.09         42.20          0.83          0.05        111.91
Just calling func    0   0        111.92


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    135.70
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       58
neval is:      143
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       58      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       59
neval is:      143


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      143     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.330032      -1.10857      -9.95245       9.95245       110.504       120.457    
   2  0.939148     -0.627826E-01 -0.563648      0.563648       116.607       117.171    
   3  0.130906      -2.03328      -18.2543       18.2543       119.057       137.312    
   4  0.664370     -0.408916      -3.67115       3.67115       119.547       123.218    
   5  0.490908     -0.711498      -6.38767       6.38767       119.097       125.484    
   6  0.711731     -0.340055      -3.05293       3.05293       119.994       123.047    
   7  0.676080     -0.391444      -3.51429       3.51429       121.129       124.643    
   8  0.611139     -0.492432      -4.42093       4.42093       120.806       125.227    
   9  0.614246     -0.487359      -4.37540       4.37540       119.704       124.079    
  10  0.988045     -0.120275E-01 -0.107980      0.107980       121.000       121.108    
  11  0.232883      -1.45722      -13.0826       13.0826       119.449       132.531    
  12  0.450825     -0.796675      -7.15236       7.15236       120.373       127.525    
  13  0.493319     -0.706599      -6.34368       6.34368       121.677       128.021    
  14  0.191184      -1.65452      -14.8539       14.8539       117.452       132.305    
  15  0.894136     -0.111897      -1.00459       1.00459       117.527       118.531    
  16  0.391751     -0.937128      -8.41331       8.41331       122.117       130.530    
  17  0.236278      -1.44275      -12.9527       12.9527       125.093       138.046    
  18  0.496874E-01  -3.00200      -26.9513       26.9513       120.104       147.056    
  19  0.784524     -0.242678      -2.17871       2.17871       125.047       127.226    
  20  0.292328      -1.22988      -11.0416       11.0416       120.857       131.899    
  21  0.832247E-01  -2.48621      -22.3206       22.3206       121.881       144.201    
  22  0.423133     -0.860069      -7.72150       7.72150       118.469       126.190    
  23  0.234472      -1.45042      -13.0215       13.0215       119.707       132.728    
  24  0.868463     -0.141031      -1.26614       1.26614       119.932       121.198    
  25  0.122969      -2.09582      -18.8158       18.8158       122.710       141.525    
  26  0.811771     -0.208537      -1.87220       1.87220       129.721       131.593    
  27  0.786834     -0.239738      -2.15231       2.15231       119.396       121.548    
  28  0.163144      -1.81312      -16.2778       16.2778       117.794       134.072    
  29  0.571103     -0.560186      -5.02922       5.02922       125.771       130.800    
  30  0.769982     -0.261388      -2.34668       2.34668       124.892       127.239    
  31  0.471769     -0.751265      -6.74468       6.74468       121.529       128.274    
  32  0.584935     -0.536254      -4.81436       4.81436       125.529       130.344    
  33  0.416140     -0.876734      -7.87111       7.87111       120.348       128.219    
  34  0.106525E-01  -4.54196      -40.7767       40.7767       119.493       160.269    
  35  0.595424     -0.518482      -4.65481       4.65481       118.681       123.336    
  36  0.302400      -1.19600      -10.7374       10.7374       137.587       148.324    
  37  0.629701     -0.462510      -4.15230       4.15230       139.770       143.922    
  38  0.939026E-01  -2.36550      -21.2369       21.2369       118.163       139.400    
  39  0.911727     -0.924151E-01 -0.829681      0.829681       127.913       128.743    
  40  0.289502      -1.23959      -11.1288       11.1288       117.629       128.758    
  41  0.326571      -1.11911      -10.0471       10.0471       122.940       132.987    
  42  0.972366     -0.280231E-01 -0.251584      0.251584       134.834       135.086    
  43  0.823413     -0.194297      -1.74435       1.74435       141.529       143.274    
  44  0.790717     -0.234815      -2.10811       2.10811       145.311       147.419    
  45  0.167922      -1.78426      -16.0186       16.0186       124.136       140.154    
  46  0.804665     -0.217329      -1.95113       1.95113       135.699       137.651    
loop,thermsimp(1:2)       59   9.95245      0.563648    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    145        118.01         67.84          1.11         42.26          0.29          0.05        111.54
Just calling func    0   0        111.54


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    146        126.66         67.76          1.10         42.17          0.38          0.05        111.46
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    118.01
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       59
neval is:      145
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       59      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       60
neval is:      145


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      145     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.304136      -1.19028      -10.6861       10.6861       116.607       127.293    
   2  0.843344     -0.170380      -1.52963       1.52963       117.527       119.056    
   3  0.457815     -0.781289      -7.01423       7.01423       110.504       117.518    
   4  0.933709     -0.685899E-01 -0.615784      0.615784       121.000       121.616    
   5  0.887159     -0.119731      -1.07491       1.07491       119.932       121.007    
   6  0.786211     -0.240530      -2.15942       2.15942       119.396       121.555    
   7  0.794803     -0.229661      -2.06184       2.06184       119.994       122.056    
   8  0.573435E-01  -2.85870      -25.6647       25.6647       119.547       145.212    
   9  0.647106     -0.435245      -3.90752       3.90752       118.681       122.589    
  10  0.110118      -2.20620      -19.8068       19.8068       119.704       139.510    
  11  0.339548      -1.08014      -9.69724       9.69724       121.129       130.826    
  12  0.635246     -0.453742      -4.07359       4.07359       120.806       124.879    
  13  0.488392     -0.716638      -6.43381       6.43381       119.097       125.531    
  14  0.602571     -0.506549      -4.54768       4.54768       118.469       123.016    
  15  0.710041     -0.342433      -3.07429       3.07429       125.047       128.121    
  16  0.585763     -0.534840      -4.80167       4.80167       124.892       129.694    
  17  0.288010      -1.24476      -11.1752       11.1752       120.373       131.548    
  18  0.455238     -0.786934      -7.06491       7.06491       121.677       128.742    
  19  0.723984     -0.322986      -2.89969       2.89969       120.348       123.248    
  20  0.554067     -0.590470      -5.30110       5.30110       121.529       126.830    
  21  0.646516     -0.436157      -3.91571       3.91571       127.913       131.829    
  22  0.271985      -1.30201      -11.6891       11.6891       117.629       129.318    
  23  0.901636E-02  -4.70871      -42.2737       42.2737       125.529       167.803    
  24  0.383616     -0.958114      -8.60172       8.60172       122.117       130.718    
  25  0.443516     -0.813022      -7.29912       7.29912       125.771       133.070    
  26  0.223023      -1.50048      -13.4710       13.4710       129.721       143.192    
  27  0.123255      -2.09350      -18.7949       18.7949       120.857       139.652    
  28  0.817485     -0.201523      -1.80923       1.80923       117.452       119.261    
  29  0.333893      -1.09693      -9.84801       9.84801       119.449       129.297    
  30  0.867877     -0.141706      -1.27220       1.27220       119.707       120.979    
  31  0.365747      -1.00581      -9.02996       9.02996       122.940       131.970    
  32  0.429445     -0.845262      -7.58856       7.58856       117.794       125.383    
  33  0.856620     -0.154761      -1.38941       1.38941       134.834       136.223    
  34  0.729532     -0.315352      -2.83116       2.83116       119.057       121.888    
  35  0.315845      -1.15251      -10.3469       10.3469       135.699       146.046    
  36  0.547596     -0.602217      -5.40656       5.40656       125.093       130.500    
  37  0.752130     -0.284846      -2.55728       2.55728       118.163       120.720    
  38  0.806451     -0.215112      -1.93123       1.93123       124.136       126.067    
  39  0.618613     -0.480275      -4.31180       4.31180       122.710       127.021    
  40  0.630350     -0.461480      -4.14306       4.14306       141.529       145.672    
  41  0.251741      -1.37935      -12.3835       12.3835       139.770       152.153    
  42  0.846504     -0.166640      -1.49605       1.49605       121.881       123.377    
  43  0.830791     -0.185377      -1.66427       1.66427       120.104       121.769    
  44  0.566838     -0.567681      -5.09651       5.09651       145.311       150.408    
  45  0.499450E-01  -2.99683      -26.9049       26.9049       137.587       164.492    
  46  0.976301     -0.239838E-01 -0.215321      0.215321       118.007       118.222    
loop,thermsimp(1:2)       60   10.6861       1.52963    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    147        117.53         67.80          1.13         42.04          0.65          0.05        111.67
Just calling func    0   0        111.67


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    148        133.68         67.91          1.18         42.01          0.52          0.05        111.66
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    117.53
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       60
neval is:      147
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       60      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       61
neval is:      147


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      147     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.829682     -0.186713      -1.67626       1.67626       110.504       112.180    
   2  0.735850     -0.306729      -2.75374       2.75374       118.007       120.761    
   3  0.828786     -0.187793      -1.68596       1.68596       117.527       119.213    
   4  0.592078     -0.524118      -4.70541       4.70541       117.452       122.157    
   5  0.691797E-01  -2.67105      -23.9800       23.9800       118.163       142.143    
   6  0.772335     -0.258337      -2.31929       2.31929       119.707       122.026    
   7  0.504563     -0.684063      -6.14136       6.14136       119.932       126.073    
   8  0.700615     -0.355797      -3.19426       3.19426       119.396       122.590    
   9  0.764596     -0.268408      -2.40970       2.40970       121.000       123.410    
  10  0.459614     -0.777368      -6.97903       6.97903       120.104       127.083    
  11  0.931193     -0.712882E-01 -0.640009      0.640009       119.057       119.697    
  12  0.502482E-01  -2.99078      -26.8505       26.8505       119.994       146.844    
  13  0.498197     -0.696760      -6.25534       6.25534       118.681       124.937    
  14  0.551534E-01  -2.89764      -26.0143       26.0143       118.469       144.483    
  15  0.172209      -1.75905      -15.7923       15.7923       120.348       136.140    
  16  0.238868E-01  -3.73443      -33.5268       33.5268       121.881       155.408    
  17  0.699366     -0.357581      -3.21028       3.21028       120.806       124.016    
  18  0.764093     -0.269066      -2.41561       2.41561       117.794       120.210    
  19  0.465633     -0.764357      -6.86222       6.86222       119.097       125.959    
  20  0.209906      -1.56110      -14.0152       14.0152       124.136       138.151    
  21  0.216891      -1.52836      -13.7213       13.7213       121.529       135.251    
  22  0.795854E-01  -2.53092      -22.7220       22.7220       122.710       145.432    
  23  0.701683     -0.354273      -3.18058       3.18058       116.607       119.788    
  24  0.574425     -0.554385      -4.97714       4.97714       125.047       130.024    
  25  0.674968     -0.393090      -3.52907       3.52907       121.677       125.206    
  26  0.684189     -0.379521      -3.40725       3.40725       119.449       122.856    
  27  0.541862     -0.612745      -5.50108       5.50108       117.629       123.130    
  28  0.668027     -0.403426      -3.62186       3.62186       124.892       128.514    
  29  0.353251      -1.04058      -9.34205       9.34205       125.093       134.435    
  30  0.778708     -0.250119      -2.24551       2.24551       122.117       124.362    
  31  0.829283     -0.187194      -1.68058       1.68058       121.129       122.810    
  32  0.679297     -0.386697      -3.47167       3.47167       120.373       123.844    
  33  0.536301     -0.623060      -5.59368       5.59368       127.913       133.507    
  34  0.247738      -1.39538      -12.5274       12.5274       122.940       135.467    
  35  0.271399      -1.30416      -11.7085       11.7085       125.771       137.479    
  36  0.284124      -1.25835      -11.2971       11.2971       134.834       146.131    
  37  0.664442     -0.408808      -3.67018       3.67018       119.704       123.374    
  38  0.874508     -0.134094      -1.20386       1.20386       120.857       122.061    
  39  0.916444     -0.872538E-01 -0.783345      0.783345       129.721       130.504    
  40  0.295165      -1.22022      -10.9549       10.9549       119.547       130.502    
  41  0.242592      -1.41637      -12.7159       12.7159       141.529       154.245    
  42  0.396124     -0.926028      -8.31367       8.31367       135.699       144.013    
  43  0.509193E-01  -2.97751      -26.7314       26.7314       145.311       172.043    
  44  0.778911     -0.249858      -2.24317       2.24317       139.770       142.013    
  45  0.351009      -1.04694      -9.39921       9.39921       137.587       146.986    
  46  0.480934     -0.732025      -6.57195       6.57195       117.526       124.098    
loop,thermsimp(1:2)       61   1.67626       2.75374    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    149        138.75         67.77          1.08         41.91          0.57          0.05        111.38
Just calling func    0   0        111.37


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    138.75
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       61
neval is:      148
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       61      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       62
neval is:      148


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      148     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.917395     -0.862167E-01 -0.774033      0.774033       110.504       111.278    
   2  0.899579E-01  -2.40841      -21.6222       21.6222       117.527       139.149    
   3  0.997625     -0.237830E-02 -0.213518E-01  0.213518E-01   119.057       119.079    
   4  0.224083      -1.49574      -13.4284       13.4284       116.607       130.036    
   5  0.120769      -2.11388      -18.9779       18.9779       117.794       136.772    
   6  0.302676E-01  -3.49768      -31.4013       31.4013       118.007       149.408    
   7  0.315161      -1.15467      -10.3664       10.3664       119.707       130.073    
   8  0.155895      -1.85857      -16.6858       16.6858       120.857       137.543    
   9  0.467639     -0.760060      -6.82364       6.82364       117.452       124.275    
  10  0.277823      -1.28077      -11.4984       11.4984       119.396       130.894    
  11  0.712282     -0.339281      -3.04598       3.04598       121.129       124.175    
  12  0.929560     -0.730437E-01 -0.655769      0.655769       119.449       120.104    
  13  0.499024     -0.695101      -6.24045       6.24045       117.629       123.870    
  14  0.940347     -0.615066E-01 -0.552192      0.552192       119.704       120.256    
  15  0.714006     -0.336864      -3.02428       3.02428       121.000       124.025    
  16  0.162603      -1.81644      -16.3076       16.3076       120.373       136.680    
  17  0.663729     -0.409881      -3.67981       3.67981       120.806       124.486    
  18  0.314148      -1.15789      -10.3953       10.3953       117.526       127.921    
  19  0.497386     -0.698388      -6.26997       6.26997       122.117       128.387    
  20  0.368387     -0.998622      -8.96540       8.96540       118.681       127.647    
  21  0.326342      -1.11981      -10.0534       10.0534       121.677       131.731    
  22  0.442952     -0.814294      -7.31054       7.31054       119.097       126.407    
  23  0.929694     -0.729000E-01 -0.654479      0.654479       119.932       120.587    
  24  0.945450E-01  -2.35868      -21.1757       21.1757       120.104       141.280    
  25  0.407158     -0.898555      -8.06701       8.06701       124.892       132.959    
  26  0.706679     -0.347179      -3.11689       3.11689       125.047       128.164    
  27  0.657848     -0.418781      -3.75972       3.75972       119.547       123.307    
  28  0.968040     -0.324817E-01 -0.291613      0.291613       129.721       130.012    
  29  0.330387      -1.10749      -9.94278       9.94278       127.913       137.856    
  30  0.756161     -0.279501      -2.50930       2.50930       125.093       127.602    
  31  0.307772      -1.17840      -10.5794       10.5794       121.529       132.109    
  32  0.759008E-01  -2.57833      -23.1476       23.1476       122.940       146.088    
  33  0.615618E-01  -2.78771      -25.0274       25.0274       120.348       145.375    
  34  0.545984     -0.605166      -5.43304       5.43304       125.771       131.204    
  35  0.339865      -1.07921      -9.68886       9.68886       124.136       133.825    
  36  0.816477     -0.202757      -1.82031       1.82031       139.770       141.590    
  37  0.932889     -0.694691E-01 -0.623677      0.623677       118.163       118.787    
  38  0.667042     -0.404902      -3.63512       3.63512       135.699       139.335    
  39  0.583049     -0.539484      -4.84336       4.84336       118.469       123.312    
  40  0.210192      -1.55973      -14.0029       14.0029       122.710       136.713    
  41  0.158846      -1.83982      -16.5175       16.5175       134.834       151.352    
  42  0.360401      -1.02054      -9.16214       9.16214       119.994       129.156    
  43  0.508154     -0.676971      -6.07769       6.07769       137.587       143.664    
  44  0.873303     -0.135473      -1.21624       1.21624       141.529       142.745    
  45  0.650524     -0.429977      -3.86024       3.86024       121.881       125.741    
  46  0.805601     -0.216166      -1.94069       1.94069       138.752       140.693    
loop,thermsimp(1:2)       62  0.774033       21.6222    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    150        138.04         67.75          1.11         42.02          0.58          0.05        111.50
Just calling func    0   0        111.50


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    138.04
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       62
neval is:      149
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       62      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       63
neval is:      149


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      149     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.617195     -0.482570      -4.33240       4.33240       110.504       114.837    
   2  0.828850     -0.187716      -1.68527       1.68527       118.163       119.848    
   3  0.138898      -1.97402      -17.7223       17.7223       119.057       136.779    
   4  0.174947      -1.74327      -15.6507       15.6507       119.449       135.099    
   5  0.452367E-01  -3.09585      -27.7938       27.7938       119.704       147.497    
   6  0.982229     -0.179305E-01 -0.160976      0.160976       119.932       120.093    
   7  0.855728     -0.155803      -1.39876       1.39876       119.547       120.946    
   8  0.350750      -1.04768      -9.40584       9.40584       118.469       127.874    
   9  0.880054     -0.127772      -1.14711       1.14711       117.629       118.776    
  10  0.106511      -2.23950      -20.1057       20.1057       121.000       141.106    
  11  0.336060      -1.09047      -9.78995       9.78995       121.129       130.919    
  12  0.904819     -0.100020     -0.897958      0.897958       117.452       118.350    
  13  0.765597     -0.267099      -2.39795       2.39795       120.806       123.204    
  14  0.551789     -0.594589      -5.33808       5.33808       121.881       127.219    
  15  0.832435     -0.183400      -1.64652       1.64652       119.097       120.743    
  16  0.353494      -1.03989      -9.33589       9.33589       125.093       134.429    
  17  0.510104     -0.673140      -6.04330       6.04330       118.681       124.725    
  18  0.523162     -0.647863      -5.81636       5.81636       117.526       123.342    
  19  0.953043     -0.480957E-01 -0.431792      0.431792       125.047       125.479    
  20  0.267001E-01  -3.62309      -32.5272       32.5272       122.117       154.644    
  21  0.280924      -1.26967      -11.3988       11.3988       119.994       131.393    
  22  0.956868     -0.440901E-01 -0.395831      0.395831       129.721       130.117    
  23  0.779725     -0.248814      -2.23379       2.23379       116.607       118.841    
  24  0.901061     -0.104183     -0.935329      0.935329       119.707       120.642    
  25  0.533391     -0.628501      -5.64254       5.64254       119.396       125.039    
  26  0.642536     -0.442333      -3.97116       3.97116       125.771       129.742    
  27  0.520565E-01  -2.95543      -26.5331       26.5331       121.677       148.210    
  28  0.330080      -1.10842      -9.95114       9.95114       121.529       131.481    
  29  0.280801      -1.27011      -11.4027       11.4027       124.892       136.295    
  30  0.144013      -1.93785      -17.3976       17.3976       124.136       141.533    
  31  0.201537      -1.60178      -14.3804       14.3804       120.373       134.753    
  32  0.920188     -0.831777E-01 -0.746750      0.746750       122.710       123.456    
  33  0.747222     -0.291393      -2.61606       2.61606       117.794       120.411    
  34  0.697959     -0.359595      -3.22836       3.22836       120.857       124.085    
  35  0.492949     -0.707349      -6.35041       6.35041       127.913       134.264    
  36  0.378001     -0.972857      -8.73408       8.73408       117.527       126.261    
  37  0.936484     -0.656225E-01 -0.589143      0.589143       135.699       136.289    
  38  0.458232     -0.780381      -7.00607       7.00607       138.752       145.758    
  39  0.286796      -1.24898      -11.2131       11.2131       120.104       131.317    
  40  0.524458     -0.645389      -5.79415       5.79415       139.770       145.564    
  41  0.126679      -2.06610      -18.5489       18.5489       141.529       160.078    
  42  0.645270     -0.438086      -3.93303       3.93303       137.587       141.520    
  43  0.996049     -0.395919E-02 -0.355447E-01  0.355447E-01   120.348       120.383    
  44  0.470695     -0.753545      -6.76515       6.76515       122.940       129.705    
  45  0.783048     -0.244561      -2.19561       2.19561       118.007       120.202    
  46  0.682425     -0.382103      -3.43043       3.43043       138.039       141.469    
loop,thermsimp(1:2)       63   4.33240       1.68527    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    151        117.82         67.87          1.14         42.05          0.58          0.05        111.70
Just calling func    0   0        111.69


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    117.82
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       63
neval is:      150
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       63      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       64
neval is:      150


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      150     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.816548     -0.202670      -1.81952       1.81952       110.504       112.324    
   2  0.209930      -1.56098      -14.0141       14.0141       117.452       131.466    
   3  0.710991     -0.341096      -3.06228       3.06228       117.629       120.692    
   4  0.967365     -0.331789E-01 -0.297872      0.297872       116.607       116.905    
   5  0.650635E-01  -2.73239      -24.5308       24.5308       118.163       142.694    
   6  0.578340     -0.547593      -4.91616       4.91616       119.932       124.848    
   7  0.928890E-01  -2.37635      -21.3343       21.3343       118.007       139.341    
   8  0.486974     -0.719546      -6.45991       6.45991       120.348       126.808    
   9  0.560625     -0.578703      -5.19546       5.19546       117.794       122.990    
  10  0.552834     -0.592698      -5.32110       5.32110       119.707       125.028    
  11  0.744529E-01  -2.59759      -23.3205       23.3205       119.097       142.417    
  12  0.937600     -0.644318E-01 -0.578454      0.578454       119.547       120.126    
  13  0.154459      -1.86783      -16.7689       16.7689       120.806       137.575    
  14  0.186893E-02  -6.28239      -56.4018       56.4018       117.526       173.928    
  15  0.250797      -1.38311      -12.4173       12.4173       122.710       135.127    
  16  0.924847E-01  -2.38071      -21.3735       21.3735       120.857       142.230    
  17  0.476680     -0.740911      -6.65172       6.65172       118.681       125.333    
  18  0.266527      -1.32228      -11.8711       11.8711       119.396       131.267    
  19  0.369755     -0.994916      -8.93212       8.93212       125.047       133.979    
  20  0.595561     -0.518252      -4.65274       4.65274       117.527       122.180    
  21  0.636070     -0.452447      -4.06197       4.06197       121.881       125.943    
  22  0.447294     -0.804540      -7.22297       7.22297       118.469       125.691    
  23  0.964945     -0.356839E-01 -0.320361      0.320361       122.940       123.260    
  24  0.752421     -0.284460      -2.55381       2.55381       125.771       128.325    
  25  0.705556     -0.348769      -3.13117       3.13117       129.721       132.852    
  26  0.943467     -0.581939E-01 -0.522451      0.522451       121.129       121.652    
  27  0.272564      -1.29988      -11.6700       11.6700       120.104       131.774    
  28  0.215815      -1.53333      -13.7659       13.7659       119.994       133.760    
  29  0.756955     -0.278452      -2.49988       2.49988       121.529       124.029    
  30  0.538381     -0.619189      -5.55893       5.55893       127.913       133.472    
  31  0.182967      -1.69845      -15.2483       15.2483       125.093       140.341    
  32  0.644758     -0.438881      -3.94017       3.94017       120.373       124.313    
  33  0.939477     -0.624320E-01 -0.560500      0.560500       119.449       120.009    
  34  0.663186     -0.410699      -3.68716       3.68716       135.699       139.387    
  35  0.795014     -0.229396      -2.05946       2.05946       124.892       126.952    
  36  0.630792     -0.460779      -4.13677       4.13677       119.057       123.194    
  37  0.151039      -1.89022      -16.9699       16.9699       121.000       137.970    
  38  0.668306     -0.403009      -3.61812       3.61812       138.039       141.657    
  39  0.683820     -0.380061      -3.41210       3.41210       137.587       140.999    
  40  0.122229      -2.10186      -18.8700       18.8700       124.136       143.006    
  41  0.664453     -0.408791      -3.67003       3.67003       139.770       143.440    
  42  0.548687     -0.600228      -5.38870       5.38870       138.752       144.141    
  43  0.931535     -0.709210E-01 -0.636712      0.636712       119.704       120.340    
  44  0.139742      -1.96796      -17.6679       17.6679       121.677       139.345    
  45  0.429142     -0.845967      -7.59489       7.59489       122.117       129.712    
  46  0.531147     -0.632717      -5.68038       5.68038       117.825       123.505    
loop,thermsimp(1:2)       64   1.81952       14.0141    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    152        122.00         67.79          1.12         42.01          0.66          0.05        111.63
Just calling func    0   0        111.63


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    153        140.15         67.75          1.09         42.16          0.30          0.05        111.35
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    122.00
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       64
neval is:      152
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       64      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       65
neval is:      152


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      152     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.367522      -1.00097      -8.98649       8.98649       110.504       119.491    
   2  0.298218      -1.20993      -10.8625       10.8625       116.607       127.470    
   3  0.374092     -0.983254      -8.82742       8.82742       119.449       128.276    
   4  0.417366     -0.873791      -7.84469       7.84469       119.547       127.392    
   5  0.299382      -1.20604      -10.8275       10.8275       119.704       130.531    
   6  0.373029     -0.986099      -8.85297       8.85297       117.629       126.482    
   7  0.628224     -0.464858      -4.17339       4.17339       121.129       125.303    
   8  0.111397      -2.19465      -19.7031       19.7031       117.527       137.230    
   9  0.983555     -0.165818E-01 -0.148867      0.148867       117.794       117.943    
  10  0.394578     -0.929938      -8.34876       8.34876       119.057       127.406    
  11  0.410639     -0.890042      -7.99059       7.99059       122.940       130.931    
  12  0.700680     -0.355705      -3.19343       3.19343       117.825       121.018    
  13  0.223946      -1.49635      -13.4339       13.4339       121.529       134.963    
  14  0.651113E-01  -2.73166      -24.5242       24.5242       120.373       144.897    
  15  0.704010     -0.350963      -3.15086       3.15086       119.932       123.083    
  16  0.172411      -1.75787      -15.7818       15.7818       119.707       135.489    
  17  0.567412     -0.566670      -5.08743       5.08743       118.681       123.769    
  18  0.186334      -1.68021      -15.0846       15.0846       118.469       133.553    
  19  0.677524     -0.389310      -3.49514       3.49514       121.881       125.376    
  20  0.362270      -1.01537      -9.11571       9.11571       120.348       129.464    
  21  0.603880     -0.504381      -4.52821       4.52821       124.892       129.421    
  22  0.782208     -0.245635      -2.20525       2.20525       125.771       127.976    
  23  0.129808      -2.04170      -18.3299       18.3299       122.117       140.447    
  24  0.284816      -1.25591      -11.2753       11.2753       119.396       130.671    
  25  0.246930      -1.39865      -12.5568       12.5568       117.452       130.008    
  26  0.256917      -1.35900      -12.2008       12.2008       120.104       132.305    
  27  0.240545      -1.42485      -12.7920       12.7920       129.721       142.513    
  28  0.218018      -1.52318      -13.6747       13.6747       127.913       141.588    
  29  0.235583E-01  -3.74828      -33.6512       33.6512       119.994       153.645    
  30  0.114660      -2.16578      -19.4439       19.4439       125.047       144.491    
  31  0.119129      -2.12755      -19.1007       19.1007       122.710       141.810    
  32  0.471707     -0.751398      -6.74587       6.74587       120.806       127.552    
  33  0.607413     -0.498546      -4.47582       4.47582       121.000       125.476    
  34  0.568731     -0.564347      -5.06657       5.06657       118.007       123.073    
  35  0.587492     -0.531893      -4.77521       4.77521       121.677       126.452    
  36  0.411259     -0.888533      -7.97704       7.97704       135.699       143.676    
  37  0.836192     -0.178897      -1.60609       1.60609       125.093       126.699    
  38  0.152977      -1.87747      -16.8555       16.8555       137.587       154.442    
  39  0.941831     -0.599291E-01 -0.538029      0.538029       138.039       138.577    
  40  0.936595     -0.655045E-01 -0.588084      0.588084       120.857       121.445    
  41  0.856621     -0.154759      -1.38939       1.38939       119.097       120.486    
  42  0.484786     -0.724047      -6.50032       6.50032       118.163       124.663    
  43  0.188261      -1.66993      -14.9922       14.9922       124.136       139.128    
  44  0.957606     -0.433189E-01 -0.388907      0.388907       139.770       140.158    
  45  0.234891      -1.44863      -13.0055       13.0055       138.752       151.758    
  46  0.758920     -0.275858      -2.47659       2.47659       122.001       124.478    
loop,thermsimp(1:2)       65   8.98649       10.8625    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    154        139.60         67.68          1.12         42.20          0.33          0.05        111.38
Just calling func    0   0        111.38


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    139.60
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       65
neval is:      153
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       65      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       66
neval is:      153


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      153     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.255462      -1.36468      -12.2518       12.2518       117.794       130.046    
   2  0.513427E-01  -2.96923      -26.6571       26.6571       110.504       137.161    
   3  0.288453      -1.24322      -11.1614       11.1614       119.097       130.258    
   4  0.107044      -2.23452      -20.0610       20.0610       117.825       137.886    
   5  0.756779     -0.278684      -2.50196       2.50196       120.857       123.359    
   6  0.333762      -1.09733      -9.85155       9.85155       118.007       127.858    
   7  0.270335      -1.30809      -11.7438       11.7438       119.932       131.676    
   8  0.666278E-01  -2.70863      -24.3175       24.3175       118.681       142.999    
   9  0.517510     -0.658727      -5.91389       5.91389       122.001       127.915    
  10  0.719680     -0.328949      -2.95322       2.95322       118.163       121.116    
  11  0.401542     -0.912442      -8.19169       8.19169       121.129       129.321    
  12  0.408125     -0.896181      -8.04570       8.04570       121.881       129.926    
  13  0.481086     -0.731710      -6.56912       6.56912       121.000       127.569    
  14  0.166952E-01  -4.09263      -36.7427       36.7427       121.677       158.420    
  15  0.913266     -0.907286E-01 -0.814540      0.814540       117.629       118.444    
  16  0.972084     -0.283134E-01 -0.254191      0.254191       125.093       125.347    
  17  0.889421     -0.117184      -1.05205       1.05205       119.547       120.599    
  18  0.171754      -1.76169      -15.8161       15.8161       119.057       134.873    
  19  0.925876     -0.770155E-01 -0.691427      0.691427       116.607       117.299    
  20  0.992897     -0.712866E-02 -0.639994E-01  0.639994E-01   120.806       120.870    
  21  0.118575E-01  -4.43479      -39.8145       39.8145       125.771       165.585    
  22  0.492413     -0.708438      -6.36019       6.36019       119.449       125.809    
  23  0.952433     -0.487360E-01 -0.437540      0.437540       124.892       125.330    
  24  0.591826     -0.524543      -4.70922       4.70922       120.348       125.057    
  25  0.762199     -0.271548      -2.43789       2.43789       117.452       119.889    
  26  0.613492     -0.488588      -4.38643       4.38643       119.704       124.090    
  27  0.134863      -2.00350      -17.9869       17.9869       119.396       137.383    
  28  0.633670     -0.456227      -4.09589       4.09589       122.940       127.036    
  29  0.829625     -0.186782      -1.67688       1.67688       120.104       121.781    
  30  0.148219      -1.90906      -17.1391       17.1391       118.469       135.608    
  31  0.198093      -1.61902      -14.5352       14.5352       121.529       136.065    
  32  0.321318      -1.13532      -10.1927       10.1927       119.707       129.900    
  33  0.475408     -0.743582      -6.67570       6.67570       117.527       124.203    
  34  0.196520      -1.62699      -14.6067       14.6067       138.039       152.646    
  35  0.637413     -0.450337      -4.04302       4.04302       124.136       128.179    
  36  0.596751     -0.516255      -4.63482       4.63482       139.770       144.404    
  37  0.351361      -1.04594      -9.39022       9.39022       122.117       131.507    
  38  0.111764      -2.19136      -19.6735       19.6735       127.913       147.587    
  39  0.213579      -1.54375      -13.8594       13.8594       122.710       136.569    
  40  0.799647     -0.223585      -2.00730       2.00730       129.721       131.728    
  41  0.670682     -0.399460      -3.58626       3.58626       135.699       139.286    
  42  0.104235      -2.26111      -20.2997       20.2997       125.047       145.347    
  43  0.607160E-01  -2.80155      -25.1516       25.1516       120.373       145.524    
  44  0.462312     -0.771516      -6.92649       6.92649       138.752       145.679    
  45  0.269658      -1.31060      -11.7663       11.7663       119.994       131.760    
  46  0.678606     -0.387714      -3.48081       3.48081       139.601       143.082    
loop,thermsimp(1:2)       66   12.2518       26.6571    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    155        110.85         67.82          1.09         41.99          0.52          0.05        111.47
Just calling func    0   0        111.47


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    156        118.69         67.91          1.05         41.98          0.49          0.05        111.48
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    110.85
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       66
neval is:      155
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       66      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       67
neval is:      155


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      155     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.297913      -1.21095      -10.8717       10.8717       116.607       127.479    
   2  0.840396     -0.173882      -1.56107       1.56107       117.629       119.190    
   3  0.165782      -1.79708      -16.1338       16.1338       117.452       133.585    
   4  0.516202E-01  -2.96384      -26.6087       26.6087       119.547       146.156    
   5  0.163201      -1.81278      -16.2747       16.2747       120.806       137.080    
   6  0.201529      -1.60182      -14.3808       14.3808       118.163       132.544    
   7  0.791805     -0.233441      -2.09577       2.09577       120.104       122.200    
   8  0.306466      -1.18265      -10.6175       10.6175       120.857       131.474    
   9  0.625963     -0.468465      -4.20577       4.20577       119.704       123.909    
  10  0.255827      -1.36325      -12.2390       12.2390       117.527       129.766    
  11  0.275269      -1.29001      -11.5814       11.5814       120.348       131.929    
  12  0.546374     -0.604451      -5.42662       5.42662       124.892       130.319    
  13  0.738275E-01  -2.60602      -23.3963       23.3963       125.093       148.489    
  14  0.459460     -0.777704      -6.98205       6.98205       119.449       126.431    
  15  0.245891      -1.40287      -12.5946       12.5946       122.940       135.535    
  16  0.818144E-01  -2.50330      -22.4741       22.4741       121.000       143.474    
  17  0.791963     -0.233241      -2.09398       2.09398       118.007       120.101    
  18  0.652560     -0.426852      -3.83218       3.83218       122.001       125.834    
  19  0.743237     -0.296740      -2.66406       2.66406       124.136       126.800    
  20  0.146095      -1.92350      -17.2687       17.2687       121.129       138.398    
  21  0.747148     -0.291492      -2.61695       2.61695       119.707       122.324    
  22  0.935024E-01  -2.36977      -21.2752       21.2752       121.881       143.156    
  23  0.924202     -0.788243E-01 -0.707666      0.707666       117.794       118.502    
  24  0.193934      -1.64024      -14.7257       14.7257       119.097       133.822    
  25  0.112499      -2.18481      -19.6147       19.6147       122.117       141.731    
  26  0.609079     -0.495807      -4.45124       4.45124       119.932       124.383    
  27  0.387822     -0.947210      -8.50383       8.50383       129.721       138.225    
  28  0.151976      -1.88403      -16.9144       16.9144       119.994       136.908    
  29  0.820125     -0.198299      -1.78028       1.78028       119.057       120.837    
  30  0.100865      -2.29397      -20.5947       20.5947       118.469       139.063    
  31  0.246930      -1.39865      -12.5568       12.5568       121.529       134.086    
  32  0.101973      -2.28305      -20.4966       20.4966       122.710       143.206    
  33  0.389401     -0.943145      -8.46734       8.46734       110.504       118.971    
  34  0.573635     -0.555762      -4.98950       4.98950       119.396       124.386    
  35  0.730896E-01  -2.61607      -23.4865       23.4865       117.825       141.311    
  36  0.260104      -1.34667      -12.0901       12.0901       135.699       147.790    
  37  0.562102     -0.576073      -5.17185       5.17185       118.681       123.853    
  38  0.159056      -1.83850      -16.5056       16.5056       139.601       156.107    
  39  0.779134E-02  -4.85474      -43.5847       43.5847       139.770       183.354    
  40  0.693208     -0.366425      -3.28968       3.28968       125.047       128.337    
  41  0.600279     -0.510361      -4.58190       4.58190       120.373       124.955    
  42  0.419387     -0.868962      -7.80134       7.80134       138.752       146.554    
  43  0.952036     -0.491524E-01 -0.441279      0.441279       127.913       128.355    
  44  0.613955     -0.487834      -4.37966       4.37966       138.039       142.419    
  45  0.842752     -0.171082      -1.53594       1.53594       121.677       123.213    
  46  0.733219     -0.310311      -2.78590       2.78590       110.854       113.640    
loop,thermsimp(1:2)       67   10.8717       1.56107    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    157        118.01         67.70          1.11         42.16          0.25          0.05        111.27
Just calling func    0   0        111.27


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    158        139.98         67.85          1.12         42.11          0.55          0.05        111.68
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    118.01
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       67
neval is:      157
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       67      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       68
neval is:      157


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      157     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.944296E-02  -4.66249      -41.8587       41.8587       110.854       152.713    
   2  0.714357     -0.336373      -3.01988       3.01988       117.794       120.814    
   3  0.997096     -0.290808E-02 -0.261081E-01  0.261081E-01   110.504       110.530    
   4  0.905437     -0.993373E-01 -0.891827      0.891827       117.629       118.521    
   5  0.307060      -1.18071      -10.6002       10.6002       118.007       128.607    
   6  0.179061      -1.72003      -15.4420       15.4420       119.057       134.499    
   7  0.384312     -0.956301      -8.58544       8.58544       120.104       128.690    
   8  0.901101     -0.104138     -0.934930      0.934930       119.707       120.642    
   9  0.606170     -0.500594      -4.49422       4.49422       121.677       126.171    
  10  0.515234     -0.663133      -5.95345       5.95345       118.681       124.635    
  11  0.639447     -0.447152      -4.01442       4.01442       119.704       123.718    
  12  0.820429     -0.197928      -1.77695       1.77695       119.932       121.709    
  13  0.521739     -0.650587      -5.84082       5.84082       119.396       125.237    
  14  0.767979     -0.263993      -2.37007       2.37007       120.373       122.743    
  15  0.530366     -0.634187      -5.69358       5.69358       122.001       127.695    
  16  0.732471     -0.311332      -2.79507       2.79507       119.449       122.244    
  17  0.440461     -0.819933      -7.36116       7.36116       124.136       131.497    
  18  0.595715     -0.517993      -4.65042       4.65042       116.607       121.258    
  19  0.407958     -0.896592      -8.04939       8.04939       125.047       133.096    
  20  0.544683     -0.607550      -5.45444       5.45444       127.913       133.368    
  21  0.611386E-01  -2.79461      -25.0894       25.0894       117.527       142.616    
  22  0.135041      -2.00218      -17.9751       17.9751       124.892       142.867    
  23  0.547242     -0.602864      -5.41237       5.41237       120.857       126.269    
  24  0.214436      -1.53975      -13.8235       13.8235       120.348       134.171    
  25  0.340220      -1.07816      -9.67949       9.67949       118.163       127.842    
  26  0.270394      -1.30787      -11.7418       11.7418       117.452       129.193    
  27  0.605229     -0.502149      -4.50817       4.50817       119.097       123.605    
  28  0.630206     -0.461709      -4.14511       4.14511       121.529       125.675    
  29  0.942476     -0.592449E-01 -0.531887      0.531887       122.940       123.472    
  30  0.293125      -1.22716      -11.0171       11.0171       119.994       131.011    
  31  0.526210     -0.642056      -5.76423       5.76423       120.806       126.570    
  32  0.972201     -0.281927E-01 -0.253107      0.253107       129.721       129.974    
  33  0.570000     -0.562119      -5.04657       5.04657       121.129       126.176    
  34  0.752945     -0.283763      -2.54756       2.54756       118.469       121.016    
  35  0.333005      -1.09960      -9.87193       9.87193       117.825       127.697    
  36  0.430444     -0.842939      -7.56771       7.56771       122.117       129.684    
  37  0.106505      -2.23957      -20.1063       20.1063       138.039       158.145    
  38  0.327953      -1.11488      -10.0092       10.0092       121.881       131.890    
  39  0.586631     -0.533359      -4.78838       4.78838       122.710       127.498    
  40  0.563274     -0.573989      -5.15314       5.15314       121.000       126.153    
  41  0.802100     -0.220522      -1.97979       1.97979       119.547       121.527    
  42  0.594871     -0.519411      -4.66315       4.66315       138.752       143.415    
  43  0.816066     -0.203261      -1.82483       1.82483       135.699       137.524    
  44  0.170795E-01  -4.06987      -36.5384       36.5384       125.093       161.632    
  45  0.554958     -0.588864      -5.28668       5.28668       139.601       144.888    
  46  0.674023     -0.394492      -3.54165       3.54165       118.006       121.548    
loop,thermsimp(1:2)       68   41.8587       3.01988    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    159        114.98         67.83          1.12         42.12          0.49          0.05        111.61
Just calling func    0   0        111.61


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    160        115.61         67.90          1.14         41.95          0.63          0.05        111.66
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    114.98
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       68
neval is:      159
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       68      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       69
neval is:      159


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      159     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.521048     -0.651914      -5.85273       5.85273       110.504       116.357    
   2  0.554375     -0.589913      -5.29610       5.29610       117.629       122.925    
   3  0.404373     -0.905418      -8.12863       8.12863       119.707       127.836    
   4  0.632877     -0.457478      -4.10713       4.10713       117.794       121.902    
   5  0.395261     -0.928209      -8.33324       8.33324       118.469       126.802    
   6  0.715068     -0.335378      -3.01095       3.01095       116.607       119.618    
   7  0.918313     -0.852174E-01 -0.765062      0.765062       119.547       120.312    
   8  0.529514E-01  -2.93838      -26.3801       26.3801       118.006       144.386    
   9  0.284219      -1.25801      -11.2941       11.2941       119.932       131.226    
  10  0.809402     -0.211460      -1.89844       1.89844       119.449       121.347    
  11  0.604758     -0.502928      -4.51517       4.51517       120.373       124.888    
  12  0.624772     -0.470369      -4.22286       4.22286       122.940       127.163    
  13  0.622683     -0.473718      -4.25293       4.25293       119.097       123.350    
  14  0.491656     -0.709976      -6.37400       6.37400       119.704       126.078    
  15  0.823484     -0.194211      -1.74358       1.74358       118.681       120.425    
  16  0.185629E-01  -3.98659      -35.7907       35.7907       119.396       155.187    
  17  0.911253     -0.929346E-01 -0.834345      0.834345       121.529       122.364    
  18  0.825116     -0.192231      -1.72581       1.72581       121.000       122.726    
  19  0.902913     -0.102129     -0.916894      0.916894       121.677       122.594    
  20  0.869925     -0.139348      -1.25104       1.25104       121.129       122.380    
  21  0.135445      -1.99919      -17.9483       17.9483       120.857       138.805    
  22  0.516840     -0.660022      -5.92553       5.92553       120.806       126.731    
  23  0.127583      -2.05899      -18.4851       18.4851       122.710       141.195    
  24  0.237062E-01  -3.74202      -33.5950       33.5950       122.001       155.596    
  25  0.456233     -0.784753      -7.04533       7.04533       117.825       124.870    
  26  0.547397     -0.602581      -5.40983       5.40983       118.163       123.573    
  27  0.231746E-02  -6.06728      -54.4706       54.4706       118.007       172.477    
  28  0.467213     -0.760969      -6.83180       6.83180       120.104       126.936    
  29  0.397333     -0.922981      -8.28631       8.28631       117.452       125.738    
  30  0.291343      -1.23325      -11.0719       11.0719       122.117       133.189    
  31  0.964262     -0.363922E-01 -0.326720      0.326720       129.721       130.047    
  32  0.260485      -1.34521      -12.0770       12.0770       119.994       132.071    
  33  0.868574     -0.140902      -1.26499       1.26499       124.136       125.401    
  34  0.832573     -0.183235      -1.64504       1.64504       121.881       123.526    
  35  0.240383      -1.42552      -12.7980       12.7980       125.047       137.845    
  36  0.878342     -0.129719      -1.16459       1.16459       127.913       129.078    
  37  0.168707      -1.77959      -15.9768       15.9768       120.348       136.325    
  38  0.348015      -1.05551      -9.47613       9.47613       119.057       128.533    
  39  0.846224     -0.166971      -1.49903       1.49903       135.699       137.198    
  40  0.842580     -0.171286      -1.53777       1.53777       117.527       119.065    
  41  0.230401      -1.46794      -13.1788       13.1788       124.892       138.071    
  42  0.441962     -0.816531      -7.33062       7.33062       138.752       146.083    
  43  0.772036     -0.258724      -2.32277       2.32277       139.601       141.924    
  44  0.970063     -0.303946E-01 -0.272875      0.272875       110.854       111.127    
  45  0.610535     -0.493419      -4.42980       4.42980       138.039       142.469    
  46  0.548201     -0.601114      -5.39666       5.39666       114.979       120.375    
loop,thermsimp(1:2)       69   5.85273       5.29610    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    161        119.18         67.84          1.13         42.03          0.48          0.05        111.55
Just calling func    0   0        111.54


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    162        129.55         67.85          1.14         42.19          0.37          0.05        111.60
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  160    119.18        1.068     -2.531      2.582     -102.6     0.7714    
                      0.8647     0.9794     -99.70      3.890     0.7462    

                       1.728    -0.2837      1.540      7258.      7000.    

                      0.1902      0.000      0.000      0.000     -1.221    



                      -1.892      0.000      0.000      7000.      465.5    

                       1.714     -4.894     -4.630     -7.561      6.687    

                      -15.81     -5.724      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4138    -0.7613      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.5431     -1.165      7000.    



                      -1.449     -1.289     -2.116     -1.956    -0.3807    

                     -0.3252      9.220      8.735    -0.1584E+05 -5.571    

                     -0.5386     -2.603      9.365      8.872    -0.1969E+05



                      -6.000     0.5720    -0.1550      8.929      9.009    

                     -0.1944E+05 -6.000    -0.9774    -0.5457      9.124    

                       8.841    -0.1891E+05 -6.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    119.18
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       69
neval is:      161
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       69      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       70
neval is:      161


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      161     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.242177      -1.41809      -12.7312       12.7312       110.854       123.585    
   2  0.384023     -0.957054      -8.59221       8.59221       110.504       119.096    
   3  0.672379     -0.396933      -3.56357       3.56357       117.527       121.090    
   4  0.204591      -1.58674      -14.2454       14.2454       116.607       130.853    
   5  0.145151      -1.92998      -17.3269       17.3269       119.547       136.874    
   6  0.235757      -1.44495      -12.9725       12.9725       114.979       127.951    
   7  0.882595     -0.124889      -1.12122       1.12122       118.681       119.803    
   8  0.215562      -1.53451      -13.7764       13.7764       119.449       133.225    
   9  0.248905      -1.39068      -12.4852       12.4852       117.794       130.280    
  10  0.695481     -0.363152      -3.26029       3.26029       121.529       124.790    
  11  0.515786     -0.662063      -5.94385       5.94385       121.129       127.073    
  12  0.956817     -0.441428E-01 -0.396304      0.396304       121.677       122.073    
  13  0.256477      -1.36072      -12.2162       12.2162       121.000       133.216    
  14  0.870409     -0.138792      -1.24604       1.24604       117.629       118.875    
  15  0.296335      -1.21627      -10.9193       10.9193       119.097       130.016    
  16  0.563087     -0.574322      -5.15613       5.15613       121.881       127.037    
  17  0.860973     -0.149692      -1.34390       1.34390       118.163       119.507    
  18  0.336353      -1.08959      -9.78211       9.78211       117.825       127.607    
  19  0.432238     -0.838780      -7.53037       7.53037       120.373       127.903    
  20  0.411587     -0.887734      -7.96987       7.96987       124.136       132.106    
  21  0.685679     -0.377346      -3.38772       3.38772       117.452       120.839    
  22  0.178038E-01  -4.02835      -36.1655       36.1655       119.704       155.869    
  23  0.330516      -1.10710      -9.93929       9.93929       120.806       130.745    
  24  0.987115     -0.129685E-01 -0.116428      0.116428       118.469       118.585    
  25  0.702947     -0.352474      -3.16443       3.16443       120.104       123.269    
  26  0.159040      -1.83860      -16.5065       16.5065       122.940       139.447    
  27  0.329714      -1.10953      -9.96111       9.96111       119.707       129.668    
  28  0.542452     -0.611656      -5.49131       5.49131       119.057       124.549    
  29  0.484074     -0.725518      -6.51353       6.51353       127.913       134.427    
  30  0.574330     -0.554551      -4.97863       4.97863       129.721       134.699    
  31  0.987944     -0.121288E-01 -0.108890      0.108890       119.932       120.041    
  32  0.565195E-01  -2.87317      -25.7946       25.7946       119.994       145.789    
  33  0.662626     -0.411545      -3.69475       3.69475       122.117       125.811    
  34  0.462195     -0.771769      -6.92876       6.92876       120.348       127.277    
  35  0.413957     -0.881994      -7.91833       7.91833       135.699       143.618    
  36  0.627825     -0.465493      -4.17909       4.17909       125.047       129.226    
  37  0.373783E-01  -3.28667      -29.5069       29.5069       124.892       154.399    
  38  0.318481      -1.14419      -10.2723       10.2723       120.857       131.129    
  39  0.193037      -1.64487      -14.7673       14.7673       122.710       137.477    
  40  0.246573      -1.40010      -12.5698       12.5698       139.601       152.171    
  41  0.913643     -0.903152E-01 -0.810829      0.810829       138.039       138.850    
  42  0.593287     -0.522077      -4.68708       4.68708       118.006       122.693    
  43  0.323913      -1.12728      -10.1204       10.1204       138.752       148.873    
  44  0.270579E-01  -3.60978      -32.4077       32.4077       119.396       151.804    
  45  0.684823     -0.378595      -3.39894       3.39894       122.001       125.400    
  46  0.279340      -1.27532      -11.4496       11.4496       119.185       130.634    
loop,thermsimp(1:2)       70   12.7312       8.59221    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    163        114.03         67.87          1.15         42.28          0.54          0.05        111.89
Just calling func    0   0        111.89


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    164        115.39         67.89          1.14         42.11          0.28          0.05        111.47
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    114.03
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       70
neval is:      163
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       70      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       71
neval is:      163


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      163     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.810305     -0.210344      -1.88842       1.88842       118.469       120.357    
   2  0.601567     -0.508218      -4.56266       4.56266       117.629       122.192    
   3  0.190401      -1.65862      -14.8907       14.8907       110.504       125.395    
   4  0.827263     -0.189632      -1.70247       1.70247       118.163       119.865    
   5  0.581677     -0.541840      -4.86451       4.86451       118.681       123.546    
   6  0.680336     -0.385169      -3.45796       3.45796       119.932       123.390    
   7  0.641383     -0.444128      -3.98728       3.98728       117.452       121.439    
   8  0.593931     -0.520992      -4.67734       4.67734       117.527       122.204    
   9  0.326400      -1.11963      -10.0518       10.0518       121.677       131.729    
  10  0.964323     -0.363286E-01 -0.326150      0.326150       118.006       118.332    
  11  0.481751     -0.730328      -6.55671       6.55671       120.104       126.661    
  12  0.230624E-01  -3.76955      -33.8421       33.8421       110.854       144.696    
  13  0.214859      -1.53777      -13.8058       13.8058       119.057       132.863    
  14  0.325804      -1.12146      -10.0682       10.0682       121.529       131.598    
  15  0.668745     -0.402353      -3.61223       3.61223       122.001       125.614    
  16  0.803263     -0.219073      -1.96678       1.96678       122.117       124.084    
  17  0.465531     -0.764577      -6.86419       6.86419       121.881       128.745    
  18  0.589796     -0.527978      -4.74007       4.74007       121.129       125.869    
  19  0.783335     -0.244195      -2.19233       2.19233       120.348       122.540    
  20  0.937099     -0.649659E-01 -0.583249      0.583249       117.825       118.408    
  21  0.504081     -0.685019      -6.14994       6.14994       120.373       126.523    
  22  0.368431E-01  -3.30109      -29.6364       29.6364       114.979       144.615    
  23  0.462712     -0.770651      -6.91872       6.91872       125.047       131.966    
  24  0.172447      -1.75767      -15.7799       15.7799       119.707       135.487    
  25  0.361979      -1.01617      -9.12294       9.12294       119.097       128.220    
  26  0.616189     -0.484202      -4.34705       4.34705       117.794       122.141    
  27  0.495582     -0.702023      -6.30260       6.30260       119.185       125.487    
  28  0.492859     -0.707532      -6.35206       6.35206       120.806       127.158    
  29  0.189027      -1.66586      -14.9557       14.9557       116.607       131.563    
  30  0.336237      -1.08994      -9.78522       9.78522       120.857       130.642    
  31  0.997382     -0.262184E-02 -0.235382E-01  0.235382E-01   124.136       124.159    
  32  0.629287     -0.463168      -4.15821       4.15821       121.000       125.159    
  33  0.226178      -1.48644      -13.3449       13.3449       119.449       132.794    
  34  0.522315     -0.649483      -5.83091       5.83091       127.913       133.744    
  35  0.238835E-02  -6.03715      -54.2002       54.2002       129.721       183.921    
  36  0.123092E-01  -4.39741      -39.4789       39.4789       119.547       159.026    
  37  0.488141     -0.717152      -6.43842       6.43842       122.710       129.148    
  38  0.925188     -0.777584E-01 -0.698096      0.698096       138.039       138.737    
  39  0.676413     -0.390952      -3.50987       3.50987       122.940       126.450    
  40  0.638827     -0.448121      -4.02313       4.02313       135.699       139.723    
  41  0.789998     -0.235725      -2.11628       2.11628       119.994       122.110    
  42  0.453703E-01  -3.09290      -27.7673       27.7673       138.752       166.520    
  43  0.866893     -0.142840      -1.28239       1.28239       119.396       120.678    
  44  0.122493E-01  -4.40228      -39.5227       39.5227       139.601       179.124    
  45  0.172311      -1.75846      -15.7870       15.7870       124.892       140.679    
  46  0.899580     -0.105827     -0.950088      0.950088       114.034       114.984    
loop,thermsimp(1:2)       71   1.88842       4.56266    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    165        113.97         67.88          1.15         42.13          0.49          0.05        111.70
Just calling func    0   0        111.70


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    166        116.41         67.85          1.10         42.08          0.34          0.05        111.42
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    113.97
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       71
neval is:      165
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       71      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       72
neval is:      165


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      165     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.870330     -0.138883      -1.24686       1.24686       114.034       115.281    
   2  0.470451     -0.754063      -6.76980       6.76980       118.006       124.776    
   3  0.615627     -0.485114      -4.35524       4.35524       117.825       122.180    
   4  0.291899      -1.23135      -11.0548       11.0548       118.163       129.218    
   5  0.584822     -0.536448      -4.81611       4.81611       118.469       123.285    
   6  0.681731     -0.383120      -3.43957       3.43957       119.396       122.836    
   7  0.680149     -0.385444      -3.46042       3.46042       117.452       120.912    
   8  0.560478     -0.578966      -5.19782       5.19782       119.994       125.192    
   9  0.392299     -0.935730      -8.40076       8.40076       117.794       126.195    
  10  0.586793     -0.533083      -4.78589       4.78589       117.629       122.415    
  11  0.461418     -0.773452      -6.94387       6.94387       117.527       124.471    
  12  0.142886      -1.94571      -17.4681       17.4681       120.348       137.816    
  13  0.960325     -0.404831E-01 -0.363448      0.363448       119.932       120.296    
  14  0.547176     -0.602984      -5.41345       5.41345       118.681       124.095    
  15  0.817596     -0.201386      -1.80800       1.80800       122.117       123.925    
  16  0.184065      -1.69247      -15.1946       15.1946       124.136       139.330    
  17  0.763954     -0.269247      -2.41724       2.41724       121.000       123.418    
  18  0.740640     -0.300240      -2.69548       2.69548       110.504       113.200    
  19  0.257299      -1.35751      -12.1874       12.1874       119.185       131.372    
  20  0.274950      -1.29117      -11.5918       11.5918       122.001       133.593    
  21  0.850599     -0.161814      -1.45273       1.45273       121.129       122.582    
  22  0.265651      -1.32557      -11.9007       11.9007       122.940       134.841    
  23  0.388810     -0.944665      -8.48098       8.48098       120.373       128.854    
  24  0.921262     -0.820106E-01 -0.736272      0.736272       120.104       120.841    
  25  0.622168     -0.474545      -4.26035       4.26035       120.806       125.066    
  26  0.831499     -0.184526      -1.65663       1.65663       119.097       120.753    
  27  0.777776     -0.251317      -2.25626       2.25626       121.881       124.137    
  28  0.519638     -0.654624      -5.87706       5.87706       122.710       128.587    
  29  0.343480      -1.06863      -9.59388       9.59388       120.857       130.451    
  30  0.379182     -0.969738      -8.70608       8.70608       116.607       125.314    
  31  0.509964     -0.673415      -6.04576       6.04576       121.529       127.575    
  32  0.457294E-01  -3.08501      -27.6965       27.6965       121.677       149.374    
  33  0.952238     -0.489400E-01 -0.439372      0.439372       125.047       125.486    
  34  0.198116      -1.61890      -14.5341       14.5341       119.449       133.983    
  35  0.863922     -0.146273      -1.31321       1.31321       119.057       120.370    
  36  0.765944     -0.266646      -2.39389       2.39389       127.913       130.307    
  37  0.849389     -0.163238      -1.46552       1.46552       119.707       121.172    
  38  0.488339     -0.716745      -6.43476       6.43476       138.039       144.474    
  39  0.969632     -0.308388E-01 -0.276864      0.276864       135.699       135.976    
  40  0.971690     -0.287184E-01 -0.257827      0.257827       124.892       125.150    
  41  0.690522     -0.370307      -3.32453       3.32453       114.979       118.303    
  42  0.266028      -1.32415      -11.8879       11.8879       110.854       122.742    
  43  0.581296     -0.542495      -4.87039       4.87039       119.547       124.418    
  44  0.636654     -0.451529      -4.05372       4.05372       138.752       142.806    
  45  0.947680     -0.537383E-01 -0.482450      0.482450       139.601       140.084    
  46  0.792806     -0.232176      -2.08442       2.08442       113.967       116.052    
loop,thermsimp(1:2)       72   1.24686       6.76980    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    167        114.00         67.77          1.12         42.11          0.57          0.05        111.62
Just calling func    0   0        111.63


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    168        116.84         67.94          1.15         42.64          0.29          0.05        112.06
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    114.00
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       72
neval is:      167
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       72      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       73
neval is:      167


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      167     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.741909     -0.298528      -2.68012       2.68012       110.504       113.184    
   2  0.823468     -0.194230      -1.74375       1.74375       114.034       115.778    
   3  0.352913      -1.04153      -9.35065       9.35065       113.967       123.318    
   4  0.268511      -1.31486      -11.8045       11.8045       114.979       126.783    
   5  0.137541      -1.98383      -17.8104       17.8104       119.932       137.743    
   6  0.953738     -0.473661E-01 -0.425242      0.425242       119.057       119.482    
   7  0.366602      -1.00348      -9.00899       9.00899       119.097       128.106    
   8  0.861530     -0.149046      -1.33810       1.33810       120.104       121.442    
   9  0.190086      -1.66028      -14.9056       14.9056       117.452       132.357    
  10  0.931621     -0.708293E-01 -0.635889      0.635889       119.707       120.343    
  11  0.135562      -1.99833      -17.9405       17.9405       117.825       135.765    
  12  0.577052     -0.549824      -4.93619       4.93619       117.629       122.565    
  13  0.937511     -0.645266E-01 -0.579304      0.579304       121.129       121.708    
  14  0.836727     -0.178258      -1.60035       1.60035       110.854       112.455    
  15  0.124731      -2.08159      -18.6880       18.6880       119.396       138.084    
  16  0.830758     -0.185417      -1.66463       1.66463       118.469       120.133    
  17  0.925849     -0.770442E-01 -0.691685      0.691685       121.000       121.692    
  18  0.945668     -0.558633E-01 -0.501528      0.501528       122.117       122.618    
  19  0.700762     -0.355587      -3.19238       3.19238       118.681       121.874    
  20  0.585168E-01  -2.83844      -25.4829       25.4829       121.881       147.364    
  21  0.241985      -1.41888      -12.7384       12.7384       119.547       132.286    
  22  0.426115     -0.853047      -7.65845       7.65845       117.527       125.185    
  23  0.730656     -0.313813      -2.81734       2.81734       118.006       120.824    
  24  0.227460      -1.48078      -13.2941       13.2941       120.806       134.100    
  25  0.824070     -0.193500      -1.73719       1.73719       124.892       126.630    
  26  0.912829     -0.912064E-01 -0.818830      0.818830       119.994       120.813    
  27  0.130860      -2.03363      -18.2574       18.2574       116.607       134.865    
  28  0.126999      -2.06358      -18.5263       18.5263       125.047       143.573    
  29  0.394828E-01  -3.23189      -29.0151       29.0151       117.794       146.810    
  30  0.927793     -0.749466E-01 -0.672853      0.672853       121.529       122.202    
  31  0.161762      -1.82163      -16.3542       16.3542       122.710       139.064    
  32  0.510374     -0.672611      -6.03855       6.03855       120.373       126.411    
  33  0.930607     -0.719186E-01 -0.645668      0.645668       118.163       118.809    
  34  0.825283E-01  -2.49461      -22.3961       22.3961       127.913       150.310    
  35  0.569143     -0.563624      -5.06008       5.06008       120.857       125.917    
  36  0.732951     -0.310676      -2.78918       2.78918       119.185       121.974    
  37  0.554950     -0.588877      -5.28680       5.28680       122.001       127.288    
  38  0.614368     -0.487160      -4.37361       4.37361       119.449       123.822    
  39  0.127889      -2.05659      -18.4636       18.4636       122.940       141.404    
  40  0.510007     -0.673330      -6.04500       6.04500       135.699       141.744    
  41  0.206107      -1.57936      -14.1791       14.1791       120.348       134.527    
  42  0.812962E-01  -2.50966      -22.5311       22.5311       124.136       146.667    
  43  0.711913     -0.339799      -3.05064       3.05064       139.601       142.652    
  44  0.649899     -0.430939      -3.86887       3.86887       138.752       142.621    
  45  0.102708      -2.27587      -20.4322       20.4322       138.039       158.471    
  46  0.152702      -1.87927      -16.8716       16.8716       114.001       130.873    
loop,thermsimp(1:2)       73   2.68012       1.74375    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    169        137.43         67.81          1.13         41.98          0.52          0.05        111.50
Just calling func    0   0        111.50


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    137.43
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       73
neval is:      168
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       73      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       74
neval is:      168


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      168     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.835960     -0.179175      -1.60859       1.60859       110.854       112.463    
   2  0.439366     -0.822423      -7.38352       7.38352       110.504       117.888    
   3  0.603094     -0.505682      -4.53989       4.53989       114.034       118.574    
   4  0.695854E-01  -2.66520      -23.9275       23.9275       118.163       142.090    
   5  0.273021      -1.29821      -11.6550       11.6550       119.057       130.712    
   6  0.418319     -0.871511      -7.82422       7.82422       118.469       126.293    
   7  0.688437     -0.373331      -3.35168       3.35168       119.707       123.059    
   8  0.400930     -0.913969      -8.20540       8.20540       119.994       128.199    
   9  0.569492     -0.563010      -5.05457       5.05457       118.006       123.061    
  10  0.812441     -0.207712      -1.86479       1.86479       120.104       121.969    
  11  0.222094      -1.50465      -13.5084       13.5084       121.000       134.509    
  12  0.695761     -0.362749      -3.25668       3.25668       121.129       124.386    
  13  0.909536E-01  -2.39741      -21.5233       21.5233       118.681       140.205    
  14  0.297191      -1.21338      -10.8934       10.8934       119.185       130.078    
  15  0.806729     -0.214767      -1.92813       1.92813       121.529       123.458    
  16  0.407021     -0.898891      -8.07003       8.07003       117.629       125.699    
  17  0.520426     -0.653107      -5.86344       5.86344       122.117       127.980    
  18  0.826852     -0.190129      -1.70694       1.70694       113.967       115.674    
  19  0.729268     -0.315714      -2.83441       2.83441       119.449       122.283    
  20  0.344086      -1.06687      -9.57806       9.57806       117.527       127.105    
  21  0.280849      -1.26994      -11.4012       11.4012       120.857       132.258    
  22  0.301244E-01  -3.50242      -31.4439       31.4439       120.373       151.817    
  23  0.503253     -0.686663      -6.16470       6.16470       124.892       131.057    
  24  0.549007     -0.599644      -5.38346       5.38346       114.979       120.362    
  25  0.814230     -0.205513      -1.84504       1.84504       122.001       123.847    
  26  0.641489     -0.443963      -3.98580       3.98580       119.097       123.083    
  27  0.248696      -1.39152      -12.4928       12.4928       114.001       126.494    
  28  0.684472     -0.379107      -3.40353       3.40353       119.547       122.951    
  29  0.815126     -0.204413      -1.83517       1.83517       117.452       119.287    
  30  0.388210     -0.946208      -8.49483       8.49483       120.806       129.301    
  31  0.670538     -0.399675      -3.58819       3.58819       120.348       123.936    
  32  0.851104     -0.161221      -1.44740       1.44740       116.607       118.055    
  33  0.381078     -0.964752      -8.66131       8.66131       117.825       126.486    
  34  0.776256     -0.253273      -2.27382       2.27382       119.932       122.206    
  35  0.168040      -1.78355      -16.0123       16.0123       119.396       135.408    
  36  0.229069      -1.47373      -13.2308       13.2308       122.710       135.940    
  37  0.917563     -0.860337E-01 -0.772390      0.772390       122.940       123.712    
  38  0.161815      -1.82130      -16.3512       16.3512       135.699       152.051    
  39  0.355170      -1.03516      -9.29341       9.29341       138.752       148.046    
  40  0.221709      -1.50639      -13.5240       13.5240       139.601       153.125    
  41  0.424436     -0.856993      -7.69388       7.69388       125.047       132.741    
  42  0.337698      -1.08560      -9.74629       9.74629       124.136       133.882    
  43  0.574481     -0.554289      -4.97628       4.97628       117.794       122.771    
  44  0.614536     -0.486888      -4.37116       4.37116       121.881       126.252    
  45  0.345602      -1.06247      -9.53859       9.53859       127.913       137.452    
  46  0.330006      -1.10864      -9.95315       9.95315       137.434       147.388    
loop,thermsimp(1:2)       74   1.60859       7.38352    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    170        132.59         67.90          1.14         42.00          0.22          0.05        111.30
Just calling func    0   0        111.30


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    132.59
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       74
neval is:      169
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       74      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       75
neval is:      169


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      169     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.374776     -0.981426      -8.81102       8.81102       110.854       119.665    
   2  0.269095      -1.31269      -11.7850       11.7850       113.967       125.752    
   3  0.301960      -1.19746      -10.7505       10.7505       110.504       121.255    
   4  0.927593     -0.751619E-01 -0.674786      0.674786       116.607       117.282    
   5  0.783450     -0.244048      -2.19100       2.19100       114.034       116.225    
   6  0.716705     -0.333091      -2.99042       2.99042       117.452       120.442    
   7  0.728578     -0.316661      -2.84291       2.84291       114.979       117.822    
   8  0.752541     -0.284300      -2.55237       2.55237       120.104       122.657    
   9  0.111710      -2.19185      -19.6779       19.6779       119.932       139.610    
  10  0.202752E-01  -3.89836      -34.9985       34.9985       119.449       154.447    
  11  0.967738     -0.327937E-01 -0.294414      0.294414       117.794       118.089    
  12  0.530869     -0.633240      -5.68508       5.68508       119.547       125.232    
  13  0.752699E-01  -2.58668      -23.2226       23.2226       119.707       142.930    
  14  0.658334     -0.418043      -3.75309       3.75309       118.006       121.759    
  15  0.383542     -0.958305      -8.60344       8.60344       119.097       127.700    
  16  0.280803      -1.27010      -11.4027       11.4027       121.529       132.932    
  17  0.976909     -0.233616E-01 -0.209735      0.209735       122.940       123.150    
  18  0.611898     -0.491189      -4.40978       4.40978       122.001       126.411    
  19  0.860469     -0.150278      -1.34916       1.34916       120.348       121.697    
  20  0.375446     -0.979641      -8.79498       8.79498       121.129       129.924    
  21  0.964573     -0.360702E-01 -0.323830      0.323830       117.629       117.953    
  22  0.865663     -0.144259      -1.29512       1.29512       121.881       123.176    
  23  0.498009     -0.697137      -6.25873       6.25873       118.469       124.727    
  24  0.732547     -0.311228      -2.79413       2.79413       117.825       120.619    
  25  0.293766      -1.22497      -10.9975       10.9975       114.001       124.999    
  26  0.805097     -0.216793      -1.94632       1.94632       117.527       119.473    
  27  0.236791      -1.44058      -12.9332       12.9332       122.117       135.050    
  28  0.759809     -0.274688      -2.46609       2.46609       119.994       122.460    
  29  0.279804      -1.27367      -11.4347       11.4347       120.806       132.240    
  30  0.862550     -0.147862      -1.32747       1.32747       119.185       120.512    
  31  0.784800     -0.242327      -2.17555       2.17555       119.057       121.233    
  32  0.231425      -1.46350      -13.1390       13.1390       124.892       138.031    
  33  0.839725     -0.174681      -1.56825       1.56825       120.857       122.425    
  34  0.204862      -1.58542      -14.2335       14.2335       125.047       139.280    
  35  0.741170     -0.299525      -2.68907       2.68907       124.136       126.825    
  36  0.838703     -0.175898      -1.57917       1.57917       121.000       122.579    
  37  0.287711      -1.24580      -11.1845       11.1845       119.396       130.581    
  38  0.937479     -0.645611E-01 -0.579615      0.579615       122.710       123.289    
  39  0.188655      -1.66783      -14.9734       14.9734       127.913       142.887    
  40  0.818317     -0.200505      -1.80009       1.80009       118.681       120.481    
  41  0.903487     -0.101493     -0.911181      0.911181       118.163       119.074    
  42  0.148828      -1.90496      -17.1023       17.1023       137.434       154.537    
  43  0.573616E-01  -2.85838      -25.6619       25.6619       138.752       164.414    
  44  0.792726E-01  -2.53486      -22.7574       22.7574       120.373       143.130    
  45  0.150401      -1.89445      -17.0080       17.0080       135.699       152.707    
  46  0.511444     -0.670518      -6.01975       6.01975       132.595       138.614    
loop,thermsimp(1:2)       75   8.81102       11.7850    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    171        136.54         67.79          1.12         42.05          0.51          0.05        111.52
Just calling func    0   0        111.53


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    136.54
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       75
neval is:      170
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       75      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       76
neval is:      170


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      170     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.497287E-01  -3.00117      -26.9438       26.9438       114.034       140.978    
   2  0.604222     -0.503814      -4.52312       4.52312       116.607       121.131    
   3  0.106168      -2.24273      -20.1347       20.1347       114.979       135.113    
   4  0.342113      -1.07261      -9.62967       9.62967       117.629       127.259    
   5  0.473442     -0.747725      -6.71290       6.71290       117.794       124.507    
   6  0.100866E-01  -4.59655      -41.2667       41.2667       118.163       159.430    
   7  0.911848     -0.922817E-01 -0.828484      0.828484       117.527       118.355    
   8  0.633547     -0.456421      -4.09764       4.09764       110.854       114.952    
   9  0.729024     -0.316048      -2.83741       2.83741       117.452       120.289    
  10  0.620163     -0.477772      -4.28933       4.28933       118.681       122.971    
  11  0.867018     -0.142695      -1.28108       1.28108       119.185       120.466    
  12  0.969344E-01  -2.33372      -20.9516       20.9516       117.825       138.776    
  13  0.358466      -1.02592      -9.21048       9.21048       119.057       128.268    
  14  0.953168     -0.479638E-01 -0.430607      0.430607       110.504       110.935    
  15  0.684510     -0.379052      -3.40304       3.40304       120.348       123.751    
  16  0.482047     -0.729713      -6.55119       6.55119       118.006       124.557    
  17  0.974791     -0.255318E-01 -0.229219      0.229219       120.857       121.086    
  18  0.978669     -0.215619E-01 -0.193578      0.193578       119.994       120.188    
  19  0.929785     -0.728022E-01 -0.653601      0.653601       121.000       121.654    
  20  0.715020     -0.335444      -3.01154       3.01154       120.104       123.116    
  21  0.598247     -0.513752      -4.61235       4.61235       122.940       127.552    
  22  0.107080      -2.23418      -20.0579       20.0579       121.881       141.939    
  23  0.559093     -0.581439      -5.22002       5.22002       122.710       127.930    
  24  0.933094     -0.692491E-01 -0.621703      0.621703       118.469       119.090    
  25  0.470169E-01  -3.05725      -27.4473       27.4473       114.001       141.448    
  26  0.166768      -1.79115      -16.0805       16.0805       119.547       135.628    
  27  0.331277      -1.10480      -9.91864       9.91864       113.967       123.886    
  28  0.961755     -0.389952E-01 -0.350090      0.350090       122.001       122.352    
  29  0.464366E-01  -3.06967      -27.5588       27.5588       124.136       151.694    
  30  0.966136E-03  -6.94221      -62.3255       62.3255       119.097       181.422    
  31  0.941012     -0.607999E-01 -0.545847      0.545847       121.129       121.675    
  32  0.201947E-01  -3.90233      -35.0342       35.0342       119.396       154.430    
  33  0.679249     -0.386768      -3.47231       3.47231       120.806       124.278    
  34  0.318772      -1.14328      -10.2641       10.2641       121.529       131.793    
  35  0.388100     -0.946493      -8.49739       8.49739       122.117       130.614    
  36  0.658606     -0.417629      -3.74938       3.74938       124.892       128.642    
  37  0.774362     -0.255715      -2.29575       2.29575       132.595       134.890    
  38  0.704871     -0.349740      -3.13988       3.13988       125.047       128.187    
  39  0.274189      -1.29394      -11.6167       11.6167       119.932       131.549    
  40  0.881806     -0.125783      -1.12925       1.12925       127.913       129.043    
  41  0.198448      -1.61723      -14.5191       14.5191       119.707       134.226    
  42  0.342590      -1.07122      -9.61718       9.61718       120.373       129.990    
  43  0.603787     -0.504534      -4.52959       4.52959       135.699       140.229    
  44  0.667409     -0.404353      -3.63019       3.63019       119.449       123.079    
  45  0.317014      -1.14881      -10.3137       10.3137       137.434       147.748    
  46  0.368458     -0.998429      -8.96366       8.96366       136.538       145.502    
loop,thermsimp(1:2)       76   26.9438       4.52312    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    172        115.34         67.80          1.12         42.09          0.62          0.05        111.67
Just calling func    0   0        111.67


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    173        121.01         67.95          1.13         42.38          0.54          0.05        112.06
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    115.34
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       76
neval is:      172
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       76      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       77
neval is:      172


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      172     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.596761     -0.516238      -4.63466       4.63466       110.504       115.139    
   2  0.476930     -0.740385      -6.64700       6.64700       110.854       117.501    
   3  0.845382     -0.167966      -1.50796       1.50796       117.527       119.035    
   4  0.397814     -0.921770      -8.27543       8.27543       118.469       126.744    
   5  0.249923      -1.38660      -12.4486       12.4486       119.994       132.443    
   6  0.591552     -0.525005      -4.71337       4.71337       117.452       122.165    
   7  0.143111      -1.94414      -17.4540       17.4540       119.185       136.639    
   8  0.306099      -1.18385      -10.6283       10.6283       120.857       131.485    
   9  0.441827     -0.816836      -7.33336       7.33336       116.607       123.941    
  10  0.504521     -0.684146      -6.14210       6.14210       121.000       127.142    
  11  0.127660      -2.05839      -18.4797       18.4797       121.129       139.609    
  12  0.333524      -1.09804      -9.85795       9.85795       122.001       131.859    
  13  0.130890      -2.03340      -18.2554       18.2554       118.681       136.937    
  14  0.307732      -1.17853      -10.5805       10.5805       119.449       130.029    
  15  0.154434E-01  -4.17057      -37.4424       37.4424       120.104       157.547    
  16  0.357863      -1.02761      -9.22560       9.22560       120.348       129.573    
  17  0.271898      -1.30233      -11.6920       11.6920       113.967       125.659    
  18  0.906228E-01  -2.40105      -21.5561       21.5561       120.806       142.362    
  19  0.344142      -1.06670      -9.57659       9.57659       117.794       127.371    
  20  0.392886     -0.934237      -8.38736       8.38736       118.006       126.394    
  21  0.454318     -0.788958      -7.08308       7.08308       117.629       124.712    
  22  0.384129     -0.956778      -8.58973       8.58973       122.940       131.530    
  23  0.354037      -1.03835      -9.32209       9.32209       122.710       132.032    
  24  0.154212      -1.86943      -16.7833       16.7833       125.047       141.830    
  25  0.816320     -0.202949      -1.82203       1.82203       119.057       120.879    
  26  0.994970     -0.504291E-02 -0.452740E-01  0.452740E-01   124.892       124.938    
  27  0.374719E-01  -3.28416      -29.4845       29.4845       127.913       157.398    
  28  0.227113      -1.48231      -13.3078       13.3078       120.373       133.681    
  29  0.410587     -0.890167      -7.99171       7.99171       122.117       130.108    
  30  0.104540E-01  -4.56077      -40.9455       40.9455       119.932       160.878    
  31  0.994826     -0.518730E-02 -0.465703E-01  0.465703E-01   121.529       121.576    
  32  0.738930     -0.302553      -2.71625       2.71625       119.707       122.423    
  33  0.715904     -0.334209      -3.00045       3.00045       132.595       135.595    
  34  0.128324      -2.05320      -18.4331       18.4331       114.979       133.412    
  35  0.856095     -0.155374      -1.39491       1.39491       119.547       120.942    
  36  0.423967     -0.858099      -7.70381       7.70381       117.825       125.529    
  37  0.504650     -0.683890      -6.13980       6.13980       135.699       141.839    
  38  0.347036      -1.05833      -9.50142       9.50142       114.034       123.536    
  39  0.906779     -0.978566E-01 -0.878533      0.878533       114.001       114.880    
  40  0.616911     -0.483030      -4.33653       4.33653       121.881       126.217    
  41  0.540209     -0.615800      -5.52851       5.52851       136.538       142.067    
  42  0.772932     -0.257564      -2.31235       2.31235       137.434       139.747    
  43  0.544989     -0.606989      -5.44941       5.44941       124.136       129.585    
  44  0.951523     -0.496917E-01 -0.446121      0.446121       119.396       119.842    
  45  0.172505      -1.75733      -15.7769       15.7769       118.163       133.940    
  46  0.871391     -0.137665      -1.23592       1.23592       115.340       116.576    
loop,thermsimp(1:2)       77   4.63466       6.64700    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    174        115.90         67.84          1.14         42.32          0.63          0.05        111.98
Just calling func    0   0        111.97


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    115.90
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       77
neval is:      173
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       77      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       78
neval is:      173


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      181
neval,tstepnext:      173     181

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.941883     -0.598737E-01 -0.537532      0.537532       114.001       114.539    
   2  0.368209     -0.999105      -8.96973       8.96973       110.504       119.474    
   3  0.508630     -0.676034      -6.06927       6.06927       115.340       121.409    
   4  0.744324     -0.295279      -2.65095       2.65095       110.854       113.505    
   5  0.401586     -0.912333      -8.19071       8.19071       117.527       125.718    
   6  0.712794     -0.338563      -3.03954       3.03954       119.396       122.436    
   7  0.186976      -1.67678      -15.0537       15.0537       119.057       134.111    
   8  0.688451     -0.373311      -3.35150       3.35150       119.547       122.899    
   9  0.668652     -0.402492      -3.61348       3.61348       121.529       125.143    
  10  0.656767     -0.420426      -3.77449       3.77449       117.452       121.226    
  11  0.853336     -0.158602      -1.42389       1.42389       119.707       121.131    
  12  0.556440     -0.586195      -5.26272       5.26272       114.034       119.297    
  13  0.258558E-01  -3.65522      -32.8157       32.8157       116.607       149.423    
  14  0.121003E-01  -4.41452      -39.6325       39.6325       117.629       157.262    
  15  0.150890      -1.89120      -16.9788       16.9788       124.892       141.871    
  16  0.820074     -0.198360      -1.78083       1.78083       117.825       119.606    
  17  0.151452      -1.88748      -16.9454       16.9454       113.967       130.913    
  18  0.305465      -1.18592      -10.6469       10.6469       121.881       132.528    
  19  0.533202     -0.628854      -5.64571       5.64571       118.006       123.652    
  20  0.143416      -1.94201      -17.4349       17.4349       118.469       135.903    
  21  0.687081     -0.375303      -3.36938       3.36938       121.000       124.370    
  22  0.546247     -0.604685      -5.42872       5.42872       117.794       123.223    
  23  0.356987      -1.03006      -9.24760       9.24760       120.348       129.596    
  24  0.545718     -0.605653      -5.43741       5.43741       124.136       129.573    
  25  0.789688     -0.236117      -2.11980       2.11980       119.449       121.568    
  26  0.752086     -0.284904      -2.55780       2.55780       122.117       124.675    
  27  0.388816     -0.944650      -8.48084       8.48084       120.857       129.338    
  28  0.988428     -0.116395E-01 -0.104497      0.104497       122.940       123.045    
  29  0.124991      -2.07952      -18.6694       18.6694       122.001       140.671    
  30  0.568214     -0.565257      -5.07475       5.07475       122.710       127.784    
  31  0.551032     -0.595962      -5.35041       5.35041       119.994       125.344    
  32  0.423622     -0.858913      -7.71112       7.71112       114.979       122.690    
  33  0.647554     -0.434553      -3.90132       3.90132       120.373       124.274    
  34  0.686255     -0.376506      -3.38019       3.38019       118.163       121.543    
  35  0.548072     -0.601349      -5.39877       5.39877       132.595       137.993    
  36  0.880777     -0.126951      -1.13974       1.13974       119.185       120.324    
  37  0.894918     -0.111023     -0.996736      0.996736       118.681       119.678    
  38  0.241077      -1.42264      -12.7721       12.7721       121.129       133.901    
  39  0.546141     -0.604877      -5.43045       5.43045       137.434       142.865    
  40  0.266590      -1.32204      -11.8690       11.8690       125.047       136.916    
  41  0.575085     -0.553238      -4.96684       4.96684       135.699       140.666    
  42  0.907139     -0.974596E-01 -0.874970      0.874970       136.538       137.413    
  43  0.469109     -0.756920      -6.79545       6.79545       120.806       127.601    
  44  0.738008     -0.303801      -2.72745       2.72745       127.913       130.641    
  45  0.557598     -0.584116      -5.24406       5.24406       120.104       125.348    
  46  0.305677      -1.18523      -10.6407       10.6407       115.899       126.540    
loop,thermsimp(1:2)       78  0.537532       8.96973    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    175        188.97         67.77          1.10         42.56          0.69          0.05        112.18
Just calling func    0   0        112.18


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    176        183.32         67.83          1.12         42.12          0.24          0.05        111.36
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       4    117.63
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    8.97776               181
loop is:       78
neval is:      175
 ............
 ............
 ............
 ............
 All the processors had case 4
 ---> shrink the simplex by replacing each point other than the current minimum
      by a point mid-way between its current position and the minimum




 after shrink
before func_dist: nevalp,nrounds (this is a value left from share outcome loop so 1 or 2):     176       2
 note that before this the last time nrounds was assigned a value was in the share outcome loop (1 or 2)
 ............
 ............
iter,obj,time:    177        110.31         67.65          1.14         42.24          0.26          0.05        111.34
iter,obj,time:    178        110.75         67.63          1.13         42.32          0.18          0.05        111.31
iter,obj,time:    179        108.29         67.56          1.12         42.30          0.16          0.05        111.20
iter,obj,time:    180        112.07         67.62          1.15         42.48          0.52          0.05        111.82
iter,obj,time:    181        110.74         67.69          1.16         42.38          0.00          0.05        111.28
iter,obj,time:    182        112.41         67.59          1.14         42.27          0.34          0.05        111.39
iter,obj,time:    183        115.91         67.61          1.12         42.37          0.61          0.05        111.77
iter,obj,time:    184        112.11         67.56          1.12         42.16          0.62          0.05        111.52
iter,obj,time:    185        110.06         67.61          1.13         42.21          0.55          0.05        111.55
iter,obj,time:    186        112.67         67.59          1.12         42.36          0.49          0.05        111.62
iter,obj,time:    187        112.60         67.63          1.15         42.23          0.43          0.05        111.48
iter,obj,time:    188        112.73         67.80          1.19         42.59          0.39          0.05        112.02
iter,obj,time:    189        111.49         67.57          1.13         42.45          0.59          0.05        111.79
iter,obj,time:    190        112.70         67.50          1.12         42.26          0.45          0.05        111.37
iter,obj,time:    191        113.54         67.59          1.12         42.23          0.34          0.05        111.33
iter,obj,time:    192        111.51         67.62          1.12         42.30          0.48          0.05        111.57
iter,obj,time:    193        111.77         67.52          1.12         42.30          0.58          0.04        111.55
iter,obj,time:    194        116.24         67.57          1.13         42.34          0.59          0.05        111.69
iter,obj,time:    195        116.60         67.54          1.13         42.55          0.51          0.05        111.78
iter,obj,time:    196        112.74         67.55          1.13         42.27          0.56          0.05        111.55
iter,obj,time:    197        115.06         67.60          1.14         42.19          0.52          0.05        111.49
iter,obj,time:    198        116.19         67.70          1.16         42.44          0.11          0.05        111.46
iter,obj,time:    199        114.98         67.54          1.12         42.12          0.66          0.05        111.48
iter,obj,time:    200        111.11         67.55          1.12         42.28          0.57          0.05        111.57
iter,obj,time:    201        110.70         67.59          1.14         42.21          0.63          0.05        111.63
iter,obj,time:    202        114.40         67.50          1.13         42.73          0.56          0.05        111.98
iter,obj,time:    203        115.02         67.51          1.12         42.26          0.45          0.05        111.38
iter,obj,time:    204        113.62         67.59          1.12         42.29          0.48          0.05        111.53
iter,obj,time:    205        115.68         67.61          1.12         42.20          0.40          0.05        111.38
iter,obj,time:    206        116.76         67.54          1.13         42.19          0.49          0.05        111.40
iter,obj,time:    207        116.83         67.54          1.12         42.34          0.29          0.05        111.34
iter,obj,time:    208        110.50         67.61          1.14         42.20          0.24          0.05        111.25
iter,obj,time:    209        112.94         67.95          1.21         42.01          0.38          0.05        111.59
iter,obj,time:    210        116.46         67.55          1.14         42.64          0.33          0.05        111.71
iter,obj,time:    211        115.77         67.61          1.13         42.34          0.52          0.05        111.65
iter,obj,time:    212        113.22         67.57          1.12         42.26          0.55          0.05        111.55
iter,obj,time:    213        118.22         67.62          1.13         42.16          0.47          0.05        111.44
iter,obj,time:    214        117.96         67.59          1.13         42.29          0.40          0.05        111.45
iter,obj,time:    215        114.28         67.57          1.12         42.32          0.62          0.05        111.70
iter,obj,time:    216        121.02         67.58          1.12         42.29          0.55          0.05        111.59
iter,obj,time:    217        117.00         67.64          1.16         42.19          0.51          0.05        111.55
iter,obj,time:    218        114.51         67.73          1.12         42.32          0.39          0.05        111.62
iter,obj,time:    219        116.89         67.59          1.12         42.74          0.55          0.05        112.05
iter,obj,time:    220        111.83         67.69          1.16         42.20          0.30          0.05        111.41
iter,obj,time:    221        112.21         67.50          1.12         42.54          0.73          0.05        111.93


 after func_dist
 increase count of number of evals per procesor (nevalp=nevalp+nrounds) 
after func_dist: nevalp,nrounds:     222      46
 note that before this the last time nrounds was assigned a value was in the share outcome loop (1 or 2)




 starting do loop for updating neval=neval+1 within do i=1,np1 which has some printing (now commented out)

after updating neval in do loop, neval:     220




loop,nloop:      78      95
 CHECK loop<?nloop
-----IF loop<nloop, repeat main cycle
-----IF loop=nloop, calc hmean&stdev, write best of h so far and test for convergence (there are other conditions so see code) 
--------------------------------------------------IF not convgd cond then repeat main cycle

 right before: 250 IF (loop < nloop) CYCLE Main_loop 


beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    8.97776               181
loop is:       79
neval is:      220


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 




neval>tstepnex so lower away!t
---> lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
     new SAtemp,tstepnext are :    4.48888               226

 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      226
neval,tstepnext:      220     226

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.708826E-01  -2.64673      -11.8809       11.8809       110.854       122.735    
   2  0.952063     -0.491245E-01 -0.220514      0.220514       110.310       110.531    
   3  0.207928      -1.57057      -7.05008       7.05008       110.750       117.800    
   4  0.564009     -0.572686      -2.57072       2.57072       108.292       110.863    
   5  0.461636     -0.772979      -3.46981       3.46981       112.068       115.538    
   6  0.683812     -0.380072      -1.70610       1.70610       110.739       112.445    
   7  0.153569      -1.87360      -8.41038       8.41038       112.407       120.817    
   8  0.605650     -0.501453      -2.25097       2.25097       115.906       118.157    
   9  0.257296      -1.35753      -6.09379       6.09379       112.106       118.200    
  10  0.517987     -0.657805      -2.95281       2.95281       110.057       113.009    
  11  0.571129     -0.560140      -2.51440       2.51440       112.670       115.184    
  12  0.735134     -0.307703      -1.38124       1.38124       112.604       113.985    
  13  0.766340E-02  -4.87130      -21.8667       21.8667       112.728       134.595    
  14  0.435932     -0.830269      -3.72698       3.72698       111.494       115.221    
  15  0.513945     -0.665639      -2.98798       2.98798       112.700       115.688    
  16  0.447046     -0.805095      -3.61398       3.61398       113.539       117.153    
  17  0.244813      -1.40726      -6.31702       6.31702       111.506       117.823    
  18  0.183933      -1.69318      -7.60050       7.60050       111.772       119.372    
  19  0.413164     -0.883910      -3.96777       3.96777       116.244       120.212    
  20  0.869613     -0.139707     -0.627130      0.627130       116.602       117.230    
  21  0.853260     -0.158691     -0.712344      0.712344       112.739       113.451    
  22  0.138067      -1.98001      -8.88804       8.88804       115.056       123.944    
  23  0.940528     -0.613134E-01 -0.275229      0.275229       116.185       116.461    
  24  0.694939     -0.363931      -1.63364       1.63364       114.981       116.614    
  25  0.962776     -0.379346E-01 -0.170284      0.170284       111.110       111.281    
  26  0.378266     -0.972158      -4.36390       4.36390       110.699       115.063    
  27  0.855922     -0.155576     -0.698362      0.698362       114.398       115.096    
  28  0.393452     -0.932797      -4.18722       4.18722       115.021       119.208    
  29  0.253590      -1.37204      -6.15892       6.15892       113.620       119.779    
  30  0.777948     -0.251096      -1.12714       1.12714       115.675       116.802    
  31  0.654890     -0.423288      -1.90009       1.90009       116.763       118.664    
  32  0.690016E-01  -2.67363      -12.0016       12.0016       116.825       128.827    
  33  0.101034      -2.29229      -10.2898       10.2898       110.495       120.785    
  34  0.684533     -0.379019      -1.70137       1.70137       112.939       114.641    
  35  0.592603     -0.523230      -2.34872       2.34872       116.462       118.811    
  36  0.904830     -0.100009     -0.448927      0.448927       115.768       116.217    
  37  0.400244     -0.915681      -4.11038       4.11038       113.219       117.329    
  38  0.698191     -0.359263      -1.61269       1.61269       118.223       119.836    
  39  0.551449E-01  -2.89779      -13.0078       13.0078       117.962       130.970    
  40  0.500493     -0.692161      -3.10703       3.10703       114.282       117.389    
  41  0.289592      -1.23928      -5.56300       5.56300       121.023       126.586    
  42  0.447163     -0.804833      -3.61280       3.61280       116.997       120.610    
  43  0.690940     -0.369702      -1.65955       1.65955       114.506       116.166    
  44  0.631068     -0.460341      -2.06642       2.06642       116.887       118.953    
  45  0.926041     -0.768363E-01 -0.344909      0.344909       111.829       112.174    
  46  0.436187     -0.829684      -3.72436       3.72436       112.210       115.935    
loop,thermsimp(1:2)       79   11.8809      0.220514    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    222        113.41         67.66          1.08         42.18          0.41          0.05        111.38
Just calling func    0   0        111.38


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    113.41
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    4.48888               226
loop is:       79
neval is:      221
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       79      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    4.48888               226
loop is:       80
neval is:      221


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      226
neval,tstepnext:      221     226

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.668425     -0.402832      -1.80826       1.80826       110.310       112.118    
   2  0.238500      -1.43339      -6.43430       6.43430       108.292       114.726    
   3  0.689211     -0.372208      -1.67080       1.67080       111.110       112.781    
   4  0.540774     -0.614753      -2.75955       2.75955       111.829       114.588    
   5  0.178857      -1.72117      -7.72613       7.72613       110.739       118.465    
   6  0.884253     -0.123012     -0.552188      0.552188       110.057       110.609    
   7  0.755546     -0.280314      -1.25830       1.25830       112.739       113.997    
   8  0.654086E-01  -2.72710      -12.2416       12.2416       112.604       124.846    
   9  0.802958     -0.219452     -0.985096      0.985096       112.939       113.924    
  10  0.840665     -0.173562     -0.779097      0.779097       110.699       111.479    
  11  0.864930     -0.145107     -0.651367      0.651367       114.398       115.049    
  12  0.728243     -0.317120      -1.42352       1.42352       112.670       114.093    
  13  0.453086     -0.791672      -3.55372       3.55372       111.494       115.048    
  14  0.702549E-01  -2.65563      -11.9208       11.9208       112.068       123.989    
  15  0.610595     -0.493321      -2.21446       2.21446       112.700       114.915    
  16  0.728410E-02  -4.92206      -22.0946       22.0946       112.210       134.305    
  17  0.913763     -0.901841E-01 -0.404826      0.404826       114.506       114.911    
  18  0.165001      -1.80180      -8.08809       8.08809       115.768       123.856    
  19  0.917747E-01  -2.38842      -10.7213       10.7213       116.185       126.907    
  20  0.338507      -1.08321      -4.86241       4.86241       114.981       119.843    
  21  0.357666      -1.02815      -4.61527       4.61527       115.675       120.290    
  22  0.389441     -0.943044      -4.23321       4.23321       113.539       117.773    
  23  0.879897     -0.127950     -0.574353      0.574353       116.602       117.177    
  24  0.418897     -0.870129      -3.90591       3.90591       113.219       117.125    
  25  0.838426     -0.176230     -0.791074      0.791074       114.282       115.073    
  26  0.185169      -1.68649      -7.57043       7.57043       110.750       118.320    
  27  0.200952      -1.60469      -7.20325       7.20325       111.506       118.709    
  28  0.877256     -0.130957     -0.587849      0.587849       115.906       116.493    
  29  0.386592     -0.950385      -4.26617       4.26617       112.106       116.372    
  30  0.888706     -0.117988     -0.529636      0.529636       116.763       117.293    
  31  0.105408      -2.24991      -10.0996       10.0996       116.462       126.562    
  32  0.994268     -0.574873E-02 -0.258054E-01  0.258054E-01   116.887       116.913    
  33  0.764077     -0.269087      -1.20790       1.20790       115.021       116.229    
  34  0.812108     -0.208121     -0.934233      0.934233       111.772       112.706    
  35  0.121669      -2.10645      -9.45562       9.45562       113.620       123.075    
  36  0.637909     -0.449559      -2.01802       2.01802       118.223       120.241    
  37  0.316007E-02  -5.75716      -25.8432       25.8432       116.244       142.088    
  38  0.229677      -1.47108      -6.60351       6.60351       116.997       123.601    
  39  0.521374     -0.651288      -2.92356       2.92356       110.495       113.419    
  40  0.391402     -0.938019      -4.21066       4.21066       112.407       116.617    
  41  0.327357      -1.11670      -5.01275       5.01275       110.854       115.867    
  42  0.963139     -0.375576E-01 -0.168592      0.168592       115.056       115.225    
  43  0.174261      -1.74720      -7.84297       7.84297       121.023       128.866    
  44  0.331602      -1.10382      -4.95491       4.95491       116.825       121.780    
  45  0.526338     -0.641812      -2.88102       2.88102       117.962       120.843    
  46  0.413265     -0.883667      -3.96668       3.96668       113.409       117.376    
loop,thermsimp(1:2)       80   1.80826       6.43430    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    223        111.32         67.76          1.09         42.27          0.66          0.05        111.84
Just calling func    0   0        111.83


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    224        110.73         67.80          1.09         42.01          0.73          0.05        111.67
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    110.73
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    4.48888               226
loop is:       80
neval is:      223
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       80      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    4.48888               226
loop is:       81
neval is:      223


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      226
neval,tstepnext:      223     226

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.270023      -1.30925      -5.87706       5.87706       110.057       115.934    
   2  0.879265     -0.128669     -0.577578      0.577578       110.699       111.277    
   3  0.684902     -0.378479      -1.69895       1.69895       110.310       112.009    
   4  0.893896     -0.112166     -0.503498      0.503498       111.772       112.275    
   5  0.476761     -0.740739      -3.32509       3.32509       111.110       114.435    
   6  0.755167     -0.280817      -1.26055       1.26055       110.495       111.756    
   7  0.452407     -0.793173      -3.56046       3.56046       112.939       116.500    
   8  0.723906     -0.323093      -1.45033       1.45033       112.739       114.189    
   9  0.451260     -0.795711      -3.57186       3.57186       112.670       116.242    
  10  0.668265     -0.403071      -1.80934       1.80934       111.829       113.638    
  11  0.777249     -0.251995      -1.13118       1.13118       108.292       109.423    
  12  0.342240      -1.07224      -4.81318       4.81318       114.506       119.319    
  13  0.639156     -0.447606      -2.00925       2.00925       112.700       114.710    
  14  0.166924      -1.79022      -8.03608       8.03608       111.494       119.530    
  15  0.375260     -0.980137      -4.39972       4.39972       114.398       118.798    
  16  0.299730      -1.20487      -5.40853       5.40853       114.282       119.691    
  17  0.407119     -0.898650      -4.03394       4.03394       115.056       119.090    
  18  0.762992E-01  -2.57309      -11.5503       11.5503       110.854       122.405    
  19  0.281066      -1.26917      -5.69713       5.69713       115.021       120.718    
  20  0.220512      -1.51180      -6.78630       6.78630       112.106       118.892    
  21  0.389846     -0.942004      -4.22855       4.22855       115.906       120.134    
  22  0.660048     -0.415443      -1.86488       1.86488       112.407       114.272    
  23  0.150026      -1.89695      -8.51518       8.51518       116.887       125.402    
  24  0.113767      -2.17360      -9.75703       9.75703       113.219       122.976    
  25  0.810589     -0.209994     -0.942639      0.942639       116.602       117.545    
  26  0.247911      -1.39468      -6.26058       6.26058       116.763       123.024    
  27  0.408875     -0.894345      -4.01461       4.01461       113.409       117.424    
  28  0.310528      -1.16948      -5.24967       5.24967       113.539       118.789    
  29  0.663027     -0.410939      -1.84466       1.84466       110.750       112.595    
  30  0.798362     -0.225193      -1.01086       1.01086       110.739       111.750    
  31  0.564885     -0.571133      -2.56375       2.56375       111.506       114.069    
  32  0.473510E-02  -5.35275      -24.0279       24.0279       114.981       139.009    
  33  0.933475E-01  -2.37143      -10.6451       10.6451       118.223       128.868    
  34  0.931702     -0.707423E-01 -0.317554      0.317554       115.675       115.993    
  35  0.341741      -1.07370      -4.81973       4.81973       117.962       122.782    
  36  0.171330      -1.76417      -7.91913       7.91913       116.825       124.745    
  37  0.355860      -1.03322      -4.63799       4.63799       113.620       118.258    
  38  0.469639     -0.755790      -3.39265       3.39265       116.997       120.390    
  39  0.805376     -0.216446     -0.971599      0.971599       115.768       116.740    
  40  0.651615     -0.428301      -1.92259       1.92259       112.068       113.991    
  41  0.126831      -2.06490      -9.26908       9.26908       112.604       121.873    
  42  0.715737     -0.334442      -1.50127       1.50127       116.462       117.963    
  43  0.444007     -0.811915      -3.64459       3.64459       116.185       119.830    
  44  0.887105     -0.119791     -0.537729      0.537729       121.023       121.561    
  45  0.492139     -0.708993      -3.18259       3.18259       112.210       115.393    
  46  0.590315     -0.527098      -2.36608       2.36608       110.730       113.096    
loop,thermsimp(1:2)       81   5.87706      0.577578    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    225        110.11         67.88          1.11         42.38          0.15          0.05        111.55
Just calling func    0   0        111.55


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    226        111.38         67.88          1.11         42.41          0.29          0.05        111.73
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    110.11
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    4.48888               226
loop is:       81
neval is:      225
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       81      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    4.48888               226
loop is:       82
neval is:      225


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      226
neval,tstepnext:      225     226

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.130014E-01  -4.34270      -19.4939       19.4939       108.292       127.786    
   2  0.906957E-01  -2.40025      -10.7744       10.7744       110.699       121.474    
   3  0.973677     -0.266758E-01 -0.119745      0.119745       110.739       110.859    
   4  0.764409     -0.268653      -1.20595       1.20595       110.495       111.701    
   5  0.647718     -0.434300      -1.94952       1.94952       110.310       112.260    
   6  0.450945     -0.796410      -3.57499       3.57499       111.772       115.347    
   7  0.342138      -1.07254      -4.81451       4.81451       110.750       115.565    
   8  0.491560     -0.710170      -3.18787       3.18787       110.730       113.918    
   9  0.728901     -0.316218      -1.41947       1.41947       111.829       113.248    
  10  0.361124      -1.01853      -4.57208       4.57208       112.068       116.640    
  11  0.187026      -1.67651      -7.52565       7.52565       111.506       119.031    
  12  0.560514     -0.578901      -2.59862       2.59862       112.739       115.337    
  13  0.218776      -1.51971      -6.82178       6.82178       112.407       119.228    
  14  0.109271      -2.21392      -9.93803       9.93803       111.110       121.048    
  15  0.263420E-01  -3.63659      -16.3242       16.3242       112.700       129.025    
  16  0.654642     -0.423667      -1.90179       1.90179       112.210       114.112    
  17  0.975959     -0.243343E-01 -0.109234      0.109234       110.057       110.166    
  18  0.107212      -2.23295      -10.0234       10.0234       115.675       125.698    
  19  0.972340     -0.280494E-01 -0.125910      0.125910       112.670       112.796    
  20  0.259158      -1.35032      -6.06142       6.06142       112.939       119.001    
  21  0.889970     -0.116568     -0.523258      0.523258       115.768       116.291    
  22  0.956672     -0.442943E-01 -0.198832      0.198832       113.409       113.608    
  23  0.299261      -1.20644      -5.41556       5.41556       116.602       122.018    
  24  0.114836      -2.16425      -9.71506       9.71506       116.462       126.177    
  25  0.728848     -0.316291      -1.41979       1.41979       113.620       115.040    
  26  0.650336     -0.430267      -1.93142       1.93142       113.539       115.471    
  27  0.816983     -0.202137     -0.907371      0.907371       114.398       115.305    
  28  0.507860     -0.677550      -3.04144       3.04144       112.106       115.147    
  29  0.920661     -0.826634E-01 -0.371066      0.371066       115.056       115.427    
  30  0.253772      -1.37132      -6.15570       6.15570       114.506       120.662    
  31  0.667512     -0.404198      -1.81440       1.81440       111.494       113.308    
  32  0.772715     -0.257844      -1.15743       1.15743       114.282       115.440    
  33  0.757620     -0.277573      -1.24599       1.24599       116.185       117.431    
  34  0.776421     -0.253060      -1.13596       1.13596       115.906       117.042    
  35  0.886642     -0.120314     -0.540077      0.540077       116.997       117.537    
  36  0.238693E-01  -3.73516      -16.7667       16.7667       115.021       131.787    
  37  0.303957      -1.19087      -5.34568       5.34568       121.023       126.369    
  38  0.875267     -0.133226     -0.598037      0.598037       112.604       113.202    
  39  0.144246      -1.93624      -8.69154       8.69154       110.854       119.546    
  40  0.993963     -0.605564E-02 -0.271831E-01  0.271831E-01   117.962       117.990    
  41  0.172168      -1.75928      -7.89721       7.89721       113.219       121.116    
  42  0.979713     -0.204952E-01 -0.920007E-01  0.920007E-01   116.763       116.855    
  43  0.938694     -0.632658E-01 -0.283993      0.283993       116.825       117.109    
  44  0.716061     -0.333990      -1.49924       1.49924       116.887       118.386    
  45  0.764601     -0.268402      -1.20482       1.20482       118.223       119.428    
  46  0.546951     -0.603396      -2.70857       2.70857       110.113       112.822    
loop,thermsimp(1:2)       82   19.4939       10.7744    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    227        110.04         67.90          1.12         41.96          0.62          0.05        111.65
Just calling func    0   0        111.65


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    228        107.09         67.86          1.09         42.18          0.15          0.05        111.33
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    107.09
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    4.48888               226
loop is:       82
neval is:      227
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       82      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    4.48888               226
loop is:       83
neval is:      227


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 




neval>tstepnex so lower away!t
---> lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
     new SAtemp,tstepnext are :    2.24444               271

 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      227     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.609134     -0.495717      -1.11261       1.11261       110.057       111.169    
   2  0.266275      -1.32323      -2.96990       2.96990       110.739       113.709    
   3  0.545538     -0.605984      -1.36009       1.36009       110.495       111.855    
   4  0.196234      -1.62845      -3.65495       3.65495       110.310       113.965    
   5  0.786411     -0.240275     -0.539284      0.539284       112.670       113.209    
   6  0.453912     -0.789853      -1.77278       1.77278       110.113       111.886    
   7  0.900549     -0.104751     -0.235107      0.235107       112.604       112.839    
   8  0.339919      -1.07905      -2.42186       2.42186       111.829       114.251    
   9  0.511643     -0.670128      -1.50406       1.50406       111.494       112.998    
  10  0.628202     -0.464894      -1.04343       1.04343       113.409       114.452    
  11  0.672886E-01  -2.69876      -6.05722       6.05722       110.730       116.787    
  12  0.518493     -0.656829      -1.47421       1.47421       112.210       113.685    
  13  0.994926     -0.508642E-02 -0.114162E-01  0.114162E-01   113.620       113.631    
  14  0.733191     -0.310349     -0.696560      0.696560       112.106       112.802    
  15  0.952818     -0.483318E-01 -0.108478      0.108478       114.398       114.506    
  16  0.735955     -0.306586     -0.688115      0.688115       112.739       113.427    
  17  0.743149     -0.296859     -0.666282      0.666282       111.772       112.438    
  18  0.549375     -0.598975      -1.34436       1.34436       115.056       116.400    
  19  0.355140      -1.03524      -2.32354       2.32354       114.282       116.606    
  20  0.482165     -0.729469      -1.63725       1.63725       113.539       115.177    
  21  0.577197     -0.549571      -1.23348       1.23348       110.750       111.984    
  22  0.107316E-01  -4.53456      -10.1776       10.1776       115.768       125.946    
  23  0.923969     -0.790764E-01 -0.177482      0.177482       112.068       112.246    
  24  0.810451     -0.210164     -0.471701      0.471701       116.763       117.235    
  25  0.143346      -1.94249      -4.35981       4.35981       115.906       120.265    
  26  0.994184     -0.583318E-02 -0.130922E-01  0.130922E-01   116.825       116.839    
  27  0.870737     -0.138415     -0.310665      0.310665       116.185       116.496    
  28  0.970691     -0.297469E-01 -0.667652E-01  0.667652E-01   116.997       117.064    
  29  0.351269      -1.04620      -2.34814       2.34814       117.962       120.311    
  30  0.464982     -0.765756      -1.71869       1.71869       116.887       118.606    
  31  0.921785     -0.814432E-01 -0.182794      0.182794       112.939       113.122    
  32  0.110512      -2.20263      -4.94367       4.94367       111.506       116.449    
  33  0.261408      -1.34167      -3.01130       3.01130       112.407       115.418    
  34  0.908908     -0.955118E-01 -0.214371      0.214371       118.223       118.438    
  35  0.819412     -0.199168     -0.447021      0.447021       110.854       111.301    
  36  0.466482     -0.762536      -1.71147       1.71147       114.506       116.218    
  37  0.717237     -0.332349     -0.745938      0.745938       111.110       111.856    
  38  0.802331     -0.220234     -0.494301      0.494301       113.219       113.713    
  39  0.949390     -0.519355E-01 -0.116566      0.116566       110.699       110.816    
  40  0.258511      -1.35282      -3.03632       3.03632       116.602       119.639    
  41  0.270423      -1.30777      -2.93521       2.93521       115.675       118.610    
  42  0.366439      -1.00392      -2.25325       2.25325       116.462       118.715    
  43  0.934403     -0.678476E-01 -0.152280      0.152280       121.023       121.176    
  44  0.956654     -0.443133E-01 -0.994586E-01  0.994586E-01   108.292       108.392    
  45  0.377790     -0.973417      -2.18478       2.18478       112.700       114.885    
  46  0.203667      -1.59127      -3.57151       3.57151       107.085       110.657    
loop,thermsimp(1:2)       83   1.11261       2.96990    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    229        110.60         67.80          1.09         42.02          0.63          0.05        111.59
Just calling func    0   0        111.59


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    110.60
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       83
neval is:      228
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       83      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       84
neval is:      228


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      228     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.572627     -0.557521      -1.25132       1.25132       108.292       109.543    
   2  0.468879     -0.757411      -1.69997       1.69997       107.085       108.785    
   3  0.886741E-01  -2.42279      -5.43780       5.43780       110.699       116.137    
   4  0.211783      -1.55219      -3.48380       3.48380       110.057       113.540    
   5  0.573306     -0.556336      -1.24866       1.24866       110.854       112.103    
   6  0.401711     -0.912021      -2.04698       2.04698       110.495       112.542    
   7  0.505706     -0.681800      -1.53026       1.53026       111.110       112.641    
   8  0.603045     -0.505763      -1.13516       1.13516       110.113       111.249    
   9  0.696575     -0.361580     -0.811546      0.811546       110.750       111.562    
  10  0.294614      -1.22209      -2.74291       2.74291       112.068       114.811    
  11  0.527550     -0.639511      -1.43535       1.43535       111.772       113.207    
  12  0.657157     -0.419832     -0.942289      0.942289       112.106       113.048    
  13  0.627866     -0.465428      -1.04463       1.04463       112.604       113.649    
  14  0.993353E-02  -4.61184      -10.3510       10.3510       111.494       121.845    
  15  0.885166E-01  -2.42456      -5.44179       5.44179       112.939       118.381    
  16  0.265764      -1.32515      -2.97422       2.97422       112.670       115.644    
  17  0.446403     -0.806534      -1.81022       1.81022       112.739       114.549    
  18  0.287864      -1.24527      -2.79493       2.79493       113.620       116.415    
  19  0.926928E-01  -2.37846      -5.33832       5.33832       112.210       117.549    
  20  0.394849     -0.929252      -2.08565       2.08565       110.739       112.825    
  21  0.540746     -0.614805      -1.37989       1.37989       113.219       114.599    
  22  0.846435     -0.166721     -0.374197      0.374197       110.310       110.684    
  23  0.417037     -0.874580      -1.96294       1.96294       111.829       113.792    
  24  0.210713      -1.55726      -3.49517       3.49517       113.409       116.904    
  25  0.764669     -0.268312     -0.602210      0.602210       114.398       115.000    
  26  0.219471E-01  -3.81912      -8.57180       8.57180       112.700       121.272    
  27  0.200728      -1.60581      -3.60414       3.60414       113.539       117.144    
  28  0.572660     -0.557463      -1.25119       1.25119       112.407       113.658    
  29  0.599083E-01  -2.81494      -6.31797       6.31797       114.506       120.824    
  30  0.214614      -1.53891      -3.45400       3.45400       115.056       118.510    
  31  0.489389     -0.714598      -1.60387       1.60387       111.506       113.109    
  32  0.162616      -1.81636      -4.07672       4.07672       116.185       120.262    
  33  0.710022     -0.342459     -0.768629      0.768629       114.282       115.051    
  34  0.753583     -0.282916     -0.634989      0.634989       110.730       111.365    
  35  0.743317     -0.296633     -0.665775      0.665775       116.825       117.491    
  36  0.155416      -1.86165      -4.17836       4.17836       116.997       121.175    
  37  0.643355     -0.441059     -0.989931      0.989931       116.763       117.753    
  38  0.656098     -0.421444     -0.945907      0.945907       118.223       119.169    
  39  0.327550      -1.11611      -2.50505       2.50505       116.887       119.392    
  40  0.192244      -1.64899      -3.70106       3.70106       115.675       119.376    
  41  0.433590     -0.835657      -1.87558       1.87558       116.462       118.338    
  42  0.788561     -0.237545     -0.533157      0.533157       116.602       117.136    
  43  0.978028     -0.222173E-01 -0.498655E-01  0.498655E-01   115.906       115.955    
  44  0.110322      -2.20435      -4.94754       4.94754       117.962       122.910    
  45  0.795332     -0.228995     -0.513967      0.513967       121.023       121.537    
  46  0.497518E-01  -3.00071      -6.73492       6.73492       110.597       117.332    
loop,thermsimp(1:2)       84   1.25132       1.69997    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    230        120.89         67.82          1.10         42.07          0.58          0.05        111.62
Just calling func    0   0        111.62


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    120.89
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       84
neval is:      229
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       84      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       85
neval is:      229


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      229     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.197499      -1.62202      -3.64053       3.64053       107.085       110.726    
   2  0.793097     -0.231809     -0.520282      0.520282       108.292       108.812    
   3  0.261081      -1.34293      -3.01412       3.01412       110.310       113.324    
   4  0.912198     -0.918984E-01 -0.206261      0.206261       110.113       110.320    
   5  0.493539     -0.706153      -1.58492       1.58492       110.730       112.315    
   6  0.721001     -0.327115     -0.734189      0.734189       110.750       111.484    
   7  0.578790     -0.546816      -1.22730       1.22730       110.854       112.082    
   8  0.684127     -0.379612     -0.852016      0.852016       110.495       111.347    
   9  0.627712     -0.465674      -1.04518       1.04518       111.110       112.155    
  10  0.858540     -0.152522     -0.342327      0.342327       110.739       111.081    
  11  0.712254E-01  -2.64191      -5.92960       5.92960       112.106       118.035    
  12  0.927250     -0.755316E-01 -0.169526      0.169526       111.506       111.675    
  13  0.458073     -0.780727      -1.75230       1.75230       111.772       113.524    
  14  0.940004     -0.618714E-01 -0.138867      0.138867       110.057       110.195    
  15  0.322549      -1.13150      -2.53959       2.53959       112.604       115.144    
  16  0.939473     -0.624358E-01 -0.140134      0.140134       112.407       112.547    
  17  0.726080     -0.320095     -0.718435      0.718435       111.829       112.547    
  18  0.602088E-02  -5.11252      -11.4748       11.4748       112.739       124.213    
  19  0.735289     -0.307492     -0.690148      0.690148       113.219       113.909    
  20  0.847617     -0.165326     -0.371065      0.371065       112.068       112.439    
  21  0.747190E-01  -2.59402      -5.82213       5.82213       114.398       120.220    
  22  0.248374      -1.39282      -3.12610       3.12610       114.282       117.408    
  23  0.350184      -1.04930      -2.35508       2.35508       112.670       115.025    
  24  0.327739E-03  -8.02329      -18.0078       18.0078       115.906       133.913    
  25  0.130012      -2.04013      -4.57895       4.57895       110.699       115.278    
  26  0.609791     -0.494639      -1.11019       1.11019       113.620       114.730    
  27  0.793414     -0.231410     -0.519387      0.519387       113.409       113.928    
  28  0.962567     -0.381519E-01 -0.856297E-01  0.856297E-01   116.602       116.688    
  29  0.499469     -0.694211      -1.55812       1.55812       113.539       115.098    
  30  0.887491     -0.119357     -0.267890      0.267890       110.597       110.865    
  31  0.136374      -1.99236      -4.47172       4.47172       116.825       121.297    
  32  0.292356      -1.22978      -2.76018       2.76018       112.210       114.971    
  33  0.301564      -1.19877      -2.69058       2.69058       116.763       119.454    
  34  0.352543      -1.04258      -2.34001       2.34001       116.462       118.802    
  35  0.483726     -0.726236      -1.62999       1.62999       112.939       114.569    
  36  0.410499     -0.890381      -1.99841       1.99841       115.056       117.054    
  37  0.458111     -0.780644      -1.75211       1.75211       118.223       119.975    
  38  0.670071     -0.400372     -0.898612      0.898612       115.675       116.574    
  39  0.175486      -1.74020      -3.90577       3.90577       116.887       120.793    
  40  0.798907     -0.224511     -0.503901      0.503901       116.185       116.689    
  41  0.270487      -1.30753      -2.93468       2.93468       114.506       117.441    
  42  0.480368     -0.733202      -1.64563       1.64563       116.997       118.643    
  43  0.658406     -0.417933     -0.938026      0.938026       112.700       113.638    
  44  0.937976     -0.640304E-01 -0.143712      0.143712       121.023       121.167    
  45  0.710083     -0.342373     -0.768436      0.768436       111.494       112.262    
  46  0.567340     -0.566797      -1.27214       1.27214       120.890       122.162    
loop,thermsimp(1:2)       85   3.64053      0.520282    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    231        109.18         67.88          1.09         42.12          0.42          0.05        111.57
Just calling func    0   0        111.57


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    232        107.06         67.87          1.11         42.11          0.62          0.05        111.77
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    107.06
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       85
neval is:      231
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       85      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       86
neval is:      231


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      231     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.464881     -0.765974      -1.71918       1.71918       108.292       110.011    
   2  0.948887     -0.524654E-01 -0.117756      0.117756       110.057       110.174    
   3  0.532332     -0.630488      -1.41509       1.41509       110.113       111.529    
   4  0.374267     -0.982785      -2.20580       2.20580       107.085       109.291    
   5  0.694531     -0.364519     -0.818141      0.818141       110.597       111.415    
   6  0.414371     -0.880994      -1.97734       1.97734       110.739       112.716    
   7  0.208827E-01  -3.86883      -8.68337       8.68337       110.495       119.179    
   8  0.627187     -0.466511      -1.04706       1.04706       110.750       111.797    
   9  0.148799E-01  -4.20774      -9.44403       9.44403       111.506       120.950    
  10  0.809008     -0.211946     -0.475701      0.475701       110.854       111.330    
  11  0.647680     -0.434359     -0.974894      0.974894       111.110       112.085    
  12  0.289351      -1.24012      -2.78337       2.78337       111.494       114.277    
  13  0.222457      -1.50302      -3.37344       3.37344       110.730       114.103    
  14  0.374268     -0.982782      -2.20580       2.20580       112.068       114.274    
  15  0.785765     -0.241097     -0.541128      0.541128       112.407       112.948    
  16  0.298051      -1.21049      -2.71688       2.71688       111.829       114.546    
  17  0.725075     -0.321480     -0.721544      0.721544       110.310       111.032    
  18  0.386364     -0.950976      -2.13441       2.13441       111.772       113.906    
  19  0.631686     -0.459363      -1.03101       1.03101       112.700       113.731    
  20  0.688282     -0.373557     -0.838427      0.838427       113.219       114.057    
  21  0.373817     -0.983990      -2.20851       2.20851       113.409       115.618    
  22  0.219845      -1.51483      -3.39996       3.39996       112.939       116.339    
  23  0.926271     -0.765889E-01 -0.171899      0.171899       113.620       113.792    
  24  0.618127     -0.481061      -1.07971       1.07971       112.210       113.290    
  25  0.176216      -1.73604      -3.89645       3.89645       112.670       116.566    
  26  0.742943     -0.297136     -0.666905      0.666905       113.539       114.206    
  27  0.357690      -1.02809      -2.30748       2.30748       112.604       114.912    
  28  0.478359     -0.737394      -1.65504       1.65504       110.699       112.354    
  29  0.395976     -0.926401      -2.07925       2.07925       115.675       117.754    
  30  0.803186     -0.219169     -0.491912      0.491912       116.602       117.094    
  31  0.231845      -1.46168      -3.28066       3.28066       116.185       119.466    
  32  0.808968     -0.211996     -0.475813      0.475813       115.056       115.532    
  33  0.579217     -0.546078      -1.22564       1.22564       114.282       115.508    
  34  0.384357     -0.956183      -2.14610       2.14610       114.506       116.652    
  35  0.856367     -0.155057     -0.348016      0.348016       112.106       112.454    
  36  0.265661      -1.32553      -2.97508       2.97508       116.997       119.972    
  37  0.288915      -1.24162      -2.78675       2.78675       116.462       119.249    
  38  0.224915      -1.49203      -3.34878       3.34878       116.763       120.112    
  39  0.685944     -0.376959     -0.846063      0.846063       118.223       119.069    
  40  0.265936      -1.32450      -2.97276       2.97276       114.398       117.371    
  41  0.412966     -0.884389      -1.98496       1.98496       116.887       118.872    
  42  0.440796     -0.819173      -1.83859       1.83859       121.023       122.862    
  43  0.572522     -0.557705      -1.25174       1.25174       116.825       118.077    
  44  0.798412     -0.225131     -0.505294      0.505294       120.890       121.396    
  45  0.127097      -2.06281      -4.62985       4.62985       112.739       117.368    
  46  0.243397      -1.41306      -3.17154       3.17154       107.064       110.236    
loop,thermsimp(1:2)       86   1.71918      0.117756    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    233        112.28         67.77          1.10         42.05          0.70          0.05        111.67
Just calling func    0   0        111.67


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    112.28
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       86
neval is:      232
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       86      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       87
neval is:      232


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      232     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.182970      -1.69843      -3.81203       3.81203       107.085       110.897    
   2  0.721345     -0.326637     -0.733119      0.733119       108.292       109.025    
   3  0.842493     -0.171390     -0.384674      0.384674       110.057       110.441    
   4  0.260540      -1.34500      -3.01877       3.01877       107.064       110.083    
   5  0.782605     -0.245127     -0.550173      0.550173       110.310       110.860    
   6  0.208492      -1.56785      -3.51896       3.51896       110.854       114.373    
   7  0.290568E-01  -3.53850      -7.94196       7.94196       110.597       118.539    
   8  0.673682     -0.394997     -0.886547      0.886547       110.113       111.000    
   9  0.399393     -0.917808      -2.05997       2.05997       110.750       112.810    
  10  0.966971     -0.335863E-01 -0.753825E-01  0.753825E-01   111.110       111.186    
  11  0.390645     -0.939956      -2.10968       2.10968       110.699       112.809    
  12  0.259548      -1.34881      -3.02733       3.02733       112.106       115.133    
  13  0.260765      -1.34413      -3.01683       3.01683       110.739       113.756    
  14  0.110601E-01  -4.50441      -10.1099       10.1099       112.407       122.517    
  15  0.727710     -0.317852     -0.713401      0.713401       112.210       112.924    
  16  0.717076     -0.332574     -0.746443      0.746443       112.700       113.447    
  17  0.612129     -0.490811      -1.10160       1.10160       113.620       114.721    
  18  0.589376     -0.528691      -1.18662       1.18662       111.772       112.958    
  19  0.541615     -0.613199      -1.37629       1.37629       113.219       114.595    
  20  0.330403      -1.10744      -2.48559       2.48559       110.730       113.216    
  21  0.229530      -1.47172      -3.30319       3.30319       113.539       116.843    
  22  0.564010     -0.572684      -1.28536       1.28536       112.068       113.354    
  23  0.454226     -0.789161      -1.77122       1.77122       111.494       113.265    
  24  0.579528     -0.545541      -1.22444       1.22444       111.829       113.053    
  25  0.245500      -1.40446      -3.15222       3.15222       112.604       115.756    
  26  0.708019     -0.345284     -0.774969      0.774969       114.282       115.057    
  27  0.300215      -1.20326      -2.70064       2.70064       115.056       117.757    
  28  0.721461     -0.326478     -0.732760      0.732760       113.409       114.142    
  29  0.326772      -1.11849      -2.51039       2.51039       112.939       115.450    
  30  0.580879     -0.543212      -1.21921       1.21921       112.670       113.889    
  31  0.963075     -0.376241E-01 -0.844451E-01  0.844451E-01   114.506       114.591    
  32  0.656935     -0.420170     -0.943046      0.943046       116.602       117.545    
  33  0.908335     -0.961416E-01 -0.215784      0.215784       112.739       112.954    
  34  0.765938     -0.266654     -0.598490      0.598490       114.398       114.996    
  35  0.497301     -0.698561      -1.56788       1.56788       115.675       117.243    
  36  0.833603     -0.181997     -0.408483      0.408483       116.825       117.234    
  37  0.433057     -0.836886      -1.87834       1.87834       116.887       118.765    
  38  0.349547      -1.05112      -2.35917       2.35917       118.223       120.582    
  39  0.142838      -1.94604      -4.36778       4.36778       110.495       114.863    
  40  0.326780      -1.11847      -2.51034       2.51034       116.462       118.972    
  41  0.707709     -0.345723     -0.775955      0.775955       116.185       116.961    
  42  0.914339     -0.895538E-01 -0.200998      0.200998       116.997       117.198    
  43  0.392800     -0.934454      -2.09733       2.09733       116.763       118.861    
  44  0.434772     -0.832933      -1.86947       1.86947       111.506       113.375    
  45  0.229545      -1.47165      -3.30304       3.30304       120.890       124.193    
  46  0.661281     -0.413577     -0.928249      0.928249       112.280       113.208    
loop,thermsimp(1:2)       87   3.81203      0.733119    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    234        118.07         67.79          1.09         41.98          0.59          0.05        111.50
Just calling func    0   0        111.50


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    118.07
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       87
neval is:      233
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       87      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       88
neval is:      233


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      233     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.220180      -1.51331      -3.39654       3.39654       108.292       111.689    
   2  0.246752E-01  -3.70196      -8.30883       8.30883       107.064       115.373    
   3  0.679039     -0.387076     -0.868770      0.868770       110.057       110.925    
   4  0.709027     -0.343862     -0.771777      0.771777       110.310       111.082    
   5  0.577754     -0.548608      -1.23132       1.23132       107.085       108.317    
   6  0.738694     -0.302871     -0.679777      0.679777       110.113       110.793    
   7  0.181723      -1.70527      -3.82738       3.82738       111.110       114.938    
   8  0.103748      -2.26579      -5.08543       5.08543       110.699       115.785    
   9  0.456811E-02  -5.38866      -12.0945       12.0945       110.750       122.845    
  10  0.303247      -1.19321      -2.67808       2.67808       112.210       114.888    
  11  0.284736      -1.25619      -2.81945       2.81945       112.739       115.558    
  12  0.900494     -0.104812     -0.235244      0.235244       111.772       112.007    
  13  0.691792     -0.368470     -0.827009      0.827009       111.829       112.656    
  14  0.502714     -0.687735      -1.54358       1.54358       112.280       113.823    
  15  0.305219      -1.18673      -2.66354       2.66354       110.730       113.394    
  16  0.412005     -0.886720      -1.99019       1.99019       111.494       113.484    
  17  0.412225     -0.886186      -1.98899       1.98899       112.068       114.057    
  18  0.121697      -2.10622      -4.72729       4.72729       111.506       116.233    
  19  0.465374     -0.764915      -1.71681       1.71681       112.700       114.417    
  20  0.273016      -1.29823      -2.91379       2.91379       110.739       113.653    
  21  0.502763     -0.687636      -1.54336       1.54336       112.670       114.213    
  22  0.516442     -0.660793      -1.48311       1.48311       113.409       114.892    
  23  0.554333     -0.589990      -1.32420       1.32420       110.854       112.178    
  24  0.192397E-01  -3.95078      -8.86729       8.86729       114.506       123.374    
  25  0.451279E-01  -3.09825      -6.95385       6.95385       113.219       120.173    
  26  0.457340     -0.782327      -1.75589       1.75589       113.620       115.376    
  27  0.325184      -1.12336      -2.52132       2.52132       110.495       113.017    
  28  0.700952     -0.355315     -0.797484      0.797484       114.398       115.195    
  29  0.961087     -0.396906E-01 -0.890832E-01  0.890832E-01   114.282       114.371    
  30  0.195966E-02  -6.23498      -13.9941       13.9941       112.106       126.100    
  31  0.766376     -0.266082     -0.597206      0.597206       112.939       113.536    
  32  0.398846     -0.919180      -2.06304       2.06304       112.604       114.667    
  33  0.675249     -0.392674     -0.881334      0.881334       113.539       114.421    
  34  0.189468      -1.66354      -3.73371       3.73371       116.185       119.919    
  35  0.444608     -0.810562      -1.81926       1.81926       116.997       118.816    
  36  0.514006     -0.665520      -1.49372       1.49372       116.825       118.319    
  37  0.575199     -0.553039      -1.24126       1.24126       115.675       116.916    
  38  0.121449      -2.10826      -4.73187       4.73187       116.602       121.334    
  39  0.209130      -1.56480      -3.51210       3.51210       115.056       118.568    
  40  0.466284E-01  -3.06555      -6.88044       6.88044       110.597       117.478    
  41  0.386630E-01  -3.25287      -7.30088       7.30088       116.887       124.188    
  42  0.335751E-01  -3.39397      -7.61757       7.61757       116.763       124.381    
  43  0.878126     -0.129965     -0.291699      0.291699       116.462       116.754    
  44  0.652938     -0.426273     -0.956744      0.956744       118.223       119.180    
  45  0.932456E-01  -2.37252      -5.32498       5.32498       112.407       117.732    
  46  0.662683     -0.411458     -0.923494      0.923494       118.065       118.989    
loop,thermsimp(1:2)       88   3.39654       8.30883    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    235        111.85         67.85          1.09         41.96          0.56          0.05        111.51
Just calling func    0   0        111.51


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    236        112.73         67.87          1.05         41.94          0.67          0.05        111.58
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    111.85
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       88
neval is:      235
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       88      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       89
neval is:      235


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      235     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.876761     -0.131521     -0.295192      0.295192       107.085       107.380    
   2  0.765270     -0.267527     -0.600449      0.600449       110.113       110.714    
   3  0.215687      -1.53393      -3.44281       3.44281       110.057       113.499    
   4  0.999601E-01  -2.30298      -5.16891       5.16891       110.310       115.479    
   5  0.706519     -0.347405     -0.779730      0.779730       108.292       109.072    
   6  0.201358      -1.60267      -3.59710       3.59710       111.772       115.369    
   7  0.450677     -0.797005      -1.78883       1.78883       110.854       112.643    
   8  0.897557     -0.108078     -0.242576      0.242576       111.829       112.072    
   9  0.161166      -1.82532      -4.09682       4.09682       110.495       114.592    
  10  0.972556E-01  -2.33041      -5.23047       5.23047       110.730       115.960    
  11  0.742112     -0.298255     -0.669415      0.669415       111.494       112.163    
  12  0.172377      -1.75807      -3.94588       3.94588       112.939       116.885    
  13  0.658751     -0.417410     -0.936851      0.936851       110.739       111.676    
  14  0.725340     -0.321114     -0.720722      0.720722       112.280       113.001    
  15  0.501488     -0.690175      -1.54906       1.54906       112.068       113.617    
  16  0.845372     -0.167978     -0.377018      0.377018       112.670       113.047    
  17  0.132369      -2.02216      -4.53862       4.53862       114.282       118.821    
  18  0.734515E-01  -2.61113      -5.86053       5.86053       112.700       118.561    
  19  0.391205     -0.938523      -2.10646       2.10646       113.539       115.646    
  20  0.376983     -0.975555      -2.18958       2.18958       112.604       114.794    
  21  0.315463      -1.15371      -2.58944       2.58944       112.210       114.800    
  22  0.267113      -1.32008      -2.96285       2.96285       113.409       116.372    
  23  0.965292     -0.353243E-01 -0.792834E-01  0.792834E-01   111.110       111.190    
  24  0.954592     -0.464714E-01 -0.104302      0.104302       114.398       114.502    
  25  0.992414     -0.761515E-02 -0.170918E-01  0.170918E-01   107.064       107.081    
  26  0.867953E-02  -4.74679      -10.6539       10.6539       113.620       124.274    
  27  0.829585     -0.186829     -0.419327      0.419327       112.739       113.158    
  28  0.349695      -1.05069      -2.35822       2.35822       110.699       113.058    
  29  0.673511     -0.395251     -0.887118      0.887118       111.506       112.393    
  30  0.340696      -1.07676      -2.41673       2.41673       116.462       118.879    
  31  0.558731     -0.582087      -1.30646       1.30646       115.675       116.981    
  32  0.747295     -0.291295     -0.653794      0.653794       110.597       111.251    
  33  0.123287      -2.09324      -4.69816       4.69816       112.407       117.105    
  34  0.355051      -1.03549      -2.32410       2.32410       116.825       119.150    
  35  0.511895     -0.669636      -1.50296       1.50296       115.056       116.559    
  36  0.571856E-01  -2.86145      -6.42236       6.42236       116.997       123.419    
  37  0.507517     -0.678226      -1.52224       1.52224       118.065       119.588    
  38  0.326770      -1.11850      -2.51040       2.51040       118.223       120.734    
  39  0.736001     -0.306523     -0.687973      0.687973       116.185       116.873    
  40  0.970046     -0.304120E-01 -0.682579E-01  0.682579E-01   113.219       113.287    
  41  0.673510     -0.395253     -0.887121      0.887121       116.602       117.490    
  42  0.335032      -1.09353      -2.45436       2.45436       110.750       113.204    
  43  0.872321E-01  -2.43918      -5.47460       5.47460       114.506       119.981    
  44  0.749956     -0.287741     -0.645817      0.645817       116.887       117.533    
  45  0.159001      -1.83884      -4.12718       4.12718       116.763       120.891    
  46  0.529687     -0.635468      -1.42627       1.42627       111.852       113.279    
loop,thermsimp(1:2)       89  0.295192      0.600449    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    237        114.43         67.80          1.11         42.47          0.51          0.05        111.94
Just calling func    0   0        111.94


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    114.43
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       89
neval is:      236
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       89      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       90
neval is:      236


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      236     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.157371      -1.84915      -4.15030       4.15030       107.064       111.214    
   2  0.894146     -0.111886     -0.251121      0.251121       107.085       107.336    
   3  0.721270     -0.326741     -0.733352      0.733352       108.292       109.026    
   4  0.536866     -0.622006      -1.39606       1.39606       110.113       111.509    
   5  0.418107     -0.872017      -1.95719       1.95719       111.110       113.067    
   6  0.391189     -0.938564      -2.10655       2.10655       110.597       112.704    
   7  0.799669     -0.223558     -0.501762      0.501762       110.739       111.241    
   8  0.595070     -0.519076      -1.16504       1.16504       111.829       112.994    
   9  0.384356E-03  -7.86394      -17.6502       17.6502       111.494       129.144    
  10  0.654302     -0.424187     -0.952062      0.952062       111.506       112.458    
  11  0.873355     -0.135413     -0.303927      0.303927       110.854       111.158    
  12  0.303212      -1.19332      -2.67834       2.67834       112.280       114.958    
  13  0.434159     -0.834344      -1.87264       1.87264       112.670       114.542    
  14  0.970825     -0.296089E-01 -0.664555E-01  0.664555E-01   110.699       110.766    
  15  0.405896     -0.901659      -2.02372       2.02372       112.739       114.762    
  16  0.250423      -1.38461      -3.10767       3.10767       110.750       113.858    
  17  0.517030     -0.659654      -1.48055       1.48055       111.852       113.333    
  18  0.165468      -1.79897      -4.03769       4.03769       113.219       117.257    
  19  0.679403     -0.386541     -0.867568      0.867568       110.057       110.924    
  20  0.554013     -0.590567      -1.32549       1.32549       112.068       113.394    
  21  0.211764E-01  -3.85487      -8.65203       8.65203       114.398       123.050    
  22  0.453828     -0.790038      -1.77319       1.77319       110.495       112.269    
  23  0.377409     -0.974426      -2.18704       2.18704       112.604       114.791    
  24  0.496879     -0.699408      -1.56978       1.56978       112.210       113.780    
  25  0.214619      -1.53889      -3.45395       3.45395       111.772       115.225    
  26  0.724154     -0.322751     -0.724396      0.724396       110.310       111.034    
  27  0.385609     -0.952932      -2.13880       2.13880       113.539       115.678    
  28  0.777864     -0.251204     -0.563812      0.563812       110.730       111.294    
  29  0.709283     -0.343500     -0.770966      0.770966       113.409       114.180    
  30  0.191760      -1.65151      -3.70672       3.70672       115.056       118.763    
  31  0.347616      -1.05666      -2.37160       2.37160       116.185       118.557    
  32  0.191581      -1.65244      -3.70881       3.70881       112.939       116.648    
  33  0.770989     -0.260081     -0.583738      0.583738       115.675       116.259    
  34  0.788566E-01  -2.54012      -5.70116       5.70116       112.407       118.108    
  35  0.229474      -1.47197      -3.30374       3.30374       116.602       119.906    
  36  0.339326      -1.08079      -2.42578       2.42578       116.887       119.313    
  37  0.220886      -1.51011      -3.38935       3.38935       112.700       116.090    
  38  0.223644      -1.49770      -3.36150       3.36150       114.282       117.644    
  39  0.138287      -1.97842      -4.44045       4.44045       116.462       120.903    
  40  0.796402     -0.227651     -0.510950      0.510950       116.825       117.336    
  41  0.104384      -2.25968      -5.07172       5.07172       118.065       123.137    
  42  0.919642     -0.837713E-01 -0.188020      0.188020       114.506       114.694    
  43  0.360767      -1.01952      -2.28826       2.28826       118.223       120.511    
  44  0.924300     -0.787181E-01 -0.176678      0.176678       116.763       116.940    
  45  0.561139     -0.577786      -1.29681       1.29681       116.997       118.294    
  46  0.509073E-01  -2.97775      -6.68338       6.68338       114.426       121.110    
loop,thermsimp(1:2)       90   4.15030      0.251121    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    238        111.22         67.76          1.10         42.02          0.70          0.05        111.62
Just calling func    0   0        111.62


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    111.22
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       90
neval is:      237
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       90      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       91
neval is:      237


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      237     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.102884      -2.27415      -5.10419       5.10419       107.085       112.189    
   2  0.846291     -0.166892     -0.374579      0.374579       108.292       108.667    
   3  0.167054      -1.78944      -4.01628       4.01628       110.699       114.716    
   4  0.786038     -0.240750     -0.540350      0.540350       110.057       110.597    
   5  0.680218     -0.385341     -0.864876      0.864876       110.310       111.175    
   6  0.843894     -0.169729     -0.380947      0.380947       110.854       111.235    
   7  0.295559      -1.21889      -2.73572       2.73572       107.064       109.800    
   8  0.383493     -0.958433      -2.15115       2.15115       110.739       112.890    
   9  0.867247     -0.142431     -0.319678      0.319678       110.730       111.050    
  10  0.241960      -1.41898      -3.18482       3.18482       110.113       113.298    
  11  0.486925     -0.719645      -1.61520       1.61520       110.495       112.111    
  12  0.750166     -0.287460     -0.645188      0.645188       111.506       112.151    
  13  0.507045     -0.679156      -1.52433       1.52433       110.597       112.121    
  14  0.237743      -1.43656      -3.22428       3.22428       111.829       115.053    
  15  0.256837E-01  -3.66190      -8.21891       8.21891       111.110       119.329    
  16  0.776460     -0.253010     -0.567865      0.567865       111.852       112.420    
  17  0.316300      -1.15106      -2.58350       2.58350       112.068       114.652    
  18  0.493161     -0.706919      -1.58664       1.58664       112.210       113.797    
  19  0.807271     -0.214096     -0.480526      0.480526       110.750       111.231    
  20  0.338915      -1.08201      -2.42850       2.42850       113.409       115.837    
  21  0.132986      -2.01751      -4.52818       4.52818       112.670       117.198    
  22  0.409975     -0.891659      -2.00128       2.00128       114.506       116.508    
  23  0.525021     -0.644317      -1.44613       1.44613       112.739       114.185    
  24  0.393064     -0.933783      -2.09582       2.09582       112.604       114.700    
  25  0.176068      -1.73689      -3.89834       3.89834       112.280       116.178    
  26  0.965490     -0.351191E-01 -0.788228E-01  0.788228E-01   111.772       111.850    
  27  0.387767     -0.947350      -2.12627       2.12627       113.539       115.666    
  28  0.936248     -0.658753E-01 -0.147853      0.147853       112.700       112.848    
  29  0.914720     -0.891370E-01 -0.200063      0.200063       115.675       115.875    
  30  0.332171      -1.10211      -2.47361       2.47361       112.939       115.413    
  31  0.845314E-01  -2.47063      -5.54519       5.54519       116.763       122.309    
  32  0.687741     -0.374343     -0.840191      0.840191       113.219       114.059    
  33  0.899776     -0.105610     -0.237034      0.237034       116.825       117.062    
  34  0.558791     -0.581980      -1.30622       1.30622       114.282       115.589    
  35  0.882799     -0.124658     -0.279788      0.279788       112.407       112.686    
  36  0.235569      -1.44575      -3.24490       3.24490       116.997       120.242    
  37  0.533400     -0.628484      -1.41059       1.41059       116.185       117.596    
  38  0.147169      -1.91617      -4.30073       4.30073       115.056       119.357    
  39  0.966208E-01  -2.33696      -5.24517       5.24517       116.887       122.132    
  40  0.952887     -0.482588E-01 -0.108314      0.108314       116.602       116.711    
  41  0.155551      -1.86078      -4.17641       4.17641       118.223       122.400    
  42  0.645067     -0.438401     -0.983966      0.983966       116.462       117.446    
  43  0.394254     -0.930759      -2.08903       2.08903       114.426       116.515    
  44  0.546893     -0.603501      -1.35452       1.35452       114.398       115.752    
  45  0.390314     -0.940803      -2.11158       2.11158       118.065       120.177    
  46  0.311561      -1.16616      -2.61738       2.61738       111.225       113.842    
loop,thermsimp(1:2)       91   5.10419      0.374579    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    239        110.27         67.85          1.09         42.22          0.66          0.05        111.88
Just calling func    0   0        111.88


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    110.27
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       91
neval is:      238
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       91      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       92
neval is:      238


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      238     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.218624      -1.52040      -3.41245       3.41245       108.292       111.705    
   2  0.389473     -0.942961      -2.11642       2.11642       107.064       109.180    
   3  0.919121     -0.843378E-01 -0.189291      0.189291       110.057       110.246    
   4  0.970518     -0.299250E-01 -0.671649E-01  0.671649E-01   110.730       110.797    
   5  0.713317     -0.337830     -0.758239      0.758239       110.310       111.068    
   6  0.639607     -0.446902      -1.00305       1.00305       110.750       111.753    
   7  0.712661     -0.338749     -0.760302      0.760302       110.854       111.615    
   8  0.212311      -1.54970      -3.47822       3.47822       111.772       115.250    
   9  0.831769     -0.184200     -0.413427      0.413427       110.495       110.909    
  10  0.794875     -0.229571     -0.515258      0.515258       110.597       111.112    
  11  0.909815     -0.945137E-01 -0.212131      0.212131       111.506       111.718    
  12  0.753651E-01  -2.58541      -5.80280       5.80280       107.085       112.888    
  13  0.676081     -0.391442     -0.878569      0.878569       111.852       112.731    
  14  0.597437     -0.515107      -1.15613       1.15613       112.407       113.563    
  15  0.146947      -1.91768      -4.30412       4.30412       112.700       117.004    
  16  0.854910     -0.156760     -0.351838      0.351838       110.739       111.091    
  17  0.984999     -0.151146E-01 -0.339238E-01  0.339238E-01   110.113       110.147    
  18  0.533419     -0.628448      -1.41051       1.41051       112.210       113.621    
  19  0.383774     -0.957703      -2.14951       2.14951       111.225       113.374    
  20  0.691729     -0.368561     -0.827214      0.827214       113.219       114.046    
  21  0.313732E-01  -3.46180      -7.76981       7.76981       112.739       120.508    
  22  0.415635     -0.877947      -1.97050       1.97050       112.068       114.039    
  23  0.288746      -1.24221      -2.78806       2.78806       112.604       115.392    
  24  0.176464      -1.73464      -3.89329       3.89329       110.699       114.593    
  25  0.881312     -0.126344     -0.283572      0.283572       111.829       112.113    
  26  0.962783     -0.379267E-01 -0.851243E-01  0.851243E-01   112.939       113.024    
  27  0.415450     -0.878393      -1.97150       1.97150       114.282       116.254    
  28  0.271836      -1.30256      -2.92351       2.92351       113.539       116.463    
  29  0.926655     -0.761736E-01 -0.170967      0.170967       114.398       114.569    
  30  0.277790      -1.28089      -2.87488       2.87488       113.409       116.284    
  31  0.189974      -1.66087      -3.72772       3.72772       115.675       119.403    
  32  0.410540     -0.890281      -1.99818       1.99818       112.280       114.278    
  33  0.952387     -0.487839E-01 -0.109493      0.109493       114.506       114.616    
  34  0.896015     -0.109798     -0.246435      0.246435       114.426       114.673    
  35  0.121549E-01  -4.41002      -9.89803       9.89803       116.602       126.500    
  36  0.723911     -0.323087     -0.725151      0.725151       116.825       117.551    
  37  0.759053     -0.275683     -0.618755      0.618755       112.670       113.289    
  38  0.969929     -0.305320E-01 -0.685273E-01  0.685273E-01   116.462       116.531    
  39  0.852636     -0.159422     -0.357814      0.357814       116.185       116.543    
  40  0.730471     -0.314065     -0.704901      0.704901       111.110       111.815    
  41  0.528358     -0.637981      -1.43191       1.43191       115.056       116.488    
  42  0.404403     -0.905344      -2.03199       2.03199       118.065       120.097    
  43  0.232822      -1.45748      -3.27123       3.27123       116.997       120.268    
  44  0.847643     -0.165296     -0.370996      0.370996       116.887       117.258    
  45  0.429393E-01  -3.14797      -7.06543       7.06543       116.763       123.829    
  46  0.673157     -0.395777     -0.888299      0.888299       110.272       111.160    
loop,thermsimp(1:2)       92   3.41245       2.11642    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    240        110.16         67.84          1.10         42.17          0.49          0.05        111.65
Just calling func    0   0        111.66


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    241        107.96         67.98          1.11         42.11          0.40          0.05        111.64
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  240    107.96       0.5818     -3.130      2.416     -102.6     0.2871    
                       1.107     0.3800     -99.70      4.372      1.138    

                       1.648     -2.521      1.540      7676.      7000.    

                      0.4517      0.000      0.000      0.000     -1.221    



                      -2.289      0.000      0.000      7000.      573.7    

                       1.890     -4.431     -6.105     -7.241      6.953    

                      -17.87     -8.087      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.3736    -0.8988      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.5058     -1.538      7000.    



                      -1.735     -1.507     -2.007     -1.957    -0.3807    

                     -0.3252      9.235      8.794    -0.1507E+05 -4.972    

                     -0.7046     -3.083      9.385      8.962    -0.1969E+05



                      -6.000     0.5480    -0.2322E-01  8.992      8.944    

                     -0.1944E+05 -6.000     -1.133    -0.4539      9.144    

                       8.931    -0.1891E+05 -6.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    107.96
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       92
neval is:      240
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       92      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       93
neval is:      240


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      240     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.148595      -1.90653      -4.27910       4.27910       107.064       111.343    
   2  0.695074     -0.363738     -0.816388      0.816388       110.113       110.930    
   3  0.541180     -0.614003      -1.37809       1.37809       110.057       111.435    
   4  0.189791      -1.66183      -3.72988       3.72988       110.730       114.460    
   5  0.245553      -1.40424      -3.15174       3.15174       110.495       113.647    
   6  0.641474     -0.443986     -0.996502      0.996502       110.310       111.307    
   7  0.308462      -1.17616      -2.63981       2.63981       110.739       113.379    
   8  0.478005     -0.738133      -1.65670       1.65670       110.597       112.254    
   9  0.395759     -0.926951      -2.08049       2.08049       110.272       112.353    
  10  0.438776E-01  -3.12635      -7.01691       7.01691       110.854       117.871    
  11  0.294628E-01  -3.52463      -7.91082       7.91082       108.292       116.203    
  12  0.331052E-01  -3.40806      -7.64920       7.64920       111.506       119.155    
  13  0.916325E-01  -2.38997      -5.36415       5.36415       110.750       116.114    
  14  0.985908     -0.141919E-01 -0.318528E-01  0.318528E-01   111.110       111.142    
  15  0.511724     -0.669970      -1.50371       1.50371       111.829       113.333    
  16  0.185695      -1.68365      -3.77885       3.77885       111.852       115.631    
  17  0.830711     -0.185474     -0.416285      0.416285       107.085       107.502    
  18  0.765179E-04  -9.47799      -21.2728       21.2728       112.939       134.212    
  19  0.129365      -2.04512      -4.59015       4.59015       112.670       117.260    
  20  0.796363     -0.227700     -0.511058      0.511058       111.225       111.736    
  21  0.589256     -0.528895      -1.18707       1.18707       112.407       113.594    
  22  0.770995     -0.260073     -0.583719      0.583719       112.210       112.794    
  23  0.685430     -0.377709     -0.847747      0.847747       112.068       112.916    
  24  0.487688     -0.718080      -1.61169       1.61169       113.219       114.831    
  25  0.114898      -2.16371      -4.85633       4.85633       112.280       117.136    
  26  0.165093      -1.80124      -4.04279       4.04279       114.398       118.441    
  27  0.302275      -1.19642      -2.68529       2.68529       110.699       113.385    
  28  0.123669      -2.09014      -4.69120       4.69120       114.506       119.198    
  29  0.960526     -0.402739E-01 -0.903923E-01  0.903923E-01   114.426       114.517    
  30  0.744557     -0.294966     -0.662033      0.662033       111.772       112.434    
  31  0.418436     -0.871232      -1.95543       1.95543       112.604       114.559    
  32  0.624411     -0.470947      -1.05701       1.05701       114.282       115.339    
  33  0.920055     -0.833222E-01 -0.187012      0.187012       113.409       113.596    
  34  0.330507      -1.10713      -2.48488       2.48488       113.539       116.024    
  35  0.889566     -0.117022     -0.262648      0.262648       115.056       115.319    
  36  0.269410      -1.31152      -2.94363       2.94363       116.462       119.406    
  37  0.458780     -0.779184      -1.74883       1.74883       116.185       117.934    
  38  0.952588     -0.485730E-01 -0.109019      0.109019       112.700       112.809    
  39  0.213836      -1.54254      -3.46215       3.46215       116.887       120.349    
  40  0.460697     -0.775015      -1.73948       1.73948       116.825       118.565    
  41  0.571693     -0.559153      -1.25499       1.25499       115.675       116.930    
  42  0.201363      -1.60265      -3.59705       3.59705       118.065       121.662    
  43  0.707817     -0.345570     -0.775612      0.775612       116.997       117.773    
  44  0.927118     -0.756745E-01 -0.169847      0.169847       112.739       112.908    
  45  0.288916      -1.24162      -2.78674       2.78674       116.763       119.550    
  46  0.702737     -0.352773     -0.791778      0.791778       107.960       108.752    
loop,thermsimp(1:2)       93   4.27910      0.816388    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    242        109.79         67.85          1.12         42.00          0.59          0.05        111.61
Just calling func    0   0        111.61


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    243        112.38         67.88          1.11         42.06          0.54          0.05        111.63
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    109.79
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       93
neval is:      242
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       93      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       94
neval is:      242


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      242     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.842284     -0.171638     -0.385231      0.385231       107.085       107.470    
   2  0.478368     -0.737375      -1.65500       1.65500       107.960       109.615    
   3  0.283498      -1.26055      -2.82923       2.82923       110.113       112.943    
   4  0.520516     -0.652935      -1.46547       1.46547       111.110       112.576    
   5  0.703282E-01  -2.65458      -5.95805       5.95805       110.310       116.268    
   6  0.914137     -0.897748E-01 -0.201494      0.201494       107.064       107.265    
   7  0.479535     -0.734938      -1.64953       1.64953       110.057       111.706    
   8  0.921875     -0.813456E-01 -0.182575      0.182575       111.225       111.407    
   9  0.739547     -0.301718     -0.677188      0.677188       110.597       111.274    
  10  0.790753     -0.234770     -0.526928      0.526928       110.272       110.799    
  11  0.212247E-01  -3.85259      -8.64691       8.64691       111.772       120.418    
  12  0.286971      -1.24837      -2.80190       2.80190       112.210       115.012    
  13  0.695666     -0.362886     -0.814476      0.814476       112.700       113.515    
  14  0.534590     -0.626255      -1.40559       1.40559       112.739       114.144    
  15  0.945577     -0.559603E-01 -0.125600      0.125600       112.068       112.194    
  16  0.619446     -0.478930      -1.07493       1.07493       111.829       112.904    
  17  0.291083E-01  -3.53673      -7.93798       7.93798       110.739       118.677    
  18  0.372584E-01  -3.28988      -7.38394       7.38394       110.699       118.083    
  19  0.713241     -0.337936     -0.758477      0.758477       112.407       113.165    
  20  0.280281      -1.27196      -2.85484       2.85484       113.409       116.264    
  21  0.254796      -1.36729      -3.06881       3.06881       110.495       113.564    
  22  0.498598     -0.695955      -1.56203       1.56203       110.730       112.292    
  23  0.515261E-01  -2.96567      -6.65626       6.65626       114.426       121.083    
  24  0.347627      -1.05662      -2.37153       2.37153       112.604       114.976    
  25  0.696212     -0.362102     -0.812716      0.812716       113.219       114.032    
  26  0.707749E-01  -2.64825      -5.94384       5.94384       115.056       121.000    
  27  0.364523E-01  -3.31175      -7.43303       7.43303       114.282       121.715    
  28  0.895087E-02  -4.71600      -10.5848       10.5848       111.852       122.437    
  29  0.333194      -1.09903      -2.46671       2.46671       113.539       116.006    
  30  0.451375     -0.795457      -1.78536       1.78536       110.750       112.535    
  31  0.849961E-01  -2.46515      -5.53288       5.53288       108.292       113.825    
  32  0.524791     -0.644756      -1.44712       1.44712       115.675       117.122    
  33  0.641068     -0.444619     -0.997922      0.997922       112.280       113.278    
  34  0.757376     -0.277895     -0.623719      0.623719       112.670       113.293    
  35  0.760597     -0.273651     -0.614194      0.614194       116.997       117.611    
  36  0.709070     -0.343801     -0.771641      0.771641       110.854       111.626    
  37  0.794718     -0.229768     -0.515700      0.515700       116.185       116.701    
  38  0.869679     -0.139632     -0.313395      0.313395       114.398       114.711    
  39  0.229100E-01  -3.77618      -8.47542       8.47542       116.825       125.301    
  40  0.935590     -0.665776E-01 -0.149430      0.149430       111.506       111.655    
  41  0.889453     -0.117149     -0.262933      0.262933       114.506       114.769    
  42  0.529054     -0.636665      -1.42896       1.42896       116.462       117.891    
  43  0.907902     -0.966186E-01 -0.216855      0.216855       116.763       116.980    
  44  0.693802     -0.365568     -0.820496      0.820496       116.887       117.707    
  45  0.883803     -0.123521     -0.277236      0.277236       118.065       118.343    
  46  0.275134E-01  -3.59308      -8.06446       8.06446       109.793       117.857    
loop,thermsimp(1:2)       94  0.385231       1.65500    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    244        105.67         67.87          1.10         42.13          0.35          0.05        111.51
Just calling func    0   0        111.51


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    245        105.95         67.88          1.10         42.13          0.65          0.05        111.82
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    105.67
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       94
neval is:      244
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       94      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       95
neval is:      244


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      244     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.744650     -0.294841     -0.661753      0.661753       107.064       107.726    
   2  0.739179     -0.302215     -0.678304      0.678304       107.085       107.764    
   3  0.131167      -2.03128      -4.55909       4.55909       107.960       112.519    
   4  0.523356     -0.647493      -1.45326       1.45326       110.272       111.725    
   5  0.660412     -0.414891     -0.931199      0.931199       110.597       111.528    
   6  0.433074E-01  -3.13943      -7.04627       7.04627       111.225       118.271    
   7  0.480352     -0.733236      -1.64571       1.64571       110.854       112.500    
   8  0.808114     -0.213053     -0.478184      0.478184       111.506       111.984    
   9  0.723804     -0.323235     -0.725481      0.725481       110.057       110.782    
  10  0.322682      -1.13109      -2.53866       2.53866       112.068       114.607    
  11  0.898907     -0.106576     -0.239204      0.239204       110.730       110.969    
  12  0.359972      -1.02173      -2.29321       2.29321       110.750       113.043    
  13  0.879118     -0.128836     -0.289165      0.289165       111.110       111.399    
  14  0.963559     -0.371220E-01 -0.833181E-01  0.833181E-01   111.829       111.912    
  15  0.662848     -0.411210     -0.922936      0.922936       110.113       111.036    
  16  0.648402     -0.433244     -0.972391      0.972391       112.407       113.379    
  17  0.375343     -0.979916      -2.19936       2.19936       112.280       114.479    
  18  0.812441     -0.207712     -0.466198      0.466198       112.670       113.136    
  19  0.248177E-01  -3.69620      -8.29590       8.29590       112.700       120.996    
  20  0.653530     -0.425366     -0.954709      0.954709       110.495       111.450    
  21  0.712244     -0.339334     -0.761616      0.761616       108.292       109.054    
  22  0.358229      -1.02658      -2.30410       2.30410       113.219       115.523    
  23  0.325518      -1.12234      -2.51902       2.51902       112.739       115.258    
  24  0.770349     -0.260912     -0.585601      0.585601       114.398       114.983    
  25  0.633518E-01  -2.75905      -6.19253       6.19253       114.506       120.699    
  26  0.168796      -1.77907      -3.99301       3.99301       112.604       116.597    
  27  0.562007     -0.576241      -1.29334       1.29334       112.210       113.504    
  28  0.156316      -1.85588      -4.16541       4.16541       113.539       117.705    
  29  0.967732     -0.328002E-01 -0.736182E-01  0.736182E-01   113.409       113.483    
  30  0.538071     -0.619766      -1.39103       1.39103       110.310       111.701    
  31  0.967495     -0.330453E-01 -0.741683E-01  0.741683E-01   116.185       116.259    
  32  0.771619     -0.259265     -0.581904      0.581904       116.763       117.345    
  33  0.246044      -1.40225      -3.14726       3.14726       115.675       118.822    
  34  0.700731     -0.355631     -0.798194      0.798194       116.997       117.795    
  35  0.382714     -0.960468      -2.15571       2.15571       116.887       119.043    
  36  0.580395     -0.544047      -1.22108       1.22108       109.793       111.014    
  37  0.305131      -1.18701      -2.66418       2.66418       116.462       119.126    
  38  0.624250     -0.471204      -1.05759       1.05759       110.699       111.757    
  39  0.575432     -0.552634      -1.24035       1.24035       118.065       119.306    
  40  0.701335     -0.354770     -0.796260      0.796260       110.739       111.535    
  41  0.290211      -1.23715      -2.77670       2.77670       111.772       114.548    
  42  0.140976      -1.95916      -4.39723       4.39723       115.056       119.453    
  43  0.275714      -1.28839      -2.89172       2.89172       114.426       117.318    
  44  0.856479     -0.154925     -0.347721      0.347721       114.282       114.630    
  45  0.994286     -0.573084E-02 -0.128625E-01  0.128625E-01   111.852       111.865    
  46  0.913008     -0.910102E-01 -0.204267      0.204267       105.672       105.876    
loop,thermsimp(1:2)       95  0.661753      0.678304    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    246        121.84         68.06          1.11         42.60          0.25          0.05        112.07
Just calling func    0   0        112.07


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    247        109.84         67.85          1.11         42.30          0.68          0.05        111.99
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    109.84
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       95
neval is:      246
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       95      95
 right before GO TO 250



 right after: 250 IF (loop < nloop) CYCLE Main_loop 
loop,nloop:       95      95
loop was equal to nloop so did not start main cycle again, now will do the following: 




calculate mean & stdev of func values for current simplex (hmean,hstd)
 write hstd
 RMS of function values of last simplex =   2.77284    

hmean,hstd :    112.119       2.77284    


writing best so far by calling functn2 
 but just writing params not moments. see the change in functn2
hmean,hstd :    112.119       2.77284    
h(1),h(best1),h(np1) :    105.672       105.672       109.837    
htherm(1),htherm(best1),htherm(np1) :    105.876       105.876       120.996    


 CHECK hstd>?stopcr
---------> IF hstd>stopcr (and maxfn,neval.nevalp conditions as well) then set iflag and loop to zero and go to the start of the main cycle again 
---------> IF hstd<=stopcr then find the centroid of the current simplex and get the function value there 
 ............
 ............
 ............
 ............
  .NOT. (hstd > stopcr .AND. (((maxfn>=0).AND.(neval <= maxfn)).OR.((maxfn<0).AND.(nevalp <= -1*maxfn))  )) 
  so find the centroid of current simplex and get teh function value there 
  call functn(p,func) 
  neval = neval + 1
  nevalp = nevalp + 1
  IF ((iprint > 0).AND.(realrank==0)) THEN 
     IF (MOD(neval,iprint) == 0) WRITE (lout,5100) neval, func, p 
  END IF  
  CHECK wtr the no. of func values allowed, maxfn, has been overrun. if so, exit with ifault= 1 
  IF maxfn>0 check based on neval. if maxfn<0 check based on nevalp. 
  i.e.: ---->IF (((maxfn>=0).AND.(neval > maxfn)).OR.((maxfn<0).AND.(nevalp > -1*maxfn))) THEN
        ---->IF the above if statement true then something ... RETURN 
        ---->IF the above if statement not true then you get out of that if statement ... CONVGENCE CRTI SATISFIED - RETURN 
 ............
 ............
iter,obj,time:    248        110.48         67.76          1.09         42.15          0.51          0.05        111.56

 EVIDENCE OF CONVERGENCE

 Centroid of last simplex =
   0.97902      -2.5265       2.7164      -102.60      0.75547      0.99452    

    1.0294      -99.700       3.9178      0.73948       1.8884      -2.2302    

    1.5400       7145.9       7000.0      0.18429       0.0000       0.0000    

    0.0000      -1.2210      -2.3941       0.0000       0.0000       7000.0    


    442.44       1.6749      -5.2147      -4.7146      -7.9248       6.6221    

   -15.860      -5.4596       5362.0       0.0000       6393.0       2126.0    

    6450.0       6136.0       2928.0       4107.0       3756.0      0.11050E-01

   0.25440     -0.33480E-01  0.15100     -0.24860     -0.14460      0.13940    


   0.80450E-01  0.91570E-01 -0.41865     -0.76147       0.0000      0.84570E-01

  -0.39310E-01 -0.46970E-01  0.14310     -0.71160     -0.11410      0.26950    

   0.32880E-01  0.15250E-02 -0.55952      -1.1804       7000.0      -1.4446    

   -1.3113      -2.0973      -1.9685     -0.38070     -0.32520       9.2233    


    8.7453      -16004.      -5.5755     -0.46785      -2.5631       9.3666    

    8.8717      -19690.      -6.0000      0.56189     -0.20747       8.9205    

    9.0102      -19440.      -6.0000     -0.89191     -0.56064       9.1114    

    8.8407      -18910.      -6.0000    
 Function value at centroid =   110.484    

beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:        1
neval is:      247


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      247     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.204528E-01  -3.88964      -8.73006       8.73006       105.672       114.402    
   2  0.977100     -0.231667E-01 -0.519962E-01  0.519962E-01   107.064       107.116    
   3  0.491467     -0.710361      -1.59436       1.59436       107.085       108.680    
   4  0.802113E-01  -2.52309      -5.66293       5.66293       108.292       113.955    
   5  0.891044     -0.115361     -0.258922      0.258922       110.057       110.315    
   6  0.397551     -0.922433      -2.07035       2.07035       110.730       112.800    
   7  0.121203      -2.11029      -4.73642       4.73642       109.793       114.529    
   8  0.789985E-01  -2.53833      -5.69712       5.69712       110.113       115.811    
   9  0.921855     -0.813679E-01 -0.182625      0.182625       111.110       111.293    
  10  0.252671      -1.37567      -3.08760       3.08760       110.495       113.583    
  11  0.787271     -0.239182     -0.536830      0.536830       110.597       111.134    
  12  0.634653     -0.454676      -1.02049       1.02049       110.739       111.760    
  13  0.706648     -0.347222     -0.779319      0.779319       110.310       111.089    
  14  0.349740E-01  -3.35315      -7.52595       7.52595       110.272       117.798    
  15  0.686787     -0.375731     -0.843305      0.843305       110.699       111.543    
  16  0.309348      -1.17329      -2.63338       2.63338       111.852       114.486    
  17  0.703748     -0.351336     -0.788552      0.788552       111.829       112.617    
  18  0.985092     -0.150207E-01 -0.337132E-01  0.337132E-01   111.506       111.539    
  19  0.440741     -0.819298      -1.83887       1.83887       110.854       112.693    
  20  0.796112     -0.228015     -0.511767      0.511767       107.960       108.472    
  21  0.451938     -0.794210      -1.78256       1.78256       110.750       112.533    
  22  0.230902      -1.46576      -3.28982       3.28982       112.670       115.960    
  23  0.760212     -0.274159     -0.615333      0.615333       112.407       113.022    
  24  0.250434E-02  -5.98973      -13.4436       13.4436       113.409       126.853    
  25  0.627913E-01  -2.76794      -6.21248       6.21248       112.210       118.423    
  26  0.263128      -1.33511      -2.99659       2.99659       112.280       115.276    
  27  0.177986      -1.72605      -3.87402       3.87402       111.772       115.646    
  28  0.919776     -0.836247E-01 -0.187691      0.187691       112.068       112.256    
  29  0.854272     -0.157506     -0.353513      0.353513       114.282       114.636    
  30  0.648187     -0.433576     -0.973135      0.973135       114.398       115.371    
  31  0.853797     -0.158061     -0.354760      0.354760       112.739       113.093    
  32  0.484551     -0.724533      -1.62617       1.62617       113.219       114.845    
  33  0.423817     -0.858454      -1.92675       1.92675       116.185       118.112    
  34  0.932015     -0.704065E-01 -0.158023      0.158023       112.604       112.762    
  35  0.161906      -1.82074      -4.08655       4.08655       114.426       118.513    
  36  0.812519     -0.207617     -0.465983      0.465983       116.763       117.229    
  37  0.346838      -1.05890      -2.37664       2.37664       113.539       115.916    
  38  0.477141     -0.739943      -1.66076       1.66076       116.997       118.658    
  39  0.931946     -0.704808E-01 -0.158190      0.158190       111.225       111.383    
  40  0.189794      -1.66182      -3.72985       3.72985       115.675       119.405    
  41  0.361902      -1.01638      -2.28121       2.28121       116.887       119.168    
  42  0.775630E-02  -4.85925      -10.9063       10.9063       116.462       127.368    
  43  0.292497      -1.22930      -2.75909       2.75909       118.065       120.824    
  44  0.264300      -1.33067      -2.98661       2.98661       115.056       118.043    
  45  0.529597     -0.635638      -1.42665       1.42665       114.506       115.933    
  46  0.163272      -1.81234      -4.06768       4.06768       109.837       113.905    
loop,thermsimp(1:2)        1   8.73006      0.519962E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    249        106.98         67.82          1.09         42.34          0.70          0.05        112.00
Just calling func    0   0        112.00


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    250        106.58         67.88          1.10         42.16          0.75          0.05        111.94
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    106.58
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:        1
neval is:      249
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        1      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:        2
neval is:      249


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      249     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.225672      -1.48867      -3.34124       3.34124       107.064       110.405    
   2  0.726663     -0.319292     -0.716632      0.716632       107.960       108.677    
   3  0.929061     -0.735808E-01 -0.165148      0.165148       107.085       107.250    
   4  0.764703     -0.268268     -0.602112      0.602112       110.057       110.659    
   5  0.119617      -2.12346      -4.76599       4.76599       110.310       115.076    
   6  0.369672     -0.995138      -2.23353       2.23353       110.597       112.831    
   7  0.875806     -0.132611     -0.297638      0.297638       111.110       111.408    
   8  0.657886     -0.418723     -0.939799      0.939799       111.225       112.165    
   9  0.387095E-01  -3.25167      -7.29818       7.29818       111.506       118.804    
  10  0.454078     -0.789485      -1.77195       1.77195       110.699       112.471    
  11  0.890470     -0.116006     -0.260368      0.260368       110.739       110.999    
  12  0.118445      -2.13331      -4.78808       4.78808       112.068       116.856    
  13  0.190238      -1.65948      -3.72461       3.72461       110.750       114.475    
  14  0.435624     -0.830976      -1.86508       1.86508       111.829       113.694    
  15  0.768655     -0.263114     -0.590543      0.590543       110.854       111.445    
  16  0.870896E-01  -2.44082      -5.47827       5.47827       112.604       118.082    
  17  0.936453     -0.656556E-01 -0.147360      0.147360       110.730       110.877    
  18  0.159312      -1.83689      -4.12279       4.12279       112.407       116.529    
  19  0.988165     -0.119051E-01 -0.267203E-01  0.267203E-01   112.739       112.765    
  20  0.713347     -0.337787     -0.758143      0.758143       110.495       111.253    
  21  0.417075     -0.874489      -1.96274       1.96274       109.837       111.800    
  22  0.719048     -0.329827     -0.740277      0.740277       108.292       109.032    
  23  0.785519     -0.241411     -0.541833      0.541833       105.672       106.214    
  24  0.356994      -1.03004      -2.31185       2.31185       111.852       114.164    
  25  0.357951      -1.02736      -2.30585       2.30585       109.793       112.099    
  26  0.154816      -1.86552      -4.18705       4.18705       114.282       118.469    
  27  0.246912      -1.39872      -3.13935       3.13935       113.219       116.358    
  28  0.553458     -0.591570      -1.32774       1.32774       112.280       113.608    
  29  0.729602     -0.315256     -0.707574      0.707574       114.398       115.105    
  30  0.605470     -0.501750      -1.12615       1.12615       111.772       112.898    
  31  0.278987E-01  -3.57918      -8.03325       8.03325       110.113       118.147    
  32  0.187991      -1.67136      -3.75128       3.75128       113.539       117.291    
  33  0.543158     -0.610355      -1.36991       1.36991       114.506       115.876    
  34  0.996749     -0.325625E-02 -0.730845E-02  0.730845E-02   112.670       112.677    
  35  0.540727     -0.614841      -1.37997       1.37997       116.763       118.143    
  36  0.833271E-01  -2.48498      -5.57739       5.57739       110.272       115.849    
  37  0.404538     -0.905011      -2.03124       2.03124       115.056       117.087    
  38  0.147302      -1.91527      -4.29871       4.29871       116.185       120.484    
  39  0.364226E-01  -3.31257      -7.43486       7.43486       112.210       119.645    
  40  0.381304     -0.964158      -2.16400       2.16400       114.426       116.590    
  41  0.737758     -0.304140     -0.682624      0.682624       116.997       117.680    
  42  0.179374      -1.71828      -3.85658       3.85658       116.887       120.744    
  43  0.281757      -1.26671      -2.84306       2.84306       115.675       118.518    
  44  0.192633      -1.64697      -3.69652       3.69652       118.065       121.762    
  45  0.954983     -0.460617E-01 -0.103383      0.103383       113.409       113.512    
  46  0.710258     -0.342127     -0.767884      0.767884       106.582       107.349    
loop,thermsimp(1:2)        2   3.34124      0.716632    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    251        117.20         67.84          1.10         42.27          0.37          0.05        111.62
Just calling func    0   0        111.63


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    117.20
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:        2
neval is:      250
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        2      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:        3
neval is:      250


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      250     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.415533     -0.878194      -1.97105       1.97105       105.672       107.643    
   2  0.117190E-02  -6.74913      -15.1480       15.1480       107.085       122.233    
   3  0.432199     -0.838870      -1.88279       1.88279       106.582       108.464    
   4  0.466381     -0.762753      -1.71196       1.71196       107.960       109.672    
   5  0.696685     -0.361422     -0.811190      0.811190       108.292       109.103    
   6  0.193714      -1.64137      -3.68396       3.68396       107.064       110.748    
   7  0.535145     -0.625217      -1.40326       1.40326       110.057       111.460    
   8  0.812984     -0.207044     -0.464699      0.464699       110.730       111.195    
   9  0.956789     -0.441723E-01 -0.991421E-01  0.991421E-01   110.739       110.838    
  10  0.496711E-01  -3.00233      -6.73856       6.73856       110.495       117.234    
  11  0.206308E-01  -3.88097      -8.71061       8.71061       111.110       119.821    
  12  0.423434     -0.859358      -1.92878       1.92878       110.854       112.783    
  13  0.216826      -1.52866      -3.43099       3.43099       109.837       113.268    
  14  0.792422     -0.232661     -0.522195      0.522195       109.793       110.315    
  15  0.265940      -1.32449      -2.97273       2.97273       111.225       114.198    
  16  0.993400     -0.662201E-02 -0.148627E-01  0.148627E-01   110.699       110.714    
  17  0.645200E-01  -2.74078      -6.15152       6.15152       112.670       118.821    
  18  0.651527     -0.428436     -0.961600      0.961600       112.739       113.700    
  19  0.858875     -0.152131     -0.341450      0.341450       110.597       110.939    
  20  0.126056      -2.07103      -4.64829       4.64829       111.772       116.420    
  21  0.772661E-01  -2.56050      -5.74689       5.74689       113.409       119.156    
  22  0.441429     -0.817737      -1.83536       1.83536       112.280       114.115    
  23  0.166586      -1.79224      -4.02258       4.02258       111.829       115.852    
  24  0.217490      -1.52560      -3.42413       3.42413       111.852       115.277    
  25  0.632871     -0.457488      -1.02681       1.02681       110.750       111.777    
  26  0.201694      -1.60100      -3.59336       3.59336       110.310       113.903    
  27  0.282690      -1.26341      -2.83564       2.83564       114.398       117.233    
  28  0.255086E-01  -3.66874      -8.23427       8.23427       110.272       118.506    
  29  0.562308     -0.575706      -1.29214       1.29214       114.506       115.798    
  30  0.283366E-01  -3.56360      -7.99829       7.99829       113.219       121.217    
  31  0.404254E-01  -3.20830      -7.20083       7.20083       112.407       119.607    
  32  0.170475      -1.76917      -3.97079       3.97079       114.426       118.397    
  33  0.141712      -1.95396      -4.38554       4.38554       112.068       116.454    
  34  0.773173     -0.257253     -0.577388      0.577388       115.056       115.633    
  35  0.255978      -1.36266      -3.05842       3.05842       113.539       116.598    
  36  0.823739     -0.193902     -0.435201      0.435201       116.997       117.432    
  37  0.166307      -1.79392      -4.02635       4.02635       112.604       116.630    
  38  0.676319     -0.391090     -0.877778      0.877778       116.763       117.641    
  39  0.144546      -1.93416      -4.34110       4.34110       110.113       114.455    
  40  0.593436     -0.521826      -1.17121       1.17121       114.282       115.454    
  41  0.762921     -0.270600     -0.607346      0.607346       115.675       116.282    
  42  0.855796     -0.155724     -0.349512      0.349512       111.506       111.855    
  43  0.433555     -0.835737      -1.87576       1.87576       112.210       114.086    
  44  0.252891      -1.37480      -3.08565       3.08565       116.185       119.271    
  45  0.942909     -0.587850E-01 -0.131940      0.131940       116.887       117.019    
  46  0.432313     -0.838605      -1.88220       1.88220       117.201       119.083    
loop,thermsimp(1:2)        3   1.97105       15.1480    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    252        128.14         67.85          1.11         41.96          0.58          0.05        111.54
Just calling func    0   0        111.54


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    253        114.02         67.84          1.11         42.23          0.52          0.05        111.76
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    114.02
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:        3
neval is:      252
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        3      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:        4
neval is:      252


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      252     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.656626     -0.420640     -0.944102      0.944102       105.672       106.616    
   2  0.880966     -0.126736     -0.284451      0.284451       106.582       106.866    
   3  0.854972     -0.156687     -0.351674      0.351674       108.292       108.644    
   4  0.797101     -0.226774     -0.508981      0.508981       107.960       108.469    
   5  0.158477      -1.84214      -4.13459       4.13459       109.793       113.927    
   6  0.593839     -0.521148      -1.16969       1.16969       110.699       111.869    
   7  0.817101     -0.201993     -0.453361      0.453361       107.064       107.517    
   8  0.997190     -0.281377E-02 -0.631534E-02  0.631534E-02   110.739       110.745    
   9  0.402857     -0.909174      -2.04059       2.04059       110.597       112.638    
  10  0.690455     -0.370405     -0.831352      0.831352       110.730       111.561    
  11  0.609635     -0.494895      -1.11076       1.11076       110.057       111.167    
  12  0.491117     -0.711073      -1.59596       1.59596       110.750       112.346    
  13  0.990676     -0.936814E-02 -0.210262E-01  0.210262E-01   111.506       111.527    
  14  0.976919     -0.233519E-01 -0.524120E-01  0.524120E-01   110.854       110.907    
  15  0.692556     -0.367366     -0.824532      0.824532       109.837       110.662    
  16  0.549694     -0.598394      -1.34306       1.34306       112.739       114.082    
  17  0.538267E-01  -2.92199      -6.55822       6.55822       110.310       116.868    
  18  0.602193     -0.507178      -1.13833       1.13833       112.210       113.349    
  19  0.537276     -0.621243      -1.39434       1.39434       112.280       113.674    
  20  0.338220      -1.08406      -2.43310       2.43310       111.225       113.658    
  21  0.306772      -1.18165      -2.65215       2.65215       110.113       112.766    
  22  0.895389     -0.110497     -0.248005      0.248005       111.852       112.100    
  23  0.120096      -2.11946      -4.75700       4.75700       114.282       119.039    
  24  0.680166     -0.385418     -0.865048      0.865048       115.056       115.921    
  25  0.369434     -0.995782      -2.23497       2.23497       114.506       116.741    
  26  0.235484      -1.44611      -3.24571       3.24571       111.829       115.075    
  27  0.260836      -1.34386      -3.01622       3.01622       115.675       118.691    
  28  0.720259     -0.328144     -0.736501      0.736501       111.772       112.508    
  29  0.695069     -0.363744     -0.816402      0.816402       112.068       112.885    
  30  0.105076      -2.25307      -5.05689       5.05689       113.539       118.596    
  31  0.968349     -0.321628E-01 -0.721875E-01  0.721875E-01   112.604       112.676    
  32  0.974131     -0.262091E-01 -0.588248E-01  0.588248E-01   116.887       116.946    
  33  0.647785E-01  -2.73678      -6.14254       6.14254       114.398       120.540    
  34  0.910402     -0.938690E-01 -0.210683      0.210683       110.495       110.706    
  35  0.488733     -0.715939      -1.60688       1.60688       116.997       118.604    
  36  0.377436E-01  -3.27694      -7.35490       7.35490       116.763       124.118    
  37  0.154608      -1.86686      -4.19006       4.19006       114.426       118.616    
  38  0.277804      -1.28084      -2.87477       2.87477       110.272       113.147    
  39  0.969547     -0.309263E-01 -0.694122E-01  0.694122E-01   112.670       112.739    
  40  0.380083     -0.967367      -2.17120       2.17120       117.201       119.372    
  41  0.751822     -0.285256     -0.640240      0.640240       113.409       114.049    
  42  0.137692      -1.98274      -4.45014       4.45014       116.185       120.635    
  43  0.293470      -1.22598      -2.75164       2.75164       112.407       115.158    
  44  0.433705     -0.835390      -1.87498       1.87498       111.110       112.985    
  45  0.418034     -0.872194      -1.95759       1.95759       113.219       115.177    
  46  0.166728      -1.79139      -4.02068       4.02068       114.020       118.041    
loop,thermsimp(1:2)        4  0.944102      0.284451    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    254        106.88         67.85          1.10         42.05          0.38          0.05        111.43
Just calling func    0   0        111.43


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    255        106.26         67.96          1.12         42.17          0.11          0.05        111.42
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    106.26
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:        4
neval is:      254
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        4      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:        5
neval is:      254


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      254     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.630229     -0.461672      -1.03620       1.03620       105.672       106.708    
   2  0.876370     -0.131967     -0.296192      0.296192       106.582       106.878    
   3  0.840080     -0.174259     -0.391113      0.391113       107.064       107.455    
   4  0.608986E-01  -2.79854      -6.28117       6.28117       107.960       114.241    
   5  0.311901      -1.16507      -2.61493       2.61493       108.292       110.907    
   6  0.937552E-01  -2.36707      -5.31275       5.31275       109.837       115.150    
   7  0.608418     -0.496893      -1.11525       1.11525       110.495       111.611    
   8  0.297707      -1.21164      -2.71946       2.71946       110.739       113.458    
   9  0.365777      -1.00573      -2.25730       2.25730       110.854       113.112    
  10  0.194673      -1.63643      -3.67287       3.67287       110.057       113.729    
  11  0.941388     -0.604003E-01 -0.135565      0.135565       111.506       111.641    
  12  0.984881     -0.152343E-01 -0.341925E-01  0.341925E-01   110.730       110.764    
  13  0.750245     -0.287355     -0.644951      0.644951       110.699       111.344    
  14  0.437446     -0.826803      -1.85571       1.85571       111.852       113.708    
  15  0.174754      -1.74437      -3.91515       3.91515       110.750       114.665    
  16  0.300465E-01  -3.50501      -7.86678       7.86678       111.772       119.638    
  17  0.372924     -0.986380      -2.21387       2.21387       110.597       112.811    
  18  0.803506     -0.218771     -0.491018      0.491018       112.604       113.095    
  19  0.232583      -1.45851      -3.27354       3.27354       112.670       115.943    
  20  0.383368     -0.958759      -2.15188       2.15188       110.113       112.265    
  21  0.622786     -0.473552      -1.06286       1.06286       112.068       113.131    
  22  0.356422      -1.03164      -2.31545       2.31545       111.110       113.426    
  23  0.919964     -0.834212E-01 -0.187234      0.187234       110.272       110.459    
  24  0.550740     -0.596492      -1.33879       1.33879       112.210       113.549    
  25  0.402627     -0.909745      -2.04187       2.04187       111.225       113.267    
  26  0.256265      -1.36154      -3.05591       3.05591       112.280       115.336    
  27  0.763510     -0.269828     -0.605614      0.605614       109.793       110.398    
  28  0.388963     -0.944271      -2.11936       2.11936       113.409       115.528    
  29  0.981923     -0.182423E-01 -0.409438E-01  0.409438E-01   112.739       112.779    
  30  0.656629     -0.420635     -0.944091      0.944091       111.829       112.773    
  31  0.932472     -0.699161E-01 -0.156923      0.156923       112.407       112.564    
  32  0.336775      -1.08834      -2.44272       2.44272       113.219       115.662    
  33  0.810758     -0.209786     -0.470852      0.470852       115.056       115.527    
  34  0.557014     -0.585166      -1.31337       1.31337       114.506       115.820    
  35  0.652747     -0.426565     -0.957400      0.957400       110.310       111.267    
  36  0.890774     -0.115665     -0.259603      0.259603       116.887       117.147    
  37  0.703035     -0.352349     -0.790827      0.790827       114.020       114.811    
  38  0.534296     -0.626805      -1.40683       1.40683       113.539       114.946    
  39  0.604162     -0.503914      -1.13100       1.13100       116.997       118.128    
  40  0.545557     -0.605948      -1.36001       1.36001       114.426       115.786    
  41  0.371346     -0.990620      -2.22339       2.22339       115.675       117.898    
  42  0.491801     -0.709680      -1.59284       1.59284       114.282       115.875    
  43  0.879731     -0.128139     -0.287601      0.287601       117.201       117.488    
  44  0.995113     -0.489866E-02 -0.109947E-01  0.109947E-01   114.398       114.409    
  45  0.467927     -0.759444      -1.70453       1.70453       116.185       117.890    
  46  0.355083      -1.03540      -2.32390       2.32390       106.255       108.579    
loop,thermsimp(1:2)        5   1.03620      0.296192    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    256        112.51         67.86          1.08         41.99          0.60          0.05        111.58
Just calling func    0   0        111.58


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    112.51
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:        5
neval is:      255
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        5      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:        6
neval is:      255


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      255     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.215976      -1.53259      -3.43980       3.43980       105.672       109.112    
   2  0.942431     -0.592928E-01 -0.133079      0.133079       106.582       106.715    
   3  0.193824      -1.64081      -3.68269       3.68269       107.064       110.747    
   4  0.162512      -1.81700      -4.07816       4.07816       106.255       110.333    
   5  0.625243     -0.469616      -1.05402       1.05402       109.793       110.847    
   6  0.499178     -0.694793      -1.55942       1.55942       110.272       111.831    
   7  0.706095     -0.348006     -0.781079      0.781079       110.730       111.511    
   8  0.527414     -0.639770      -1.43593       1.43593       108.292       109.728    
   9  0.575748     -0.552085      -1.23912       1.23912       110.310       111.549    
  10  0.490522     -0.712286      -1.59868       1.59868       110.699       112.298    
  11  0.306517      -1.18248      -2.65401       2.65401       110.495       113.149    
  12  0.798470     -0.225057     -0.505128      0.505128       111.506       112.011    
  13  0.333550      -1.09796      -2.46431       2.46431       110.113       112.578    
  14  0.166731      -1.79138      -4.02064       4.02064       112.407       116.427    
  15  0.443580     -0.812878      -1.82446       1.82446       111.829       113.653    
  16  0.669985     -0.400500     -0.898899      0.898899       112.739       113.637    
  17  0.339921      -1.07904      -2.42185       2.42185       110.597       113.019    
  18  0.201260      -1.60316      -3.59820       3.59820       112.604       116.202    
  19  0.772250     -0.258447     -0.580068      0.580068       110.854       111.434    
  20  0.401372E-01  -3.21545      -7.21689       7.21689       112.068       119.285    
  21  0.940962     -0.608526E-01 -0.136580      0.136580       111.225       111.361    
  22  0.115324      -2.16001      -4.84802       4.84802       111.110       115.958    
  23  0.939991E-01  -2.36447      -5.30691       5.30691       110.739       116.046    
  24  0.412221     -0.886196      -1.98901       1.98901       112.210       114.199    
  25  0.136462      -1.99171      -4.47028       4.47028       111.852       116.323    
  26  0.310095      -1.17088      -2.62796       2.62796       110.057       112.685    
  27  0.985727     -0.143755E-01 -0.322649E-01  0.322649E-01   107.960       107.992    
  28  0.900161     -0.105182     -0.236074      0.236074       114.398       114.634    
  29  0.250220      -1.38542      -3.10949       3.10949       110.750       113.860    
  30  0.780405     -0.247942     -0.556491      0.556491       114.020       114.576    
  31  0.228719      -1.47526      -3.31113       3.31113       113.539       116.851    
  32  0.407088     -0.898727      -2.01714       2.01714       109.837       111.855    
  33  0.975627     -0.246749E-01 -0.553814E-01  0.553814E-01   112.280       112.335    
  34  0.885140     -0.122009     -0.273843      0.273843       115.056       115.330    
  35  0.896135     -0.109664     -0.246135      0.246135       113.409       113.655    
  36  0.856661     -0.154713     -0.347245      0.347245       113.219       113.566    
  37  0.258643      -1.35231      -3.03518       3.03518       114.426       117.461    
  38  0.336283      -1.08980      -2.44599       2.44599       114.506       116.952    
  39  0.868205     -0.141327     -0.317200      0.317200       114.282       114.600    
  40  0.937935     -0.640747E-01 -0.143812      0.143812       112.670       112.814    
  41  0.418906     -0.870109      -1.95291       1.95291       116.887       118.840    
  42  0.351040      -1.04685      -2.34960       2.34960       117.201       119.550    
  43  0.611628E-01  -2.79422      -6.27146       6.27146       116.185       122.457    
  44  0.153518      -1.87394      -4.20594       4.20594       115.675       119.881    
  45  0.938341     -0.636423E-01 -0.142841      0.142841       116.997       117.140    
  46  0.598133     -0.513942      -1.15351       1.15351       112.509       113.663    
loop,thermsimp(1:2)        6   3.43980      0.133079    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    257        108.46         67.85          1.10         42.08          0.54          0.05        111.62
Just calling func    0   0        111.62


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    108.46
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:        6
neval is:      256
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        6      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:        7
neval is:      256


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      256     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.264215      -1.33099      -2.98734       2.98734       106.582       109.569    
   2  0.401807     -0.911784      -2.04644       2.04644       107.960       110.007    
   3  0.418885     -0.870159      -1.95302       1.95302       105.672       107.625    
   4  0.753378     -0.283189     -0.635600      0.635600       108.292       108.928    
   5  0.792066     -0.233111     -0.523204      0.523204       106.255       106.778    
   6  0.868474     -0.141017     -0.316505      0.316505       107.064       107.380    
   7  0.318670      -1.14360      -2.56674       2.56674       109.793       112.360    
   8  0.863267     -0.147031     -0.330002      0.330002       111.225       111.555    
   9  0.589255     -0.528896      -1.18708       1.18708       110.854       112.041    
  10  0.632079E-01  -2.76133      -6.19763       6.19763       110.730       116.928    
  11  0.992270     -0.775975E-02 -0.174163E-01  0.174163E-01   110.310       110.327    
  12  0.466140     -0.763269      -1.71311       1.71311       110.272       111.985    
  13  0.177509      -1.72873      -3.88004       3.88004       109.837       113.717    
  14  0.933326     -0.690005E-01 -0.154868      0.154868       111.506       111.660    
  15  0.876357     -0.131982     -0.296225      0.296225       110.699       110.996    
  16  0.673496     -0.395274     -0.887169      0.887169       112.280       113.167    
  17  0.648708     -0.432773     -0.971333      0.971333       110.113       111.085    
  18  0.400813     -0.914259      -2.05200       2.05200       110.057       112.109    
  19  0.763164     -0.270282     -0.606632      0.606632       112.670       113.276    
  20  0.196240      -1.62842      -3.65489       3.65489       110.597       114.252    
  21  0.923666     -0.794046E-01 -0.178219      0.178219       110.495       110.674    
  22  0.999600     -0.400298E-03 -0.898445E-03  0.898445E-03   113.219       113.220    
  23  0.379715     -0.968335      -2.17337       2.17337       112.739       114.912    
  24  0.197375      -1.62265      -3.64194       3.64194       111.829       115.471    
  25  0.760736     -0.273468     -0.613784      0.613784       113.409       114.023    
  26  0.392182     -0.936030      -2.10086       2.10086       112.509       114.610    
  27  0.256208      -1.36177      -3.05641       3.05641       110.750       113.806    
  28  0.251796      -1.37914      -3.09539       3.09539       112.210       115.306    
  29  0.332089E-01  -3.40494      -7.64218       7.64218       114.020       121.662    
  30  0.970457     -0.299883E-01 -0.673070E-01  0.673070E-01   114.282       114.350    
  31  0.467370E-01  -3.06322      -6.87521       6.87521       114.398       121.273    
  32  0.716125     -0.333901     -0.749420      0.749420       115.056       115.805    
  33  0.757897     -0.277208     -0.622177      0.622177       111.110       111.732    
  34  0.765628     -0.267059     -0.599399      0.599399       110.739       111.338    
  35  0.323816      -1.12758      -2.53079       2.53079       112.604       115.135    
  36  0.909845     -0.944807E-01 -0.212056      0.212056       111.852       112.064    
  37  0.515782     -0.662071      -1.48598       1.48598       112.407       113.893    
  38  0.464370     -0.767074      -1.72165       1.72165       113.539       115.261    
  39  0.445707     -0.808094      -1.81372       1.81372       114.506       116.320    
  40  0.786320     -0.240391     -0.539545      0.539545       116.997       117.537    
  41  0.631860     -0.459087      -1.03039       1.03039       114.426       115.457    
  42  0.672488     -0.396772     -0.890530      0.890530       116.887       117.778    
  43  0.251717E-02  -5.98462      -13.4321       13.4321       112.068       125.500    
  44  0.245023      -1.40640      -3.15659       3.15659       117.201       120.357    
  45  0.252688      -1.37560      -3.08745       3.08745       115.675       118.762    
  46  0.268946      -1.31324      -2.94750       2.94750       108.464       111.411    
loop,thermsimp(1:2)        7   2.98734       2.04644    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    258        108.94         67.78          1.11         42.26          0.45          0.05        111.64
Just calling func    0   0        111.64


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    108.94
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:        7
neval is:      257
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        7      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:        8
neval is:      257


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      257     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.105813      -2.24608      -5.04120       5.04120       106.255       111.296    
   2  0.476819     -0.740619      -1.66228       1.66228       107.064       108.726    
   3  0.564430     -0.571938      -1.28368       1.28368       105.672       106.956    
   4  0.211741      -1.55239      -3.48425       3.48425       108.292       111.776    
   5  0.154226E-01  -4.17192      -9.36363       9.36363       106.582       115.945    
   6  0.489577     -0.714213      -1.60301       1.60301       107.960       109.563    
   7  0.583965     -0.537914      -1.20732       1.20732       110.310       111.517    
   8  0.430258     -0.843370      -1.89289       1.89289       110.495       112.388    
   9  0.280982      -1.26946      -2.84924       2.84924       110.699       113.549    
  10  0.535183     -0.625146      -1.40310       1.40310       110.113       111.517    
  11  0.306750      -1.18172      -2.65231       2.65231       110.739       113.391    
  12  0.924930     -0.780370E-01 -0.175149      0.175149       108.464       108.639    
  13  0.829670E-01  -2.48931      -5.58712       5.58712       111.225       116.812    
  14  0.330275      -1.10783      -2.48646       2.48646       111.506       113.992    
  15  0.229751      -1.47076      -3.30103       3.30103       111.110       114.411    
  16  0.455737     -0.785839      -1.76377       1.76377       110.272       112.036    
  17  0.830949     -0.185187     -0.415642      0.415642       110.854       111.270    
  18  0.148624      -1.90634      -4.27867       4.27867       111.852       116.131    
  19  0.883001     -0.124429     -0.279274      0.279274       110.057       110.336    
  20  0.668001     -0.403466     -0.905555      0.905555       109.793       110.698    
  21  0.610583     -0.493341      -1.10728       1.10728       112.280       113.387    
  22  0.689050     -0.372441     -0.835922      0.835922       113.219       114.055    
  23  0.124417      -2.08412      -4.67768       4.67768       112.670       117.347    
  24  0.785584E-01  -2.54391      -5.70966       5.70966       109.837       115.547    
  25  0.936565     -0.655366E-01 -0.147093      0.147093       110.750       110.897    
  26  0.483719     -0.726252      -1.63003       1.63003       112.407       114.037    
  27  0.715685     -0.334515     -0.750800      0.750800       113.409       114.160    
  28  0.786437     -0.240243     -0.539211      0.539211       110.597       111.136    
  29  0.361023      -1.01881      -2.28667       2.28667       114.282       116.569    
  30  0.325559      -1.12221      -2.51874       2.51874       112.509       115.028    
  31  0.850460     -0.161978     -0.363550      0.363550       112.739       113.102    
  32  0.301358      -1.19946      -2.69211       2.69211       112.604       115.296    
  33  0.304725      -1.18834      -2.66717       2.66717       113.539       116.207    
  34  0.887065     -0.119838     -0.268968      0.268968       112.210       112.479    
  35  0.762822     -0.270730     -0.607638      0.607638       114.426       115.034    
  36  0.364130      -1.01024      -2.26744       2.26744       111.829       114.096    
  37  0.762041     -0.271754     -0.609937      0.609937       115.056       115.666    
  38  0.941180     -0.606207E-01 -0.136060      0.136060       114.506       114.642    
  39  0.449403     -0.799835      -1.79518       1.79518       110.730       112.525    
  40  0.743855     -0.295910     -0.664152      0.664152       116.997       117.661    
  41  0.743104     -0.296920     -0.666419      0.666419       116.887       117.553    
  42  0.350527      -1.04832      -2.35289       2.35289       115.675       118.028    
  43  0.607240     -0.498831      -1.11960       1.11960       117.201       118.320    
  44  0.557347     -0.584567      -1.31203       1.31203       114.398       115.710    
  45  0.217970      -1.52340      -3.41917       3.41917       114.020       117.439    
  46  0.364570      -1.00904      -2.26472       2.26472       108.940       111.205    
loop,thermsimp(1:2)        8   5.04120       1.66228    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    259        116.22         67.86          1.10         42.08          0.36          0.05        111.46
Just calling func    0   0        111.46


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    116.22
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:        8
neval is:      258
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        8      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:        9
neval is:      258


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      258     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.641422     -0.444068     -0.996684      0.996684       105.672       106.669    
   2  0.805197     -0.216668     -0.486298      0.486298       108.464       108.950    
   3  0.976428     -0.238543E-01 -0.535396E-01  0.535396E-01   107.064       107.118    
   4  0.599028     -0.512447      -1.15016       1.15016       107.960       109.110    
   5  0.591081     -0.525802      -1.18013       1.18013       110.057       111.237    
   6  0.151500      -1.88717      -4.23563       4.23563       109.793       114.028    
   7  0.565682     -0.569723      -1.27871       1.27871       110.750       112.029    
   8  0.345258      -1.06346      -2.38688       2.38688       110.597       112.984    
   9  0.658101     -0.418397     -0.939068      0.939068       108.940       109.879    
  10  0.691977E-01  -2.67079      -5.99442       5.99442       110.854       116.849    
  11  0.289062      -1.24111      -2.78561       2.78561       106.255       109.041    
  12  0.949819     -0.514835E-01 -0.115552      0.115552       110.113       110.229    
  13  0.791632     -0.233658     -0.524432      0.524432       110.310       110.834    
  14  0.400532     -0.914962      -2.05358       2.05358       108.292       110.346    
  15  0.241886      -1.41929      -3.18551       3.18551       110.272       113.458    
  16  0.383016     -0.959678      -2.15394       2.15394       110.495       112.649    
  17  0.993978     -0.604041E-02 -0.135573E-01  0.135573E-01   112.210       112.224    
  18  0.807089     -0.214322     -0.481033      0.481033       110.730       111.211    
  19  0.732161     -0.311755     -0.699715      0.699715       112.739       113.438    
  20  0.176507      -1.73440      -3.89275       3.89275       112.280       116.173    
  21  0.628098     -0.465059      -1.04380       1.04380       110.739       111.783    
  22  0.383392     -0.958697      -2.15174       2.15174       110.699       112.851    
  23  0.906421     -0.982517E-01 -0.220520      0.220520       111.506       111.726    
  24  0.329288      -1.11082      -2.49318       2.49318       112.407       114.900    
  25  0.869436     -0.139911     -0.314022      0.314022       113.219       113.533    
  26  0.354994      -1.03565      -2.32446       2.32446       111.829       114.153    
  27  0.127935      -2.05623      -4.61510       4.61510       113.409       118.024    
  28  0.840123     -0.174207     -0.390997      0.390997       111.110       111.501    
  29  0.625861     -0.468627      -1.05181       1.05181       114.506       115.558    
  30  0.488384     -0.716653      -1.60848       1.60848       112.509       114.118    
  31  0.888226E-01  -2.42111      -5.43405       5.43405       114.426       119.860    
  32  0.262955      -1.33577      -2.99806       2.99806       112.604       115.602    
  33  0.153205E-01  -4.17856      -9.37854       9.37854       109.837       119.216    
  34  0.432355     -0.838509      -1.88199       1.88199       115.056       116.938    
  35  0.225273      -1.49044      -3.34521       3.34521       114.398       117.743    
  36  0.812147     -0.208074     -0.467011      0.467011       106.582       107.049    
  37  0.832805E-01  -2.48554      -5.57865       5.57865       111.852       117.431    
  38  0.442280     -0.815813      -1.83104       1.83104       113.539       115.370    
  39  0.106639      -2.23831      -5.02376       5.02376       114.282       119.306    
  40  0.143053      -1.94454      -4.36440       4.36440       111.225       115.589    
  41  0.871774     -0.137225     -0.307994      0.307994       112.670       112.978    
  42  0.137692      -1.98273      -4.45013       4.45013       114.020       118.470    
  43  0.366512      -1.00372      -2.25280       2.25280       116.887       119.140    
  44  0.617157     -0.482633      -1.08324       1.08324       116.997       118.080    
  45  0.420337     -0.866700      -1.94526       1.94526       115.675       117.620    
  46  0.935846     -0.663044E-01 -0.148816      0.148816       116.219       116.368    
loop,thermsimp(1:2)        9  0.996684      0.486298    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    260        112.26         67.85          1.10         41.94          0.79          0.05        111.72
Just calling func    0   0        111.72


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    112.26
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:        9
neval is:      259
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        9      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       10
neval is:      259


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      259     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.833163     -0.182525     -0.409668      0.409668       105.672       106.082    
   2  0.367543      -1.00091      -2.24649       2.24649       106.582       108.828    
   3  0.528755     -0.637231      -1.43023       1.43023       107.064       108.494    
   4  0.776829     -0.252535     -0.566801      0.566801       108.464       109.031    
   5  0.149594E-01  -4.20242      -9.43208       9.43208       106.255       115.687    
   6  0.892228     -0.114033     -0.255940      0.255940       107.960       108.216    
   7  0.191037      -1.65529      -3.71519       3.71519       108.940       112.655    
   8  0.516533     -0.660616      -1.48271       1.48271       110.113       111.596    
   9  0.273230      -1.29744      -2.91203       2.91203       108.292       111.204    
  10  0.822225     -0.195741     -0.439330      0.439330       110.310       110.749    
  11  0.359850      -1.02207      -2.29397       2.29397       110.730       113.024    
  12  0.611658     -0.491581      -1.10333       1.10333       110.057       111.160    
  13  0.249481      -1.38837      -3.11612       3.11612       111.110       114.226    
  14  0.441252     -0.818139      -1.83626       1.83626       111.506       113.342    
  15  0.910514E-01  -2.39633      -5.37843       5.37843       110.739       116.117    
  16  0.745146     -0.294175     -0.660259      0.660259       110.750       111.410    
  17  0.758301     -0.276675     -0.620981      0.620981       112.210       112.831    
  18  0.638521     -0.448601      -1.00686       1.00686       110.495       111.502    
  19  0.150180      -1.89592      -4.25528       4.25528       110.699       114.955    
  20  0.144147      -1.93692      -4.34731       4.34731       112.670       117.017    
  21  0.104928      -2.25448      -5.06005       5.06005       110.597       115.657    
  22  0.398120     -0.921002      -2.06714       2.06714       112.739       114.806    
  23  0.802258     -0.220325     -0.494507      0.494507       110.272       110.767    
  24  0.399299     -0.918044      -2.06049       2.06049       113.219       115.279    
  25  0.493060     -0.707124      -1.58710       1.58710       109.793       111.380    
  26  0.504407     -0.684372      -1.53603       1.53603       112.509       114.045    
  27  0.762058     -0.271733     -0.609888      0.609888       111.829       112.439    
  28  0.430267     -0.843350      -1.89285       1.89285       112.407       114.300    
  29  0.993832     -0.618725E-02 -0.138869E-01  0.138869E-01   113.539       113.553    
  30  0.705390     -0.349005     -0.783321      0.783321       114.506       115.290    
  31  0.969760     -0.307069E-01 -0.689198E-01  0.689198E-01   111.225       111.294    
  32  0.245618      -1.40398      -3.15115       3.15115       112.604       115.755    
  33  0.685790     -0.377184     -0.846568      0.846568       112.280       113.126    
  34  0.905089     -0.997222E-01 -0.223821      0.223821       116.219       116.443    
  35  0.414065     -0.881732      -1.97900       1.97900       110.854       112.833    
  36  0.714747E-01  -2.63841      -5.92176       5.92176       115.056       120.978    
  37  0.694510     -0.364548     -0.818207      0.818207       111.852       112.671    
  38  0.770213E-01  -2.56367      -5.75401       5.75401       115.675       121.429    
  39  0.846173     -0.167031     -0.374891      0.374891       114.398       114.773    
  40  0.485012     -0.723582      -1.62404       1.62404       113.409       115.033    
  41  0.345787      -1.06193      -2.38345       2.38345       116.997       119.381    
  42  0.851861     -0.160332     -0.359855      0.359855       114.020       114.380    
  43  0.774151     -0.255989     -0.574552      0.574552       116.887       117.462    
  44  0.512382     -0.668685      -1.50082       1.50082       109.837       111.338    
  45  0.839798     -0.174594     -0.391867      0.391867       114.282       114.674    
  46  0.430550     -0.842692      -1.89137       1.89137       112.259       114.151    
loop,thermsimp(1:2)       10  0.409668       2.24649    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    261        108.59         67.87          1.11         42.39          0.66          0.05        112.07
Just calling func    0   0        112.08


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  260    108.59       0.7875     -2.742      2.616     -102.6     0.6184    
                       1.172     0.8041     -99.70      4.303      1.044    

                       1.581     -2.319      1.540      7390.      7000.    

                      0.3161      0.000      0.000      0.000     -1.221    



                      -2.366      0.000      0.000      7000.      445.6    

                       1.763     -4.940     -5.847     -7.789      6.612    

                      -17.31     -6.591      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4094    -0.8352      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.5386     -1.163      7000.    



                      -1.598     -1.476     -2.055     -1.966    -0.3807    

                     -0.3252      9.237      8.768    -0.1561E+05 -5.256    

                     -0.5126     -2.961      9.374      8.882    -0.1969E+05



                      -6.000     0.5112    -0.1339      8.952      9.124    

                     -0.1944E+05 -6.000     -1.040    -0.5338      9.134    

                       8.855    -0.1891E+05 -6.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    108.59
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       10
neval is:      260
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       10      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       11
neval is:      260


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      260     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.919397     -0.840375E-01 -0.188617      0.188617       105.672       105.861    
   2  0.309089      -1.17413      -2.63526       2.63526       107.960       110.595    
   3  0.237901      -1.43590      -3.22279       3.22279       107.064       110.287    
   4  0.542467     -0.611627      -1.37276       1.37276       106.582       107.954    
   5  0.523672     -0.646889      -1.45191       1.45191       108.464       109.916    
   6  0.850058     -0.162450     -0.364610      0.364610       110.310       110.675    
   7  0.589343     -0.528746      -1.18674       1.18674       110.272       111.459    
   8  0.979269     -0.209490E-01 -0.470187E-01  0.470187E-01   110.057       110.104    
   9  0.110419      -2.20347      -4.94557       4.94557       108.292       113.238    
  10  0.557914     -0.583550      -1.30974       1.30974       111.225       112.535    
  11  0.474464     -0.745569      -1.67338       1.67338       109.837       111.511    
  12  0.312482      -1.16321      -2.61075       2.61075       109.793       112.404    
  13  0.297011      -1.21399      -2.72472       2.72472       110.750       113.475    
  14  0.857571     -0.153651     -0.344862      0.344862       110.495       110.840    
  15  0.792567     -0.232479     -0.521785      0.521785       110.113       110.635    
  16  0.963006     -0.376958E-01 -0.846061E-01  0.846061E-01   111.829       111.914    
  17  0.294103      -1.22382      -2.74680       2.74680       108.940       111.687    
  18  0.403484     -0.907618      -2.03709       2.03709       111.852       113.890    
  19  0.449313     -0.800035      -1.79563       1.79563       112.210       114.006    
  20  0.721912     -0.325852     -0.731356      0.731356       110.854       111.586    
  21  0.512488     -0.668479      -1.50036       1.50036       110.730       112.230    
  22  0.885190     -0.121953     -0.273716      0.273716       112.280       112.554    
  23  0.694751E-01  -2.66679      -5.98545       5.98545       111.506       117.491    
  24  0.820879     -0.197380     -0.443007      0.443007       113.539       113.982    
  25  0.211527      -1.55340      -3.48653       3.48653       112.509       115.996    
  26  0.937420     -0.646236E-01 -0.145044      0.145044       112.259       112.404    
  27  0.515756E-01  -2.96471      -6.65411       6.65411       111.110       117.764    
  28  0.695222     -0.363525     -0.815910      0.815910       112.407       113.223    
  29  0.718776     -0.330205     -0.741126      0.741126       114.020       114.761    
  30  0.536080     -0.623471      -1.39934       1.39934       114.282       115.682    
  31  0.585855     -0.534682      -1.20006       1.20006       114.398       115.598    
  32  0.693572     -0.365900     -0.821242      0.821242       112.739       113.560    
  33  0.700823     -0.355500     -0.797898      0.797898       110.699       111.497    
  34  0.250985      -1.38236      -3.10263       3.10263       113.409       116.512    
  35  0.290600      -1.23581      -2.77369       2.77369       113.219       115.993    
  36  0.828609     -0.188007     -0.421971      0.421971       114.506       114.928    
  37  0.225820      -1.48802      -3.33977       3.33977       110.597       113.937    
  38  0.999674     -0.326354E-03 -0.732482E-03  0.732482E-03   106.255       106.256    
  39  0.878216     -0.129862     -0.291469      0.291469       112.604       112.895    
  40  0.685898E-01  -2.67961      -6.01423       6.01423       110.739       116.753    
  41  0.273860      -1.29514      -2.90686       2.90686       116.219       119.126    
  42  0.697655     -0.360030     -0.808067      0.808067       112.670       113.478    
  43  0.293168      -1.22701      -2.75395       2.75395       116.887       119.641    
  44  0.319476      -1.14107      -2.56107       2.56107       116.997       119.558    
  45  0.874681     -0.133896     -0.300522      0.300522       115.056       115.357    
  46  0.408697     -0.894781      -2.00828       2.00828       108.593       110.601    
loop,thermsimp(1:2)       11  0.188617       2.63526    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    262        116.31         67.87          1.11         42.08          0.43          0.05        111.53
Just calling func    0   0        111.53


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    116.31
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       11
neval is:      261
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       11      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       12
neval is:      261


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      261     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.762868     -0.270671     -0.607504      0.607504       105.672       106.280    
   2  0.482922E-01  -3.03048      -6.80174       6.80174       106.255       113.057    
   3  0.612960     -0.489456      -1.09856       1.09856       106.582       107.680    
   4  0.910127     -0.941714E-01 -0.211362      0.211362       108.464       108.675    
   5  0.362433      -1.01492      -2.27792       2.27792       110.057       112.334    
   6  0.476779     -0.740702      -1.66246       1.66246       107.064       108.726    
   7  0.179006E-01  -4.02292      -9.02921       9.02921       107.960       116.989    
   8  0.589646     -0.528233      -1.18559       1.18559       108.593       109.779    
   9  0.926206     -0.766581E-01 -0.172055      0.172055       110.113       110.285    
  10  0.492629     -0.707999      -1.58906       1.58906       110.310       111.899    
  11  0.661123     -0.413815     -0.928783      0.928783       110.495       111.424    
  12  0.542248     -0.612032      -1.37367       1.37367       110.272       111.646    
  13  0.216527      -1.53004      -3.43408       3.43408       110.699       114.133    
  14  0.549832     -0.598143      -1.34250       1.34250       109.837       111.180    
  15  0.429556     -0.845003      -1.89656       1.89656       110.854       112.751    
  16  0.264838      -1.32864      -2.98205       2.98205       108.940       111.922    
  17  0.251706      -1.37949      -3.09619       3.09619       111.829       114.925    
  18  0.701724     -0.354215     -0.795014      0.795014       110.730       111.525    
  19  0.324289      -1.12612      -2.52751       2.52751       109.793       112.320    
  20  0.160749E-02  -6.43308      -14.4387       14.4387       112.259       126.698    
  21  0.533627     -0.628058      -1.40964       1.40964       111.225       112.634    
  22  0.883065     -0.124357     -0.279111      0.279111       112.280       112.559    
  23  0.484824     -0.723969      -1.62491       1.62491       112.604       114.229    
  24  0.724157     -0.322747     -0.724387      0.724387       112.407       113.131    
  25  0.847375     -0.165612     -0.371707      0.371707       108.292       108.664    
  26  0.167586      -1.78626      -4.00915       4.00915       110.750       114.759    
  27  0.890079     -0.116445     -0.261353      0.261353       112.670       112.931    
  28  0.235223      -1.44722      -3.24821       3.24821       112.739       115.987    
  29  0.206112      -1.57934      -3.54473       3.54473       111.852       115.397    
  30  0.463385     -0.769198      -1.72642       1.72642       110.597       112.323    
  31  0.487880E-01  -3.02027      -6.77882       6.77882       113.539       120.318    
  32  0.244157      -1.40994      -3.16453       3.16453       112.210       115.375    
  33  0.770602     -0.260583     -0.584863      0.584863       114.020       114.605    
  34  0.264159      -1.33120      -2.98781       2.98781       114.506       117.494    
  35  0.189030E-01  -3.96843      -8.90692       8.90692       115.056       123.963    
  36  0.635342     -0.453592      -1.01806       1.01806       114.398       115.416    
  37  0.139550      -1.96933      -4.42005       4.42005       114.282       118.702    
  38  0.561566     -0.577026      -1.29510       1.29510       113.219       114.514    
  39  0.951789     -0.494118E-01 -0.110902      0.110902       112.509       112.620    
  40  0.527693     -0.639242      -1.43474       1.43474       113.409       114.844    
  41  0.925337     -0.775972E-01 -0.174162      0.174162       110.739       110.913    
  42  0.795352     -0.228971     -0.513912      0.513912       111.506       112.019    
  43  0.530799     -0.633371      -1.42156       1.42156       111.110       112.532    
  44  0.642763     -0.441979     -0.991996      0.991996       116.219       117.211    
  45  0.485146     -0.723305      -1.62342       1.62342       116.997       118.621    
  46  0.795896     -0.228287     -0.512377      0.512377       116.310       116.823    
loop,thermsimp(1:2)       12  0.607504       6.80174    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    263        112.94         67.81          1.11         41.82          0.65          0.05        111.42
Just calling func    0   0        111.42


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    264        123.43         67.77          1.10         41.83          0.72          0.05        111.47
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    112.94
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       12
neval is:      263
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       12      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       13
neval is:      263


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      263     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.592808     -0.522884      -1.17358       1.17358       105.672       106.846    
   2  0.691791     -0.368472     -0.827013      0.827013       106.582       107.409    
   3  0.688173     -0.373715     -0.838781      0.838781       108.292       109.131    
   4  0.439966     -0.821058      -1.84282       1.84282       108.464       110.307    
   5  0.945690     -0.558403E-01 -0.125330      0.125330       107.064       107.189    
   6  0.238956      -1.43147      -3.21286       3.21286       108.593       111.806    
   7  0.280830E-01  -3.57259      -8.01847       8.01847       110.113       118.132    
   8  0.902031E-01  -2.40569      -5.39943       5.39943       110.739       116.138    
   9  0.198361      -1.61767      -3.63076       3.63076       109.837       113.468    
  10  0.201288      -1.60302      -3.59788       3.59788       110.495       114.093    
  11  0.710033     -0.342444     -0.768595      0.768595       110.730       111.499    
  12  0.182913      -1.69874      -3.81273       3.81273       110.272       114.085    
  13  0.817316     -0.201730     -0.452770      0.452770       110.310       110.763    
  14  0.894732     -0.111231     -0.249651      0.249651       108.940       109.190    
  15  0.854000     -0.157824     -0.354227      0.354227       111.506       111.860    
  16  0.248066      -1.39406      -3.12889       3.12889       109.793       112.922    
  17  0.670877     -0.399170     -0.895913      0.895913       110.597       111.493    
  18  0.701473     -0.354573     -0.795818      0.795818       110.057       110.852    
  19  0.199467      -1.61210      -3.61827       3.61827       111.110       114.729    
  20  0.391533     -0.937685      -2.10458       2.10458       112.280       114.384    
  21  0.586761     -0.533138      -1.19660       1.19660       112.509       113.706    
  22  0.163799      -1.80912      -4.06045       4.06045       111.225       115.285    
  23  0.955964     -0.450353E-01 -0.101079      0.101079       110.854       110.955    
  24  0.365727      -1.00587      -2.25761       2.25761       112.670       114.927    
  25  0.733577     -0.309822     -0.695378      0.695378       106.255       106.951    
  26  0.111597      -2.19286      -4.92175       4.92175       112.407       117.328    
  27  0.714895     -0.335619     -0.753277      0.753277       110.699       111.453    
  28  0.816688     -0.202498     -0.454495      0.454495       112.604       113.059    
  29  0.480603     -0.732714      -1.64453       1.64453       113.219       114.864    
  30  0.573891     -0.555316      -1.24637       1.24637       114.020       115.266    
  31  0.204452      -1.58742      -3.56288       3.56288       110.750       114.313    
  32  0.845356E-01  -2.47058      -5.54508       5.54508       113.409       118.954    
  33  0.524789E-01  -2.94734      -6.61514       6.61514       111.829       118.444    
  34  0.631781     -0.459213      -1.03068       1.03068       112.210       113.241    
  35  0.620363     -0.477450      -1.07161       1.07161       111.852       112.924    
  36  0.553551     -0.591402      -1.32737       1.32737       114.398       115.725    
  37  0.546271     -0.604640      -1.35708       1.35708       112.739       114.096    
  38  0.402204     -0.910797      -2.04423       2.04423       116.310       118.355    
  39  0.735174     -0.307648     -0.690497      0.690497       107.960       108.651    
  40  0.359565      -1.02286      -2.29575       2.29575       116.219       118.515    
  41  0.564111     -0.572504      -1.28495       1.28495       114.506       115.791    
  42  0.412661     -0.885128      -1.98662       1.98662       116.997       118.984    
  43  0.795853     -0.228341     -0.512498      0.512498       114.282       114.795    
  44  0.909991E-01  -2.39691      -5.37971       5.37971       113.539       118.919    
  45  0.830687     -0.185502     -0.416349      0.416349       115.056       115.472    
  46  0.592588     -0.523256      -1.17442       1.17442       112.940       114.114    
loop,thermsimp(1:2)       13   1.17358      0.827013    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    265        107.36         67.88          1.09         42.02          0.69          0.05        111.74
Just calling func    0   0        111.74


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    107.36
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       13
neval is:      264
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       13      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       14
neval is:      264


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      264     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.338981      -1.08181      -2.42806       2.42806       105.672       108.100    
   2  0.649641     -0.431335     -0.968106      0.968106       106.255       107.223    
   3  0.930116     -0.724456E-01 -0.162600      0.162600       107.064       107.227    
   4  0.297326      -1.21293      -2.72234       2.72234       106.582       109.304    
   5  0.751734     -0.285373     -0.640502      0.640502       107.960       108.601    
   6  0.409056     -0.893902      -2.00631       2.00631       108.292       110.298    
   7  0.115094      -2.16201      -4.85250       4.85250       108.940       113.793    
   8  0.606681     -0.499753      -1.12167       1.12167       108.464       109.586    
   9  0.140571      -1.96204      -4.40369       4.40369       110.310       114.714    
  10  0.447669E-01  -3.10629      -6.97188       6.97188       110.057       117.028    
  11  0.517394     -0.658951      -1.47898       1.47898       110.854       112.333    
  12  0.587057     -0.532633      -1.19546       1.19546       110.699       111.895    
  13  0.384993E-01  -3.25712      -7.31040       7.31040       110.597       117.907    
  14  0.829105E-01  -2.48999      -5.58864       5.58864       110.730       116.319    
  15  0.382179     -0.961866      -2.15885       2.15885       108.593       110.752    
  16  0.269516      -1.31113      -2.94275       2.94275       111.506       114.448    
  17  0.879580     -0.128311     -0.287986      0.287986       109.793       110.081    
  18  0.760503E-01  -2.57636      -5.78249       5.78249       111.852       117.635    
  19  0.482544     -0.728684      -1.63549       1.63549       112.604       114.240    
  20  0.561499     -0.577145      -1.29537       1.29537       112.210       113.506    
  21  0.254621      -1.36798      -3.07035       3.07035       109.837       112.908    
  22  0.479261     -0.735511      -1.65081       1.65081       112.509       114.160    
  23  0.638455     -0.448704      -1.00709       1.00709       110.272       111.279    
  24  0.289082      -1.24105      -2.78545       2.78545       110.495       113.281    
  25  0.656024     -0.421558     -0.946162      0.946162       112.739       113.685    
  26  0.597431     -0.515117      -1.15615       1.15615       112.940       114.096    
  27  0.859562     -0.151333     -0.339658      0.339658       110.750       111.090    
  28  0.554826     -0.589100      -1.32220       1.32220       112.280       113.602    
  29  0.128413      -2.05250      -4.60673       4.60673       111.110       115.717    
  30  0.311170      -1.16742      -2.62020       2.62020       114.282       116.903    
  31  0.606679     -0.499755      -1.12167       1.12167       113.219       114.341    
  32  0.923238     -0.798686E-01 -0.179260      0.179260       112.670       112.849    
  33  0.734154     -0.309037     -0.693616      0.693616       114.020       114.714    
  34  0.988670     -0.113947E-01 -0.255748E-01  0.255748E-01   111.225       111.250    
  35  0.136308      -1.99284      -4.47281       4.47281       115.056       119.529    
  36  0.345839      -1.06178      -2.38311       2.38311       114.398       116.781    
  37  0.349440      -1.05142      -2.35986       2.35986       114.506       116.866    
  38  0.625658E-01  -2.77154      -6.22055       6.22055       110.739       116.960    
  39  0.394804     -0.929365      -2.08590       2.08590       112.407       114.493    
  40  0.899667E-02  -4.71090      -10.5733       10.5733       110.113       120.687    
  41  0.823946     -0.193651     -0.434637      0.434637       116.310       116.745    
  42  0.834235     -0.181240     -0.406783      0.406783       111.829       112.236    
  43  0.777534     -0.251627     -0.564763      0.564763       116.219       116.784    
  44  0.384993     -0.954531      -2.14239       2.14239       113.539       115.682    
  45  0.247443E-01  -3.69916      -8.30255       8.30255       113.409       121.712    
  46  0.810695     -0.209863     -0.471025      0.471025       107.359       107.830    
loop,thermsimp(1:2)       14   2.42806      0.968106    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    266        109.15         67.86          1.09         41.98          0.71          0.05        111.69
Just calling func    0   0        111.69


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    109.15
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       14
neval is:      265
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       14      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       15
neval is:      265


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      265     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.219724      -1.51538      -3.40119       3.40119       106.255       109.656    
   2  0.894567E-01  -2.41400      -5.41808       5.41808       107.064       112.482    
   3  0.863615     -0.146628     -0.329098      0.329098       107.359       107.688    
   4  0.807990     -0.213206     -0.478528      0.478528       105.672       106.151    
   5  0.318173      -1.14516      -2.57025       2.57025       107.960       110.530    
   6  0.464606     -0.766566      -1.72051       1.72051       106.582       108.302    
   7  0.574933     -0.553501      -1.24230       1.24230       108.464       109.706    
   8  0.974939     -0.253802E-01 -0.569644E-01  0.569644E-01   109.793       109.850    
   9  0.415757     -0.877653      -1.96984       1.96984       108.292       110.262    
  10  0.187109      -1.67606      -3.76182       3.76182       108.593       112.355    
  11  0.730515E-01  -2.61659      -5.87278       5.87278       110.750       116.623    
  12  0.209185      -1.56454      -3.51151       3.51151       111.225       114.736    
  13  0.496690     -0.699790      -1.57064       1.57064       110.272       111.843    
  14  0.862986     -0.147356     -0.330733      0.330733       110.699       111.030    
  15  0.888200     -0.118558     -0.266096      0.266096       111.829       112.095    
  16  0.380888     -0.965250      -2.16645       2.16645       110.854       113.021    
  17  0.135305      -2.00022      -4.48938       4.48938       112.670       117.159    
  18  0.927079     -0.757167E-01 -0.169942      0.169942       109.837       110.007    
  19  0.603067     -0.505727      -1.13507       1.13507       110.495       111.630    
  20  0.136202      -1.99362      -4.47456       4.47456       112.210       116.685    
  21  0.954653     -0.464076E-01 -0.104159      0.104159       112.280       112.384    
  22  0.151192      -1.88920      -4.24021       4.24021       112.739       116.979    
  23  0.449259     -0.800155      -1.79590       1.79590       108.940       110.736    
  24  0.780874     -0.247341     -0.555143      0.555143       112.940       113.495    
  25  0.456238     -0.784740      -1.76130       1.76130       112.509       114.270    
  26  0.163284      -1.81227      -4.06752       4.06752       112.604       116.672    
  27  0.821444     -0.196692     -0.441463      0.441463       113.219       113.660    
  28  0.861448     -0.149141     -0.334738      0.334738       111.506       111.840    
  29  0.924167     -0.788621E-01 -0.177001      0.177001       112.407       112.584    
  30  0.195059      -1.63445      -3.66844       3.66844       114.020       117.688    
  31  0.375134     -0.980472      -2.20061       2.20061       110.310       112.511    
  32  0.909862     -0.944628E-01 -0.212016      0.212016       113.539       113.751    
  33  0.831459     -0.184574     -0.414265      0.414265       111.110       111.525    
  34  0.627278     -0.466365      -1.04673       1.04673       110.730       111.777    
  35  0.918890     -0.845891E-01 -0.189855      0.189855       116.310       116.500    
  36  0.475784     -0.742791      -1.66715       1.66715       114.398       116.065    
  37  0.344524      -1.06559      -2.39166       2.39166       116.219       118.611    
  38  0.286778      -1.24905      -2.80341       2.80341       114.506       117.310    
  39  0.336148      -1.09020      -2.44690       2.44690       114.282       116.729    
  40  0.709840     -0.342716     -0.769207      0.769207       110.739       111.508    
  41  0.219827      -1.51491      -3.40013       3.40013       110.057       113.457    
  42  0.347594      -1.05672      -2.37175       2.37175       111.852       114.224    
  43  0.905734     -0.990099E-01 -0.222222      0.222222       110.597       110.819    
  44  0.826231     -0.190881     -0.428421      0.428421       115.056       115.484    
  45  0.400277     -0.915599      -2.05501       2.05501       110.113       112.168    
  46  0.555153     -0.588512      -1.32088       1.32088       109.148       110.469    
loop,thermsimp(1:2)       15   3.40119       5.41808    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    267        117.75         67.81          1.09         42.18          0.67          0.05        111.80
Just calling func    0   0        111.80


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    117.75
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       15
neval is:      266
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       15      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       16
neval is:      266


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      266     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.231724      -1.46221      -3.28184       3.28184       105.672       108.954    
   2  0.641193     -0.444425     -0.997485      0.997485       107.359       108.357    
   3  0.353033      -1.04119      -2.33690       2.33690       106.582       108.918    
   4  0.928955     -0.736953E-01 -0.165405      0.165405       106.255       106.421    
   5  0.350257      -1.04909      -2.35462       2.35462       108.464       110.819    
   6  0.682617     -0.381821     -0.856975      0.856975       109.793       110.650    
   7  0.162763      -1.81546      -4.07469       4.07469       109.837       113.912    
   8  0.874032     -0.134639     -0.302188      0.302188       108.292       108.594    
   9  0.518909     -0.656027      -1.47241       1.47241       109.148       110.621    
  10  0.461984     -0.772226      -1.73322       1.73322       107.960       109.693    
  11  0.449468     -0.799691      -1.79486       1.79486       108.940       110.735    
  12  0.523281     -0.647637      -1.45358       1.45358       110.597       112.051    
  13  0.637377     -0.450394      -1.01088       1.01088       110.699       111.710    
  14  0.596329     -0.516963      -1.16029       1.16029       110.739       111.899    
  15  0.286246      -1.25090      -2.80758       2.80758       111.110       113.918    
  16  0.590425     -0.526913      -1.18263       1.18263       110.495       111.678    
  17  0.853637     -0.158249     -0.355180      0.355180       110.730       111.085    
  18  0.245572      -1.40416      -3.15156       3.15156       111.506       114.657    
  19  0.375654     -0.979088      -2.19750       2.19750       110.272       112.470    
  20  0.281654      -1.26708      -2.84388       2.84388       111.829       114.673    
  21  0.443392     -0.813302      -1.82541       1.82541       110.113       111.939    
  22  0.442934     -0.814335      -1.82773       1.82773       108.593       110.421    
  23  0.171790      -1.76149      -3.95355       3.95355       112.280       116.233    
  24  0.802582     -0.219921     -0.493601      0.493601       107.064       107.558    
  25  0.162733      -1.81564      -4.07511       4.07511       110.310       114.385    
  26  0.838320     -0.176355     -0.395818      0.395818       112.407       112.802    
  27  0.210754      -1.55706      -3.49474       3.49474       110.854       114.349    
  28  0.240377      -1.42554      -3.19955       3.19955       110.057       113.256    
  29  0.173042E-01  -4.05680      -9.10526       9.10526       112.940       122.045    
  30  0.640146     -0.446059      -1.00115       1.00115       113.219       114.220    
  31  0.749210     -0.288736     -0.648051      0.648051       113.539       114.187    
  32  0.666162     -0.406222     -0.911742      0.911742       111.852       112.764    
  33  0.601746     -0.507920      -1.14000       1.14000       112.509       113.649    
  34  0.677044     -0.390020     -0.875376      0.875376       111.225       112.100    
  35  0.290379      -1.23657      -2.77541       2.77541       115.056       117.831    
  36  0.439723     -0.821610      -1.84406       1.84406       114.398       116.242    
  37  0.680091     -0.385528     -0.865295      0.865295       116.310       117.176    
  38  0.803784     -0.218425     -0.490242      0.490242       110.750       111.240    
  39  0.507823     -0.677622      -1.52088       1.52088       112.604       114.125    
  40  0.894573     -0.111408     -0.250050      0.250050       112.210       112.460    
  41  0.826908     -0.190062     -0.426583      0.426583       114.282       114.709    
  42  0.815562     -0.203878     -0.457593      0.457593       112.739       113.196    
  43  0.352457      -1.04283      -2.34057       2.34057       112.670       115.010    
  44  0.104059      -2.26279      -5.07871       5.07871       114.506       119.585    
  45  0.601892     -0.507677      -1.13945       1.13945       114.020       115.159    
  46  0.988184     -0.118862E-01 -0.266778E-01  0.266778E-01   117.750       117.777    
loop,thermsimp(1:2)       16   3.28184      0.997485    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    268        112.15         67.80          1.09         42.10          0.56          0.05        111.60
Just calling func    0   0        111.60


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    112.15
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       16
neval is:      267
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       16      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       17
neval is:      267


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      267     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.776913     -0.252427     -0.566557      0.566557       106.255       106.822    
   2  0.350417      -1.04863      -2.35359       2.35359       107.064       109.418    
   3  0.533846     -0.627648      -1.40872       1.40872       107.359       108.768    
   4  0.622955     -0.473280      -1.06225       1.06225       108.292       109.354    
   5  0.661091E-01  -2.71645      -6.09691       6.09691       106.582       112.678    
   6  0.759206     -0.275482     -0.618303      0.618303       105.672       106.290    
   7  0.430535     -0.842727      -1.89145       1.89145       107.960       109.852    
   8  0.257678      -1.35604      -3.04356       3.04356       108.593       111.637    
   9  0.296561      -1.21550      -2.72812       2.72812       109.148       111.876    
  10  0.805929     -0.215760     -0.484260      0.484260       109.793       110.277    
  11  0.421616     -0.863661      -1.93844       1.93844       108.940       110.879    
  12  0.767803     -0.264223     -0.593032      0.593032       108.464       109.057    
  13  0.605260     -0.502097      -1.12693       1.12693       110.730       111.857    
  14  0.566784     -0.567776      -1.27434       1.27434       110.750       112.024    
  15  0.292740      -1.22847      -2.75723       2.75723       110.495       113.253    
  16  0.898463     -0.107069     -0.240311      0.240311       110.699       110.940    
  17  0.218067      -1.52295      -3.41818       3.41818       110.739       114.157    
  18  0.856756     -0.154603     -0.346996      0.346996       110.113       110.460    
  19  0.338883      -1.08210      -2.42871       2.42871       110.597       113.026    
  20  0.796034     -0.228113     -0.511987      0.511987       111.225       111.737    
  21  0.778636     -0.250212     -0.561585      0.561585       112.210       112.772    
  22  0.575989     -0.551667      -1.23819       1.23819       110.272       111.510    
  23  0.355531      -1.03414      -2.32107       2.32107       111.852       114.173    
  24  0.164949      -1.80212      -4.04475       4.04475       112.407       116.451    
  25  0.315998      -1.15202      -2.58564       2.58564       112.739       115.324    
  26  0.330933      -1.10584      -2.48199       2.48199       110.057       112.539    
  27  0.429436     -0.845283      -1.89719       1.89719       112.509       114.406    
  28  0.464808     -0.766130      -1.71953       1.71953       109.837       111.557    
  29  0.192211      -1.64916      -3.70145       3.70145       111.110       114.812    
  30  0.866849     -0.142891     -0.320709      0.320709       112.604       112.925    
  31  0.474973     -0.744498      -1.67098       1.67098       113.539       115.210    
  32  0.667713     -0.403897     -0.906522      0.906522       113.219       114.126    
  33  0.994155     -0.586200E-02 -0.131569E-01  0.131569E-01   110.854       110.867    
  34  0.577739     -0.548634      -1.23138       1.23138       110.310       111.541    
  35  0.381919     -0.962546      -2.16038       2.16038       111.506       113.666    
  36  0.733204     -0.310331     -0.696519      0.696519       111.829       112.525    
  37  0.492382     -0.708500      -1.59019       1.59019       114.282       115.873    
  38  0.188899E-01  -3.96913      -8.90848       8.90848       112.670       121.578    
  39  0.741920E-01  -2.60110      -5.83801       5.83801       114.020       119.858    
  40  0.210592      -1.55783      -3.49646       3.49646       112.280       115.776    
  41  0.682838     -0.381498     -0.856250      0.856250       114.398       115.254    
  42  0.656831     -0.420328     -0.943402      0.943402       116.310       117.254    
  43  0.444670     -0.810424      -1.81895       1.81895       117.750       119.569    
  44  0.872301     -0.136621     -0.306638      0.306638       115.056       115.363    
  45  0.932741     -0.696282E-01 -0.156276      0.156276       114.506       114.663    
  46  0.601727     -0.507951      -1.14007       1.14007       112.154       113.294    
loop,thermsimp(1:2)       17  0.566557       2.35359    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    269        106.63         67.88          1.11         42.08          0.58          0.05        111.70
Just calling func    0   0        111.70


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    270        106.40         67.89          1.08         42.32          0.42          0.05        111.76
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    106.40
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       17
neval is:      269
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       17      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       18
neval is:      269


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      269     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.240395      -1.42547      -3.19938       3.19938       105.672       108.871    
   2  0.711556E-02  -4.94547      -11.0998       11.0998       106.255       117.355    
   3  0.909796     -0.945347E-01 -0.212178      0.212178       107.359       107.571    
   4  0.659218     -0.416702     -0.935262      0.935262       108.464       109.399    
   5  0.833482     -0.182144     -0.408811      0.408811       108.292       108.701    
   6  0.726295E-01  -2.62238      -5.88579       5.88579       107.064       112.950    
   7  0.687091     -0.375288     -0.842312      0.842312       107.960       108.802    
   8  0.860775     -0.149922     -0.336491      0.336491       109.793       110.129    
   9  0.846215     -0.166982     -0.374781      0.374781       110.113       110.488    
  10  0.398551     -0.919919      -2.06470       2.06470       110.854       112.919    
  11  0.416092     -0.876849      -1.96804       1.96804       108.940       110.908    
  12  0.463389     -0.769189      -1.72640       1.72640       110.699       112.426    
  13  0.207356      -1.57332      -3.53122       3.53122       110.272       113.803    
  14  0.133003      -2.01738      -4.52790       4.52790       110.310       114.838    
  15  0.464971     -0.765779      -1.71875       1.71875       109.837       111.556    
  16  0.568281     -0.565140      -1.26842       1.26842       108.593       109.861    
  17  0.638811     -0.448147      -1.00584       1.00584       111.225       112.231    
  18  0.865664     -0.144259     -0.323781      0.323781       110.730       111.054    
  19  0.475002     -0.744436      -1.67084       1.67084       109.148       110.819    
  20  0.537086     -0.621597      -1.39514       1.39514       110.750       112.145    
  21  0.782345     -0.245459     -0.550918      0.550918       111.829       112.380    
  22  0.725469     -0.320937     -0.720324      0.720324       110.057       110.777    
  23  0.701426E-01  -2.65723      -5.96399       5.96399       106.582       112.546    
  24  0.297043      -1.21388      -2.72448       2.72448       112.210       114.935    
  25  0.444870     -0.809973      -1.81794       1.81794       112.604       114.422    
  26  0.685684     -0.377338     -0.846913      0.846913       110.597       111.444    
  27  0.651244     -0.428871     -0.962576      0.962576       110.495       111.458    
  28  0.269082      -1.31274      -2.94636       2.94636       112.154       115.100    
  29  0.177107      -1.73100      -3.88513       3.88513       111.506       115.391    
  30  0.766464     -0.265968     -0.596949      0.596949       113.219       113.816    
  31  0.801833     -0.220855     -0.495695      0.495695       110.739       111.235    
  32  0.759414     -0.275209     -0.617690      0.617690       111.852       112.470    
  33  0.566307     -0.568618      -1.27623       1.27623       112.509       113.785    
  34  0.297948      -1.21084      -2.71765       2.71765       114.506       117.224    
  35  0.430097E-01  -3.14633      -7.06175       7.06175       111.110       118.172    
  36  0.529414     -0.635984      -1.42743       1.42743       113.539       114.967    
  37  0.717133     -0.332494     -0.746262      0.746262       114.398       115.144    
  38  0.209457      -1.56323      -3.50859       3.50859       112.739       116.247    
  39  0.732428     -0.311390     -0.698897      0.698897       115.056       115.755    
  40  0.697782     -0.359849     -0.807660      0.807660       112.280       113.088    
  41  0.977227     -0.230362E-01 -0.517033E-01  0.517033E-01   114.282       114.334    
  42  0.744700     -0.294773     -0.661601      0.661601       112.407       113.068    
  43  0.713341     -0.337796     -0.758164      0.758164       116.310       117.069    
  44  0.497823     -0.697510      -1.56552       1.56552       117.750       119.316    
  45  0.968758     -0.317404E-01 -0.712394E-01  0.712394E-01   114.020       114.091    
  46  0.287665      -1.24596      -2.79648       2.79648       106.398       109.194    
loop,thermsimp(1:2)       18   3.19938       11.0998    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    271        115.52         67.80          1.09         41.96          0.78          0.05        111.68
Just calling func    0   0        111.68


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    115.52
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       18
neval is:      270
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       18      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       19
neval is:      270


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      270     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.722200     -0.325453     -0.730460      0.730460       107.359       108.090    
   2  0.240049      -1.42691      -3.20262       3.20262       108.292       111.495    
   3  0.365543      -1.00637      -2.25874       2.25874       107.960       110.219    
   4  0.399010     -0.918769      -2.06212       2.06212       105.672       107.734    
   5  0.685268     -0.377945     -0.848275      0.848275       106.398       107.246    
   6  0.335805E-01  -3.39381      -7.61721       7.61721       108.464       116.081    
   7  0.820520     -0.197817     -0.443988      0.443988       108.593       109.037    
   8  0.756560     -0.278973     -0.626139      0.626139       109.793       110.419    
   9  0.869461     -0.139882     -0.313957      0.313957       110.113       110.427    
  10  0.787378     -0.239047     -0.536526      0.536526       110.057       110.593    
  11  0.330926      -1.10586      -2.48204       2.48204       109.148       111.630    
  12  0.339084E-01  -3.38409      -7.59540       7.59540       108.940       116.536    
  13  0.672805     -0.396300     -0.889472      0.889472       110.730       111.619    
  14  0.822413     -0.195513     -0.438817      0.438817       110.739       111.178    
  15  0.928870     -0.737865E-01 -0.165609      0.165609       110.597       110.763    
  16  0.778944     -0.249816     -0.560698      0.560698       110.495       111.056    
  17  0.301602E-01  -3.50123      -7.85831       7.85831       109.837       117.696    
  18  0.292626      -1.22886      -2.75811       2.75811       110.750       113.508    
  19  0.149515      -1.90036      -4.26524       4.26524       111.225       115.490    
  20  0.500330E-01  -2.99507      -6.72226       6.72226       111.829       118.551    
  21  0.759114E-01  -2.57819      -5.78659       5.78659       110.699       116.486    
  22  0.613440     -0.488673      -1.09680       1.09680       111.852       112.949    
  23  0.132502      -2.02116      -4.53637       4.53637       106.582       111.118    
  24  0.189750E-02  -6.26722      -14.0664       14.0664       110.854       124.921    
  25  0.507622     -0.678018      -1.52177       1.52177       107.064       108.586    
  26  0.378733     -0.970924      -2.17918       2.17918       112.407       114.586    
  27  0.139411      -1.97033      -4.42228       4.42228       112.280       116.702    
  28  0.298599      -1.20865      -2.71275       2.71275       112.509       115.222    
  29  0.767617     -0.264464     -0.593574      0.593574       110.272       110.866    
  30  0.656077     -0.421478     -0.945982      0.945982       113.219       114.165    
  31  0.701883     -0.353988     -0.794505      0.794505       114.020       114.814    
  32  0.940950     -0.608655E-01 -0.136609      0.136609       114.282       114.419    
  33  0.621043     -0.476355      -1.06915       1.06915       112.604       113.673    
  34  0.622910     -0.473353      -1.06241       1.06241       110.310       111.372    
  35  0.525019     -0.644320      -1.44614       1.44614       112.210       113.657    
  36  0.871126     -0.137969     -0.309663      0.309663       113.539       113.849    
  37  0.475532     -0.743322      -1.66834       1.66834       112.154       113.822    
  38  0.320094      -1.13914      -2.55673       2.55673       114.398       116.955    
  39  0.688986     -0.372534     -0.836131      0.836131       111.506       112.342    
  40  0.831218     -0.184863     -0.414914      0.414914       115.056       115.471    
  41  0.639633     -0.446861      -1.00295       1.00295       112.739       113.742    
  42  0.628257     -0.464807      -1.04323       1.04323       116.310       117.354    
  43  0.925835     -0.770596E-01 -0.172956      0.172956       114.506       114.679    
  44  0.611089     -0.492512      -1.10541       1.10541       106.255       107.361    
  45  0.423003E-01  -3.16296      -7.09908       7.09908       111.110       118.209    
  46  0.430763     -0.842198      -1.89026       1.89026       115.517       117.408    
loop,thermsimp(1:2)       19  0.730460       3.20262    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    272        113.09         67.81          1.10         42.09          0.57          0.05        111.62
Just calling func    0   0        111.62


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    113.09
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       19
neval is:      271
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       19      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       20
neval is:      271


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      271
neval,tstepnext:      271     271

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.311857      -1.16521      -2.61525       2.61525       106.398       109.013    
   2  0.362384      -1.01505      -2.27822       2.27822       106.255       108.533    
   3  0.900627     -0.104664     -0.234913      0.234913       105.672       105.907    
   4  0.233893      -1.45289      -3.26093       3.26093       107.359       110.620    
   5  0.183338      -1.69642      -3.80752       3.80752       107.064       110.871    
   6  0.351708      -1.04495      -2.34533       2.34533       108.593       110.938    
   7  0.979617     -0.205938E-01 -0.462215E-01  0.462215E-01   107.960       108.006    
   8  0.801294     -0.221527     -0.497205      0.497205       109.793       110.290    
   9  0.423893     -0.858275      -1.92635       1.92635       110.113       112.040    
  10  0.486446     -0.720630      -1.61741       1.61741       110.057       111.674    
  11  0.430531     -0.842736      -1.89147       1.89147       110.597       112.489    
  12  0.214629      -1.53884      -3.45384       3.45384       110.272       113.726    
  13  0.860310     -0.150463     -0.337705      0.337705       110.495       110.833    
  14  0.450659     -0.797045      -1.78892       1.78892       106.582       108.371    
  15  0.867432     -0.142218     -0.319200      0.319200       110.739       111.058    
  16  0.850327     -0.162134     -0.363900      0.363900       110.310       110.674    
  17  0.914193     -0.897130E-01 -0.201356      0.201356       108.292       108.494    
  18  0.908448     -0.960172E-01 -0.215505      0.215505       110.730       110.945    
  19  0.349788E-01  -3.35301      -7.52564       7.52564       109.148       116.674    
  20  0.825048     -0.192314     -0.431638      0.431638       111.506       111.937    
  21  0.628933     -0.463730      -1.04081       1.04081       111.852       112.893    
  22  0.756366     -0.279229     -0.626714      0.626714       110.750       111.377    
  23  0.545707     -0.605674      -1.35940       1.35940       112.210       113.570    
  24  0.653619     -0.425231     -0.954407      0.954407       112.604       113.558    
  25  0.781643     -0.246357     -0.552933      0.552933       112.739       113.291    
  26  0.444411     -0.811005      -1.82025       1.82025       112.154       113.974    
  27  0.223111      -1.50008      -3.36685       3.36685       113.539       116.906    
  28  0.143901      -1.93863      -4.35114       4.35114       113.219       117.570    
  29  0.419282E-01  -3.17180      -7.11891       7.11891       114.282       121.401    
  30  0.407367     -0.898040      -2.01560       2.01560       112.407       114.422    
  31  0.722138     -0.325538     -0.730652      0.730652       114.506       115.237    
  32  0.290143      -1.23738      -2.77723       2.77723       114.020       116.797    
  33  0.236931E-01  -3.74257      -8.39998       8.39998       112.509       120.909    
  34  0.198981      -1.61454      -3.62375       3.62375       115.056       118.680    
  35  0.765966     -0.266617     -0.598406      0.598406       111.225       111.823    
  36  0.522733     -0.648684      -1.45593       1.45593       108.464       109.920    
  37  0.297579E-01  -3.51466      -7.88845       7.88845       110.699       118.588    
  38  0.175475      -1.74026      -3.90590       3.90590       108.940       112.846    
  39  0.311931      -1.16497      -2.61471       2.61471       112.280       114.895    
  40  0.310920      -1.16822      -2.62200       2.62200       114.398       117.020    
  41  0.122272      -2.10150      -4.71670       4.71670       116.310       121.027    
  42  0.949359     -0.519686E-01 -0.116640      0.116640       115.517       115.634    
  43  0.500750     -0.691648      -1.55236       1.55236       109.837       111.390    
  44  0.729401E-01  -2.61812      -5.87621       5.87621       111.110       116.986    
  45  0.952528     -0.486360E-01 -0.109161      0.109161       111.829       111.938    
  46  0.718842     -0.330114     -0.740922      0.740922       113.092       113.833    
loop,thermsimp(1:2)       20   2.61525       2.27822    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    273        110.02         67.85          1.10         42.45          0.56          0.05        112.01
Just calling func    0   0        112.01


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    110.02
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    2.24444               271
loop is:       20
neval is:      272
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       20      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    2.24444               271
loop is:       21
neval is:      272


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 




neval>tstepnex so lower away!t
---> lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
     new SAtemp,tstepnext are :    1.12222               316

 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      272     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.307193      -1.18028      -1.32453       1.32453       105.672       106.997    
   2  0.575213     -0.553015     -0.620604      0.620604       107.960       108.581    
   3  0.632244     -0.458480     -0.514516      0.514516       106.582       107.096    
   4  0.819203     -0.199424     -0.223797      0.223797       108.292       108.516    
   5  0.137693E-02  -6.58790      -7.39307       7.39307       106.255       113.648    
   6  0.367814      -1.00018      -1.12242       1.12242       106.398       107.520    
   7  0.452636     -0.792666     -0.889547      0.889547       108.464       109.353    
   8  0.278102      -1.27977      -1.43618       1.43618       109.793       111.229    
   9  0.417803     -0.872745     -0.979412      0.979412       107.359       108.339    
  10  0.682140     -0.382521     -0.429273      0.429273       110.310       110.739    
  11  0.204733      -1.58605      -1.77989       1.77989       110.495       112.275    
  12  0.637442     -0.450292     -0.505327      0.505327       107.064       107.569    
  13  0.114518      -2.16702      -2.43188       2.43188       108.593       111.025    
  14  0.724207     -0.322678     -0.362116      0.362116       110.730       111.092    
  15  0.461399     -0.773492     -0.868029      0.868029       110.739       111.607    
  16  0.731739     -0.312332     -0.350505      0.350505       110.750       111.101    
  17  0.773272     -0.257124     -0.288550      0.288550       109.837       110.126    
  18  0.789195     -0.236742     -0.265677      0.265677       110.057       110.322    
  19  0.762001     -0.271807     -0.305027      0.305027       111.225       111.530    
  20  0.933384     -0.689386E-01 -0.773643E-01  0.773643E-01   111.506       111.583    
  21  0.694037     -0.365230     -0.409869      0.409869       111.829       112.239    
  22  0.423570     -0.859038     -0.964030      0.964030       110.113       111.077    
  23  0.272919      -1.29858      -1.45729       1.45729       110.597       112.054    
  24  0.535843     -0.623914     -0.700170      0.700170       108.940       109.640    
  25  0.902288     -0.102822     -0.115389      0.115389       111.852       111.968    
  26  0.479374     -0.735275     -0.825140      0.825140       112.739       113.564    
  27  0.494900E-01  -3.00599      -3.37338       3.37338       112.604       115.977    
  28  0.921867     -0.813539E-01 -0.912970E-01  0.912970E-01   112.210       112.302    
  29  0.132425      -2.02174      -2.26883       2.26883       110.272       112.541    
  30  0.640539     -0.445446     -0.499888      0.499888       113.092       113.592    
  31  0.215363      -1.53543      -1.72309       1.72309       112.154       113.877    
  32  0.437204E-01  -3.12994      -3.51248       3.51248       112.407       115.919    
  33  0.166028      -1.79560      -2.01506       2.01506       112.280       114.295    
  34  0.425825     -0.853727     -0.958070      0.958070       114.506       115.464    
  35  0.810393     -0.210235     -0.235931      0.235931       115.517       115.753    
  36  0.855958     -0.155534     -0.174544      0.174544       109.148       109.323    
  37  0.830452     -0.185786     -0.208492      0.208492       114.020       114.228    
  38  0.658784     -0.417359     -0.468369      0.468369       113.539       114.008    
  39  0.910965     -0.932509E-01 -0.104648      0.104648       111.110       111.215    
  40  0.603480     -0.505043     -0.566769      0.566769       114.398       114.965    
  41  0.702610     -0.352953     -0.396092      0.396092       113.219       113.615    
  42  0.329065      -1.11150      -1.24735       1.24735       110.699       111.947    
  43  0.790497     -0.235094     -0.263827      0.263827       115.056       115.320    
  44  0.641572     -0.443834     -0.498079      0.498079       112.509       113.007    
  45  0.650683     -0.429733     -0.482256      0.482256       116.310       116.793    
  46  0.194049E-02  -6.24481      -7.00806       7.00806       110.023       117.031    
loop,thermsimp(1:2)       21   1.32453      0.620604    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    274        114.28         67.82          1.10         42.09          0.62          0.05        111.67
Just calling func    0   0        111.67


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    114.28
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       21
neval is:      273
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       21      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       22
neval is:      273


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      273     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.838898     -0.175666     -0.197136      0.197136       105.672       105.869    
   2  0.801853     -0.220830     -0.247820      0.247820       106.582       106.829    
   3  0.768645     -0.263126     -0.295285      0.295285       106.398       106.693    
   4  0.855557     -0.156003     -0.175070      0.175070       107.064       107.239    
   5  0.845591     -0.167720     -0.188219      0.188219       107.359       107.547    
   6  0.350050      -1.04968      -1.17797       1.17797       108.292       109.470    
   7  0.927608     -0.751463E-01 -0.843307E-01  0.843307E-01   107.960       108.044    
   8  0.655345E-01  -2.72518      -3.05825       3.05825       109.148       112.206    
   9  0.355481      -1.03428      -1.16069       1.16069       108.464       109.625    
  10  0.728523     -0.316737     -0.355449      0.355449       108.940       109.296    
  11  0.573220     -0.556486     -0.624500      0.624500       109.837       110.462    
  12  0.112478      -2.18499      -2.45205       2.45205       110.057       112.509    
  13  0.338739      -1.08253      -1.21483       1.21483       110.310       111.525    
  14  0.239648      -1.42858      -1.60318       1.60318       108.593       110.196    
  15  0.918959     -0.845134E-01 -0.948426E-01  0.948426E-01   110.113       110.208    
  16  0.283771      -1.25959      -1.41353       1.41353       110.730       112.144    
  17  0.414404     -0.880913     -0.988579      0.988579       110.750       111.739    
  18  0.716403     -0.333512     -0.374274      0.374274       111.110       111.485    
  19  0.317726      -1.14657      -1.28670       1.28670       109.793       111.080    
  20  0.339005      -1.08174      -1.21395       1.21395       111.225       112.439    
  21  0.163059      -1.81364      -2.03531       2.03531       111.506       113.541    
  22  0.477081     -0.740069     -0.830520      0.830520       110.739       111.570    
  23  0.105851      -2.24573      -2.52020       2.52020       110.699       113.220    
  24  0.840431     -0.173840     -0.195087      0.195087       111.852       112.047    
  25  0.235315      -1.44683      -1.62366       1.62366       110.597       112.221    
  26  0.865464     -0.144489     -0.162149      0.162149       111.829       111.991    
  27  0.909462     -0.949026E-01 -0.106502      0.106502       110.495       110.602    
  28  0.152105E-01  -4.18577      -4.69735       4.69735       112.210       116.908    
  29  0.962485     -0.382371E-01 -0.429105E-01  0.429105E-01   110.272       110.315    
  30  0.259410      -1.34934      -1.51426       1.51426       112.509       114.023    
  31  0.364880      -1.00819      -1.13141       1.13141       112.739       113.870    
  32  0.467235     -0.760923     -0.853923      0.853923       113.092       113.946    
  33  0.844908     -0.168527     -0.189125      0.189125       113.219       113.408    
  34  0.188232      -1.67008      -1.87420       1.87420       106.255       108.129    
  35  0.496585     -0.700000     -0.785555      0.785555       112.154       112.939    
  36  0.410505     -0.890367     -0.999188      0.999188       113.539       114.539    
  37  0.533875     -0.627594     -0.704299      0.704299       114.020       114.724    
  38  0.610668     -0.493202     -0.553481      0.553481       112.280       112.833    
  39  0.241933      -1.41910      -1.59254       1.59254       114.398       115.990    
  40  0.642629     -0.442188     -0.496232      0.496232       115.056       115.552    
  41  0.775072     -0.254799     -0.285941      0.285941       114.506       114.792    
  42  0.345343      -1.06322      -1.19316       1.19316       115.517       116.711    
  43  0.844097     -0.169488     -0.190203      0.190203       112.407       112.597    
  44  0.426886     -0.851239     -0.955278      0.955278       112.604       113.559    
  45  0.594109     -0.520693     -0.584333      0.584333       116.310       116.895    
  46  0.489527     -0.714316     -0.801620      0.801620       114.282       115.084    
loop,thermsimp(1:2)       22  0.197136      0.247820    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    275        129.41         67.91          1.11         42.06          0.47          0.05        111.60
Just calling func    0   0        111.61


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    276        110.07         67.89          1.10         42.09          0.45          0.05        111.57
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    110.07
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       22
neval is:      275
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       22      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       23
neval is:      275


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      275     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.848355     -0.164456     -0.184556      0.184556       105.672       105.857    
   2  0.848474     -0.164316     -0.184399      0.184399       106.398       106.582    
   3  0.146795      -1.91872      -2.15322       2.15322       106.582       108.735    
   4  0.398624     -0.919738      -1.03215       1.03215       107.064       108.096    
   5  0.888093     -0.118679     -0.133184      0.133184       107.359       107.492    
   6  0.475009     -0.744421     -0.835405      0.835405       107.960       108.795    
   7  0.120824      -2.11342      -2.37172       2.37172       106.255       108.627    
   8  0.270052      -1.30914      -1.46914       1.46914       108.940       110.409    
   9  0.201748E-01  -3.90332      -4.38039       4.38039       108.292       112.673    
  10  0.999386     -0.614559E-03 -0.689670E-03  0.689670E-03   108.464       108.465    
  11  0.212655      -1.54808      -1.73729       1.73729       108.593       110.330    
  12  0.197911      -1.61994      -1.81793       1.81793       110.113       111.931    
  13  0.786394     -0.240297     -0.269667      0.269667       110.272       110.542    
  14  0.781263     -0.246844     -0.277013      0.277013       109.837       110.114    
  15  0.788011     -0.238244     -0.267362      0.267362       110.495       110.763    
  16  0.956387     -0.445927E-01 -0.500428E-01  0.500428E-01   109.793       109.843    
  17  0.717415     -0.332100     -0.372690      0.372690       111.110       111.483    
  18  0.808756     -0.212258     -0.238200      0.238200       110.310       110.548    
  19  0.756838     -0.278606     -0.312658      0.312658       110.739       111.052    
  20  0.570684     -0.560919     -0.629475      0.629475       110.750       111.380    
  21  0.946031     -0.554796E-01 -0.622604E-01  0.622604E-01   111.829       111.891    
  22  0.678634E-01  -2.69026      -3.01906       3.01906       111.852       114.871    
  23  0.631502     -0.459654     -0.515833      0.515833       110.730       111.246    
  24  0.114784E-01  -4.46729      -5.01328       5.01328       109.148       114.161    
  25  0.549681     -0.598417     -0.671556      0.671556       110.597       111.269    
  26  0.846433     -0.166725     -0.187102      0.187102       111.225       111.412    
  27  0.441841     -0.816805     -0.916635      0.916635       110.057       110.973    
  28  0.299100      -1.20698      -1.35449       1.35449       112.407       113.761    
  29  0.378130     -0.972517      -1.09138       1.09138       112.280       113.371    
  30  0.830469     -0.185764     -0.208468      0.208468       112.154       112.362    
  31  0.675108     -0.392883     -0.440902      0.440902       110.699       111.140    
  32  0.997619     -0.238377E-02 -0.267511E-02  0.267511E-02   113.219       113.222    
  33  0.897623     -0.108005     -0.121205      0.121205       111.506       111.627    
  34  0.591811E-01  -2.82715      -3.17269       3.17269       112.604       115.777    
  35  0.229825      -1.47044      -1.65015       1.65015       112.739       114.389    
  36  0.654017     -0.424622     -0.476520      0.476520       113.092       113.568    
  37  0.305777      -1.18490      -1.32972       1.32972       112.509       113.839    
  38  0.936135     -0.659954E-01 -0.740614E-01  0.740614E-01   113.539       113.613    
  39  0.698153     -0.359317     -0.403233      0.403233       114.020       114.423    
  40  0.829975     -0.186360     -0.209137      0.209137       114.506       114.715    
  41  0.951351     -0.498721E-01 -0.559675E-01  0.559675E-01   114.282       114.338    
  42  0.883299     -0.124092     -0.139259      0.139259       115.056       115.195    
  43  0.910087     -0.942154E-01 -0.105730      0.105730       114.398       114.504    
  44  0.590840     -0.526210     -0.590524      0.590524       115.517       116.108    
  45  0.146785      -1.91879      -2.15330       2.15330       116.310       118.464    
  46  0.830381E-01  -2.48846      -2.79260       2.79260       110.074       112.867    
loop,thermsimp(1:2)       23  0.184556      0.184399    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    277        115.28         67.77          1.09         42.05          0.54          0.05        111.50
Just calling func    0   0        111.50


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    115.28
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       23
neval is:      276
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       23      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       24
neval is:      276


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      276     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.102026      -2.28253      -2.56150       2.56150       105.672       108.234    
   2  0.372115     -0.988552      -1.10937       1.10937       106.398       107.507    
   3  0.732875     -0.310780     -0.348764      0.348764       107.359       107.708    
   4  0.341646      -1.07398      -1.20524       1.20524       107.064       108.269    
   5  0.406512     -0.900141      -1.01016       1.01016       108.464       109.474    
   6  0.271848      -1.30251      -1.46171       1.46171       106.255       107.717    
   7  0.738418     -0.303245     -0.340307      0.340307       106.582       106.922    
   8  0.903199     -0.101813     -0.114257      0.114257       107.960       108.074    
   9  0.511789     -0.669842     -0.751711      0.751711       109.793       110.545    
  10  0.202674      -1.59616      -1.79124       1.79124       109.837       111.629    
  11  0.325695      -1.12179      -1.25890       1.25890       108.593       109.852    
  12  0.719720     -0.328893     -0.369090      0.369090       108.940       109.309    
  13  0.715609     -0.334622     -0.375519      0.375519       110.272       110.648    
  14  0.973328     -0.270339E-01 -0.303380E-01  0.303380E-01   110.310       110.340    
  15  0.373998     -0.983504      -1.10371       1.10371       110.495       111.599    
  16  0.977965     -0.222815E-01 -0.250048E-01  0.250048E-01   110.057       110.082    
  17  0.105495      -2.24909      -2.52398       2.52398       110.739       113.263    
  18  0.729809     -0.314973     -0.353469      0.353469       110.699       111.053    
  19  0.378008     -0.972839      -1.09174       1.09174       110.730       111.822    
  20  0.678326     -0.388127     -0.435564      0.435564       110.597       111.033    
  21  0.671993     -0.397507     -0.446091      0.446091       110.750       111.196    
  22  0.515926     -0.661792     -0.742677      0.742677       111.225       111.967    
  23  0.363490      -1.01200      -1.13569       1.13569       111.110       112.246    
  24  0.206319      -1.57833      -1.77123       1.77123       111.506       113.277    
  25  0.755157E-01  -2.58341      -2.89916       2.89916       111.829       114.728    
  26  0.413763     -0.882461     -0.990316      0.990316       110.113       111.104    
  27  0.279023      -1.27646      -1.43247       1.43247       112.154       113.586    
  28  0.506422     -0.680385     -0.763542      0.763542       108.292       109.056    
  29  0.643082E-02  -5.04665      -5.66346       5.66346       110.074       115.738    
  30  0.285888E-01  -3.55474      -3.98920       3.98920       113.219       117.208    
  31  0.660419     -0.414880     -0.465587      0.465587       112.280       112.745    
  32  0.739369     -0.301959     -0.338864      0.338864       113.092       113.431    
  33  0.270269      -1.30834      -1.46824       1.46824       113.539       115.008    
  34  0.663889     -0.409640     -0.459706      0.459706       112.407       112.866    
  35  0.898739E-01  -2.40935      -2.70382       2.70382       112.509       115.213    
  36  0.832427     -0.183410     -0.205827      0.205827       109.148       109.354    
  37  0.723106     -0.324200     -0.363824      0.363824       114.282       114.646    
  38  0.986274     -0.138207E-01 -0.155099E-01  0.155099E-01   112.739       112.754    
  39  0.812861     -0.207195     -0.232519      0.232519       114.020       114.252    
  40  0.553236     -0.591971     -0.664322      0.664322       114.398       115.062    
  41  0.693785E-01  -2.66818      -2.99429       2.99429       114.506       117.501    
  42  0.117256      -2.14340      -2.40537       2.40537       111.852       114.258    
  43  0.807809     -0.213430     -0.239515      0.239515       115.056       115.296    
  44  0.900249     -0.105084     -0.117927      0.117927       112.604       112.722    
  45  0.753470     -0.283066     -0.317662      0.317662       115.517       115.835    
  46  0.127159      -2.06232      -2.31438       2.31438       115.281       117.595    
loop,thermsimp(1:2)       24   2.56150       1.10937    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    278        116.31         67.80          1.10         42.13          0.46          0.05        111.54
Just calling func    0   0        111.54


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    116.31
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       24
neval is:      277
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       24      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       25
neval is:      277


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      277     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.962782     -0.379284E-01 -0.425641E-01  0.425641E-01   106.582       106.624    
   2  0.355374      -1.03458      -1.16103       1.16103       106.398       107.559    
   3  0.294461      -1.22261      -1.37204       1.37204       107.359       108.731    
   4  0.644538     -0.439222     -0.492904      0.492904       106.255       106.748    
   5  0.741622     -0.298915     -0.335449      0.335449       107.960       108.296    
   6  0.805913E-01  -2.51837      -2.82616       2.82616       105.672       108.498    
   7  0.498180     -0.696794     -0.781957      0.781957       107.064       107.846    
   8  0.771004     -0.260061     -0.291846      0.291846       108.292       108.584    
   9  0.753480     -0.283053     -0.317648      0.317648       108.940       109.258    
  10  0.460525     -0.775387     -0.870156      0.870156       109.148       110.018    
  11  0.918626     -0.848759E-01 -0.952495E-01  0.952495E-01   108.464       108.559    
  12  0.355379      -1.03457      -1.16102       1.16102       108.593       109.754    
  13  0.664646     -0.408501     -0.458428      0.458428       110.057       110.515    
  14  0.328018      -1.11469      -1.25093       1.25093       110.310       111.561    
  15  0.529583     -0.635665     -0.713356      0.713356       109.793       110.506    
  16  0.259823      -1.34775      -1.51248       1.51248       110.272       111.784    
  17  0.463690E-01  -3.07112      -3.44648       3.44648       110.597       114.044    
  18  0.366509      -1.00373      -1.12641       1.12641       110.699       111.826    
  19  0.794534     -0.229999     -0.258110      0.258110       110.113       110.372    
  20  0.669373     -0.401413     -0.450474      0.450474       110.750       111.201    
  21  0.798901     -0.224518     -0.251959      0.251959       110.495       110.747    
  22  0.610403     -0.493636     -0.553969      0.553969       109.837       110.391    
  23  0.267818      -1.31745      -1.47847       1.47847       110.730       112.208    
  24  0.663049     -0.410906     -0.461127      0.461127       111.225       111.686    
  25  0.782871     -0.244788     -0.274706      0.274706       111.110       111.385    
  26  0.706545     -0.347368     -0.389824      0.389824       112.604       112.994    
  27  0.120119      -2.11927      -2.37829       2.37829       112.280       114.658    
  28  0.270575      -1.30721      -1.46698       1.46698       112.739       114.206    
  29  0.505391     -0.682422     -0.765828      0.765828       112.407       113.172    
  30  0.665734     -0.406865     -0.456592      0.456592       110.739       111.196    
  31  0.836788     -0.178185     -0.199963      0.199963       111.506       111.705    
  32  0.866983     -0.142736     -0.160181      0.160181       113.092       113.252    
  33  0.552904     -0.592571     -0.664995      0.664995       112.154       112.819    
  34  0.554153     -0.590314     -0.662463      0.662463       114.020       114.682    
  35  0.592407E-01  -2.82615      -3.17156       3.17156       111.852       115.024    
  36  0.902163     -0.102960     -0.115543      0.115543       114.282       114.398    
  37  0.266638E-01  -3.62445      -4.06743       4.06743       111.829       115.896    
  38  0.897053     -0.108640     -0.121918      0.121918       113.539       113.661    
  39  0.840496     -0.173763     -0.195000      0.195000       114.398       114.593    
  40  0.288358      -1.24355      -1.39554       1.39554       112.509       113.905    
  41  0.835972E-01  -2.48175      -2.78507       2.78507       115.056       117.841    
  42  0.412070     -0.886563     -0.994919      0.994919       110.074       111.069    
  43  0.725010     -0.321570     -0.360872      0.360872       115.517       115.878    
  44  0.316556      -1.15026      -1.29084       1.29084       113.219       114.510    
  45  0.486178     -0.721181     -0.809324      0.809324       114.506       115.316    
  46  0.143341      -1.94253      -2.17995       2.17995       116.310       118.490    
loop,thermsimp(1:2)       25  0.425641E-01   1.16103    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    279        115.28         67.81          1.10         42.46          0.45          0.05        111.86
Just calling func    0   0        111.86


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    115.28
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       25
neval is:      278
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       25      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       26
neval is:      278


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      278     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.987524     -0.125549E-01 -0.140893E-01  0.140893E-01   106.582       106.596    
   2  0.516099     -0.661457     -0.742301      0.742301       106.255       106.998    
   3  0.202206      -1.59847      -1.79384       1.79384       106.398       108.191    
   4  0.240260      -1.42603      -1.60032       1.60032       107.064       108.664    
   5  0.717263E-01  -2.63490      -2.95694       2.95694       107.960       110.917    
   6  0.395382     -0.927902      -1.04131       1.04131       105.672       106.713    
   7  0.494348     -0.704516     -0.790623      0.790623       108.464       109.255    
   8  0.970815     -0.296196E-01 -0.332398E-01  0.332398E-01   108.292       108.325    
   9  0.992795     -0.723105E-02 -0.811484E-02  0.811484E-02   107.359       107.367    
  10  0.387320     -0.948503      -1.06443       1.06443       108.940       110.005    
  11  0.586568     -0.533466     -0.598667      0.598667       108.593       109.192    
  12  0.119144      -2.12742      -2.38744       2.38744       109.148       111.536    
  13  0.145144      -1.93003      -2.16592       2.16592       110.113       112.279    
  14  0.767931     -0.264056     -0.296329      0.296329       109.837       110.134    
  15  0.415014     -0.879442     -0.986928      0.986928       109.793       110.780    
  16  0.994477     -0.553801E-02 -0.621486E-02  0.621486E-02   110.057       110.063    
  17  0.757243     -0.278071     -0.312057      0.312057       110.495       110.807    
  18  0.669290     -0.401537     -0.450613      0.450613       110.074       110.525    
  19  0.112026      -2.18903      -2.45657       2.45657       110.739       113.196    
  20  0.434244     -0.834148     -0.936098      0.936098       110.750       111.686    
  21  0.491828     -0.709627     -0.796358      0.796358       111.110       111.907    
  22  0.517535     -0.658677     -0.739181      0.739181       110.310       111.049    
  23  0.411147     -0.888804     -0.997434      0.997434       111.225       112.222    
  24  0.250164      -1.38564      -1.55499       1.55499       111.506       113.061    
  25  0.109742E-01  -4.51221      -5.06370       5.06370       110.272       115.336    
  26  0.559459     -0.580786     -0.651770      0.651770       110.699       111.351    
  27  0.289677      -1.23899      -1.39042       1.39042       110.730       112.120    
  28  0.835809     -0.179356     -0.201277      0.201277       112.154       112.355    
  29  0.236182      -1.44315      -1.61953       1.61953       112.604       114.224    
  30  0.700988     -0.355264     -0.398685      0.398685       112.407       112.805    
  31  0.886914     -0.120007     -0.134675      0.134675       113.092       113.227    
  32  0.182911      -1.69875      -1.90638       1.90638       113.539       115.446    
  33  0.693089     -0.366597     -0.411403      0.411403       112.509       112.921    
  34  0.108523      -2.22079      -2.49221       2.49221       110.597       113.089    
  35  0.141600      -1.95475      -2.19366       2.19366       112.739       114.932    
  36  0.168348E-01  -4.08431      -4.58349       4.58349       114.282       118.866    
  37  0.419419E-01  -3.17147      -3.55909       3.55909       113.219       116.778    
  38  0.244896      -1.40692      -1.57888       1.57888       114.398       115.977    
  39  0.360662      -1.01981      -1.14446       1.14446       112.280       113.424    
  40  0.927013     -0.757879E-01 -0.850507E-01  0.850507E-01   114.020       114.105    
  41  0.869067     -0.140335     -0.157487      0.157487       111.852       112.010    
  42  0.827083     -0.189851     -0.213054      0.213054       114.506       114.719    
  43  0.928403     -0.742893E-01 -0.833690E-01  0.833690E-01   115.517       115.601    
  44  0.513193     -0.667103     -0.748637      0.748637       111.829       112.578    
  45  0.809080     -0.211858     -0.237751      0.237751       115.056       115.294    
  46  0.341224E-02  -5.68039      -6.37465       6.37465       115.281       121.656    
loop,thermsimp(1:2)       26  0.140893E-01  0.742301    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    280        116.31         67.78          1.10         42.30          0.17          0.05        111.40
Just calling func    0   0        111.40


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    116.31
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       26
neval is:      279
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       26      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       27
neval is:      279


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      279     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.199609      -1.61140      -1.80834       1.80834       106.582       108.390    
   2  0.983274     -0.168677E-01 -0.189292E-01  0.189292E-01   105.672       105.691    
   3  0.569108     -0.563685     -0.632579      0.632579       106.255       106.888    
   4  0.411179     -0.888728     -0.997349      0.997349       107.359       108.357    
   5  0.889241     -0.117387     -0.131734      0.131734       106.398       106.529    
   6  0.109537      -2.21149      -2.48179       2.48179       108.292       110.774    
   7  0.658027     -0.418509     -0.469660      0.469660       107.064       107.534    
   8  0.427534     -0.849722     -0.953575      0.953575       108.593       109.547    
   9  0.277803      -1.28084      -1.43739       1.43739       108.464       109.901    
  10  0.568421     -0.564892     -0.633934      0.633934       108.940       109.574    
  11  0.368489     -0.998346      -1.12036       1.12036       110.057       111.177    
  12  0.100945E-01  -4.59576      -5.15746       5.15746       109.837       114.995    
  13  0.811445     -0.208939     -0.234475      0.234475       110.074       110.309    
  14  0.135138      -2.00146      -2.24608       2.24608       109.793       112.039    
  15  0.600340     -0.510258     -0.572622      0.572622       110.495       111.068    
  16  0.537538     -0.620755     -0.696625      0.696625       107.960       108.657    
  17  0.923261     -0.798434E-01 -0.896019E-01  0.896019E-01   110.310       110.400    
  18  0.296505      -1.21569      -1.36428       1.36428       110.699       112.064    
  19  0.975666     -0.246348E-01 -0.276457E-01  0.276457E-01   109.148       109.176    
  20  0.102971      -2.27331      -2.55116       2.55116       110.750       113.301    
  21  0.110137      -2.20603      -2.47565       2.47565       111.110       113.586    
  22  0.874539     -0.134058     -0.150443      0.150443       111.852       112.003    
  23  0.887507     -0.119339     -0.133925      0.133925       110.730       110.864    
  24  0.811767     -0.208543     -0.234031      0.234031       111.225       111.459    
  25  0.304283      -1.18980      -1.33521       1.33521       110.113       111.449    
  26  0.304144      -1.19025      -1.33573       1.33573       112.154       113.489    
  27  0.854538     -0.157194     -0.176406      0.176406       111.829       112.005    
  28  0.543001     -0.610645     -0.685278      0.685278       112.407       113.092    
  29  0.808766     -0.212246     -0.238187      0.238187       112.509       112.747    
  30  0.286176      -1.25115      -1.40406       1.40406       111.506       112.910    
  31  0.328161      -1.11425      -1.25043       1.25043       110.597       111.848    
  32  0.563264     -0.574006     -0.644161      0.644161       110.739       111.383    
  33  0.180895      -1.70984      -1.91882       1.91882       113.092       115.011    
  34  0.977796     -0.224538E-01 -0.251981E-01  0.251981E-01   112.280       112.305    
  35  0.650784     -0.429577     -0.482080      0.482080       114.020       114.502    
  36  0.350586      -1.04815      -1.17625       1.17625       112.604       113.780    
  37  0.852996E-01  -2.46159      -2.76244       2.76244       114.506       117.269    
  38  0.363921      -1.01082      -1.13436       1.13436       112.739       113.873    
  39  0.715496E-01  -2.63737      -2.95971       2.95971       115.056       118.016    
  40  0.540542     -0.615184     -0.690372      0.690372       110.272       110.962    
  41  0.458744E-02  -5.38443      -6.04252       6.04252       113.539       119.582    
  42  0.684509     -0.379054     -0.425382      0.425382       115.517       115.943    
  43  0.827193     -0.189717     -0.212905      0.212905       114.398       114.611    
  44  0.430712     -0.842315     -0.945264      0.945264       113.219       114.164    
  45  0.925073     -0.778822E-01 -0.874011E-01  0.874011E-01   114.282       114.370    
  46  0.139567      -1.96921      -2.20989       2.20989       116.310       118.520    
loop,thermsimp(1:2)       27   1.80834      0.189292E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    281        108.87         67.91          1.12         42.12          0.38          0.05        111.58
Just calling func    0   0        111.58


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  280    108.87       0.8143     -2.734      2.701     -102.6     0.5319    
                       1.056     0.8278     -99.70      4.305     0.9889    

                       1.620     -2.235      1.540      7353.      7000.    

                      0.3796      0.000      0.000      0.000     -1.221    



                      -2.368      0.000      0.000      7000.      1398.    

                       1.736     -5.139     -5.322     -8.119      7.039    

                      -17.20     -6.758      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4397    -0.8127      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.5496     -1.177      7000.    



                      -1.615     -1.490     -2.022     -1.960    -0.3807    

                     -0.3252      9.244      8.765    -0.1568E+05 -5.223    

                     -0.3960     -3.154      9.409      8.872    -0.1969E+05



                      -6.000     0.5250    -0.1684      8.946      8.988    

                     -0.1944E+05 -6.000    -0.9013    -0.5886      9.109    

                       8.846    -0.1891E+05 -6.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    108.87
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       27
neval is:      280
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       27      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       28
neval is:      280


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      280     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.231666      -1.46246      -1.64120       1.64120       105.672       107.313    
   2  0.922423     -0.807516E-01 -0.906212E-01  0.906212E-01   106.398       106.488    
   3  0.556007     -0.586974     -0.658714      0.658714       106.255       106.914    
   4  0.921345     -0.819211E-01 -0.919336E-01  0.919336E-01   107.064       107.156    
   5  0.623358     -0.472635     -0.530401      0.530401       107.359       107.890    
   6  0.967150     -0.334012E-01 -0.374835E-01  0.374835E-01   106.582       106.619    
   7  0.239844      -1.42777      -1.60227       1.60227       107.960       109.562    
   8  0.707370     -0.346201     -0.388514      0.388514       109.148       109.537    
   9  0.375591     -0.979256      -1.09894       1.09894       108.593       109.692    
  10  0.164915      -1.80233      -2.02261       2.02261       108.940       110.963    
  11  0.634729     -0.454558     -0.510114      0.510114       108.464       108.974    
  12  0.956585     -0.443852E-01 -0.498100E-01  0.498100E-01   110.074       110.124    
  13  0.281051      -1.26922      -1.42434       1.42434       110.310       111.734    
  14  0.332446      -1.10128      -1.23588       1.23588       108.292       109.528    
  15  0.417901     -0.872510     -0.979149      0.979149       110.730       111.709    
  16  0.454459     -0.788647     -0.885036      0.885036       110.272       111.157    
  17  0.163150      -1.81309      -2.03468       2.03468       110.495       112.530    
  18  0.412675     -0.885095     -0.993272      0.993272       110.057       111.050    
  19  0.510076     -0.673195     -0.755474      0.755474       110.739       111.494    
  20  0.159872E-02  -6.43855      -7.22547       7.22547       110.113       117.339    
  21  0.279094      -1.27620      -1.43218       1.43218       111.225       112.657    
  22  0.229843E-01  -3.77294      -4.23408       4.23408       110.597       114.831    
  23  0.829240E-02  -4.79242      -5.37815       5.37815       111.852       117.231    
  24  0.722732     -0.324717     -0.364404      0.364404       111.829       112.193    
  25  0.399402     -0.917787      -1.02996       1.02996       109.793       110.823    
  26  0.321457      -1.13489      -1.27360       1.27360       110.699       111.973    
  27  0.103147      -2.27160      -2.54923       2.54923       112.280       114.829    
  28  0.488570     -0.716273     -0.803817      0.803817       112.509       113.313    
  29  0.775391     -0.254388     -0.285479      0.285479       111.506       111.791    
  30  0.264831      -1.32866      -1.49105       1.49105       112.407       113.898    
  31  0.291634      -1.23225      -1.38286       1.38286       110.750       112.133    
  32  0.754799E-02  -4.88647      -5.48370       5.48370       112.154       117.637    
  33  0.403715     -0.907047      -1.01791       1.01791       111.110       112.128    
  34  0.794963     -0.229460     -0.257505      0.257505       112.604       112.862    
  35  0.482612E-01  -3.03113      -3.40159       3.40159       112.739       116.140    
  36  0.309506      -1.17278      -1.31611       1.31611       113.219       114.535    
  37  0.265676      -1.32548      -1.48748       1.48748       114.282       115.770    
  38  0.793358     -0.231480     -0.259772      0.259772       114.020       114.280    
  39  0.603192E-01  -2.80811      -3.15131       3.15131       114.398       117.549    
  40  0.516664     -0.660363     -0.741073      0.741073       109.837       110.578    
  41  0.524892E-01  -2.94715      -3.30735       3.30735       113.092       116.399    
  42  0.581500     -0.542144     -0.608405      0.608405       115.517       116.126    
  43  0.403805     -0.906823      -1.01766       1.01766       114.506       115.524    
  44  0.447829     -0.803344     -0.901529      0.901529       115.056       115.958    
  45  0.470604     -0.753737     -0.845860      0.845860       116.310       117.156    
  46  0.479088     -0.735871     -0.825809      0.825809       108.870       109.696    
loop,thermsimp(1:2)       28   1.64120      0.906212E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    282        111.80         67.80          1.10         41.97          0.71          0.05        111.62
Just calling func    0   0        111.62


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    111.80
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       28
neval is:      281
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       28      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       29
neval is:      281


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      281     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.332051      -1.10247      -1.23721       1.23721       106.398       107.635    
   2  0.991191     -0.884791E-02 -0.992930E-02  0.992930E-02   106.582       106.592    
   3  0.752830     -0.283916     -0.318617      0.318617       106.255       106.574    
   4  0.718872     -0.330071     -0.370413      0.370413       107.064       107.434    
   5  0.362244      -1.01544      -1.13955       1.13955       105.672       106.812    
   6  0.993342E-01  -2.30927      -2.59151       2.59151       107.359       109.951    
   7  0.734379     -0.308729     -0.346462      0.346462       108.464       108.810    
   8  0.190509      -1.65806      -1.86070       1.86070       108.292       110.153    
   9  0.113713      -2.17408      -2.43979       2.43979       109.148       111.588    
  10  0.582158     -0.541014     -0.607137      0.607137       107.960       108.567    
  11  0.100405E-01  -4.60113      -5.16348       5.16348       108.593       113.757    
  12  0.614877     -0.486333     -0.545773      0.545773       108.870       109.416    
  13  0.996806     -0.319890E-02 -0.358988E-02  0.358988E-02   110.074       110.078    
  14  0.439871E-01  -3.12386      -3.50566       3.50566       109.837       113.343    
  15  0.610456     -0.493549     -0.553871      0.553871       109.793       110.347    
  16  0.676471     -0.390866     -0.438637      0.438637       108.940       109.379    
  17  0.263829      -1.33246      -1.49531       1.49531       110.057       111.552    
  18  0.761962     -0.271858     -0.305085      0.305085       110.272       110.577    
  19  0.405295     -0.903140      -1.01352       1.01352       110.739       111.753    
  20  0.184680      -1.68913      -1.89558       1.89558       110.730       112.626    
  21  0.695434     -0.363219     -0.407612      0.407612       110.310       110.718    
  22  0.597154     -0.515580     -0.578595      0.578595       111.506       112.084    
  23  0.254276      -1.36933      -1.53669       1.53669       110.699       112.236    
  24  0.777974     -0.251062     -0.281747      0.281747       111.110       111.392    
  25  0.597236     -0.515443     -0.578441      0.578441       110.750       111.328    
  26  0.658168     -0.418295     -0.469419      0.469419       111.829       112.298    
  27  0.917953     -0.856086E-01 -0.960717E-01  0.960717E-01   110.495       110.591    
  28  0.167567      -1.78637      -2.00471       2.00471       111.225       113.229    
  29  0.867739E-02  -4.74703      -5.32722       5.32722       112.604       117.931    
  30  0.157469      -1.84853      -2.07446       2.07446       112.509       114.584    
  31  0.947458     -0.539724E-01 -0.605690E-01  0.605690E-01   112.407       112.467    
  32  0.883772     -0.123556     -0.138657      0.138657       114.020       114.159    
  33  0.873100     -0.135705     -0.152291      0.152291       113.219       113.371    
  34  0.138043      -1.98019      -2.22221       2.22221       112.280       114.502    
  35  0.833185     -0.182500     -0.204805      0.204805       110.597       110.802    
  36  0.907894     -0.966275E-01 -0.108437      0.108437       114.506       114.615    
  37  0.858432     -0.152648     -0.171305      0.171305       114.282       114.454    
  38  0.192050      -1.65000      -1.85166       1.85166       115.056       116.908    
  39  0.890666     -0.115786     -0.129937      0.129937       115.517       115.647    
  40  0.389935     -0.941775      -1.05688       1.05688       112.739       113.795    
  41  0.842362     -0.171545     -0.192512      0.192512       113.092       113.284    
  42  0.143912      -1.93855      -2.17548       2.17548       116.310       118.486    
  43  0.678545     -0.387804     -0.435202      0.435202       111.852       112.288    
  44  0.621021     -0.476390     -0.534615      0.534615       110.113       110.648    
  45  0.533199     -0.628861     -0.705721      0.705721       114.398       115.104    
  46  0.891703     -0.114623     -0.128632      0.128632       111.796       111.924    
loop,thermsimp(1:2)       29   1.23721      0.992930E-02

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    283        114.50         67.83          1.10         42.39          0.76          0.05        112.14
Just calling func    0   0        112.14


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    114.50
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       29
neval is:      282
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       29      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       30
neval is:      282


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      282     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.157557      -1.84797      -2.07383       2.07383       106.255       108.329    
   2  0.553200     -0.592035     -0.664394      0.664394       106.582       107.246    
   3  0.825049     -0.192313     -0.215817      0.215817       105.672       105.888    
   4  0.767336     -0.264830     -0.297198      0.297198       107.064       107.361    
   5  0.966534     -0.340385E-01 -0.381987E-01  0.381987E-01   106.398       106.436    
   6  0.954430     -0.466410E-01 -0.523415E-01  0.523415E-01   107.960       108.012    
   7  0.780674     -0.247598     -0.277859      0.277859       108.464       108.742    
   8  0.312863      -1.16199      -1.30401       1.30401       108.940       110.244    
   9  0.990226     -0.982218E-02 -0.110227E-01  0.110227E-01   108.870       108.881    
  10  0.893872     -0.112193     -0.125905      0.125905       107.359       107.485    
  11  0.322320      -1.13221      -1.27059       1.27059       110.074       111.345    
  12  0.927465     -0.752997E-01 -0.845029E-01  0.845029E-01   108.292       108.377    
  13  0.539466     -0.617176     -0.692607      0.692607       109.793       110.485    
  14  0.461474     -0.773330     -0.867847      0.867847       110.272       111.140    
  15  0.745701     -0.293430     -0.329293      0.329293       110.495       110.825    
  16  0.703580     -0.351573     -0.394543      0.394543       110.113       110.508    
  17  0.917420E-01  -2.38878      -2.68073       2.68073       110.310       112.991    
  18  0.671661     -0.398001     -0.446645      0.446645       110.597       111.044    
  19  0.845179     -0.168207     -0.188765      0.188765       110.750       110.939    
  20  0.283605E-01  -3.56276      -3.99820       3.99820       111.110       115.108    
  21  0.108883E-01  -4.52006      -5.07251       5.07251       110.057       115.129    
  22  0.506006     -0.681208     -0.764465      0.764465       109.148       109.913    
  23  0.353918      -1.03869      -1.16564       1.16564       110.739       111.905    
  24  0.656862     -0.420282     -0.471649      0.471649       111.796       112.267    
  25  0.691560     -0.368806     -0.413881      0.413881       111.506       111.919    
  26  0.445402     -0.808779     -0.907628      0.907628       110.699       111.607    
  27  0.832700     -0.183081     -0.205458      0.205458       111.852       112.058    
  28  0.963063     -0.376360E-01 -0.422359E-01  0.422359E-01   111.829       111.871    
  29  0.422212     -0.862247     -0.967632      0.967632       112.407       113.374    
  30  0.917895     -0.856720E-01 -0.961428E-01  0.961428E-01   110.730       110.826    
  31  0.767210     -0.264994     -0.297382      0.297382       111.225       111.522    
  32  0.360836      -1.01933      -1.14391       1.14391       113.092       114.236    
  33  0.635930     -0.452667     -0.507992      0.507992       109.837       110.345    
  34  0.687292     -0.374995     -0.420828      0.420828       113.219       113.640    
  35  0.833832     -0.181724     -0.203934      0.203934       108.593       108.797    
  36  0.362075      -1.01590      -1.14007       1.14007       112.739       113.879    
  37  0.385764     -0.952530      -1.06895       1.06895       114.020       115.089    
  38  0.752556     -0.284279     -0.319024      0.319024       114.282       114.601    
  39  0.547433     -0.602515     -0.676154      0.676154       112.280       112.956    
  40  0.171004      -1.76607      -1.98192       1.98192       112.509       114.491    
  41  0.159022      -1.83871      -2.06344       2.06344       114.506       116.570    
  42  0.850806     -0.161571     -0.181318      0.181318       114.398       114.579    
  43  0.926075     -0.768001E-01 -0.861867E-01  0.861867E-01   115.517       115.604    
  44  0.584885     -0.536340     -0.601891      0.601891       115.056       115.658    
  45  0.547650     -0.602120     -0.675711      0.675711       112.604       113.280    
  46  0.864296     -0.145840     -0.163665      0.163665       114.504       114.668    
loop,thermsimp(1:2)       30   2.07383      0.664394    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    284        105.37         67.80          1.09         42.14          0.53          0.05        111.61
Just calling func    0   0        111.61


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    285        106.95         67.80          1.07         42.32          0.50          0.05        111.73
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    105.37
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       30
neval is:      284
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       30      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       31
neval is:      284


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      284     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.277512      -1.28189      -1.43856       1.43856       105.672       107.111    
   2  0.202445      -1.59728      -1.79251       1.79251       106.398       108.190    
   3  0.927152     -0.756373E-01 -0.848818E-01  0.848818E-01   106.582       106.666    
   4  0.403144     -0.908460      -1.01949       1.01949       107.064       108.083    
   5  0.791838     -0.233398     -0.261924      0.261924       107.359       107.621    
   6  0.292576      -1.22903      -1.37924       1.37924       107.960       109.339    
   7  0.135578      -1.99821      -2.24243       2.24243       106.255       108.498    
   8  0.516570     -0.660545     -0.741278      0.741278       108.292       109.033    
   9  0.730579     -0.313918     -0.352285      0.352285       108.464       108.816    
  10  0.508248     -0.676786     -0.759503      0.759503       108.593       109.353    
  11  0.928455     -0.742338E-01 -0.833067E-01  0.833067E-01   108.870       108.954    
  12  0.696477     -0.361721     -0.405930      0.405930       109.148       109.554    
  13  0.465556     -0.764522     -0.857962      0.857962       108.940       109.798    
  14  0.194653      -1.63654      -1.83655       1.83655       109.837       111.674    
  15  0.650312     -0.430303     -0.482895      0.482895       109.793       110.276    
  16  0.555802     -0.587343     -0.659128      0.659128       110.113       110.773    
  17  0.985517     -0.145893E-01 -0.163724E-01  0.163724E-01   110.495       110.512    
  18  0.923066     -0.800544E-01 -0.898387E-01  0.898387E-01   110.730       110.820    
  19  0.658765     -0.417388     -0.468401      0.468401       110.750       111.218    
  20  0.197878      -1.62010      -1.81811       1.81811       110.597       112.415    
  21  0.449673     -0.799236     -0.896919      0.896919       110.272       111.169    
  22  0.208093      -1.56977      -1.76163       1.76163       110.074       111.836    
  23  0.102791      -2.27506      -2.55312       2.55312       111.225       113.778    
  24  0.650538     -0.429955     -0.482505      0.482505       110.699       111.182    
  25  0.223365      -1.49895      -1.68215       1.68215       111.829       113.511    
  26  0.520729     -0.652525     -0.732277      0.732277       110.739       111.471    
  27  0.919707E-01  -2.38629      -2.67794       2.67794       111.506       114.183    
  28  0.788427     -0.237716     -0.266769      0.266769       111.852       112.119    
  29  0.395754     -0.926961      -1.04026       1.04026       111.796       112.836    
  30  0.903388     -0.101603     -0.114021      0.114021       112.280       112.394    
  31  0.569415     -0.563145     -0.631973      0.631973       110.310       110.942    
  32  0.974677     -0.256496E-01 -0.287845E-01  0.287845E-01   112.604       112.633    
  33  0.376411     -0.977073      -1.09649       1.09649       112.407       113.503    
  34  0.309090      -1.17412      -1.31763       1.31763       113.219       114.537    
  35  0.248039      -1.39417      -1.56457       1.56457       112.739       114.303    
  36  0.941329     -0.604621E-01 -0.678518E-01  0.678518E-01   113.092       113.160    
  37  0.131879      -2.02587      -2.27348       2.27348       112.509       114.783    
  38  0.188022      -1.67120      -1.87545       1.87545       114.398       116.273    
  39  0.898649E-01  -2.40945      -2.70393       2.70393       114.282       116.986    
  40  0.853893     -0.157949     -0.177254      0.177254       114.504       114.681    
  41  0.643577     -0.440714     -0.494578      0.494578       114.020       114.514    
  42  0.664391     -0.408885     -0.458859      0.458859       111.110       111.569    
  43  0.825262     -0.192054     -0.215527      0.215527       110.057       110.272    
  44  0.611498     -0.491843     -0.551956      0.551956       115.517       116.069    
  45  0.284000      -1.25878      -1.41263       1.41263       115.056       116.469    
  46  0.108174      -2.22402      -2.49584       2.49584       105.372       107.868    
loop,thermsimp(1:2)       31   1.43856       1.79251    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    286        109.59         67.82          1.10         42.02          0.43          0.05        111.42
Just calling func    0   0        111.42


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    109.59
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       31
neval is:      285
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       31      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       32
neval is:      285


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      285     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.701343     -0.354759     -0.398117      0.398117       106.582       106.980    
   2  0.779682     -0.248869     -0.279286      0.279286       105.672       105.951    
   3  0.611645     -0.491604     -0.551688      0.551688       107.359       107.911    
   4  0.380626     -0.965937      -1.08399       1.08399       105.372       106.456    
   5  0.986599     -0.134915E-01 -0.151404E-01  0.151404E-01   107.064       107.079    
   6  0.699021     -0.358075     -0.401839      0.401839       106.398       106.799    
   7  0.981217E-01  -2.32155      -2.60529       2.60529       106.255       108.861    
   8  0.221199      -1.50869      -1.69308       1.69308       108.464       110.157    
   9  0.802460     -0.220073     -0.246971      0.246971       108.870       109.117    
  10  0.623430     -0.472519     -0.530270      0.530270       108.292       108.822    
  11  0.669862     -0.400684     -0.449656      0.449656       107.960       108.410    
  12  0.957999     -0.429090E-01 -0.481533E-01  0.481533E-01   108.593       108.641    
  13  0.569879E-01  -2.86492      -3.21507       3.21507       109.148       112.363    
  14  0.245244      -1.40550      -1.57728       1.57728       108.940       110.517    
  15  0.870123     -0.139121     -0.156124      0.156124       110.057       110.213    
  16  0.429679     -0.844716     -0.947957      0.947957       109.793       110.741    
  17  0.369880     -0.994577      -1.11613       1.11613       110.495       111.611    
  18  0.964882     -0.357490E-01 -0.401183E-01  0.401183E-01   110.113       110.154    
  19  0.625983     -0.468432     -0.525684      0.525684       110.730       111.256    
  20  0.508652     -0.675991     -0.758611      0.758611       110.310       111.069    
  21  0.694697     -0.364279     -0.408801      0.408801       110.272       110.681    
  22  0.817819     -0.201114     -0.225694      0.225694       110.699       110.925    
  23  0.655732     -0.422003     -0.473581      0.473581       110.750       111.224    
  24  0.658757     -0.417401     -0.468415      0.468415       110.739       111.207    
  25  0.325934      -1.12106      -1.25808       1.25808       111.110       112.368    
  26  0.849137     -0.163535     -0.183522      0.183522       109.837       110.021    
  27  0.953435     -0.476843E-01 -0.535123E-01  0.535123E-01   110.074       110.128    
  28  0.435049     -0.832297     -0.934020      0.934020       111.852       112.786    
  29  0.155341E-01  -4.16472      -4.67373       4.67373       112.280       116.954    
  30  0.390095     -0.941364      -1.05642       1.05642       110.597       111.653    
  31  0.400867E-02  -5.51929      -6.19387       6.19387       112.604       118.798    
  32  0.989750     -0.103025E-01 -0.115617E-01  0.115617E-01   111.796       111.807    
  33  0.194149      -1.63913      -1.83946       1.83946       113.092       114.931    
  34  0.573547     -0.555915     -0.623859      0.623859       112.407       113.031    
  35  0.570216     -0.561740     -0.630396      0.630396       111.829       112.459    
  36  0.802122     -0.220494     -0.247443      0.247443       111.225       111.472    
  37  0.831214E-01  -2.48745      -2.79147       2.79147       111.506       114.297    
  38  0.280368      -1.27165      -1.42707       1.42707       112.739       114.166    
  39  0.568263     -0.565171     -0.634246      0.634246       114.020       114.654    
  40  0.570544     -0.561165     -0.629751      0.629751       113.219       113.849    
  41  0.524202     -0.645877     -0.724817      0.724817       114.504       115.229    
  42  0.625335E-01  -2.77205      -3.11086       3.11086       112.509       115.620    
  43  0.717146     -0.332476     -0.373112      0.373112       115.517       115.891    
  44  0.234175      -1.45169      -1.62911       1.62911       114.398       116.027    
  45  0.366320      -1.00425      -1.12699       1.12699       115.056       116.183    
  46  0.458915     -0.778891     -0.874088      0.874088       109.588       110.462    
loop,thermsimp(1:2)       32  0.398117      0.279286    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    287        106.78         67.84          1.08         42.46          0.71          0.05        112.15
Just calling func    0   0        112.15


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    288        106.05         67.91          1.06         42.12          0.54          0.05        111.68
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    106.05
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       32
neval is:      287
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       32      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       33
neval is:      287


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      287     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.403971     -0.906412      -1.01719       1.01719       105.672       106.689    
   2  0.598662     -0.513057     -0.575764      0.575764       105.372       105.948    
   3  0.165178      -1.80073      -2.02082       2.02082       106.398       108.418    
   4  0.785331     -0.241651     -0.271185      0.271185       106.582       106.853    
   5  0.422061     -0.862604     -0.968032      0.968032       107.064       108.032    
   6  0.343624      -1.06821      -1.19876       1.19876       107.359       108.558    
   7  0.988862     -0.112001E-01 -0.125690E-01  0.125690E-01   107.960       107.973    
   8  0.586093E-01  -2.83686      -3.18358       3.18358       108.593       111.777    
   9  0.324880      -1.12430      -1.26171       1.26171       108.292       109.554    
  10  0.869373     -0.139983     -0.157092      0.157092       106.255       106.412    
  11  0.314362      -1.15721      -1.29864       1.29864       108.870       110.169    
  12  0.635265     -0.453712     -0.509165      0.509165       109.837       110.347    
  13  0.800738     -0.222221     -0.249381      0.249381       110.074       110.324    
  14  0.234515      -1.45024      -1.62748       1.62748       110.113       111.741    
  15  0.818766     -0.199957     -0.224396      0.224396       108.464       108.688    
  16  0.480807     -0.732289     -0.821789      0.821789       110.057       110.878    
  17  0.173083      -1.75398      -1.96836       1.96836       109.588       111.556    
  18  0.544835     -0.607272     -0.681494      0.681494       108.940       109.622    
  19  0.955728     -0.452816E-01 -0.508159E-01  0.508159E-01   110.272       110.323    
  20  0.909631     -0.947157E-01 -0.106292      0.106292       109.793       109.899    
  21  0.538276     -0.619384     -0.695085      0.695085       110.699       111.394    
  22  0.640373     -0.445705     -0.500179      0.500179       110.310       110.810    
  23  0.588429     -0.530300     -0.595113      0.595113       110.739       111.334    
  24  0.954392     -0.466804E-01 -0.523857E-01  0.523857E-01   110.750       110.802    
  25  0.976738     -0.235363E-01 -0.264130E-01  0.264130E-01   110.730       110.756    
  26  0.801897     -0.220775     -0.247758      0.247758       111.225       111.473    
  27  0.679499     -0.386400     -0.433626      0.433626       110.495       110.929    
  28  0.303686      -1.19176      -1.33742       1.33742       110.597       111.934    
  29  0.907562     -0.969936E-01 -0.108848      0.108848       111.796       111.904    
  30  0.117971E-01  -4.43990      -4.98255       4.98255       109.148       114.131    
  31  0.324683      -1.12491      -1.26239       1.26239       111.110       112.373    
  32  0.662106     -0.412329     -0.462725      0.462725       111.829       112.292    
  33  0.334080      -1.09637      -1.23037       1.23037       111.852       113.083    
  34  0.307577      -1.17903      -1.32313       1.32313       112.407       113.730    
  35  0.539029     -0.617986     -0.693517      0.693517       113.219       113.913    
  36  0.822737     -0.195119     -0.218967      0.218967       112.739       112.958    
  37  0.973480     -0.268776E-01 -0.301626E-01  0.301626E-01   111.506       111.536    
  38  0.918970     -0.845018E-01 -0.948296E-01  0.948296E-01   114.020       114.115    
  39  0.203072      -1.59419      -1.78904       1.78904       113.092       114.881    
  40  0.467655     -0.760024     -0.852915      0.852915       114.504       115.357    
  41  0.323145      -1.12965      -1.26772       1.26772       112.509       113.777    
  42  0.505961     -0.681295     -0.764563      0.764563       115.517       116.282    
  43  0.699853E-01  -2.65947      -2.98451       2.98451       114.398       117.382    
  44  0.188263      -1.66991      -1.87401       1.87401       115.056       116.930    
  45  0.663178     -0.410711     -0.460909      0.460909       112.280       112.741    
  46  0.680233     -0.385320     -0.432414      0.432414       106.050       106.482    
loop,thermsimp(1:2)       33   1.01719      0.575764    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    289        106.44         67.87          1.09         42.01          0.62          0.05        111.65
Just calling func    0   0        111.65


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    106.44
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       33
neval is:      288
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       33      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       34
neval is:      288


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      288     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.228924      -1.47437      -1.65456       1.65456       105.372       107.027    
   2  0.299376      -1.20605      -1.35346       1.35346       106.255       107.609    
   3  0.220114      -1.51361      -1.69860       1.69860       106.050       107.748    
   4  0.229209      -1.47312      -1.65317       1.65317       105.672       107.325    
   5  0.902477     -0.102612     -0.115154      0.115154       106.582       106.697    
   6  0.659052     -0.416953     -0.467913      0.467913       107.960       108.428    
   7  0.100321E-01  -4.60197      -5.16442       5.16442       107.064       112.228    
   8  0.588837     -0.529606     -0.594334      0.594334       106.398       106.992    
   9  0.270943      -1.30585      -1.46545       1.46545       107.359       108.825    
  10  0.505518     -0.682171     -0.765547      0.765547       108.464       109.229    
  11  0.264565      -1.32967      -1.49218       1.49218       108.292       109.784    
  12  0.806386     -0.215193     -0.241494      0.241494       108.940       109.182    
  13  0.340560      -1.07716      -1.20882       1.20882       109.793       111.002    
  14  0.906186     -0.985106E-01 -0.110551      0.110551       108.870       108.981    
  15  0.786070     -0.240709     -0.270129      0.270129       110.272       110.542    
  16  0.540508     -0.615247     -0.690442      0.690442       110.074       110.765    
  17  0.935065     -0.671392E-01 -0.753450E-01  0.753450E-01   109.837       109.913    
  18  0.915359     -0.884391E-01 -0.992482E-01  0.992482E-01   110.730       110.829    
  19  0.958261     -0.426353E-01 -0.478462E-01  0.478462E-01   110.750       110.798    
  20  0.935110     -0.670907E-01 -0.752906E-01  0.752906E-01   110.310       110.385    
  21  0.637755     -0.449800     -0.504775      0.504775       110.057       110.561    
  22  0.975714     -0.245861E-01 -0.275911E-01  0.275911E-01   110.495       110.523    
  23  0.797424     -0.226369     -0.254036      0.254036       110.739       110.993    
  24  0.214179      -1.54094      -1.72928       1.72928       110.699       112.429    
  25  0.372145     -0.988472      -1.10928       1.10928       111.225       112.334    
  26  0.925208     -0.777367E-01 -0.872377E-01  0.872377E-01   111.506       111.593    
  27  0.175897      -1.73786      -1.95026       1.95026       109.588       111.538    
  28  0.952033     -0.491554E-01 -0.551632E-01  0.551632E-01   110.113       110.169    
  29  0.158274E-01  -4.14601      -4.65274       4.65274       108.593       113.246    
  30  0.799308     -0.224008     -0.251387      0.251387       111.796       112.047    
  31  0.248227      -1.39341      -1.56371       1.56371       110.597       112.161    
  32  0.244914      -1.40685      -1.57879       1.57879       111.829       113.408    
  33  0.390842     -0.939452      -1.05427       1.05427       111.110       112.165    
  34  0.146784      -1.91879      -2.15331       2.15331       112.280       114.433    
  35  0.500975     -0.691199     -0.775678      0.775678       112.739       113.514    
  36  0.480131E-01  -3.03628      -3.40738       3.40738       111.852       115.260    
  37  0.124503      -2.08343      -2.33806       2.33806       112.407       114.745    
  38  0.670304     -0.400024     -0.448916      0.448916       112.509       112.958    
  39  0.997449     -0.255468E-02 -0.286691E-02  0.286691E-02   113.219       113.222    
  40  0.681761     -0.383076     -0.429896      0.429896       114.020       114.450    
  41  0.440529     -0.819778     -0.919972      0.919972       109.148       110.068    
  42  0.342489      -1.07152      -1.20248       1.20248       113.092       114.294    
  43  0.735753     -0.306861     -0.344366      0.344366       114.504       114.848    
  44  0.614752     -0.486537     -0.546001      0.546001       115.517       116.063    
  45  0.351660      -1.04509      -1.17282       1.17282       115.056       116.229    
  46  0.777165     -0.252103     -0.282915      0.282915       106.444       106.727    
loop,thermsimp(1:2)       34   1.65456       1.35346    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    290        104.41         67.86          1.09         42.04          0.57          0.05        111.60
Just calling func    0   0        111.61


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    291        111.84         68.15          1.10         42.12          0.49          0.05        111.91
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    104.41
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       34
neval is:      290
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       34      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       35
neval is:      290


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      290     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.347237      -1.05775      -1.18703       1.18703       106.582       107.769    
   2  0.621479     -0.475653     -0.533788      0.533788       106.444       106.978    
   3  0.221273      -1.50836      -1.69271       1.69271       106.398       108.090    
   4  0.180626E-01  -4.01391      -4.50450       4.50450       105.372       109.877    
   5  0.216093      -1.53205      -1.71930       1.71930       105.672       107.391    
   6  0.351343      -1.04599      -1.17383       1.17383       106.255       107.429    
   7  0.360847      -1.01930      -1.14388       1.14388       106.050       107.193    
   8  0.439525     -0.822061     -0.922533      0.922533       107.960       108.883    
   9  0.910616E-01  -2.39622      -2.68909       2.68909       107.359       110.048    
  10  0.549745     -0.598300     -0.671425      0.671425       108.870       109.542    
  11  0.619825     -0.478318     -0.536778      0.536778       108.940       109.477    
  12  0.548169E-01  -2.90376      -3.25866       3.25866       108.464       111.723    
  13  0.947163     -0.542842E-01 -0.609189E-01  0.609189E-01   108.292       108.353    
  14  0.725459     -0.320951     -0.360177      0.360177       109.837       110.198    
  15  0.481613     -0.730615     -0.819911      0.819911       109.148       109.968    
  16  0.866286     -0.143540     -0.161084      0.161084       110.113       110.275    
  17  0.221988E-01  -3.80772      -4.27310       4.27310       110.310       114.583    
  18  0.980823     -0.193630E-01 -0.217296E-01  0.217296E-01   110.495       110.517    
  19  0.332549      -1.10097      -1.23553       1.23553       110.272       111.508    
  20  0.989035     -0.110256E-01 -0.123732E-01  0.123732E-01   110.057       110.069    
  21  0.364016      -1.01056      -1.13407       1.13407       110.074       111.208    
  22  0.861799     -0.148733     -0.166911      0.166911       110.750       110.917    
  23  0.622306     -0.474324     -0.532296      0.532296       110.730       111.262    
  24  0.575476     -0.552558     -0.620092      0.620092       110.739       111.359    
  25  0.205536      -1.58213      -1.77550       1.77550       109.793       111.568    
  26  0.124037      -2.08718      -2.34227       2.34227       109.588       111.930    
  27  0.467008     -0.761408     -0.854468      0.854468       111.506       112.360    
  28  0.273870      -1.29510      -1.45339       1.45339       111.796       113.249    
  29  0.842780     -0.171050     -0.191955      0.191955       110.597       110.789    
  30  0.709315     -0.343455     -0.385432      0.385432       111.110       111.496    
  31  0.677144     -0.389871     -0.437521      0.437521       107.064       107.501    
  32  0.656062     -0.421500     -0.473016      0.473016       111.225       111.698    
  33  0.721592     -0.326295     -0.366175      0.366175       110.699       111.066    
  34  0.120172      -2.11883      -2.37780       2.37780       112.509       114.887    
  35  0.832403     -0.183439     -0.205859      0.205859       113.219       113.425    
  36  0.607577     -0.498276     -0.559176      0.559176       108.593       109.152    
  37  0.169814      -1.77305      -1.98975       1.98975       111.829       113.819    
  38  0.578085     -0.548034     -0.615015      0.615015       112.739       113.354    
  39  0.201144      -1.60373      -1.79974       1.79974       113.092       114.892    
  40  0.922823     -0.803178E-01 -0.901343E-01  0.901343E-01   112.280       112.370    
  41  0.136644      -1.99038      -2.23364       2.23364       114.020       116.254    
  42  0.836366     -0.178689     -0.200528      0.200528       112.407       112.607    
  43  0.590669     -0.526499     -0.590848      0.590848       114.504       115.095    
  44  0.745946     -0.293102     -0.328925      0.328925       111.852       112.181    
  45  0.874736     -0.133833     -0.150190      0.150190       115.517       115.668    
  46  0.370232     -0.993625      -1.11507       1.11507       104.407       105.522    
loop,thermsimp(1:2)       35   1.18703      0.533788    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    292        105.49         67.91          1.10         42.15          0.22          0.05        111.44
Just calling func    0   0        111.44


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    293        113.11         68.15          1.13         42.19          0.42          0.05        111.93
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    105.49
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       35
neval is:      292
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       35      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       36
neval is:      292


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      292     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.233712      -1.45367      -1.63134       1.63134       104.407       106.038    
   2  0.607568     -0.498291     -0.559192      0.559192       106.444       107.003    
   3  0.905785     -0.989529E-01 -0.111047      0.111047       106.050       106.161    
   4  0.995938E-01  -2.30666      -2.58858       2.58858       105.672       108.261    
   5  0.851360     -0.160920     -0.180588      0.180588       106.255       106.436    
   6  0.730583     -0.313913     -0.352280      0.352280       107.064       107.416    
   7  0.426216     -0.852810     -0.957041      0.957041       106.582       107.539    
   8  0.285108      -1.25489      -1.40826       1.40826       106.398       107.806    
   9  0.839246     -0.175251     -0.196671      0.196671       108.292       108.489    
  10  0.217639      -1.52492      -1.71129       1.71129       107.960       109.671    
  11  0.183996E-02  -6.29801      -7.06776       7.06776       108.593       115.661    
  12  0.682631     -0.381801     -0.428465      0.428465       108.940       109.369    
  13  0.203596      -1.59162      -1.78615       1.78615       108.870       110.657    
  14  0.881164     -0.126512     -0.141974      0.141974       105.372       105.514    
  15  0.711431     -0.340477     -0.382090      0.382090       109.148       109.530    
  16  0.874326     -0.134302     -0.150716      0.150716       107.359       107.510    
  17  0.814222     -0.205523     -0.230642      0.230642       110.057       110.287    
  18  0.995668     -0.434126E-02 -0.487186E-02  0.487186E-02   109.837       109.842    
  19  0.693805     -0.365564     -0.410244      0.410244       110.113       110.524    
  20  0.958584     -0.422984E-01 -0.474682E-01  0.474682E-01   110.495       110.543    
  21  0.748022     -0.290323     -0.325807      0.325807       110.597       110.923    
  22  0.696703     -0.361396     -0.405566      0.405566       110.750       111.156    
  23  0.732990     -0.310623     -0.348588      0.348588       110.699       111.048    
  24  0.534749     -0.625958     -0.702462      0.702462       110.074       110.777    
  25  0.691641     -0.368688     -0.413749      0.413749       110.730       111.144    
  26  0.300458      -1.20245      -1.34941       1.34941       110.739       112.088    
  27  0.977116     -0.231502E-01 -0.259797E-01  0.259797E-01   111.110       111.136    
  28  0.542581     -0.611418     -0.686146      0.686146       110.272       110.958    
  29  0.266111      -1.32384      -1.48564       1.48564       109.793       111.278    
  30  0.692298     -0.367738     -0.412683      0.412683       111.225       111.637    
  31  0.664047     -0.409403     -0.459440      0.459440       108.464       108.923    
  32  0.542186     -0.612146     -0.686963      0.686963       109.588       110.275    
  33  0.362243      -1.01544      -1.13955       1.13955       111.852       112.992    
  34  0.578658     -0.547044     -0.613904      0.613904       111.506       112.119    
  35  0.489298     -0.714783     -0.802144      0.802144       112.280       113.082    
  36  0.617485     -0.482100     -0.541023      0.541023       112.407       112.948    
  37  0.368651     -0.997905      -1.11987       1.11987       111.796       112.915    
  38  0.198936      -1.61477      -1.81213       1.81213       112.739       114.551    
  39  0.505263     -0.682676     -0.766113      0.766113       113.219       113.985    
  40  0.983997     -0.161325E-01 -0.181042E-01  0.181042E-01   111.829       111.847    
  41  0.630553     -0.461159     -0.517522      0.517522       110.310       110.828    
  42  0.423821E-01  -3.16103      -3.54737       3.54737       112.509       116.056    
  43  0.488935     -0.715526     -0.802979      0.802979       113.092       113.895    
  44  0.402078     -0.911110      -1.02247       1.02247       114.504       115.527    
  45  0.380878     -0.965277      -1.08325       1.08325       115.517       116.601    
  46  0.260585E-01  -3.64741      -4.09320       4.09320       105.487       109.580    
loop,thermsimp(1:2)       36   1.63134      0.559192    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    294        112.37         67.81          1.09         42.01          0.79          0.05        111.75
Just calling func    0   0        111.75


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    112.37
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       36
neval is:      293
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       36      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       37
neval is:      293


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      293     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.411300     -0.888432     -0.997017      0.997017       105.372       106.369    
   2  0.697205     -0.360676     -0.404758      0.404758       104.407       104.811    
   3  0.314648E-01  -3.45889      -3.88163       3.88163       106.050       109.931    
   4  0.857269     -0.154003     -0.172825      0.172825       106.255       106.428    
   5  0.652165     -0.427457     -0.479702      0.479702       106.444       106.924    
   6  0.510145     -0.673060     -0.755321      0.755321       107.064       107.819    
   7  0.175175      -1.74197      -1.95487       1.95487       107.359       109.314    
   8  0.373803     -0.984025      -1.10429       1.10429       106.582       107.686    
   9  0.514972     -0.663642     -0.744753      0.744753       106.398       107.142    
  10  0.548235     -0.601051     -0.674512      0.674512       105.672       106.347    
  11  0.541310     -0.613763     -0.688778      0.688778       108.292       108.981    
  12  0.734083     -0.309133     -0.346915      0.346915       108.464       108.811    
  13  0.422599     -0.861332     -0.966605      0.966605       108.940       109.907    
  14  0.287055      -1.24808      -1.40062       1.40062       109.148       110.549    
  15  0.885133     -0.122017     -0.136930      0.136930       105.487       105.624    
  16  0.391075     -0.938857      -1.05360       1.05360       107.960       109.014    
  17  0.473784     -0.747003     -0.838302      0.838302       109.837       110.676    
  18  0.691812     -0.368440     -0.413471      0.413471       109.588       110.001    
  19  0.644447     -0.439363     -0.493062      0.493062       110.057       110.550    
  20  0.805933     -0.215754     -0.242124      0.242124       110.113       110.356    
  21  0.393766     -0.931998      -1.04591       1.04591       110.495       111.541    
  22  0.907098E-01  -2.40009      -2.69343       2.69343       108.870       111.564    
  23  0.376515     -0.976796      -1.09618       1.09618       110.074       111.171    
  24  0.819190     -0.199439     -0.223815      0.223815       110.310       110.534    
  25  0.692438     -0.367536     -0.412456      0.412456       110.597       111.010    
  26  0.188370      -1.66935      -1.87338       1.87338       110.272       112.145    
  27  0.500532     -0.692083     -0.776670      0.776670       110.699       111.476    
  28  0.282311      -1.26475      -1.41932       1.41932       111.110       112.530    
  29  0.338061      -1.08453      -1.21708       1.21708       110.730       111.947    
  30  0.466208     -0.763123     -0.856393      0.856393       110.750       111.606    
  31  0.893084     -0.113075     -0.126895      0.126895       109.793       109.920    
  32  0.818806     -0.199908     -0.224341      0.224341       111.225       111.449    
  33  0.585066     -0.536031     -0.601545      0.601545       111.829       112.430    
  34  0.527412     -0.639774     -0.717968      0.717968       110.739       111.457    
  35  0.994295     -0.572143E-02 -0.642071E-02  0.642071E-02   111.506       111.512    
  36  0.739278     -0.302082     -0.339002      0.339002       111.796       112.135    
  37  0.230995      -1.46536      -1.64445       1.64445       112.407       114.051    
  38  0.414929     -0.879648     -0.987159      0.987159       111.852       112.840    
  39  0.378446     -0.971682      -1.09044       1.09044       112.280       113.370    
  40  0.368620     -0.997990      -1.11996       1.11996       113.092       114.212    
  41  0.301312      -1.19961      -1.34622       1.34622       113.219       114.565    
  42  0.105882E-01  -4.54801      -5.10387       5.10387       112.739       117.842    
  43  0.481885     -0.730049     -0.819276      0.819276       114.504       115.323    
  44  0.446716     -0.805833     -0.904322      0.904322       108.593       109.497    
  45  0.482098     -0.729608     -0.818781      0.818781       112.509       113.328    
  46  0.278892      -1.27693      -1.43300       1.43300       112.374       113.807    
loop,thermsimp(1:2)       37  0.997017      0.404758    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    295        104.81         67.94          1.10         42.07          0.45          0.04        111.61
Just calling func    0   0        111.61


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    296        119.12         68.15          1.10         42.29          0.24          0.05        111.84
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    104.81
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       37
neval is:      295
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       37      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       38
neval is:      295


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      295     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.408852     -0.894401      -1.00372       1.00372       104.407       105.410    
   2  0.259700      -1.34823      -1.51301       1.51301       105.487       107.000    
   3  0.681144E-01  -2.68657      -3.01492       3.01492       105.672       108.687    
   4  0.158140      -1.84427      -2.06968       2.06968       105.372       107.442    
   5  0.497681     -0.697796     -0.783081      0.783081       106.255       107.038    
   6  0.800218     -0.222871     -0.250110      0.250110       106.444       106.694    
   7  0.831967     -0.183962     -0.206446      0.206446       106.398       106.604    
   8  0.707345     -0.346237     -0.388554      0.388554       106.582       106.970    
   9  0.265927      -1.32454      -1.48642       1.48642       107.064       108.550    
  10  0.659046     -0.416962     -0.467923      0.467923       108.464       108.932    
  11  0.654587E-01  -2.72634      -3.05955       3.05955       108.292       111.352    
  12  0.223329      -1.49911      -1.68233       1.68233       107.960       109.642    
  13  0.996019     -0.398855E-02 -0.447603E-02  0.447603E-02   107.359       107.364    
  14  0.553910     -0.590753     -0.662955      0.662955       108.593       109.256    
  15  0.218863      -1.51931      -1.70500       1.70500       108.940       110.645    
  16  0.414020     -0.881841     -0.989620      0.989620       109.793       110.782    
  17  0.229117      -1.47352      -1.65362       1.65362       106.050       107.703    
  18  0.341764      -1.07363      -1.20486       1.20486       109.588       110.792    
  19  0.357052      -1.02987      -1.15574       1.15574       110.113       111.269    
  20  0.780779     -0.247463     -0.277708      0.277708       110.310       110.588    
  21  0.382234     -0.961721      -1.07926       1.07926       109.148       110.227    
  22  0.123899      -2.08829      -2.34352       2.34352       110.057       112.400    
  23  0.393312     -0.933152      -1.04720       1.04720       109.837       110.885    
  24  0.481741     -0.730349     -0.819613      0.819613       110.597       111.417    
  25  0.120001      -2.12026      -2.37940       2.37940       110.074       112.454    
  26  0.506023     -0.681173     -0.764427      0.764427       111.225       111.989    
  27  0.891157     -0.115235     -0.129319      0.129319       110.739       110.868    
  28  0.584674     -0.536701     -0.602297      0.602297       110.699       111.302    
  29  0.313196      -1.16093      -1.30281       1.30281       111.506       112.808    
  30  0.507340     -0.678574     -0.761510      0.761510       110.495       111.257    
  31  0.985030     -0.150835E-01 -0.169271E-01  0.169271E-01   108.870       108.887    
  32  0.186570      -1.67895      -1.88415       1.88415       110.750       112.634    
  33  0.992622     -0.740493E-02 -0.830997E-02  0.830997E-02   110.730       110.738    
  34  0.344152      -1.06667      -1.19704       1.19704       111.796       112.993    
  35  0.327214      -1.11714      -1.25368       1.25368       110.272       111.526    
  36  0.722008     -0.325719     -0.365529      0.365529       111.829       112.194    
  37  0.471441     -0.751960     -0.843866      0.843866       111.110       111.954    
  38  0.483594     -0.726510     -0.815304      0.815304       111.852       112.668    
  39  0.799410     -0.223881     -0.251244      0.251244       112.509       112.760    
  40  0.864070     -0.146101     -0.163958      0.163958       112.280       112.444    
  41  0.326419      -1.11957      -1.25641       1.25641       112.374       113.630    
  42  0.970166E-01  -2.33287      -2.61800       2.61800       112.407       115.025    
  43  0.822479     -0.195432     -0.219318      0.219318       113.092       113.311    
  44  0.719858     -0.328701     -0.368875      0.368875       113.219       113.588    
  45  0.359763      -1.02231      -1.14726       1.14726       114.504       115.651    
  46  0.879180     -0.128765     -0.144503      0.144503       104.808       104.952    
loop,thermsimp(1:2)       38   1.00372       1.51301    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    297        112.92         67.90          1.11         42.01          0.73          0.05        111.79
Just calling func    0   0        111.79


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    112.92
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       38
neval is:      296
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       38      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       39
neval is:      296


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      296     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.125069      -2.07889      -2.33297       2.33297       104.808       107.141    
   2  0.274837      -1.29158      -1.44943       1.44943       104.407       105.856    
   3  0.305931E-01  -3.48698      -3.91316       3.91316       106.398       110.311    
   4  0.929157     -0.734779E-01 -0.824584E-01  0.824584E-01   106.444       106.527    
   5  0.995956     -0.405208E-02 -0.454732E-02  0.454732E-02   106.582       106.586    
   6  0.904971     -0.998521E-01 -0.112056      0.112056       105.487       105.599    
   7  0.189758      -1.66200      -1.86514       1.86514       106.255       108.120    
   8  0.134931      -2.00299      -2.24780       2.24780       107.359       109.607    
   9  0.302412      -1.19596      -1.34214       1.34214       105.372       106.714    
  10  0.389155     -0.943777      -1.05913       1.05913       106.050       107.109    
  11  0.947428     -0.540040E-01 -0.606044E-01  0.606044E-01   107.064       107.125    
  12  0.338357      -1.08365      -1.21610       1.21610       105.672       106.888    
  13  0.937476     -0.645645E-01 -0.724556E-01  0.724556E-01   108.870       108.943    
  14  0.399493     -0.917560      -1.02970       1.02970       108.464       109.494    
  15  0.527586     -0.639444     -0.717597      0.717597       108.593       109.311    
  16  0.297740      -1.21153      -1.35961       1.35961       107.960       109.320    
  17  0.557978     -0.583436     -0.654744      0.654744       109.148       109.803    
  18  0.267521      -1.31856      -1.47971       1.47971       110.310       111.790    
  19  0.637637     -0.449986     -0.504983      0.504983       108.940       109.445    
  20  0.838569     -0.176059     -0.197577      0.197577       110.730       110.928    
  21  0.132199E-01  -4.32603      -4.85476       4.85476       109.793       114.648    
  22  0.745606     -0.293557     -0.329436      0.329436       109.588       109.917    
  23  0.334504      -1.09511      -1.22895       1.22895       110.739       111.968    
  24  0.118852      -2.12987      -2.39019       2.39019       109.837       112.228    
  25  0.319911      -1.13971      -1.27901       1.27901       110.495       111.774    
  26  0.638302E-01  -2.75153      -3.08782       3.08782       110.113       113.201    
  27  0.173204      -1.75329      -1.96757       1.96757       110.699       112.667    
  28  0.885640     -0.121444     -0.136287      0.136287       108.292       108.428    
  29  0.710758     -0.341423     -0.383152      0.383152       110.597       110.980    
  30  0.938919     -0.630265E-01 -0.707296E-01  0.707296E-01   110.272       110.343    
  31  0.217740      -1.52445      -1.71077       1.71077       111.110       112.821    
  32  0.130036      -2.03994      -2.28926       2.28926       111.225       113.514    
  33  0.331090      -1.10537      -1.24046       1.24046       111.829       113.069    
  34  0.453525E-01  -3.09329      -3.47135       3.47135       110.057       113.528    
  35  0.494600     -0.704006     -0.790050      0.790050       112.280       113.070    
  36  0.488771E-01  -3.01845      -3.38736       3.38736       110.074       113.462    
  37  0.262916E-01  -3.63850      -4.08320       4.08320       110.750       114.833    
  38  0.975293     -0.250177E-01 -0.280754E-01  0.280754E-01   111.852       111.880    
  39  0.521026     -0.651955     -0.731637      0.731637       112.509       113.241    
  40  0.210960      -1.55609      -1.74627       1.74627       111.506       113.252    
  41  0.475166E-02  -5.34926      -6.00305       6.00305       111.796       117.799    
  42  0.675859     -0.391771     -0.439653      0.439653       113.092       113.532    
  43  0.691418     -0.369011     -0.414112      0.414112       113.219       113.633    
  44  0.425152     -0.855309     -0.959846      0.959846       112.374       113.333    
  45  0.141313      -1.95678      -2.19593       2.19593       112.407       114.603    
  46  0.902170     -0.102952     -0.115535      0.115535       112.922       113.038    
loop,thermsimp(1:2)       39   2.33297       1.44943    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    298        110.31         67.81          1.08         42.02          0.54          0.05        111.50
Just calling func    0   0        111.50


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    110.31
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       39
neval is:      297
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       39      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       40
neval is:      297


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      297     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.465620     -0.764385     -0.857808      0.857808       105.487       106.345    
   2  0.310178      -1.17061      -1.31368       1.31368       104.407       105.720    
   3  0.883713     -0.123623     -0.138732      0.138732       106.444       106.583    
   4  0.641465     -0.444001     -0.498267      0.498267       106.582       107.080    
   5  0.458576E-01  -3.08222      -3.45893       3.45893       105.372       108.831    
   6  0.611421     -0.491970     -0.552099      0.552099       105.672       106.224    
   7  0.292603      -1.22894      -1.37914       1.37914       106.050       107.429    
   8  0.180818      -1.71026      -1.91929       1.91929       107.064       108.983    
   9  0.490648     -0.712028     -0.799053      0.799053       104.808       105.607    
  10  0.538601     -0.618781     -0.694409      0.694409       106.255       106.950    
  11  0.451209     -0.795824     -0.893090      0.893090       108.292       109.185    
  12  0.610260     -0.493870     -0.554231      0.554231       108.870       109.425    
  13  0.425113     -0.855401     -0.959948      0.959948       108.593       109.553    
  14  0.647858     -0.434084     -0.487138      0.487138       107.960       108.447    
  15  0.394937     -0.929029      -1.04258       1.04258       108.940       109.983    
  16  0.452279E-01  -3.09604      -3.47444       3.47444       108.464       111.938    
  17  0.954905     -0.461437E-01 -0.517834E-01  0.517834E-01   107.359       107.411    
  18  0.362548      -1.01460      -1.13860       1.13860       109.148       110.287    
  19  0.808078     -0.213097     -0.239142      0.239142       109.588       109.827    
  20  0.219348      -1.51709      -1.70251       1.70251       106.398       108.100    
  21  0.206981      -1.57513      -1.76764       1.76764       110.272       112.040    
  22  0.719933     -0.328597     -0.368759      0.368759       110.730       111.099    
  23  0.950238     -0.510432E-01 -0.572817E-01  0.572817E-01   110.597       110.654    
  24  0.845993     -0.167244     -0.187685      0.187685       110.495       110.683    
  25  0.157926      -1.84563      -2.07120       2.07120       110.310       112.381    
  26  0.430020     -0.843924     -0.947069      0.947069       111.852       112.799    
  27  0.624159     -0.471350     -0.528959      0.528959       110.739       111.268    
  28  0.355386      -1.03455      -1.16099       1.16099       109.837       110.998    
  29  0.297353      -1.21284      -1.36107       1.36107       110.699       112.060    
  30  0.185476      -1.68483      -1.89075       1.89075       111.110       113.001    
  31  0.406569     -0.900002      -1.01000       1.01000       112.922       113.932    
  32  0.147052      -1.91697      -2.15126       2.15126       111.829       113.980    
  33  0.205955      -1.58010      -1.77322       1.77322       112.280       114.053    
  34  0.383503     -0.958409      -1.07555       1.07555       110.113       111.189    
  35  0.514677E-01  -2.96680      -3.32941       3.32941       112.509       115.839    
  36  0.499194     -0.694760     -0.779673      0.779673       111.506       112.285    
  37  0.103172E-01  -4.57394      -5.13297       5.13297       112.374       117.507    
  38  0.470163     -0.754676     -0.846913      0.846913       110.074       110.921    
  39  0.983694     -0.164404E-01 -0.184497E-01  0.184497E-01   111.225       111.243    
  40  0.880425     -0.127351     -0.142916      0.142916       110.057       110.199    
  41  0.969759     -0.307072E-01 -0.344602E-01  0.344602E-01   113.092       113.126    
  42  0.761826E-01  -2.57462      -2.88929       2.88929       113.219       116.108    
  43  0.124427      -2.08404      -2.33875       2.33875       112.407       114.745    
  44  0.997702     -0.230032E-02 -0.258147E-02  0.258147E-02   109.793       109.795    
  45  0.213939      -1.54206      -1.73054       1.73054       110.750       112.481    
  46  0.471369     -0.752113     -0.844037      0.844037       110.306       111.150    
loop,thermsimp(1:2)       40  0.857808       1.31368    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    299        115.71         67.87          1.10         42.27          0.16          0.05        111.45
Just calling func    0   0        111.45


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    115.71
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       40
neval is:      298
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       40      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       41
neval is:      298


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      298     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.231075      -1.46501      -1.64407       1.64407       104.808       106.452    
   2  0.984723     -0.153953E-01 -0.172770E-01  0.172770E-01   104.407       104.424    
   3  0.689569     -0.371688     -0.417116      0.417116       105.672       106.089    
   4  0.539532     -0.617054     -0.692470      0.692470       105.487       106.180    
   5  0.103859      -2.26472      -2.54152       2.54152       106.444       108.986    
   6  0.403261     -0.908171      -1.01917       1.01917       106.255       107.274    
   7  0.545138     -0.606716     -0.680869      0.680869       106.582       107.262    
   8  0.211198      -1.55496      -1.74501       1.74501       107.359       109.104    
   9  0.533123     -0.629004     -0.705881      0.705881       106.050       106.755    
  10  0.891214     -0.115171     -0.129247      0.129247       106.398       106.527    
  11  0.604806     -0.502847     -0.564305      0.564305       107.960       108.524    
  12  0.176166      -1.73633      -1.94855       1.94855       105.372       107.321    
  13  0.733693     -0.309664     -0.347511      0.347511       107.064       107.411    
  14  0.248504      -1.39230      -1.56247       1.56247       108.292       109.855    
  15  0.183808      -1.69387      -1.90089       1.90089       108.870       110.771    
  16  0.308674E-02  -5.78064      -6.48715       6.48715       108.593       115.080    
  17  0.651025     -0.429207     -0.481665      0.481665       109.793       110.274    
  18  0.864353     -0.145775     -0.163591      0.163591       109.588       109.751    
  19  0.547352     -0.602664     -0.676321      0.676321       108.940       109.617    
  20  0.631248     -0.460057     -0.516286      0.516286       110.057       110.573    
  21  0.344368E-01  -3.36863      -3.78035       3.78035       109.148       112.928    
  22  0.876828     -0.131444     -0.147509      0.147509       110.597       110.745    
  23  0.884538     -0.122690     -0.137686      0.137686       110.495       110.633    
  24  0.926808     -0.760084E-01 -0.852982E-01  0.852982E-01   110.074       110.160    
  25  0.823462     -0.194237     -0.217977      0.217977       109.837       110.055    
  26  0.852580     -0.159489     -0.178982      0.178982       110.730       110.909    
  27  0.577707     -0.548689     -0.615750      0.615750       110.306       110.922    
  28  0.510093     -0.673163     -0.755437      0.755437       110.113       110.869    
  29  0.890288     -0.116210     -0.130413      0.130413       111.225       111.355    
  30  0.304875      -1.18785      -1.33303       1.33303       110.739       112.072    
  31  0.152164      -1.88279      -2.11291       2.11291       108.464       110.577    
  32  0.718687     -0.330329     -0.370702      0.370702       110.272       110.643    
  33  0.488128     -0.717177     -0.804831      0.804831       110.699       111.504    
  34  0.373052     -0.986038      -1.10655       1.10655       111.506       112.612    
  35  0.247351      -1.39695      -1.56768       1.56768       110.310       111.878    
  36  0.532108     -0.630909     -0.708019      0.708019       110.750       111.458    
  37  0.828879E-02  -4.79285      -5.37864       5.37864       111.852       117.231    
  38  0.168277      -1.78214      -1.99996       1.99996       111.110       113.110    
  39  0.253216      -1.37351      -1.54139       1.54139       113.092       114.633    
  40  0.458588     -0.779602     -0.874886      0.874886       112.922       113.797    
  41  0.725692     -0.320630     -0.359817      0.359817       111.829       112.189    
  42  0.283543      -1.26039      -1.41444       1.41444       112.280       113.694    
  43  0.798055     -0.225578     -0.253148      0.253148       112.407       112.660    
  44  0.805371     -0.216453     -0.242908      0.242908       112.509       112.752    
  45  0.580747     -0.543441     -0.609861      0.609861       113.219       113.829    
  46  0.581119     -0.542799     -0.609140      0.609140       115.712       116.321    
loop,thermsimp(1:2)       41   1.64407      0.172770E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    300        105.99         67.87          1.09         42.03          0.54          0.05        111.58
Just calling func    0   0        111.58


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    105.99
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       41
neval is:      299
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       41      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       42
neval is:      299


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      299     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.442958E-01  -3.11686      -3.49781       3.49781       104.407       107.904    
   2  0.196215      -1.62854      -1.82758       1.82758       105.672       107.500    
   3  0.501152     -0.690846     -0.775282      0.775282       105.487       106.262    
   4  0.288339      -1.24362      -1.39562       1.39562       104.808       106.204    
   5  0.773132     -0.257306     -0.288754      0.288754       106.398       106.686    
   6  0.417683     -0.873033     -0.979736      0.979736       106.050       107.029    
   7  0.229479      -1.47195      -1.65185       1.65185       106.582       108.233    
   8  0.964123     -0.365367E-01 -0.410022E-01  0.410022E-01   106.255       106.296    
   9  0.263782      -1.33263      -1.49551       1.49551       105.372       106.868    
  10  0.102960      -2.27342      -2.55127       2.55127       107.064       109.615    
  11  0.828790     -0.187788     -0.210740      0.210740       107.960       108.171    
  12  0.738697     -0.302868     -0.339884      0.339884       106.444       106.784    
  13  0.458595     -0.779589     -0.874870      0.874870       107.359       108.234    
  14  0.905176     -0.996260E-01 -0.111802      0.111802       108.940       109.052    
  15  0.147067      -1.91687      -2.15115       2.15115       109.588       111.739    
  16  0.142365      -1.94936      -2.18761       2.18761       108.292       110.480    
  17  0.483147     -0.727435     -0.816343      0.816343       109.837       110.654    
  18  0.640417     -0.445636     -0.500102      0.500102       110.074       110.574    
  19  0.719349     -0.329408     -0.369669      0.369669       109.793       110.162    
  20  0.714234     -0.336545     -0.377678      0.377678       110.057       110.434    
  21  0.825507     -0.191757     -0.215194      0.215194       108.464       108.679    
  22  0.155188      -1.86312      -2.09083       2.09083       110.495       112.586    
  23  0.248874      -1.39081      -1.56080       1.56080       110.272       111.833    
  24  0.107953      -2.22606      -2.49813       2.49813       110.597       113.095    
  25  0.349169      -1.05220      -1.18080       1.18080       108.870       110.051    
  26  0.967311     -0.332356E-01 -0.372977E-01  0.372977E-01   110.113       110.151    
  27  0.519506     -0.654877     -0.734917      0.734917       110.730       111.465    
  28  0.462662     -0.770758     -0.864961      0.864961       110.306       111.171    
  29  0.811438     -0.208948     -0.234485      0.234485       111.225       111.459    
  30  0.394710E-01  -3.23219      -3.62723       3.62723       110.750       114.377    
  31  0.482930     -0.727884     -0.816846      0.816846       110.699       111.516    
  32  0.520883     -0.652231     -0.731947      0.731947       110.310       111.042    
  33  0.980978E-01  -2.32179      -2.60556       2.60556       110.739       113.345    
  34  0.626549     -0.467529     -0.524671      0.524671       111.829       112.354    
  35  0.618402     -0.480616     -0.539358      0.539358       111.506       112.045    
  36  0.681438     -0.383550     -0.430427      0.430427       112.407       112.837    
  37  0.816820     -0.202336     -0.227066      0.227066       112.509       112.736    
  38  0.578487     -0.547340     -0.614236      0.614236       109.148       109.762    
  39  0.349734      -1.05058      -1.17898       1.17898       111.110       112.289    
  40  0.945672     -0.558596E-01 -0.626867E-01  0.626867E-01   112.280       112.343    
  41  0.767680     -0.264382     -0.296695      0.296695       112.922       113.219    
  42  0.122064      -2.10321      -2.36026       2.36026       113.219       115.579    
  43  0.211623      -1.55295      -1.74275       1.74275       113.092       114.835    
  44  0.969992E-01  -2.33305      -2.61820       2.61820       108.593       111.211    
  45  0.877482     -0.130699     -0.146673      0.146673       115.712       115.858    
  46  0.448991     -0.800752     -0.898620      0.898620       105.987       106.886    
loop,thermsimp(1:2)       42   3.49781       1.82758    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    301        112.52         67.91          1.10         41.98          0.74          0.04        111.78
Just calling func    0   0        111.78


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  300    112.52       0.6958     -2.842      2.614     -102.6     0.5080    
                      0.8898     0.7944     -99.70      4.363      1.003    

                       1.935     -2.349      1.540      7392.      7000.    

                      0.3082      0.000      0.000      0.000     -1.221    



                      -2.295      0.000      0.000      7000.      490.3    

                       1.747     -4.926     -5.181     -7.715      6.743    

                      -17.36     -6.260      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.4307    -0.8039      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.5508     -1.176      7000.    



                      -1.661     -1.506     -2.040     -1.844    -0.3807    

                     -0.3252      9.237      8.768    -0.1530E+05 -5.292    

                     -0.4224     -3.260      9.410      8.875    -0.1969E+05



                      -6.000     0.5760    -0.1709      8.951      8.994    

                     -0.1944E+05 -6.000     -1.016    -0.4624      9.106    

                       8.872    -0.1891E+05 -6.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    112.52
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       42
neval is:      300
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       42      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       43
neval is:      300


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      300     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.298594      -1.20867      -1.35639       1.35639       104.808       106.164    
   2  0.383173     -0.959268      -1.07651       1.07651       105.487       106.564    
   3  0.386205     -0.951387      -1.06767       1.06767       106.255       107.323    
   4  0.362178      -1.01562      -1.13975       1.13975       106.398       107.537    
   5  0.394462     -0.930233      -1.04393       1.04393       106.444       107.488    
   6  0.883072     -0.124349     -0.139547      0.139547       105.372       105.512    
   7  0.571477     -0.559531     -0.627917      0.627917       105.987       106.615    
   8  0.944036     -0.575912E-01 -0.646301E-01  0.646301E-01   106.050       106.114    
   9  0.326573      -1.11910      -1.25588       1.25588       105.672       106.928    
  10  0.467297     -0.760791     -0.853775      0.853775       104.407       105.260    
  11  0.828365     -0.188301     -0.211315      0.211315       107.960       108.171    
  12  0.826991     -0.189962     -0.213179      0.213179       106.582       106.795    
  13  0.675447E-01  -2.69497      -3.02435       3.02435       107.359       110.384    
  14  0.924113     -0.789214E-01 -0.885672E-01  0.885672E-01   108.464       108.552    
  15  0.810131     -0.210560     -0.236295      0.236295       108.940       109.176    
  16  0.410286     -0.890900     -0.999786      0.999786       107.064       108.064    
  17  0.334977      -1.09369      -1.22737       1.22737       109.148       110.376    
  18  0.119017      -2.12849      -2.38863       2.38863       108.870       111.259    
  19  0.447328     -0.804463     -0.902785      0.902785       110.113       111.016    
  20  0.324388E-02  -5.73098      -6.43143       6.43143       109.793       116.224    
  21  0.158272      -1.84344      -2.06875       2.06875       110.057       112.125    
  22  0.241219      -1.42205      -1.59586       1.59586       108.292       109.888    
  23  0.259790      -1.34788      -1.51262       1.51262       110.074       111.587    
  24  0.521973     -0.650139     -0.729599      0.729599       109.837       110.567    
  25  0.336335      -1.08965      -1.22282       1.22282       110.310       111.533    
  26  0.642248     -0.442780     -0.496897      0.496897       110.306       110.803    
  27  0.984615     -0.155047E-01 -0.173997E-01  0.173997E-01   108.593       108.610    
  28  0.373782     -0.984082      -1.10436       1.10436       111.225       112.329    
  29  0.932479     -0.699087E-01 -0.784529E-01  0.784529E-01   110.730       110.808    
  30  0.711360     -0.340577     -0.382203      0.382203       110.699       111.082    
  31  0.315363      -1.15403      -1.29508       1.29508       109.588       110.883    
  32  0.528583     -0.637556     -0.715478      0.715478       110.272       110.987    
  33  0.622355E-01  -2.77683      -3.11622       3.11622       111.506       114.622    
  34  0.144849      -1.93206      -2.16820       2.16820       111.110       113.278    
  35  0.868928     -0.140495     -0.157666      0.157666       112.280       112.438    
  36  0.243398      -1.41306      -1.58576       1.58576       111.829       113.415    
  37  0.936928     -0.651491E-01 -0.731117E-01  0.731117E-01   110.495       110.568    
  38  0.979804E-01  -2.32299      -2.60691       2.60691       112.509       115.116    
  39  0.805773     -0.215953     -0.242346      0.242346       112.407       112.649    
  40  0.210751      -1.55708      -1.74739       1.74739       110.597       112.344    
  41  0.497104     -0.698956     -0.784383      0.784383       112.922       113.707    
  42  0.532106     -0.630913     -0.708024      0.708024       110.739       111.447    
  43  0.898420     -0.107117     -0.120209      0.120209       110.750       110.870    
  44  0.579370     -0.545814     -0.612523      0.612523       113.092       113.704    
  45  0.191213      -1.65437      -1.85656       1.85656       113.219       115.076    
  46  0.491633     -0.710023     -0.796803      0.796803       112.520       113.317    
loop,thermsimp(1:2)       43   1.35639       1.07651    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    302        107.20         67.88          1.10         42.11          0.46          0.05        111.61
Just calling func    0   0        111.61


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    107.20
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       43
neval is:      301
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       43      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       44
neval is:      301


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      301     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.287044      -1.24812      -1.40067       1.40067       104.407       105.807    
   2  0.260243      -1.34614      -1.51066       1.51066       105.372       106.883    
   3  0.646915     -0.435540     -0.488772      0.488772       106.050       106.538    
   4  0.572447     -0.557835     -0.626013      0.626013       104.808       105.434    
   5  0.105907      -2.24520      -2.51961       2.51961       105.487       108.007    
   6  0.693038     -0.366671     -0.411485      0.411485       105.987       106.399    
   7  0.329408      -1.11046      -1.24618       1.24618       106.582       107.828    
   8  0.187221      -1.67546      -1.88024       1.88024       105.672       107.552    
   9  0.545731     -0.605630     -0.679650      0.679650       106.255       106.935    
  10  0.752820     -0.283930     -0.318632      0.318632       106.444       106.763    
  11  0.153542      -1.87378      -2.10279       2.10279       106.398       108.500    
  12  0.400659     -0.914645      -1.02643       1.02643       107.064       108.090    
  13  0.306182      -1.18357      -1.32823       1.32823       107.960       109.288    
  14  0.270957E-01  -3.60838      -4.04940       4.04940       108.464       112.513    
  15  0.776765     -0.252618     -0.283493      0.283493       108.593       108.877    
  16  0.711945     -0.339755     -0.381280      0.381280       108.940       109.321    
  17  0.217190      -1.52698      -1.71361       1.71361       108.292       110.006    
  18  0.285226      -1.25447      -1.40780       1.40780       109.148       110.556    
  19  0.348904      -1.05296      -1.18165       1.18165       107.359       108.541    
  20  0.686414     -0.376275     -0.422264      0.422264       109.837       110.260    
  21  0.212825      -1.54729      -1.73640       1.73640       110.495       112.232    
  22  0.501697     -0.689760     -0.774062      0.774062       110.306       111.080    
  23  0.363771      -1.01123      -1.13482       1.13482       110.730       111.865    
  24  0.789273     -0.236642     -0.265565      0.265565       110.750       111.016    
  25  0.232884      -1.45721      -1.63531       1.63531       109.588       111.223    
  26  0.754896     -0.281175     -0.315540      0.315540       110.272       110.588    
  27  0.639358     -0.447290     -0.501958      0.501958       110.113       110.615    
  28  0.532505     -0.630163     -0.707182      0.707182       110.699       111.407    
  29  0.759813     -0.274683     -0.308255      0.308255       108.870       109.179    
  30  0.768360     -0.263497     -0.295702      0.295702       110.739       111.035    
  31  0.245116      -1.40602      -1.57787       1.57787       110.310       111.888    
  32  0.672517     -0.396727     -0.445215      0.445215       110.074       110.520    
  33  0.910675     -0.935691E-01 -0.105005      0.105005       110.057       110.162    
  34  0.441618     -0.817310     -0.917202      0.917202       111.225       112.142    
  35  0.212980      -1.54656      -1.73558       1.73558       110.597       112.333    
  36  0.471690     -0.751434     -0.843274      0.843274       112.280       113.123    
  37  0.968545     -0.319606E-01 -0.358668E-01  0.358668E-01   112.407       112.443    
  38  0.711169     -0.340845     -0.382503      0.382503       111.110       111.493    
  39  0.222170      -1.50431      -1.68817       1.68817       112.520       114.208    
  40  0.896100     -0.109703     -0.123111      0.123111       111.829       111.952    
  41  0.898054     -0.107525     -0.120667      0.120667       113.092       113.213    
  42  0.981364     -0.188122E-01 -0.211114E-01  0.211114E-01   112.922       112.943    
  43  0.238126      -1.43496      -1.61034       1.61034       111.506       113.116    
  44  0.884882     -0.122301     -0.137249      0.137249       113.219       113.356    
  45  0.206421      -1.57784      -1.77068       1.77068       112.509       114.280    
  46  0.421939     -0.862894     -0.968358      0.968358       107.201       108.170    
loop,thermsimp(1:2)       44   1.40067       1.51066    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    303        108.61         67.83          1.10         42.03          0.52          0.05        111.53
Just calling func    0   0        111.53


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    108.61
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       44
neval is:      302
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       44      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       45
neval is:      302


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      302     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.204302      -1.58816      -1.78226       1.78226       104.808       106.590    
   2  0.455846E-01  -3.08818      -3.46562       3.46562       104.407       107.872    
   3  0.655807     -0.421889     -0.473452      0.473452       105.987       106.461    
   4  0.902989     -0.102045     -0.114517      0.114517       106.050       106.164    
   5  0.826012     -0.191146     -0.214508      0.214508       106.444       106.659    
   6  0.160871      -1.82715      -2.05047       2.05047       105.372       107.423    
   7  0.516410     -0.660854     -0.741624      0.741624       106.255       106.997    
   8  0.506939     -0.679364     -0.762396      0.762396       105.672       106.435    
   9  0.728359     -0.316962     -0.355701      0.355701       106.582       106.937    
  10  0.453162     -0.791506     -0.888244      0.888244       105.487       106.375    
  11  0.837994     -0.176745     -0.198346      0.198346       107.064       107.262    
  12  0.118024      -2.13686      -2.39803       2.39803       107.201       109.599    
  13  0.274030      -1.29452      -1.45274       1.45274       106.398       107.850    
  14  0.402227     -0.910738      -1.02205       1.02205       107.359       108.381    
  15  0.444245     -0.811380     -0.910547      0.910547       108.593       109.504    
  16  0.594880     -0.519396     -0.582877      0.582877       108.870       109.453    
  17  0.548806     -0.600010     -0.673344      0.673344       107.960       108.633    
  18  0.222827      -1.50136      -1.68486       1.68486       108.940       110.625    
  19  0.152541      -1.88032      -2.11013       2.11013       108.292       110.402    
  20  0.816533     -0.202688     -0.227460      0.227460       110.057       110.284    
  21  0.525417     -0.643564     -0.722221      0.722221       109.837       110.560    
  22  0.661450     -0.413320     -0.463837      0.463837       110.074       110.538    
  23  0.437535     -0.826598     -0.927625      0.927625       109.148       110.076    
  24  0.464442     -0.766918     -0.860651      0.860651       110.272       111.133    
  25  0.683975     -0.379834     -0.426257      0.426257       110.113       110.540    
  26  0.407919     -0.896688      -1.00628       1.00628       110.750       111.756    
  27  0.934669     -0.675632E-01 -0.758208E-01  0.758208E-01   110.739       110.815    
  28  0.866891     -0.142842     -0.160300      0.160300       110.306       110.467    
  29  0.145435E-01  -4.23061      -4.74768       4.74768       109.588       114.335    
  30  0.514599     -0.664368     -0.745567      0.745567       110.699       111.445    
  31  0.370591     -0.992656      -1.11398       1.11398       111.110       112.224    
  32  0.251726      -1.37941      -1.54801       1.54801       110.730       112.278    
  33  0.959470     -0.413742E-01 -0.464309E-01  0.464309E-01   110.310       110.356    
  34  0.344885E-01  -3.36713      -3.77866       3.77866       111.829       115.608    
  35  0.348690      -1.05357      -1.18234       1.18234       111.225       112.407    
  36  0.610898     -0.492826     -0.553059      0.553059       110.495       111.048    
  37  0.440567     -0.819693     -0.919876      0.919876       110.597       111.517    
  38  0.340409      -1.07761      -1.20931       1.20931       112.407       113.616    
  39  0.345015E-01  -3.36675      -3.77824       3.77824       108.464       112.242    
  40  0.667224     -0.404630     -0.454084      0.454084       112.922       113.376    
  41  0.138336      -1.97807      -2.21983       2.21983       111.506       113.725    
  42  0.412023     -0.886676     -0.995046      0.995046       112.280       113.275    
  43  0.578410     -0.547473     -0.614385      0.614385       113.092       113.706    
  44  0.972817     -0.275594E-01 -0.309278E-01  0.309278E-01   113.219       113.250    
  45  0.152341      -1.88163      -2.11161       2.11161       112.520       114.632    
  46  0.764264     -0.268842     -0.301700      0.301700       108.613       108.914    
loop,thermsimp(1:2)       45   1.78226       3.46562    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    304        104.39         67.99          1.11         42.11          0.54          0.06        111.81
Just calling func    0   0        111.81


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    305        109.45         68.15          1.11         42.19          0.38          0.05        111.87
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    104.39
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       45
neval is:      304
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       45      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       46
neval is:      304


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      304     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.794521     -0.230016     -0.258129      0.258129       106.050       106.308    
   2  0.338444      -1.08340      -1.21581       1.21581       105.487       106.703    
   3  0.563800     -0.573055     -0.643094      0.643094       105.672       106.315    
   4  0.295284      -1.21982      -1.36890       1.36890       105.987       107.356    
   5  0.506481     -0.680269     -0.763412      0.763412       104.808       105.571    
   6  0.345803      -1.06189      -1.19167       1.19167       106.444       107.636    
   7  0.741641     -0.298890     -0.335420      0.335420       106.582       106.917    
   8  0.182310      -1.70204      -1.91007       1.91007       106.255       108.165    
   9  0.315187      -1.15459      -1.29570       1.29570       107.064       108.360    
  10  0.598844     -0.512755     -0.575424      0.575424       105.372       105.948    
  11  0.659119     -0.416852     -0.467800      0.467800       106.398       106.865    
  12  0.247481      -1.39642      -1.56709       1.56709       104.407       105.974    
  13  0.255298      -1.36532      -1.53219       1.53219       107.359       108.891    
  14  0.876488     -0.131833     -0.147945      0.147945       107.960       108.108    
  15  0.358010      -1.02719      -1.15274       1.15274       108.613       109.765    
  16  0.317480      -1.14734      -1.28757       1.28757       108.870       110.158    
  17  0.153422      -1.87456      -2.10367       2.10367       108.593       110.697    
  18  0.296162      -1.21685      -1.36557       1.36557       107.201       108.567    
  19  0.629760     -0.462417     -0.518934      0.518934       109.148       109.667    
  20  0.458345E-01  -3.08272      -3.45949       3.45949       110.057       113.516    
  21  0.209534      -1.56287      -1.75388       1.75388       110.310       112.064    
  22  0.490210E-01  -3.01551      -3.38406       3.38406       108.292       111.676    
  23  0.144817      -1.93229      -2.16845       2.16845       110.306       112.475    
  24  0.764061     -0.269107     -0.301998      0.301998       110.074       110.376    
  25  0.158664      -1.84097      -2.06597       2.06597       110.113       112.179    
  26  0.242818      -1.41544      -1.58844       1.58844       109.837       111.426    
  27  0.779950     -0.248525     -0.278900      0.278900       108.940       109.219    
  28  0.763580     -0.269737     -0.302705      0.302705       110.739       111.042    
  29  0.817639     -0.201335     -0.225942      0.225942       110.495       110.721    
  30  0.656802     -0.420373     -0.471752      0.471752       110.272       110.744    
  31  0.202192      -1.59854      -1.79391       1.79391       110.699       112.493    
  32  0.469647     -0.755773     -0.848145      0.848145       110.597       111.445    
  33  0.107456      -2.23067      -2.50330       2.50330       110.750       113.253    
  34  0.709118     -0.343734     -0.385745      0.385745       111.110       111.496    
  35  0.988480     -0.115868E-01 -0.130030E-01  0.130030E-01   108.464       108.477    
  36  0.645173     -0.438236     -0.491798      0.491798       110.730       111.222    
  37  0.583143     -0.539322     -0.605239      0.605239       111.225       111.830    
  38  0.276552E-01  -3.58794      -4.02646       4.02646       113.219       117.245    
  39  0.560517     -0.578896     -0.649649      0.649649       112.280       112.930    
  40  0.292779      -1.22834      -1.37846       1.37846       112.922       114.301    
  41  0.486207     -0.721121     -0.809257      0.809257       112.407       113.216    
  42  0.379142E-01  -3.27243      -3.67239       3.67239       113.092       116.764    
  43  0.459895     -0.776757     -0.871692      0.871692       111.506       112.377    
  44  0.810771     -0.209769     -0.235407      0.235407       109.588       109.823    
  45  0.189138      -1.66528      -1.86881       1.86881       112.520       114.389    
  46  0.509870     -0.673599     -0.755926      0.755926       104.387       105.143    
loop,thermsimp(1:2)       46  0.258129       1.21581    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    306        107.04         67.95          1.11         42.05          0.53          0.05        111.69
Just calling func    0   0        111.69


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    107.04
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       46
neval is:      305
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       46      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       47
neval is:      305


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      305     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.652512     -0.426926     -0.479105      0.479105       104.387       104.866    
   2  0.474910     -0.744630     -0.835639      0.835639       104.808       105.644    
   3  0.125725      -2.07366      -2.32710       2.32710       105.372       107.699    
   4  0.950967     -0.502756E-01 -0.564203E-01  0.564203E-01   104.407       104.463    
   5  0.562475     -0.575409     -0.645736      0.645736       106.050       106.695    
   6  0.728528     -0.316729     -0.355440      0.355440       105.672       106.028    
   7  0.326058      -1.12068      -1.25765       1.25765       105.487       106.745    
   8  0.460979     -0.774402     -0.869050      0.869050       106.398       107.267    
   9  0.186861      -1.67739      -1.88240       1.88240       106.582       108.464    
  10  0.737773     -0.304119     -0.341289      0.341289       105.987       106.329    
  11  0.254524      -1.36836      -1.53560       1.53560       106.444       107.980    
  12  0.475390     -0.743621     -0.834506      0.834506       107.960       108.795    
  13  0.783107     -0.244486     -0.274367      0.274367       106.255       106.530    
  14  0.615536     -0.485261     -0.544570      0.544570       107.064       107.609    
  15  0.600710E-01  -2.81223      -3.15594       3.15594       108.464       111.620    
  16  0.834417     -0.181022     -0.203147      0.203147       107.201       107.404    
  17  0.270355      -1.30802      -1.46789       1.46789       107.359       108.827    
  18  0.408387     -0.895540      -1.00499       1.00499       108.940       109.945    
  19  0.248286      -1.39318      -1.56345       1.56345       109.148       110.712    
  20  0.586808E-01  -2.83564      -3.18222       3.18222       108.613       111.795    
  21  0.747050     -0.291623     -0.327266      0.327266       109.588       109.915    
  22  0.261869E-01  -3.64250      -4.08769       4.08769       108.870       112.958    
  23  0.495813     -0.701557     -0.787301      0.787301       110.074       110.862    
  24  0.600032     -0.510772     -0.573199      0.573199       108.593       109.166    
  25  0.936456     -0.656531E-01 -0.736773E-01  0.736773E-01   110.495       110.569    
  26  0.583260     -0.539121     -0.605013      0.605013       110.272       110.877    
  27  0.994266     -0.575021E-02 -0.645301E-02  0.645301E-02   110.739       110.745    
  28  0.149755      -1.89876      -2.13082       2.13082       110.730       112.861    
  29  0.751239     -0.286032     -0.320990      0.320990       109.837       110.158    
  30  0.703931     -0.351075     -0.393983      0.393983       110.597       110.991    
  31  0.998476     -0.152564E-02 -0.171210E-02  0.171210E-02   111.110       111.112    
  32  0.501495     -0.690161     -0.774513      0.774513       108.292       109.067    
  33  0.446468     -0.806387     -0.904944      0.904944       111.225       112.130    
  34  0.321376      -1.13514      -1.27388       1.27388       110.310       111.584    
  35  0.850901     -0.161459     -0.181193      0.181193       110.113       110.295    
  36  0.975881     -0.244142E-01 -0.273981E-01  0.273981E-01   111.506       111.533    
  37  0.386316     -0.951100      -1.06734       1.06734       110.306       111.374    
  38  0.782734     -0.244962     -0.274902      0.274902       110.699       110.974    
  39  0.142678      -1.94716      -2.18515       2.18515       112.280       114.465    
  40  0.509914     -0.673514     -0.755831      0.755831       112.407       113.162    
  41  0.211111      -1.55537      -1.74547       1.74547       110.750       112.496    
  42  0.212538      -1.54864      -1.73791       1.73791       110.057       111.794    
  43  0.889982     -0.116555     -0.130800      0.130800       112.922       113.053    
  44  0.769070     -0.262573     -0.294665      0.294665       112.520       112.815    
  45  0.792434     -0.232646     -0.261080      0.261080       113.092       113.353    
  46  0.250220E-01  -3.68800      -4.13875       4.13875       107.044       111.182    
loop,thermsimp(1:2)       47  0.479105      0.835639    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    307        114.31         67.91          1.09         42.07          0.50          0.05        111.62
Just calling func    0   0        111.62


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    114.31
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       47
neval is:      306
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       47      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       48
neval is:      306


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      306     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.316013      -1.15197      -1.29277       1.29277       104.407       105.699    
   2  0.452730     -0.792459     -0.889314      0.889314       104.387       105.277    
   3  0.463916     -0.768051     -0.861923      0.861923       104.808       105.670    
   4  0.531172E-01  -2.93526      -3.29400       3.29400       105.672       108.966    
   5  0.933113     -0.692290E-01 -0.776902E-01  0.776902E-01   105.987       106.065    
   6  0.107612      -2.22922      -2.50168       2.50168       106.255       108.757    
   7  0.228017      -1.47833      -1.65902       1.65902       106.050       107.709    
   8  0.766526     -0.265887     -0.298384      0.298384       105.487       105.785    
   9  0.676418     -0.390944     -0.438725      0.438725       106.398       106.836    
  10  0.220696      -1.51097      -1.69564       1.69564       107.201       108.897    
  11  0.959946E-01  -2.34346      -2.62988       2.62988       107.064       109.694    
  12  0.570655     -0.560971     -0.629534      0.629534       105.372       106.002    
  13  0.736426     -0.305947     -0.343340      0.343340       106.444       106.787    
  14  0.966377     -0.342013E-01 -0.383815E-01  0.383815E-01   106.582       106.620    
  15  0.797662     -0.226070     -0.253701      0.253701       107.960       108.214    
  16  0.413688     -0.882643     -0.990520      0.990520       107.359       108.350    
  17  0.200670      -1.60609      -1.80239       1.80239       108.292       110.095    
  18  0.843958E-01  -2.47224      -2.77440       2.77440       108.593       111.367    
  19  0.375580     -0.979284      -1.09897       1.09897       109.588       110.687    
  20  0.968669     -0.318322E-01 -0.357227E-01  0.357227E-01   108.940       108.976    
  21  0.379263     -0.969525      -1.08802       1.08802       109.837       110.925    
  22  0.421746     -0.863352     -0.968871      0.968871       110.113       111.082    
  23  0.639909     -0.446429     -0.500992      0.500992       110.495       110.996    
  24  0.549878     -0.598059     -0.671154      0.671154       109.148       109.819    
  25  0.226469      -1.48515      -1.66666       1.66666       110.739       112.406    
  26  0.547044E-02  -5.20840      -5.84497       5.84497       110.074       115.919    
  27  0.372808     -0.986692      -1.10729       1.10729       110.272       111.379    
  28  0.406819E-01  -3.20197      -3.59332       3.59332       110.699       114.293    
  29  0.664564     -0.408624     -0.458566      0.458566       110.597       111.056    
  30  0.708700     -0.344323     -0.386406      0.386406       111.110       111.497    
  31  0.863329     -0.146959     -0.164920      0.164920       107.044       107.209    
  32  0.406109     -0.901134      -1.01127       1.01127       110.306       111.317    
  33  0.101947      -2.28330      -2.56237       2.56237       111.506       114.068    
  34  0.660574     -0.414646     -0.465324      0.465324       110.310       110.775    
  35  0.839002     -0.175542     -0.196997      0.196997       108.464       108.661    
  36  0.735312E-01  -2.61005      -2.92905       2.92905       110.057       112.986    
  37  0.559917     -0.579967     -0.650851      0.650851       108.613       109.264    
  38  0.922004     -0.812055E-01 -0.911305E-01  0.911305E-01   111.225       111.316    
  39  0.891471     -0.114882     -0.128923      0.128923       110.750       110.879    
  40  0.489346     -0.714686     -0.802036      0.802036       112.520       113.322    
  41  0.583196     -0.539231     -0.605136      0.605136       110.730       111.335    
  42  0.989235     -0.108230E-01 -0.121458E-01  0.121458E-01   108.870       108.883    
  43  0.844741     -0.168725     -0.189347      0.189347       112.922       113.112    
  44  0.734982     -0.307909     -0.345542      0.345542       112.407       112.752    
  45  0.913246     -0.907495E-01 -0.101841      0.101841       113.092       113.194    
  46  0.605096     -0.502369     -0.563769      0.563769       114.308       114.872    
loop,thermsimp(1:2)       48   1.29277      0.889314    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    308        107.31         67.86          1.10         42.21          0.19          0.05        111.41
Just calling func    0   0        111.41


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    107.31
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       48
neval is:      307
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       48      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       49
neval is:      307


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      307     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.991535     -0.850114E-02 -0.954016E-02  0.954016E-02   104.387       104.397    
   2  0.120199      -2.11861      -2.37754       2.37754       104.808       107.185    
   3  0.825835     -0.191360     -0.214748      0.214748       104.407       104.621    
   4  0.769690     -0.261767     -0.293760      0.293760       105.487       105.781    
   5  0.206534      -1.57729      -1.77007       1.77007       105.372       107.142    
   6  0.435455     -0.831363     -0.932972      0.932972       105.987       106.920    
   7  0.408718     -0.894731      -1.00409       1.00409       106.582       107.586    
   8  0.504170E-01  -2.98743      -3.35255       3.35255       106.444       109.797    
   9  0.943874     -0.577631E-01 -0.648229E-01  0.648229E-01   106.398       106.462    
  10  0.161493      -1.82330      -2.04614       2.04614       107.044       109.090    
  11  0.248560      -1.39207      -1.56221       1.56221       106.050       107.612    
  12  0.952734     -0.484195E-01 -0.543374E-01  0.543374E-01   107.960       108.014    
  13  0.349224      -1.05204      -1.18062       1.18062       107.359       108.540    
  14  0.245013      -1.40644      -1.57834       1.57834       108.464       110.042    
  15  0.713805     -0.337146     -0.378352      0.378352       106.255       106.634    
  16  0.206995      -1.57506      -1.76757       1.76757       108.870       110.638    
  17  0.573984     -0.555154     -0.623005      0.623005       107.201       107.824    
  18  0.791297     -0.234082     -0.262692      0.262692       105.672       105.935    
  19  0.599323     -0.511955     -0.574527      0.574527       108.940       109.515    
  20  0.632893     -0.457454     -0.513365      0.513365       108.613       109.126    
  21  0.920472     -0.828688E-01 -0.929970E-01  0.929970E-01   107.064       107.157    
  22  0.650695     -0.429713     -0.482233      0.482233       109.148       109.630    
  23  0.759327     -0.275322     -0.308972      0.308972       108.292       108.601    
  24  0.547563     -0.602278     -0.675888      0.675888       109.588       110.264    
  25  0.375945     -0.978312      -1.09788       1.09788       110.310       111.408    
  26  0.436593     -0.828753     -0.930044      0.930044       110.750       111.680    
  27  0.226348      -1.48568      -1.66726       1.66726       109.837       111.505    
  28  0.889061     -0.117589     -0.131961      0.131961       110.495       110.627    
  29  0.294563      -1.22226      -1.37165       1.37165       110.597       111.969    
  30  0.760606     -0.273640     -0.307085      0.307085       110.113       110.421    
  31  0.131934      -2.02545      -2.27300       2.27300       111.225       113.498    
  32  0.150887      -1.89123      -2.12237       2.12237       110.306       112.429    
  33  0.108814      -2.21811      -2.48921       2.48921       110.730       113.219    
  34  0.392982     -0.933991      -1.04814       1.04814       108.593       109.641    
  35  0.524209     -0.645865     -0.724803      0.724803       110.272       110.997    
  36  0.779329     -0.249322     -0.279794      0.279794       111.110       111.390    
  37  0.684136     -0.379599     -0.425994      0.425994       110.739       111.165    
  38  0.898629     -0.106885     -0.119949      0.119949       112.407       112.527    
  39  0.885947E-01  -2.42368      -2.71991       2.71991       110.057       112.776    
  40  0.865042     -0.144977     -0.162696      0.162696       112.922       113.085    
  41  0.953799     -0.473027E-01 -0.530840E-01  0.530840E-01   113.092       113.145    
  42  0.264945      -1.32823      -1.49057       1.49057       112.520       114.011    
  43  0.931660     -0.707875E-01 -0.794392E-01  0.794392E-01   111.506       111.585    
  44  0.273150      -1.29773      -1.45634       1.45634       110.699       112.156    
  45  0.773196     -0.257223     -0.288661      0.288661       114.308       114.596    
  46  0.936342     -0.657743E-01 -0.738132E-01  0.738132E-01   107.310       107.384    
loop,thermsimp(1:2)       49  0.954016E-02   2.37754    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    309        111.98         67.81          1.09         41.96          0.52          0.05        111.43
Just calling func    0   0        111.43


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    111.98
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       49
neval is:      308
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       49      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       50
neval is:      308


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      308     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.919134E-02  -4.68949      -5.26265       5.26265       104.387       109.650    
   2  0.902150     -0.102974     -0.115560      0.115560       104.407       104.522    
   3  0.375868     -0.978517      -1.09811       1.09811       105.487       106.585    
   4  0.136549E-01  -4.29366      -4.81843       4.81843       105.672       110.491    
   5  0.948329     -0.530533E-01 -0.595375E-01  0.595375E-01   106.398       106.457    
   6  0.489379E-01  -3.01720      -3.38597       3.38597       106.255       109.641    
   7  0.319400      -1.14131      -1.28080       1.28080       105.987       107.268    
   8  0.748008     -0.290342     -0.325827      0.325827       105.372       105.698    
   9  0.468015     -0.759255     -0.852051      0.852051       107.064       107.916    
  10  0.467420     -0.760527     -0.853479      0.853479       104.808       105.661    
  11  0.345085      -1.06396      -1.19400       1.19400       107.310       108.504    
  12  0.598981     -0.512526     -0.575167      0.575167       106.582       107.157    
  13  0.231496      -1.46319      -1.64202       1.64202       106.050       107.692    
  14  0.685496     -0.377613     -0.423765      0.423765       107.201       107.625    
  15  0.225803      -1.48809      -1.66997       1.66997       107.960       109.630    
  16  0.744991E-01  -2.59697      -2.91437       2.91437       107.359       110.274    
  17  0.436777     -0.828332     -0.929571      0.929571       108.292       109.222    
  18  0.241074      -1.42265      -1.59653       1.59653       107.044       108.640    
  19  0.728071     -0.317357     -0.356145      0.356145       108.613       108.969    
  20  0.228500      -1.47622      -1.65664       1.65664       108.940       110.597    
  21  0.423678     -0.858781     -0.963742      0.963742       109.148       110.112    
  22  0.812855     -0.207202     -0.232526      0.232526       108.593       108.826    
  23  0.810546     -0.210047     -0.235719      0.235719       106.444       106.680    
  24  0.113500      -2.17595      -2.44190       2.44190       108.464       110.906    
  25  0.197385      -1.62260      -1.82092       1.82092       109.588       111.409    
  26  0.101018      -2.29246      -2.57265       2.57265       110.113       112.686    
  27  0.857009E-01  -2.45689      -2.75717       2.75717       110.495       113.252    
  28  0.693668     -0.365762     -0.410465      0.410465       108.870       109.281    
  29  0.705918     -0.348256     -0.390820      0.390820       110.272       110.663    
  30  0.309793      -1.17185      -1.31508       1.31508       110.739       112.054    
  31  0.144843      -1.93210      -2.16825       2.16825       111.110       113.278    
  32  0.412916     -0.884511     -0.992617      0.992617       110.310       111.303    
  33  0.916661     -0.870180E-01 -0.976534E-01  0.976534E-01   109.837       109.935    
  34  0.933384E-01  -2.37152      -2.66137       2.66137       111.506       114.167    
  35  0.937330     -0.647200E-01 -0.726301E-01  0.726301E-01   110.750       110.823    
  36  0.958012     -0.428952E-01 -0.481379E-01  0.481379E-01   110.597       110.645    
  37  0.692877E-01  -2.66949      -2.99575       2.99575       110.699       113.695    
  38  0.228520E-01  -3.77872      -4.24056       4.24056       110.306       114.547    
  39  0.188135      -1.67060      -1.87478       1.87478       112.407       114.281    
  40  0.122595E-01  -4.40146      -4.93941       4.93941       110.057       114.996    
  41  0.776693     -0.252710     -0.283597      0.283597       112.922       113.206    
  42  0.571957     -0.558691     -0.626975      0.626975       113.092       113.719    
  43  0.313016      -1.16150      -1.30346       1.30346       110.730       112.033    
  44  0.512360     -0.668728     -0.750460      0.750460       111.225       111.975    
  45  0.874954     -0.133584     -0.149911      0.149911       112.520       112.670    
  46  0.617920     -0.481397     -0.540233      0.540233       111.985       112.525    
loop,thermsimp(1:2)       50   5.26265      0.115560    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    310        104.29         67.91          1.11         42.27          0.34          0.05        111.69
Just calling func    0   0        111.69


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    311        107.86         67.95          1.10         42.16          0.39          0.05        111.65
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    104.29
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       50
neval is:      310
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       50      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       51
neval is:      310


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      310     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.903412     -0.101577     -0.113991      0.113991       104.407       104.520    
   2  0.808902     -0.212077     -0.237998      0.237998       104.808       105.046    
   3  0.762147     -0.271616     -0.304813      0.304813       105.372       105.677    
   4  0.287851      -1.24531      -1.39751       1.39751       106.398       107.795    
   5  0.212418      -1.54920      -1.73855       1.73855       105.487       107.226    
   6  0.380717     -0.965699      -1.08373       1.08373       106.444       107.528    
   7  0.877795     -0.130342     -0.146272      0.146272       106.582       106.728    
   8  0.836834     -0.178130     -0.199901      0.199901       105.987       106.187    
   9  0.435183     -0.831988     -0.933674      0.933674       107.201       108.135    
  10  0.900166     -0.105177     -0.118031      0.118031       106.050       106.168    
  11  0.175095      -1.74242      -1.95538       1.95538       107.064       109.019    
  12  0.322232      -1.13248      -1.27090       1.27090       107.310       108.581    
  13  0.706662     -0.347203     -0.389639      0.389639       107.044       107.433    
  14  0.494297     -0.704618     -0.790737      0.790737       108.593       109.384    
  15  0.324383      -1.12583      -1.26343       1.26343       108.613       109.876    
  16  0.777122     -0.252157     -0.282976      0.282976       108.292       108.575    
  17  0.499054E-01  -2.99763      -3.36400       3.36400       108.870       112.234    
  18  0.489193E-01  -3.01758      -3.38640       3.38640       107.960       111.346    
  19  0.480140     -0.733678     -0.823348      0.823348       106.255       107.079    
  20  0.914126     -0.897865E-01 -0.100760      0.100760       104.387       104.488    
  21  0.613008     -0.489378     -0.549190      0.549190       109.837       110.387    
  22  0.470573     -0.753804     -0.845934      0.845934       109.148       109.994    
  23  0.614279     -0.487307     -0.546866      0.546866       107.359       107.906    
  24  0.410529     -0.890308     -0.999122      0.999122       105.672       106.671    
  25  0.582759     -0.539981     -0.605978      0.605978       108.940       109.546    
  26  0.422753E-01  -3.16355      -3.55020       3.55020       110.597       114.147    
  27  0.717044     -0.332618     -0.373271      0.373271       110.272       110.645    
  28  0.420765     -0.865682     -0.971486      0.971486       110.750       111.722    
  29  0.801392     -0.221405     -0.248465      0.248465       108.464       108.712    
  30  0.426188     -0.852875     -0.957113      0.957113       110.310       111.267    
  31  0.338881      -1.08211      -1.21436       1.21436       109.588       110.802    
  32  0.398160     -0.920902      -1.03346       1.03346       111.225       112.258    
  33  0.938837     -0.631132E-01 -0.708269E-01  0.708269E-01   110.730       110.801    
  34  0.411860E-01  -3.18966      -3.57950       3.57950       110.739       114.319    
  35  0.180703      -1.71090      -1.92001       1.92001       111.985       113.905    
  36  0.617012     -0.482867     -0.541883      0.541883       112.520       113.062    
  37  0.788612     -0.237480     -0.266505      0.266505       110.113       110.380    
  38  0.381719     -0.963071      -1.08078       1.08078       112.922       114.003    
  39  0.376038     -0.978064      -1.09760       1.09760       110.495       111.593    
  40  0.105996      -2.24435      -2.51866       2.51866       111.110       113.629    
  41  0.769932E-01  -2.56404      -2.87742       2.87742       110.699       113.577    
  42  0.365987      -1.00516      -1.12801       1.12801       113.092       114.220    
  43  0.731763     -0.312298     -0.350467      0.350467       111.506       111.856    
  44  0.447137     -0.804891     -0.903265      0.903265       112.407       113.310    
  45  0.273519      -1.29638      -1.45483       1.45483       110.306       111.761    
  46  0.870614     -0.138556     -0.155491      0.155491       104.294       104.450    
loop,thermsimp(1:2)       51  0.113991      0.237998    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    312        105.94         67.96          1.11         42.23          0.56          0.05        111.92
Just calling func    0   0        111.92


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    105.94
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       51
neval is:      311
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       51      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       52
neval is:      311


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      311     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.421091     -0.864906     -0.970616      0.970616       104.294       105.265    
   2  0.315135      -1.15476      -1.29589       1.29589       104.387       105.683    
   3  0.696708     -0.361389     -0.405558      0.405558       104.407       104.812    
   4  0.922116     -0.810842E-01 -0.909944E-01  0.909944E-01   104.808       104.899    
   5  0.908133     -0.963648E-01 -0.108143      0.108143       105.372       105.480    
   6  0.174132      -1.74794      -1.96158       1.96158       106.050       108.011    
   7  0.490629     -0.712068     -0.799097      0.799097       105.987       106.786    
   8  0.382604     -0.960755      -1.07818       1.07818       105.672       106.750    
   9  0.985159     -0.149527E-01 -0.167802E-01  0.167802E-01   106.582       106.598    
  10  0.182634      -1.70027      -1.90808       1.90808       106.255       108.163    
  11  0.554568     -0.589565     -0.661622      0.661622       105.487       106.149    
  12  0.999791     -0.209153E-03 -0.234716E-03  0.234716E-03   107.044       107.044    
  13  0.284621      -1.25660      -1.41018       1.41018       106.444       107.854    
  14  0.920706E-01  -2.38520      -2.67672       2.67672       106.398       109.074    
  15  0.243911      -1.41095      -1.58340       1.58340       107.359       108.943    
  16  0.866829     -0.142914     -0.160380      0.160380       107.201       107.362    
  17  0.640039     -0.446225     -0.500763      0.500763       108.292       108.793    
  18  0.737488E-01  -2.60709      -2.92573       2.92573       107.310       110.236    
  19  0.511916     -0.669594     -0.751432      0.751432       108.464       109.215    
  20  0.870220     -0.139009     -0.155999      0.155999       107.064       107.220    
  21  0.594690     -0.519714     -0.583234      0.583234       108.593       109.176    
  22  0.659508     -0.416262     -0.467138      0.467138       108.940       109.407    
  23  0.702023     -0.353789     -0.397030      0.397030       108.613       109.010    
  24  0.178121      -1.72529      -1.93616       1.93616       109.148       111.084    
  25  0.622271     -0.474379     -0.532358      0.532358       110.113       110.646    
  26  0.877027     -0.131217     -0.147255      0.147255       109.837       109.985    
  27  0.206753      -1.57623      -1.76888       1.76888       110.272       112.041    
  28  0.927381     -0.753912E-01 -0.846056E-01  0.846056E-01   110.730       110.815    
  29  0.610274     -0.493848     -0.554206      0.554206       109.588       110.142    
  30  0.453676     -0.790373     -0.886973      0.886973       110.310       111.197    
  31  0.203335      -1.59290      -1.78759       1.78759       107.960       109.748    
  32  0.558786     -0.581989     -0.653120      0.653120       110.495       111.148    
  33  0.685013     -0.378317     -0.424555      0.424555       110.750       111.175    
  34  0.753574     -0.282929     -0.317508      0.317508       110.306       110.624    
  35  0.736990E-01  -2.60777      -2.92649       2.92649       111.506       114.432    
  36  0.719848     -0.328716     -0.368891      0.368891       108.870       109.239    
  37  0.177345E-01  -4.03224      -4.52507       4.52507       111.225       115.750    
  38  0.277334E-01  -3.58512      -4.02330       4.02330       112.520       116.543    
  39  0.228604      -1.47576      -1.65613       1.65613       112.407       114.063    
  40  0.874609     -0.133979     -0.150354      0.150354       110.699       110.850    
  41  0.875699     -0.132733     -0.148956      0.148956       111.110       111.259    
  42  0.540874     -0.614569     -0.689682      0.689682       111.985       112.674    
  43  0.343108E-01  -3.37230      -3.78446       3.78446       112.922       116.707    
  44  0.982551     -0.176027E-01 -0.197542E-01  0.197542E-01   110.597       110.617    
  45  0.201823      -1.60037      -1.79596       1.79596       113.092       114.888    
  46  0.116838      -2.14697      -2.40937       2.40937       105.936       108.346    
loop,thermsimp(1:2)       52  0.970616       1.29589    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    313        110.72         67.83          1.10         42.08          0.47          0.05        111.53
Just calling func    0   0        111.53


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    110.72
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       52
neval is:      312
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       52      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       53
neval is:      312


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      312     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.340866E-01  -3.37885      -3.79182       3.79182       104.407       108.198    
   2  0.714674     -0.335928     -0.376985      0.376985       104.808       105.185    
   3  0.977792     -0.224587E-01 -0.252036E-01  0.252036E-01   104.294       104.319    
   4  0.771231     -0.259767     -0.291516      0.291516       105.372       105.664    
   5  0.265148      -1.32747      -1.48971       1.48971       104.387       105.877    
   6  0.559491     -0.580728     -0.651705      0.651705       105.487       106.139    
   7  0.934824E-01  -2.36998      -2.65964       2.65964       106.582       109.241    
   8  0.928182     -0.745278E-01 -0.836366E-01  0.836366E-01   105.672       105.756    
   9  0.464905     -0.765922     -0.859533      0.859533       105.987       106.847    
  10  0.871919     -0.137059     -0.153810      0.153810       107.044       107.197    
  11  0.982233     -0.179265E-01 -0.201174E-01  0.201174E-01   107.064       107.084    
  12  0.426376     -0.852433     -0.956618      0.956618       107.201       108.158    
  13  0.471128E-01  -3.05521      -3.42862       3.42862       106.444       109.873    
  14  0.686439     -0.376238     -0.422223      0.422223       106.050       106.472    
  15  0.117826      -2.13855      -2.39992       2.39992       106.255       108.655    
  16  0.756878E-01  -2.58114      -2.89661       2.89661       105.936       108.833    
  17  0.196211      -1.62856      -1.82761       1.82761       108.292       110.120    
  18  0.431930     -0.839491     -0.942094      0.942094       107.359       108.301    
  19  0.707794     -0.345602     -0.387842      0.387842       108.613       109.001    
  20  0.174358E-01  -4.04923      -4.54413       4.54413       106.398       110.942    
  21  0.267976      -1.31686      -1.47780       1.47780       108.593       110.071    
  22  0.793866     -0.230841     -0.259054      0.259054       108.464       108.723    
  23  0.135848      -1.99622      -2.24020       2.24020       108.870       111.111    
  24  0.663958     -0.409536     -0.459590      0.459590       108.940       109.400    
  25  0.281101      -1.26904      -1.42414       1.42414       107.960       109.384    
  26  0.606466     -0.500106     -0.561229      0.561229       109.837       110.399    
  27  0.940056     -0.618158E-01 -0.693710E-01  0.693710E-01   109.588       109.657    
  28  0.124106      -2.08662      -2.34165       2.34165       107.310       109.651    
  29  0.205090      -1.58431      -1.77794       1.77794       110.597       112.375    
  30  0.852960     -0.159043     -0.178481      0.178481       110.306       110.485    
  31  0.241701      -1.42005      -1.59361       1.59361       110.113       111.707    
  32  0.744368     -0.295220     -0.331302      0.331302       110.730       111.061    
  33  0.279909      -1.27329      -1.42891       1.42891       110.699       112.128    
  34  0.142971      -1.94511      -2.18285       2.18285       109.148       111.331    
  35  0.367233      -1.00176      -1.12419       1.12419       110.495       111.620    
  36  0.839044     -0.175493     -0.196941      0.196941       110.750       110.947    
  37  0.762369     -0.271325     -0.304487      0.304487       110.310       110.614    
  38  0.414704     -0.880189     -0.987767      0.987767       111.110       112.098    
  39  0.294445      -1.22266      -1.37210       1.37210       110.272       111.644    
  40  0.296874      -1.21445      -1.36288       1.36288       111.985       113.347    
  41  0.834777     -0.180590     -0.202662      0.202662       112.407       112.609    
  42  0.399354     -0.917907      -1.03009       1.03009       111.506       112.536    
  43  0.948666     -0.526981E-01 -0.591389E-01  0.591389E-01   113.092       113.151    
  44  0.306553E-01  -3.48495      -3.91088       3.91088       111.225       115.136    
  45  0.768324E-01  -2.56613      -2.87976       2.87976       112.520       115.400    
  46  0.723813     -0.323222     -0.362726      0.362726       110.717       111.079    
loop,thermsimp(1:2)       53   3.79182      0.376985    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    314        111.18         67.88          1.10         42.10          0.36          0.05        111.49
Just calling func    0   0        111.49


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    111.18
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       53
neval is:      313
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       53      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       54
neval is:      313


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      313     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.615000     -0.486133     -0.545549      0.545549       104.294       104.840    
   2  0.438442     -0.824528     -0.925303      0.925303       104.808       105.733    
   3  0.666371     -0.405908     -0.455519      0.455519       105.372       105.828    
   4  0.419797     -0.867984     -0.974069      0.974069       105.672       106.646    
   5  0.662493     -0.411746     -0.462069      0.462069       104.387       104.849    
   6  0.261021      -1.34315      -1.50731       1.50731       105.487       106.994    
   7  0.451731     -0.794667     -0.891792      0.891792       106.050       106.941    
   8  0.858047     -0.153096     -0.171808      0.171808       105.987       106.159    
   9  0.678039     -0.388550     -0.436039      0.436039       107.064       107.500    
  10  0.257304      -1.35750      -1.52341       1.52341       107.044       108.567    
  11  0.379774     -0.968178      -1.08651       1.08651       107.201       108.288    
  12  0.200314      -1.60787      -1.80439       1.80439       104.407       106.211    
  13  0.702955E-01  -2.65505      -2.97955       2.97955       107.359       110.339    
  14  0.846007     -0.167228     -0.187667      0.187667       106.255       106.443    
  15  0.692217     -0.367856     -0.412816      0.412816       108.464       108.877    
  16  0.830541     -0.185678     -0.208372      0.208372       105.936       106.145    
  17  0.162133E-02  -6.42451      -7.20971       7.20971       108.613       115.822    
  18  0.829216     -0.187275     -0.210163      0.210163       106.582       106.792    
  19  0.464918     -0.765894     -0.859503      0.859503       107.960       108.820    
  20  0.204157      -1.58887      -1.78306       1.78306       108.940       110.723    
  21  0.203429      -1.59244      -1.78707       1.78707       107.310       109.097    
  22  0.403935     -0.906500      -1.01729       1.01729       109.588       110.605    
  23  0.508037     -0.677201     -0.759969      0.759969       106.444       107.204    
  24  0.337702      -1.08559      -1.21827       1.21827       108.593       109.811    
  25  0.375672     -0.979039      -1.09870       1.09870       108.292       109.391    
  26  0.218755      -1.51980      -1.70555       1.70555       109.837       111.543    
  27  0.803422     -0.218876     -0.245627      0.245627       110.306       110.552    
  28  0.324101      -1.12670      -1.26441       1.26441       110.310       111.574    
  29  0.804001     -0.218155     -0.244817      0.244817       106.398       106.642    
  30  0.727676     -0.317899     -0.356753      0.356753       110.750       111.107    
  31  0.769479     -0.262042     -0.294069      0.294069       110.730       111.024    
  32  0.632293     -0.458402     -0.514428      0.514428       110.717       111.231    
  33  0.300459      -1.20244      -1.34941       1.34941       108.870       110.220    
  34  0.567362     -0.566759     -0.636028      0.636028       109.148       109.784    
  35  0.803345     -0.218971     -0.245734      0.245734       110.495       110.741    
  36  0.764706     -0.268264     -0.301052      0.301052       110.272       110.573    
  37  0.159444      -1.83606      -2.06047       2.06047       110.113       112.174    
  38  0.951670     -0.495367E-01 -0.555911E-01  0.555911E-01   111.110       111.166    
  39  0.769198     -0.262407     -0.294478      0.294478       110.699       110.994    
  40  0.916532     -0.871588E-01 -0.978114E-01  0.978114E-01   110.597       110.695    
  41  0.146117E-01  -4.22593      -4.74243       4.74243       111.506       116.248    
  42  0.196164      -1.62880      -1.82788       1.82788       112.407       114.235    
  43  0.399482     -0.917586      -1.02973       1.02973       113.092       114.122    
  44  0.646732     -0.435823     -0.489090      0.489090       111.985       112.474    
  45  0.207790      -1.57122      -1.76326       1.76326       111.225       112.988    
  46  0.276388      -1.28595      -1.44312       1.44312       111.176       112.620    
loop,thermsimp(1:2)       54  0.545549      0.925303    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    315        106.98         67.93          1.09         42.12          0.34          0.05        111.53
Just calling func    0   0        111.53


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    106.98
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       54
neval is:      314
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       54      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       55
neval is:      314


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      314     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.626103     -0.468241     -0.525469      0.525469       104.294       104.820    
   2  0.909442     -0.949244E-01 -0.106526      0.106526       104.387       104.494    
   3  0.449837     -0.798870     -0.896509      0.896509       104.808       105.704    
   4  0.761598     -0.272336     -0.305621      0.305621       105.372       105.678    
   5  0.706800     -0.347007     -0.389419      0.389419       105.936       106.326    
   6  0.214343      -1.54018      -1.72842       1.72842       105.987       107.716    
   7  0.855661     -0.155881     -0.174933      0.174933       104.407       104.581    
   8  0.432924E-01  -3.13978      -3.52352       3.52352       106.255       109.779    
   9  0.902784     -0.102271     -0.114771      0.114771       106.398       106.512    
  10  0.706965     -0.346774     -0.389157      0.389157       105.672       106.061    
  11  0.826667     -0.190354     -0.213619      0.213619       106.582       106.795    
  12  0.824436     -0.193055     -0.216651      0.216651       106.050       106.266    
  13  0.442772     -0.814700     -0.914273      0.914273       105.487       106.401    
  14  0.416355     -0.876217     -0.983308      0.983308       106.444       107.427    
  15  0.268464      -1.31504      -1.47576       1.47576       107.064       108.540    
  16  0.779742     -0.248792     -0.279199      0.279199       107.201       107.480    
  17  0.406799E-01  -3.20202      -3.59338       3.59338       107.044       110.637    
  18  0.975397     -0.249106E-01 -0.279552E-01  0.279552E-01   107.960       107.988    
  19  0.425150E-01  -3.15790      -3.54386       3.54386       108.464       112.008    
  20  0.302481      -1.19574      -1.34188       1.34188       107.310       108.652    
  21  0.732033     -0.311930     -0.350054      0.350054       108.292       108.642    
  22  0.774561     -0.255459     -0.286682      0.286682       109.148       109.435    
  23  0.899897     -0.105475     -0.118366      0.118366       108.593       108.711    
  24  0.549624     -0.598520     -0.671672      0.671672       108.870       109.542    
  25  0.143543      -1.94112      -2.17837       2.17837       107.359       109.538    
  26  0.229055      -1.47379      -1.65392       1.65392       110.306       111.960    
  27  0.334206      -1.09600      -1.22995       1.22995       110.272       111.502    
  28  0.301620      -1.19859      -1.34508       1.34508       109.588       110.933    
  29  0.856030     -0.155449     -0.174449      0.174449       110.597       110.772    
  30  0.978878     -0.213482E-01 -0.239574E-01  0.239574E-01   108.940       108.964    
  31  0.890790E-01  -2.41823      -2.71379       2.71379       110.495       113.209    
  32  0.275076      -1.29071      -1.44846       1.44846       110.699       112.148    
  33  0.506865     -0.679511     -0.762562      0.762562       110.730       111.493    
  34  0.628553     -0.464334     -0.521086      0.521086       110.750       111.271    
  35  0.787972     -0.238293     -0.267417      0.267417       111.110       111.378    
  36  0.746168     -0.292804     -0.328591      0.328591       110.717       111.045    
  37  0.116954      -2.14598      -2.40826       2.40826       109.837       112.246    
  38  0.245368      -1.40500      -1.57672       1.57672       110.310       111.887    
  39  0.873952     -0.134729     -0.151196      0.151196       110.113       110.265    
  40  0.850596     -0.161818     -0.181595      0.181595       111.985       112.166    
  41  0.455763     -0.785783     -0.881822      0.881822       111.176       112.058    
  42  0.984333     -0.157910E-01 -0.177210E-01  0.177210E-01   111.225       111.243    
  43  0.956700     -0.442655E-01 -0.496757E-01  0.496757E-01   113.092       113.142    
  44  0.186161      -1.68114      -1.88661       1.88661       112.407       114.293    
  45  0.791379     -0.233979     -0.262576      0.262576       108.613       108.875    
  46  0.262937      -1.33584      -1.49911       1.49911       106.979       108.478    
loop,thermsimp(1:2)       55  0.525469      0.106526    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    316        105.51         67.92          1.10         42.20          0.30          0.05        111.58
Just calling func    0   0        111.58


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    317        113.03         68.14          1.10         42.27          0.25          0.05        111.80
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    105.51
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       55
neval is:      316
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       55      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       56
neval is:      316


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      316
neval,tstepnext:      316     316

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.245842      -1.40307      -1.57455       1.57455       104.387       105.962    
   2  0.963480     -0.372033E-01 -0.417503E-01  0.417503E-01   104.407       104.448    
   3  0.633143     -0.457059     -0.512921      0.512921       104.294       104.807    
   4  0.939850E-02  -4.66721      -5.23763       5.23763       105.372       110.610    
   5  0.796978     -0.226928     -0.254664      0.254664       104.808       105.063    
   6  0.229125      -1.47349      -1.65358       1.65358       105.672       107.326    
   7  0.926958     -0.758467E-01 -0.851168E-01  0.851168E-01   106.050       106.135    
   8  0.687512     -0.374676     -0.420469      0.420469       105.936       106.357    
   9  0.695030     -0.363800     -0.408264      0.408264       105.487       105.895    
  10  0.900736     -0.104543     -0.117320      0.117320       106.398       106.515    
  11  0.867179     -0.142510     -0.159927      0.159927       106.582       106.742    
  12  0.879271     -0.128662     -0.144387      0.144387       106.444       106.589    
  13  0.197557      -1.62173      -1.81994       1.81994       107.201       109.021    
  14  0.790701     -0.234835     -0.263537      0.263537       105.987       106.251    
  15  0.807456     -0.213867     -0.240006      0.240006       107.960       108.200    
  16  0.688117     -0.373796     -0.419482      0.419482       106.979       107.398    
  17  0.227000      -1.48280      -1.66403       1.66403       107.064       108.728    
  18  0.374715     -0.981589      -1.10156       1.10156       108.292       109.394    
  19  0.176077      -1.73683      -1.94911       1.94911       107.310       109.259    
  20  0.446126E-01  -3.10974      -3.48981       3.48981       108.593       112.083    
  21  0.997763E-01  -2.30482      -2.58652       2.58652       108.613       111.199    
  22  0.142978E-01  -4.24765      -4.76680       4.76680       108.940       113.707    
  23  0.652216     -0.427379     -0.479614      0.479614       109.148       109.628    
  24  0.909797     -0.945339E-01 -0.106088      0.106088       107.359       107.465    
  25  0.145015      -1.93092      -2.16692       2.16692       108.870       111.037    
  26  0.189723      -1.66219      -1.86535       1.86535       106.255       108.121    
  27  0.260997      -1.34324      -1.50742       1.50742       110.113       111.621    
  28  0.167755      -1.78525      -2.00344       2.00344       107.044       109.047    
  29  0.148939      -1.90422      -2.13695       2.13695       110.597       112.734    
  30  0.209474      -1.56315      -1.75420       1.75420       109.588       111.342    
  31  0.594522     -0.519998     -0.583552      0.583552       110.717       111.300    
  32  0.401703     -0.912043      -1.02351       1.02351       111.225       112.248    
  33  0.306469      -1.18264      -1.32718       1.32718       110.750       112.077    
  34  0.879335     -0.128589     -0.144305      0.144305       111.110       111.255    
  35  0.920707     -0.826134E-01 -0.927105E-01  0.927105E-01   110.730       110.823    
  36  0.215616      -1.53425      -1.72177       1.72177       110.272       111.994    
  37  0.821708     -0.196370     -0.220371      0.220371       110.310       110.530    
  38  0.935240     -0.669517E-01 -0.751346E-01  0.751346E-01   110.306       110.381    
  39  0.691932     -0.368268     -0.413278      0.413278       108.464       108.877    
  40  0.493152     -0.706938     -0.793340      0.793340       111.176       111.970    
  41  0.362160      -1.01567      -1.13980       1.13980       110.699       111.839    
  42  0.636318     -0.452056     -0.507307      0.507307       111.985       112.492    
  43  0.178369      -1.72390      -1.93460       1.93460       109.837       111.772    
  44  0.987372     -0.127089E-01 -0.142622E-01  0.142622E-01   113.092       113.106    
  45  0.557690     -0.583953     -0.655324      0.655324       110.495       111.151    
  46  0.434391     -0.833811     -0.935720      0.935720       105.511       106.447    
loop,thermsimp(1:2)       56   1.57455      0.417503E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    318        108.35         67.90          1.10         42.14          0.70          0.05        111.88
Just calling func    0   0        111.88


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    108.35
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:    1.12222               316
loop is:       56
neval is:      317
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       56      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:    1.12222               316
loop is:       57
neval is:      317


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 




neval>tstepnex so lower away!t
---> lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
     new SAtemp,tstepnext are :   0.561110               361

 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      317     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.303901      -1.19105     -0.668312      0.668312       104.407       105.075    
   2  0.729962     -0.314762     -0.176616      0.176616       104.294       104.471    
   3  0.788140     -0.238080     -0.133589      0.133589       104.808       104.942    
   4  0.718031     -0.331242     -0.185864      0.185864       105.487       105.673    
   5  0.603575     -0.504885     -0.283296      0.283296       104.387       104.671    
   6  0.287757      -1.24564     -0.698941      0.698941       106.050       106.749    
   7  0.690986     -0.369635     -0.207406      0.207406       105.987       106.195    
   8  0.976315     -0.239695E-01 -0.134495E-01  0.134495E-01   105.936       105.950    
   9  0.983892     -0.162393E-01 -0.911204E-02  0.911204E-02   105.511       105.521    
  10  0.858769     -0.152255     -0.854317E-01  0.854317E-01   106.398       106.483    
  11  0.968889     -0.316048E-01 -0.177338E-01  0.177338E-01   106.444       106.462    
  12  0.364921      -1.00807     -0.565641      0.565641       106.582       107.147    
  13  0.540930     -0.614466     -0.344783      0.344783       105.672       106.017    
  14  0.812278E-01  -2.51050      -1.40867       1.40867       106.979       108.387    
  15  0.919841     -0.835539E-01 -0.468830E-01  0.468830E-01   107.359       107.406    
  16  0.275462      -1.28930     -0.723442      0.723442       106.255       106.979    
  17  0.704362     -0.350463     -0.196649      0.196649       107.960       108.157    
  18  0.896809     -0.108913     -0.611121E-01  0.611121E-01   107.064       107.125    
  19  0.166873      -1.79052      -1.00468       1.00468       108.464       109.469    
  20  0.927791E-02  -4.68012      -2.62606       2.62606       107.201       109.827    
  21  0.906733     -0.979074E-01 -0.549368E-01  0.549368E-01   107.044       107.099    
  22  0.575421     -0.552654     -0.310100      0.310100       107.310       107.620    
  23  0.975069     -0.252469E-01 -0.141663E-01  0.141663E-01   108.292       108.306    
  24  0.610094     -0.494143     -0.277269      0.277269       109.148       109.425    
  25  0.823028     -0.194765     -0.109284      0.109284       110.306       110.415    
  26  0.709022     -0.343869     -0.192948      0.192948       110.310       110.503    
  27  0.956893     -0.440633E-01 -0.247244E-01  0.247244E-01   105.372       105.397    
  28  0.897850E-01  -2.41034      -1.35246       1.35246       110.730       112.082    
  29  0.836996     -0.177936     -0.998420E-01  0.998420E-01   108.870       108.970    
  30  0.688664     -0.373001     -0.209295      0.209295       110.495       110.705    
  31  0.587454     -0.531957     -0.298487      0.298487       108.613       108.911    
  32  0.880970     -0.126731     -0.711102E-01  0.711102E-01   111.110       111.181    
  33  0.506724     -0.679789     -0.381437      0.381437       110.717       111.098    
  34  0.802262     -0.220320     -0.123624      0.123624       109.588       109.711    
  35  0.764787E-01  -2.57074      -1.44247       1.44247       110.113       111.556    
  36  0.907101     -0.975014E-01 -0.547090E-01  0.547090E-01   109.837       109.892    
  37  0.797350     -0.226461     -0.127070      0.127070       110.699       110.826    
  38  0.257375      -1.35722     -0.761550      0.761550       111.176       111.938    
  39  0.643190     -0.441315     -0.247626      0.247626       110.272       110.520    
  40  0.513768     -0.665984     -0.373690      0.373690       110.750       111.124    
  41  0.850264     -0.162208     -0.910167E-01  0.910167E-01   108.593       108.684    
  42  0.200819      -1.60535     -0.900779      0.900779       111.225       112.126    
  43  0.331940      -1.10280     -0.618793      0.618793       111.985       112.603    
  44  0.900490     -0.104816     -0.588134E-01  0.588134E-01   110.597       110.656    
  45  0.618957     -0.479719     -0.269176      0.269176       113.092       113.361    
  46  0.395756     -0.926956     -0.520125      0.520125       108.345       108.866    
loop,thermsimp(1:2)       57  0.668312      0.176616    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    319        104.54         67.92          1.09         42.41          0.39          0.05        111.86
Just calling func    0   0        111.86


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    320        108.64         67.95          1.07         42.12          0.14          0.06        111.34
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    104.54
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       57
neval is:      319
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       57      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       58
neval is:      319


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      319     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.530208     -0.634486     -0.356017      0.356017       104.294       104.650    
   2  0.175946E-01  -4.04016      -2.26698       2.26698       104.387       106.654    
   3  0.419998     -0.867504     -0.486766      0.486766       104.808       105.295    
   4  0.448197E-01  -3.10511      -1.74231       1.74231       104.407       106.149    
   5  0.501784     -0.689586     -0.386934      0.386934       105.372       105.759    
   6  0.858173     -0.152949     -0.858215E-01  0.858215E-01   105.511       105.597    
   7  0.101932      -2.28345      -1.28127       1.28127       105.487       106.768    
   8  0.453268     -0.791273     -0.443991      0.443991       105.936       106.380    
   9  0.128092      -2.05501      -1.15309       1.15309       105.672       106.825    
  10  0.779644     -0.248918     -0.139670      0.139670       105.987       106.127    
  11  0.769943E-01  -2.56402      -1.43870       1.43870       106.444       107.883    
  12  0.140214      -1.96458      -1.10235       1.10235       106.398       107.500    
  13  0.571588     -0.559337     -0.313850      0.313850       106.050       106.363    
  14  0.455096     -0.787247     -0.441732      0.441732       106.255       106.697    
  15  0.594240     -0.520471     -0.292042      0.292042       107.044       107.336    
  16  0.833288     -0.182376     -0.102333      0.102333       107.064       107.166    
  17  0.807090E-01  -2.51691      -1.41226       1.41226       106.582       107.994    
  18  0.430313     -0.843242     -0.473152      0.473152       107.359       107.832    
  19  0.990463     -0.958277E-02 -0.537699E-02  0.537699E-02   107.310       107.315    
  20  0.907906     -0.966144E-01 -0.542113E-01  0.542113E-01   107.960       108.014    
  21  0.607469     -0.498455     -0.279688      0.279688       108.292       108.572    
  22  0.927102     -0.756916E-01 -0.424713E-01  0.424713E-01   106.979       107.021    
  23  0.379122     -0.969896     -0.544219      0.544219       108.593       109.137    
  24  0.183121E-01  -4.00019      -2.24455       2.24455       108.345       110.590    
  25  0.561966     -0.576313     -0.323375      0.323375       108.613       108.936    
  26  0.638772     -0.448208     -0.251494      0.251494       108.870       109.122    
  27  0.234202      -1.45157     -0.814491      0.814491       109.148       109.963    
  28  0.257221      -1.35782     -0.761886      0.761886       108.464       109.226    
  29  0.688379     -0.373416     -0.209528      0.209528       109.588       109.797    
  30  0.360237E-01  -3.32358      -1.86489       1.86489       107.201       109.066    
  31  0.849177     -0.163487     -0.917344E-01  0.917344E-01   109.837       109.929    
  32  0.324868E-01  -3.42692      -1.92288       1.92288       110.306       112.229    
  33  0.216483E-01  -3.83283      -2.15064       2.15064       110.310       112.461    
  34  0.794095     -0.230552     -0.129365      0.129365       110.272       110.401    
  35  0.453180     -0.791465     -0.444099      0.444099       110.597       111.041    
  36  0.286278      -1.25079     -0.701832      0.701832       110.495       111.197    
  37  0.931500     -0.709590E-01 -0.398158E-01  0.398158E-01   110.699       110.739    
  38  0.483424     -0.726861     -0.407849      0.407849       110.717       111.124    
  39  0.782276     -0.245547     -0.137779      0.137779       110.750       110.888    
  40  0.976661     -0.236156E-01 -0.132509E-01  0.132509E-01   111.110       111.124    
  41  0.707981     -0.345338     -0.193772      0.193772       110.113       110.307    
  42  0.101993      -2.28285      -1.28093       1.28093       111.176       112.457    
  43  0.690974E-01  -2.67224      -1.49942       1.49942       110.730       112.229    
  44  0.767576E-01  -2.56710      -1.44043       1.44043       111.225       112.665    
  45  0.584825     -0.536443     -0.301004      0.301004       111.985       112.286    
  46  0.588828     -0.529621     -0.297176      0.297176       104.538       104.835    
loop,thermsimp(1:2)       58  0.356017       2.26698    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    321        106.65         67.95          1.10         42.05          0.52          0.05        111.67
Just calling func    0   0        111.67


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  320    106.65        1.404     -3.117      2.405     -102.6     0.1643    
                       1.292     0.4857     -99.70      4.570      1.267    

                       1.283     -2.618      1.540      7735.      7000.    

                      0.5294      0.000      0.000      0.000     -1.221    



                      -2.263      0.000      0.000      7000.      712.9    

                       1.919     -4.370     -6.573     -7.630      8.018    

                      -18.28     -7.426      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.3705    -0.8976      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.4835     -1.162      7000.    



                      -1.894     -1.723     -2.003     -1.933    -0.3807    

                     -0.3252      9.266      8.784    -0.1480E+05 -4.880    

                     -0.6818     -3.700      9.397      8.896    -0.1969E+05



                      -6.000     0.5834    -0.6768E-02  8.994      8.949    

                     -0.1944E+05 -6.000     -1.337    -0.3149      9.138    

                       8.874    -0.1891E+05 -6.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    106.65
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       58
neval is:      320
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       58      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       59
neval is:      320


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      320     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.946919     -0.545412E-01 -0.306036E-01  0.306036E-01   104.294       104.325    
   2  0.224221      -1.49512     -0.838928      0.838928       104.538       105.377    
   3  0.699642     -0.357186     -0.200421      0.200421       104.808       105.008    
   4  0.490916     -0.711482     -0.399220      0.399220       105.511       105.911    
   5  0.204251      -1.58840     -0.891270      0.891270       105.372       106.264    
   6  0.356522      -1.03136     -0.578706      0.578706       105.987       106.566    
   7  0.745938     -0.293113     -0.164469      0.164469       104.407       104.571    
   8  0.451533     -0.795107     -0.446143      0.446143       106.050       106.496    
   9  0.101038      -2.29226      -1.28621       1.28621       105.936       107.223    
  10  0.826978     -0.189977     -0.106598      0.106598       104.387       104.494    
  11  0.212337      -1.54958     -0.869486      0.869486       106.255       107.125    
  12  0.490540     -0.712248     -0.399650      0.399650       105.487       105.887    
  13  0.672078     -0.397381     -0.222974      0.222974       105.672       105.895    
  14  0.690580     -0.370223     -0.207736      0.207736       106.979       107.186    
  15  0.513190     -0.667108     -0.374321      0.374321       107.064       107.438    
  16  0.268393      -1.31530     -0.738031      0.738031       107.310       108.048    
  17  0.896898     -0.108813     -0.610561E-01  0.610561E-01   107.044       107.105    
  18  0.911953     -0.921674E-01 -0.517161E-01  0.517161E-01   106.398       106.449    
  19  0.355703      -1.03366     -0.579996      0.579996       107.359       107.939    
  20  0.293818      -1.22479     -0.687244      0.687244       106.444       107.131    
  21  0.713392     -0.337724     -0.189500      0.189500       106.582       106.771    
  22  0.660627     -0.414565     -0.232617      0.232617       107.960       108.193    
  23  0.795097     -0.229291     -0.128657      0.128657       108.292       108.421    
  24  0.919484     -0.839428E-01 -0.471012E-01  0.471012E-01   108.613       108.660    
  25  0.976382     -0.239014E-01 -0.134113E-01  0.134113E-01   107.201       107.215    
  26  0.922195     -0.809991E-01 -0.454494E-01  0.454494E-01   108.870       108.916    
  27  0.436062     -0.829970     -0.465705      0.465705       108.593       109.059    
  28  0.271848      -1.30251     -0.730853      0.730853       108.464       109.195    
  29  0.389360     -0.943252     -0.529268      0.529268       109.588       110.117    
  30  0.314178E-01  -3.46038      -1.94166       1.94166       109.837       111.779    
  31  0.545460     -0.606126     -0.340103      0.340103       109.148       109.488    
  32  0.925479E-01  -2.38003      -1.33546       1.33546       110.113       111.449    
  33  0.971973     -0.284273E-01 -0.159509E-01  0.159509E-01   110.272       110.288    
  34  0.403500     -0.907578     -0.509251      0.509251       108.345       108.855    
  35  0.392926     -0.934133     -0.524152      0.524152       110.699       111.224    
  36  0.718758     -0.330230     -0.185296      0.185296       110.750       110.935    
  37  0.746082     -0.292920     -0.164360      0.164360       110.597       110.761    
  38  0.353478      -1.03993     -0.583518      0.583518       111.110       111.694    
  39  0.843229     -0.170517     -0.956788E-01  0.956788E-01   110.717       110.812    
  40  0.388011     -0.946720     -0.531215      0.531215       110.495       111.027    
  41  0.969569     -0.309034E-01 -0.173402E-01  0.173402E-01   110.306       110.324    
  42  0.441380E-01  -3.12043      -1.75091       1.75091       110.730       112.481    
  43  0.533000     -0.629233     -0.353069      0.353069       111.985       112.338    
  44  0.288396      -1.24342     -0.697697      0.697697       111.176       111.874    
  45  0.683115     -0.381092     -0.213835      0.213835       110.310       110.524    
  46  0.339511      -1.08025     -0.606140      0.606140       106.650       107.256    
loop,thermsimp(1:2)       59  0.306036E-01  0.838928    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    322        107.31         67.83          1.08         41.84          0.92          0.05        111.72
Just calling func    0   0        111.72


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    107.31
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       59
neval is:      321
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       59      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       60
neval is:      321


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      321     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.347122      -1.05808     -0.593699      0.593699       104.294       104.888    
   2  0.605757     -0.501276     -0.281271      0.281271       104.387       104.668    
   3  0.690633     -0.370146     -0.207693      0.207693       104.407       104.614    
   4  0.400665     -0.914628     -0.513207      0.513207       104.808       105.321    
   5  0.862165     -0.148309     -0.832176E-01  0.832176E-01   104.538       104.621    
   6  0.874011     -0.134662     -0.755603E-01  0.755603E-01   105.487       105.563    
   7  0.389525     -0.942826     -0.529029      0.529029       105.672       106.201    
   8  0.102225E-01  -4.58317      -2.57166       2.57166       105.511       108.083    
   9  0.102697      -2.27597      -1.27707       1.27707       105.372       106.649    
  10  0.818271     -0.200561     -0.112537      0.112537       106.398       106.510    
  11  0.888768     -0.117920     -0.661659E-01  0.661659E-01   106.050       106.116    
  12  0.539210     -0.617651     -0.346570      0.346570       105.987       106.334    
  13  0.317914      -1.14597     -0.643018      0.643018       106.582       107.225    
  14  0.437422     -0.826857     -0.463958      0.463958       107.044       107.508    
  15  0.925263     -0.776773E-01 -0.435855E-01  0.435855E-01   106.255       106.299    
  16  0.422436     -0.861717     -0.483518      0.483518       106.444       106.928    
  17  0.965248     -0.353697E-01 -0.198463E-01  0.198463E-01   106.979       106.999    
  18  0.771278     -0.259706     -0.145724      0.145724       107.201       107.347    
  19  0.902488     -0.102600     -0.575700E-01  0.575700E-01   105.936       105.994    
  20  0.512816     -0.667839     -0.374731      0.374731       106.650       107.025    
  21  0.915966     -0.877758E-01 -0.492519E-01  0.492519E-01   107.064       107.113    
  22  0.612605     -0.490035     -0.274964      0.274964       107.359       107.634    
  23  0.323528      -1.12847     -0.633196      0.633196       107.310       107.943    
  24  0.206646      -1.57675     -0.884730      0.884730       107.960       108.845    
  25  0.481057     -0.731769     -0.410603      0.410603       108.292       108.703    
  26  0.287887E-01  -3.54777      -1.99069       1.99069       108.613       110.603    
  27  0.996968     -0.303648E-02 -0.170380E-02  0.170380E-02   108.345       108.347    
  28  0.132770      -2.01914      -1.13296       1.13296       108.870       110.003    
  29  0.716038     -0.334023     -0.187423      0.187423       108.593       108.780    
  30  0.229552      -1.47162     -0.825744      0.825744       108.464       109.290    
  31  0.236358      -1.44241     -0.809349      0.809349       109.148       109.957    
  32  0.542780     -0.611051     -0.342867      0.342867       109.588       109.931    
  33  0.875156     -0.133353     -0.748256E-01  0.748256E-01   110.272       110.347    
  34  0.988730     -0.113343E-01 -0.635980E-02  0.635980E-02   110.306       110.313    
  35  0.244332      -1.40923     -0.790732      0.790732       110.310       111.101    
  36  0.659246     -0.416659     -0.233792      0.233792       110.597       110.831    
  37  0.457872     -0.781166     -0.438320      0.438320       110.717       111.155    
  38  0.380652E-01  -3.26846      -1.83396       1.83396       110.750       112.584    
  39  0.358843      -1.02487     -0.575065      0.575065       110.495       111.070    
  40  0.846233     -0.166960     -0.936830E-01  0.936830E-01   110.699       110.793    
  41  0.359308      -1.02358     -0.574339      0.574339       110.113       110.688    
  42  0.533329     -0.628617     -0.352724      0.352724       111.110       111.463    
  43  0.645289     -0.438058     -0.245799      0.245799       109.837       110.083    
  44  0.311850      -1.16523     -0.653823      0.653823       111.176       111.830    
  45  0.270084      -1.30902     -0.734505      0.734505       111.985       112.719    
  46  0.530313     -0.634287     -0.355905      0.355905       107.308       107.664    
loop,thermsimp(1:2)       60  0.593699      0.281271    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    323        111.89         67.89          1.08         42.40          0.39          0.05        111.82
Just calling func    0   0        111.82


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    111.89
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       60
neval is:      322
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       60      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       61
neval is:      322


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      322     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.663917     -0.409597     -0.229829      0.229829       104.407       104.636    
   2  0.718953     -0.329960     -0.185144      0.185144       104.538       104.723    
   3  0.454275     -0.789053     -0.442746      0.442746       104.387       104.830    
   4  0.253407E-01  -3.67534      -2.06227       2.06227       104.294       106.356    
   5  0.611947     -0.491110     -0.275567      0.275567       104.808       105.083    
   6  0.234016      -1.45237     -0.814938      0.814938       105.487       106.302    
   7  0.359481E-01  -3.32568      -1.86607       1.86607       105.936       107.802    
   8  0.222118E-01  -3.80713      -2.13622       2.13622       106.050       108.186    
   9  0.905838E-01  -2.40148      -1.34750       1.34750       105.672       107.020    
  10  0.791683     -0.233594     -0.131072      0.131072       106.255       106.386    
  11  0.557734     -0.583873     -0.327617      0.327617       105.987       106.315    
  12  0.936048E-01  -2.36867      -1.32909       1.32909       106.398       107.727    
  13  0.431059     -0.841510     -0.472180      0.472180       105.372       105.844    
  14  0.225758      -1.48829     -0.835096      0.835096       106.444       107.279    
  15  0.275181E-01  -3.59291      -2.01602       2.01602       106.979       108.995    
  16  0.802517     -0.220002     -0.123446      0.123446       106.650       106.774    
  17  0.423872     -0.858323     -0.481614      0.481614       107.064       107.546    
  18  0.300971      -1.20074     -0.673748      0.673748       106.582       107.255    
  19  0.479556     -0.734895     -0.412357      0.412357       107.201       107.614    
  20  0.621838     -0.475076     -0.266570      0.266570       107.044       107.310    
  21  0.397654     -0.922172     -0.517440      0.517440       107.359       107.877    
  22  0.664976     -0.408004     -0.228935      0.228935       107.308       107.537    
  23  0.288358      -1.24355     -0.697769      0.697769       107.310       108.008    
  24  0.442017     -0.816406     -0.458094      0.458094       105.511       105.970    
  25  0.150763E-01  -4.19463      -2.35365       2.35365       108.345       110.699    
  26  0.600886     -0.509350     -0.285802      0.285802       108.292       108.578    
  27  0.162927      -1.81446      -1.01811       1.01811       108.593       109.611    
  28  0.932743     -0.696251E-01 -0.390674E-01  0.390674E-01   107.960       107.999    
  29  0.997186     -0.281799E-02 -0.158121E-02  0.158121E-02   108.464       108.465    
  30  0.418339     -0.871463     -0.488987      0.488987       109.588       110.077    
  31  0.694800     -0.364132     -0.204318      0.204318       109.148       109.352    
  32  0.852711     -0.159334     -0.894042E-01  0.894042E-01   108.870       108.960    
  33  0.624847     -0.470249     -0.263861      0.263861       109.837       110.101    
  34  0.427649     -0.849453     -0.476637      0.476637       110.306       110.783    
  35  0.149871      -1.89798      -1.06498       1.06498       110.272       111.337    
  36  0.563430     -0.573713     -0.321916      0.321916       108.613       108.935    
  37  0.860100     -0.150706     -0.845628E-01  0.845628E-01   110.113       110.198    
  38  0.867090E-01  -2.44520      -1.37203       1.37203       110.699       112.071    
  39  0.847848     -0.165054     -0.926133E-01  0.926133E-01   110.597       110.690    
  40  0.782599E-01  -2.54772      -1.42955       1.42955       110.495       111.925    
  41  0.697889E-01  -2.66228      -1.49383       1.49383       110.310       111.804    
  42  0.422765     -0.860939     -0.483082      0.483082       110.717       111.200    
  43  0.158365      -1.84286      -1.03405       1.03405       111.110       112.144    
  44  0.518935     -0.655976     -0.368075      0.368075       111.176       111.545    
  45  0.430406     -0.843027     -0.473031      0.473031       110.750       111.223    
  46  0.639805     -0.446592     -0.250588      0.250588       111.893       112.144    
loop,thermsimp(1:2)       61  0.229829      0.185144    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    324        110.94         67.96          1.09         42.63          0.24          0.05        111.98
Just calling func    0   0        111.98


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    110.94
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       61
neval is:      323
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       61      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       62
neval is:      323


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      323     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.985932     -0.141675E-01 -0.794951E-02  0.794951E-02   104.407       104.414    
   2  0.420912     -0.865330     -0.485546      0.485546       104.538       105.023    
   3  0.617210     -0.482545     -0.270761      0.270761       104.387       104.658    
   4  0.787846     -0.238453     -0.133799      0.133799       104.808       104.942    
   5  0.608770     -0.496315     -0.278488      0.278488       105.372       105.651    
   6  0.925975     -0.769083E-01 -0.431540E-01  0.431540E-01   105.511       105.555    
   7  0.545822     -0.605462     -0.339731      0.339731       105.487       105.827    
   8  0.240142      -1.42653     -0.800438      0.800438       105.987       106.788    
   9  0.800257     -0.222822     -0.125028      0.125028       104.294       104.419    
  10  0.250149      -1.38570     -0.777530      0.777530       106.255       107.033    
  11  0.814044     -0.205741     -0.115444      0.115444       106.650       106.766    
  12  0.897552     -0.108084     -0.606470E-01  0.606470E-01   105.672       105.733    
  13  0.807530     -0.213775     -0.119952      0.119952       106.582       106.702    
  14  0.369031     -0.996874     -0.559356      0.559356       106.444       107.004    
  15  0.892620     -0.113594     -0.637389E-01  0.637389E-01   107.044       107.107    
  16  0.992736     -0.729054E-02 -0.409080E-02  0.409080E-02   107.308       107.312    
  17  0.264259      -1.33083     -0.746741      0.746741       107.064       107.811    
  18  0.164586      -1.80432      -1.01242       1.01242       107.201       108.214    
  19  0.594739     -0.519633     -0.291571      0.291571       106.398       106.689    
  20  0.766319     -0.266156     -0.149343      0.149343       105.936       106.086    
  21  0.392663     -0.934804     -0.524528      0.524528       107.359       107.884    
  22  0.900399     -0.104917     -0.588702E-01  0.588702E-01   107.960       108.019    
  23  0.853164E-01  -2.46139      -1.38111       1.38111       107.310       108.691    
  24  0.753181     -0.283450     -0.159047      0.159047       106.050       106.209    
  25  0.801958     -0.220699     -0.123836      0.123836       108.464       108.588    
  26  0.840206     -0.174108     -0.976940E-01  0.976940E-01   108.292       108.390    
  27  0.899787     -0.105597     -0.592518E-01  0.592518E-01   108.613       108.672    
  28  0.555629     -0.587654     -0.329739      0.329739       108.870       109.200    
  29  0.117481E-01  -4.44406      -2.49361       2.49361       106.979       109.472    
  30  0.228476      -1.47632     -0.828380      0.828380       109.148       109.977    
  31  0.121877      -2.10474      -1.18099       1.18099       108.593       109.774    
  32  0.475375     -0.743652     -0.417271      0.417271       109.588       110.005    
  33  0.208734      -1.56669     -0.879088      0.879088       109.837       110.717    
  34  0.680231     -0.385322     -0.216208      0.216208       110.113       110.330    
  35  0.211647      -1.55284     -0.871313      0.871313       110.597       111.468    
  36  0.982763     -0.173870E-01 -0.975605E-02  0.975605E-02   108.345       108.355    
  37  0.819904     -0.198568     -0.111419      0.111419       110.306       110.418    
  38  0.282339      -1.26465     -0.709607      0.709607       110.717       111.426    
  39  0.391986     -0.936529     -0.525496      0.525496       110.750       111.276    
  40  0.218050      -1.52303     -0.854589      0.854589       110.272       111.127    
  41  0.236244      -1.44289     -0.809621      0.809621       111.176       111.986    
  42  0.544673     -0.607570     -0.340914      0.340914       110.310       110.651    
  43  0.721937     -0.325818     -0.182820      0.182820       110.495       110.678    
  44  0.649728     -0.431202     -0.241952      0.241952       110.699       110.941    
  45  0.641823     -0.443443     -0.248820      0.248820       111.893       112.142    
  46  0.597293     -0.515347     -0.289166      0.289166       110.937       111.226    
loop,thermsimp(1:2)       62  0.794951E-02  0.485546    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    325        111.17         67.84          1.12         42.46          0.20          0.05        111.67
Just calling func    0   0        111.67


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    111.17
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       62
neval is:      324
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       62      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       63
neval is:      324


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      324     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.984982     -0.151315E-01 -0.849044E-02  0.849044E-02   104.407       104.415    
   2  0.760415     -0.273890     -0.153683      0.153683       104.294       104.448    
   3  0.328612      -1.11288     -0.624446      0.624446       104.387       105.012    
   4  0.164880      -1.80254      -1.01142       1.01142       104.808       105.819    
   5  0.706606     -0.347282     -0.194863      0.194863       104.538       104.732    
   6  0.832070     -0.183839     -0.103154      0.103154       105.511       105.615    
   7  0.231505      -1.46315     -0.820990      0.820990       105.372       106.193    
   8  0.802671E-01  -2.52240      -1.41534       1.41534       105.672       107.087    
   9  0.116349      -2.15116      -1.20704       1.20704       105.487       106.694    
  10  0.874222     -0.134421     -0.754252E-01  0.754252E-01   105.936       106.012    
  11  0.729333     -0.315625     -0.177101      0.177101       106.050       106.227    
  12  0.301675      -1.19841     -0.672438      0.672438       106.398       107.070    
  13  0.496896     -0.699375     -0.392426      0.392426       106.582       106.974    
  14  0.692174     -0.367918     -0.206443      0.206443       106.650       106.857    
  15  0.717718     -0.331678     -0.186108      0.186108       105.987       106.173    
  16  0.867334E-01  -2.44492      -1.37187       1.37187       106.444       107.816    
  17  0.762934     -0.270584     -0.151827      0.151827       106.255       106.407    
  18  0.966741     -0.338246E-01 -0.189793E-01  0.189793E-01   107.044       107.063    
  19  0.375386     -0.979801     -0.549777      0.549777       107.308       107.858    
  20  0.878716     -0.129293     -0.725477E-01  0.725477E-01   107.064       107.137    
  21  0.238969      -1.43142     -0.803185      0.803185       107.359       108.162    
  22  0.939578     -0.623249E-01 -0.349711E-01  0.349711E-01   107.960       107.995    
  23  0.694828     -0.364091     -0.204295      0.204295       107.201       107.405    
  24  0.869149     -0.140241     -0.786904E-01  0.786904E-01   108.345       108.424    
  25  0.310010      -1.17115     -0.657145      0.657145       108.292       108.949    
  26  0.831753     -0.184219     -0.103367      0.103367       108.464       108.567    
  27  0.621050     -0.476344     -0.267281      0.267281       108.613       108.880    
  28  0.902274     -0.102837     -0.577031E-01  0.577031E-01   107.310       107.367    
  29  0.341345      -1.07486     -0.603117      0.603117       108.870       109.474    
  30  0.718647     -0.330385     -0.185382      0.185382       106.979       107.164    
  31  0.489532     -0.714305     -0.400804      0.400804       108.593       108.994    
  32  0.387793     -0.947282     -0.531530      0.531530       109.148       109.680    
  33  0.576785     -0.550285     -0.308771      0.308771       109.588       109.896    
  34  0.454048     -0.789552     -0.443026      0.443026       110.113       110.556    
  35  0.532728     -0.629744     -0.353356      0.353356       110.306       110.660    
  36  0.459832     -0.776895     -0.435924      0.435924       110.310       110.746    
  37  0.784910     -0.242187     -0.135893      0.135893       110.495       110.631    
  38  0.842297     -0.171622     -0.962989E-01  0.962989E-01   109.837       109.934    
  39  0.967556     -0.329823E-01 -0.185067E-01  0.185067E-01   110.699       110.718    
  40  0.126414      -2.06819      -1.16048       1.16048       110.272       111.433    
  41  0.407002     -0.898938     -0.504403      0.504403       110.937       111.441    
  42  0.903435     -0.101551     -0.569816E-01  0.569816E-01   110.750       110.807    
  43  0.430116     -0.843701     -0.473409      0.473409       110.717       111.190    
  44  0.675859     -0.391771     -0.219827      0.219827       110.597       110.817    
  45  0.444470     -0.810872     -0.454989      0.454989       111.176       111.631    
  46  0.728661     -0.316547     -0.177618      0.177618       111.175       111.352    
loop,thermsimp(1:2)       63  0.849044E-02  0.153683    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    326        111.48         67.87          1.10         42.13          0.38          0.05        111.54
Just calling func    0   0        111.54


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    111.48
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       63
neval is:      325
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       63      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       64
neval is:      325


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      325     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.964311     -0.363416E-01 -0.203917E-01  0.203917E-01   104.407       104.427    
   2  0.186231      -1.68077     -0.943095      0.943095       104.294       105.237    
   3  0.127308      -2.06115      -1.15653       1.15653       104.538       105.694    
   4  0.305661      -1.18528     -0.665073      0.665073       104.387       105.052    
   5  0.685804     -0.377164     -0.211630      0.211630       105.511       105.723    
   6  0.713250     -0.337923     -0.189612      0.189612       104.808       104.998    
   7  0.562604     -0.575180     -0.322739      0.322739       105.936       106.259    
   8  0.410540     -0.890283     -0.499547      0.499547       105.987       106.487    
   9  0.667633     -0.404017     -0.226698      0.226698       105.372       105.599    
  10  0.111237      -2.19609      -1.23225       1.23225       106.050       107.282    
  11  0.987129     -0.129550E-01 -0.726917E-02  0.726917E-02   106.255       106.262    
  12  0.525481     -0.643442     -0.361042      0.361042       105.487       105.848    
  13  0.740553     -0.300358     -0.168534      0.168534       106.650       106.819    
  14  0.456748E-01  -3.08621      -1.73170       1.73170       106.582       108.313    
  15  0.831796     -0.184168     -0.103339      0.103339       107.044       107.147    
  16  0.798422     -0.225118     -0.126316      0.126316       106.398       106.524    
  17  0.985535     -0.145708E-01 -0.817580E-02  0.817580E-02   105.672       105.680    
  18  0.323340      -1.12905     -0.633521      0.633521       107.064       107.697    
  19  0.745026     -0.294336     -0.165155      0.165155       106.979       107.144    
  20  0.711871     -0.339858     -0.190698      0.190698       107.310       107.500    
  21  0.232875      -1.45725     -0.817680      0.817680       107.201       108.019    
  22  0.118192      -2.13545      -1.19822       1.19822       106.444       107.642    
  23  0.310641      -1.16912     -0.656003      0.656003       107.308       107.964    
  24  0.220899      -1.51005     -0.847306      0.847306       107.960       108.807    
  25  0.487797     -0.717856     -0.402796      0.402796       107.359       107.762    
  26  0.278848      -1.27709     -0.716587      0.716587       108.345       109.062    
  27  0.159355      -1.83662      -1.03055       1.03055       108.464       109.494    
  28  0.473156     -0.748329     -0.419895      0.419895       108.613       109.033    
  29  0.358980      -1.02449     -0.574851      0.574851       108.292       108.867    
  30  0.873266     -0.135515     -0.760387E-01  0.760387E-01   108.593       108.669    
  31  0.168201      -1.78260      -1.00023       1.00023       108.870       109.871    
  32  0.492581     -0.708096     -0.397320      0.397320       109.148       109.545    
  33  0.878329     -0.129734     -0.727953E-01  0.727953E-01   109.588       109.660    
  34  0.266147      -1.32371     -0.742746      0.742746       109.837       110.580    
  35  0.510485     -0.672394     -0.377287      0.377287       110.113       110.491    
  36  0.810074     -0.210630     -0.118187      0.118187       110.495       110.614    
  37  0.950614     -0.506467E-01 -0.284184E-01  0.284184E-01   110.306       110.335    
  38  0.329006      -1.11168     -0.623775      0.623775       110.699       111.323    
  39  0.934893E-01  -2.36991      -1.32978       1.32978       110.310       111.640    
  40  0.686671     -0.375900     -0.210921      0.210921       110.750       110.961    
  41  0.888060     -0.118716     -0.666129E-01  0.666129E-01   110.597       110.664    
  42  0.749618     -0.288192     -0.161707      0.161707       110.717       110.878    
  43  0.433754     -0.835279     -0.468683      0.468683       111.175       111.643    
  44  0.630341     -0.461494     -0.258949      0.258949       110.272       110.531    
  45  0.569388     -0.563194     -0.316014      0.316014       110.937       111.253    
  46  0.965872     -0.347242E-01 -0.194841E-01  0.194841E-01   111.482       111.502    
loop,thermsimp(1:2)       64  0.203917E-01  0.943095    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    327        112.45         67.92          1.11         42.12          0.57          0.05        111.77
Just calling func    0   0        111.77


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    328        107.46         67.88          1.11         42.55          0.33          0.05        111.93
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    107.46
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       64
neval is:      327
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       64      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       65
neval is:      327


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      327     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.424550     -0.856726     -0.480718      0.480718       104.407       104.887    
   2  0.350039      -1.04971     -0.589003      0.589003       104.808       105.397    
   3  0.872911     -0.135921     -0.762668E-01  0.762668E-01   104.387       104.463    
   4  0.829005     -0.187529     -0.105224      0.105224       104.294       104.399    
   5  0.201827      -1.60035     -0.897971      0.897971       105.372       106.270    
   6  0.735791     -0.306809     -0.172154      0.172154       105.672       105.844    
   7  0.985788     -0.143135E-01 -0.803144E-02  0.803144E-02   104.538       104.546    
   8  0.962727     -0.379858E-01 -0.213142E-01  0.213142E-01   105.511       105.533    
   9  0.796954     -0.226958     -0.127349      0.127349       105.487       105.614    
  10  0.563149     -0.574211     -0.322196      0.322196       105.936       106.259    
  11  0.776846     -0.252513     -0.141688      0.141688       106.255       106.397    
  12  0.921010     -0.822839E-01 -0.461703E-01  0.461703E-01   105.987       106.034    
  13  0.884938     -0.122238     -0.685891E-01  0.685891E-01   106.398       106.466    
  14  0.850974     -0.161373     -0.905482E-01  0.905482E-01   106.650       106.741    
  15  0.391065     -0.938882     -0.526816      0.526816       106.979       107.506    
  16  0.150921      -1.89100      -1.06106       1.06106       107.044       108.105    
  17  0.295162      -1.22023     -0.684684      0.684684       106.050       106.734    
  18  0.662567     -0.411634     -0.230972      0.230972       107.310       107.541    
  19  0.893994     -0.112056     -0.628757E-01  0.628757E-01   106.444       106.507    
  20  0.103282      -2.27029      -1.27388       1.27388       107.064       108.338    
  21  0.416341     -0.876251     -0.491673      0.491673       107.359       107.851    
  22  0.986101E-01  -2.31658      -1.29986       1.29986       107.308       108.608    
  23  0.617817E-01  -2.78415      -1.56221       1.56221       107.201       108.763    
  24  0.371945     -0.989010     -0.554944      0.554944       106.582       107.137    
  25  0.884755     -0.122444     -0.687047E-01  0.687047E-01   108.593       108.662    
  26  0.584237     -0.537449     -0.301568      0.301568       107.960       108.262    
  27  0.239981      -1.42719     -0.800814      0.800814       108.292       109.093    
  28  0.106477      -2.23982      -1.25679       1.25679       108.613       109.869    
  29  0.142954      -1.94523      -1.09149       1.09149       108.345       109.437    
  30  0.802284     -0.220292     -0.123608      0.123608       108.464       108.588    
  31  0.373571     -0.984648     -0.552496      0.552496       109.148       109.701    
  32  0.617091     -0.482739     -0.270870      0.270870       109.588       109.859    
  33  0.813617     -0.206266     -0.115738      0.115738       108.870       108.986    
  34  0.219787E-01  -3.81768      -2.14214       2.14214       110.306       112.448    
  35  0.398995     -0.918807     -0.515552      0.515552       110.113       110.629    
  36  0.906985     -0.976296E-01 -0.547810E-01  0.547810E-01   110.272       110.327    
  37  0.259146E-01  -3.65295      -2.04971       2.04971       109.837       111.887    
  38  0.347543      -1.05687     -0.593019      0.593019       110.495       111.088    
  39  0.879549     -0.128346     -0.720161E-01  0.720161E-01   110.597       110.669    
  40  0.618015     -0.481242     -0.270030      0.270030       110.717       110.987    
  41  0.173348      -1.75246     -0.983321      0.983321       110.750       111.733    
  42  0.324418      -1.12572     -0.631654      0.631654       110.937       111.569    
  43  0.426503     -0.852135     -0.478142      0.478142       110.699       111.178    
  44  0.672650     -0.396530     -0.222497      0.222497       111.482       111.705    
  45  0.500711     -0.691727     -0.388135      0.388135       110.310       110.698    
  46  0.457446     -0.782097     -0.438842      0.438842       107.460       107.899    
loop,thermsimp(1:2)       65  0.480718      0.589003    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    329        105.00         67.86          1.12         42.16          0.61          0.05        111.80
Just calling func    0   0        111.80


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    105.00
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       65
neval is:      328
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       65      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       66
neval is:      328


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      328     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.474155     -0.746220     -0.418712      0.418712       104.294       104.713    
   2  0.162949E-01  -4.11691      -2.31004       2.31004       104.387       106.697    
   3  0.560104     -0.579632     -0.325238      0.325238       104.538       104.863    
   4  0.583629     -0.538490     -0.302152      0.302152       104.407       104.709    
   5  0.794243     -0.230366     -0.129261      0.129261       104.808       104.937    
   6  0.183626E-01  -3.99744      -2.24300       2.24300       105.511       107.754    
   7  0.642495     -0.442397     -0.248234      0.248234       105.487       105.735    
   8  0.611061E-02  -5.09773      -2.86039       2.86039       105.672       108.532    
   9  0.974115E-01  -2.32881      -1.30672       1.30672       105.987       107.294    
  10  0.817249E-01  -2.50440      -1.40524       1.40524       105.936       107.342    
  11  0.644422     -0.439401     -0.246552      0.246552       105.372       105.619    
  12  0.378181     -0.972383     -0.545614      0.545614       106.255       106.801    
  13  0.105422      -2.24978      -1.26238       1.26238       106.398       107.660    
  14  0.713647     -0.337367     -0.189300      0.189300       106.444       106.633    
  15  0.602100     -0.507333     -0.284670      0.284670       106.050       106.334    
  16  0.746624     -0.292194     -0.163953      0.163953       106.650       106.814    
  17  0.687673     -0.374442     -0.210103      0.210103       106.582       106.792    
  18  0.356323      -1.03192     -0.579020      0.579020       106.979       107.558    
  19  0.631203     -0.460128     -0.258183      0.258183       107.310       107.568    
  20  0.348432      -1.05431     -0.591586      0.591586       107.359       107.951    
  21  0.200848      -1.60521     -0.900698      0.900698       107.460       108.360    
  22  0.863860     -0.146345     -0.821155E-01  0.821155E-01   107.044       107.126    
  23  0.278415      -1.27864     -0.717459      0.717459       107.960       108.678    
  24  0.871038     -0.138069     -0.774722E-01  0.774722E-01   107.064       107.141    
  25  0.581010     -0.542987     -0.304675      0.304675       108.464       108.769    
  26  0.960519     -0.402815E-01 -0.226024E-01  0.226024E-01   107.308       107.330    
  27  0.104828      -2.25543      -1.26555       1.26555       108.593       109.859    
  28  0.907238     -0.973501E-01 -0.546242E-01  0.546242E-01   107.201       107.256    
  29  0.685005     -0.378330     -0.212285      0.212285       108.870       109.083    
  30  0.239566E-01  -3.73151      -2.09379       2.09379       108.292       110.386    
  31  0.643900     -0.440211     -0.247007      0.247007       108.345       108.592    
  32  0.526819     -0.640898     -0.359615      0.359615       109.148       109.508    
  33  0.463387     -0.769192     -0.431602      0.431602       109.588       110.019    
  34  0.847158E-01  -2.46845      -1.38507       1.38507       108.613       109.998    
  35  0.134368E-01  -4.30976      -2.41825       2.41825       110.272       112.690    
  36  0.141068      -1.95851      -1.09894       1.09894       110.113       111.212    
  37  0.239867      -1.42767     -0.801080      0.801080       110.597       111.398    
  38  0.317049      -1.14870     -0.644547      0.644547       110.310       110.955    
  39  0.925847     -0.770459E-01 -0.432313E-01  0.432313E-01   110.717       110.760    
  40  0.939258     -0.626649E-01 -0.351619E-01  0.351619E-01   110.495       110.530    
  41  0.111598      -2.19286      -1.23043       1.23043       110.699       111.930    
  42  0.357545      -1.02849     -0.577098      0.577098       110.937       111.514    
  43  0.902640     -0.102432     -0.574755E-01  0.574755E-01   111.482       111.540    
  44  0.914421     -0.894640E-01 -0.501992E-01  0.501992E-01   110.750       110.800    
  45  0.320420      -1.13812     -0.638611      0.638611       109.837       110.476    
  46  0.341333      -1.07490     -0.603136      0.603136       105.004       105.607    
loop,thermsimp(1:2)       66  0.418712       2.31004    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    330        105.86         67.99          1.11         42.14          0.23          0.05        111.52
Just calling func    0   0        111.53


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    105.86
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       66
neval is:      329
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       66      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       67
neval is:      329


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      329     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.711215     -0.340780     -0.191215      0.191215       104.407       104.598    
   2  0.492413     -0.708438     -0.397512      0.397512       104.294       104.692    
   3  0.156563      -1.85430      -1.04047       1.04047       104.538       105.578    
   4  0.185270      -1.68594     -0.946000      0.946000       104.808       105.754    
   5  0.685983     -0.376903     -0.211484      0.211484       105.004       105.216    
   6  0.518581     -0.656659     -0.368458      0.368458       105.372       105.741    
   7  0.430667     -0.842421     -0.472691      0.472691       105.487       105.960    
   8  0.748228     -0.290047     -0.162749      0.162749       106.050       106.212    
   9  0.348167      -1.05507     -0.592012      0.592012       106.444       107.036    
  10  0.281980E-01  -3.56850      -2.00232       2.00232       104.387       106.390    
  11  0.670749     -0.399360     -0.224085      0.224085       106.582       106.806    
  12  0.225031      -1.49152     -0.836906      0.836906       106.255       107.092    
  13  0.258016      -1.35474     -0.760156      0.760156       106.650       107.410    
  14  0.122388      -2.10056      -1.17864       1.17864       107.044       108.222    
  15  0.556210     -0.586609     -0.329152      0.329152       107.064       107.393    
  16  0.938933     -0.630108E-01 -0.353560E-01  0.353560E-01   107.201       107.237    
  17  0.440352     -0.820180     -0.460211      0.460211       105.987       106.448    
  18  0.779048     -0.249683     -0.140100      0.140100       107.308       107.448    
  19  0.929725     -0.728667E-01 -0.408862E-01  0.408862E-01   105.936       105.977    
  20  0.330740      -1.10642     -0.620826      0.620826       106.979       107.600    
  21  0.214890      -1.53763     -0.862779      0.862779       107.310       108.173    
  22  0.363221      -1.01274     -0.568261      0.568261       106.398       106.966    
  23  0.681309     -0.383740     -0.215320      0.215320       105.511       105.727    
  24  0.107313      -2.23200      -1.25240       1.25240       107.359       108.612    
  25  0.622524     -0.473973     -0.265951      0.265951       107.460       107.726    
  26  0.532378     -0.630402     -0.353725      0.353725       105.672       106.026    
  27  0.298562      -1.20878     -0.678258      0.678258       108.345       109.024    
  28  0.432099     -0.839100     -0.470828      0.470828       107.960       108.431    
  29  0.243978      -1.41068     -0.791546      0.791546       108.464       109.255    
  30  0.581243     -0.542587     -0.304451      0.304451       108.870       109.175    
  31  0.897127E-01  -2.41114      -1.35292       1.35292       109.148       110.501    
  32  0.738124     -0.303644     -0.170378      0.170378       108.593       108.763    
  33  0.462727     -0.770619     -0.432402      0.432402       108.613       109.045    
  34  0.984641E-01  -2.31806      -1.30069       1.30069       109.588       110.888    
  35  0.641923     -0.443287     -0.248733      0.248733       108.292       108.541    
  36  0.334628      -1.09474     -0.614268      0.614268       109.837       110.452    
  37  0.482851     -0.728048     -0.408515      0.408515       110.495       110.904    
  38  0.826279     -0.190822     -0.107072      0.107072       110.717       110.824    
  39  0.966417     -0.341596E-01 -0.191673E-01  0.191673E-01   110.750       110.769    
  40  0.236833      -1.44040     -0.808224      0.808224       110.310       111.118    
  41  0.274744      -1.29192     -0.724907      0.724907       110.113       110.838    
  42  0.310307      -1.17019     -0.656607      0.656607       110.597       111.254    
  43  0.697298     -0.360543     -0.202304      0.202304       110.937       111.139    
  44  0.239072      -1.43099     -0.802944      0.802944       111.482       112.285    
  45  0.809729     -0.211055     -0.118425      0.118425       110.699       110.818    
  46  0.651880     -0.427895     -0.240096      0.240096       105.856       106.096    
loop,thermsimp(1:2)       67  0.191215      0.397512    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    331        112.45         67.83          1.10         42.18          0.32          0.05        111.47
Just calling func    0   0        111.47


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    332        109.46         67.92          1.12         42.39          0.23          0.05        111.72
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    109.46
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       67
neval is:      331
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       67      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       68
neval is:      331


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      331     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.595062     -0.519089     -0.291266      0.291266       104.407       104.698    
   2  0.204294      -1.58819     -0.891152      0.891152       104.294       105.185    
   3  0.902141     -0.102985     -0.577857E-01  0.577857E-01   105.004       105.062    
   4  0.317306      -1.14789     -0.644093      0.644093       104.538       105.182    
   5  0.914914E-01  -2.39151      -1.34190       1.34190       105.511       106.853    
   6  0.362439      -1.01490     -0.569470      0.569470       105.372       105.942    
   7  0.284546      -1.25686     -0.705236      0.705236       104.808       105.513    
   8  0.752727     -0.284053     -0.159385      0.159385       105.487       105.646    
   9  0.972148     -0.282475E-01 -0.158499E-01  0.158499E-01   105.936       105.952    
  10  0.312417      -1.16342     -0.652804      0.652804       105.672       106.325    
  11  0.772549E-01  -2.56064      -1.43680       1.43680       105.856       107.293    
  12  0.190763      -1.65672     -0.929605      0.929605       106.050       106.979    
  13  0.829036     -0.187492     -0.105204      0.105204       104.387       104.492    
  14  0.309766      -1.17194     -0.657587      0.657587       105.987       106.645    
  15  0.691616     -0.368724     -0.206895      0.206895       106.582       106.788    
  16  0.177510      -1.72873     -0.970008      0.970008       106.398       107.368    
  17  0.848561     -0.164214     -0.921420E-01  0.921420E-01   106.444       106.536    
  18  0.464945     -0.765836     -0.429718      0.429718       106.255       106.685    
  19  0.626682     -0.467316     -0.262216      0.262216       107.201       107.463    
  20  0.451266     -0.795699     -0.446475      0.446475       107.064       107.510    
  21  0.161179E-01  -4.12783      -2.31617       2.31617       106.650       108.966    
  22  0.848853     -0.163869     -0.919488E-01  0.919488E-01   107.308       107.400    
  23  0.565946     -0.569256     -0.319416      0.319416       106.979       107.298    
  24  0.798567     -0.224937     -0.126214      0.126214       107.460       107.586    
  25  0.282371      -1.26453     -0.709543      0.709543       107.310       108.019    
  26  0.887219     -0.119663     -0.671444E-01  0.671444E-01   107.044       107.111    
  27  0.311981      -1.16481     -0.653588      0.653588       107.960       108.614    
  28  0.454937     -0.787596     -0.441928      0.441928       108.292       108.734    
  29  0.200774E-01  -3.90816      -2.19291       2.19291       107.359       109.552    
  30  0.549692     -0.598397     -0.335766      0.335766       108.593       108.929    
  31  0.928164     -0.745470E-01 -0.418291E-01  0.418291E-01   108.345       108.387    
  32  0.876026     -0.132360     -0.742684E-01  0.742684E-01   108.613       108.687    
  33  0.360538      -1.02016     -0.572421      0.572421       108.870       109.443    
  34  0.810484     -0.210124     -0.117903      0.117903       108.464       108.582    
  35  0.350387      -1.04872     -0.588446      0.588446       109.837       110.426    
  36  0.609257     -0.495514     -0.278038      0.278038       109.148       109.426    
  37  0.847473     -0.165497     -0.928618E-01  0.928618E-01   110.750       110.843    
  38  0.459433     -0.777763     -0.436411      0.436411       110.699       111.136    
  39  0.213778      -1.54282     -0.865692      0.865692       110.717       111.582    
  40  0.983077     -0.170677E-01 -0.957684E-02  0.957684E-02   110.113       110.123    
  41  0.719533     -0.329153     -0.184691      0.184691       109.588       109.772    
  42  0.317292      -1.14793     -0.644118      0.644118       110.495       111.139    
  43  0.300670      -1.20174     -0.674310      0.674310       110.310       110.984    
  44  0.486388     -0.720748     -0.404419      0.404419       110.937       111.341    
  45  0.309580      -1.17254     -0.657923      0.657923       110.597       111.255    
  46  0.111802      -2.19103      -1.22941       1.22941       109.462       110.691    
loop,thermsimp(1:2)       68  0.291266      0.891152    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    333        111.65         67.93          1.12         42.10          0.39          0.05        111.59
Just calling func    0   0        111.59


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    111.65
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       68
neval is:      332
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       68      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       69
neval is:      332


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      332     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.440626     -0.819560     -0.459863      0.459863       104.387       104.847    
   2  0.752309     -0.284608     -0.159696      0.159696       104.407       104.566    
   3  0.209108      -1.56490     -0.878084      0.878084       105.004       105.882    
   4  0.842922     -0.170881     -0.958833E-01  0.958833E-01   104.538       104.634    
   5  0.161148      -1.82543      -1.02427       1.02427       104.294       105.318    
   6  0.601748     -0.507917     -0.284998      0.284998       104.808       105.093    
   7  0.890912     -0.115510     -0.648138E-01  0.648138E-01   105.487       105.552    
   8  0.631939     -0.458963     -0.257529      0.257529       105.372       105.630    
   9  0.144759E-01  -4.23527      -2.37645       2.37645       105.936       108.313    
  10  0.653698     -0.425110     -0.238534      0.238534       105.672       105.911    
  11  0.401463     -0.912639     -0.512091      0.512091       106.444       106.956    
  12  0.906126     -0.985765E-01 -0.553123E-01  0.553123E-01   105.987       106.043    
  13  0.480601E-01  -3.03530      -1.70314       1.70314       106.255       107.958    
  14  0.264260      -1.33082     -0.746737      0.746737       106.582       107.328    
  15  0.586033     -0.534379     -0.299846      0.299846       105.511       105.811    
  16  0.323072      -1.12988     -0.633987      0.633987       106.050       106.684    
  17  0.785147     -0.241884     -0.135723      0.135723       107.044       107.179    
  18  0.139165      -1.97210      -1.10656       1.10656       105.856       106.963    
  19  0.105818E-01  -4.54862      -2.55228       2.55228       106.979       109.531    
  20  0.896943     -0.108763     -0.610283E-01  0.610283E-01   106.398       106.459    
  21  0.854239     -0.157544     -0.883994E-01  0.883994E-01   107.308       107.396    
  22  0.566003     -0.569157     -0.319360      0.319360       107.201       107.521    
  23  0.566387     -0.568477     -0.318978      0.318978       107.064       107.383    
  24  0.414905     -0.879707     -0.493613      0.493613       107.460       107.953    
  25  0.173772      -1.75001     -0.981951      0.981951       107.310       108.292    
  26  0.884308E-01  -2.42554      -1.36099       1.36099       108.345       109.706    
  27  0.417457     -0.873573     -0.490171      0.490171       108.464       108.954    
  28  0.334615      -1.09477     -0.614289      0.614289       107.960       108.574    
  29  0.706024E-01  -2.65069      -1.48733       1.48733       108.613       110.100    
  30  0.996422     -0.358418E-02 -0.201112E-02  0.201112E-02   108.292       108.294    
  31  0.894500     -0.111491     -0.625586E-01  0.625586E-01   108.593       108.656    
  32  0.827855     -0.188917     -0.106003      0.106003       106.650       106.756    
  33  0.434964     -0.832492     -0.467120      0.467120       109.148       109.615    
  34  0.121450      -2.10825      -1.18296       1.18296       108.870       110.053    
  35  0.498977     -0.695195     -0.390081      0.390081       107.359       107.749    
  36  0.117961      -2.13740      -1.19932       1.19932       109.588       110.787    
  37  0.309211      -1.17373     -0.658592      0.658592       110.113       110.772    
  38  0.786265     -0.240461     -0.134925      0.134925       109.837       109.972    
  39  0.614330     -0.487222     -0.273385      0.273385       109.462       109.735    
  40  0.820857     -0.197407     -0.110767      0.110767       110.750       110.861    
  41  0.670448     -0.399809     -0.224337      0.224337       110.310       110.534    
  42  0.742403     -0.297863     -0.167134      0.167134       110.699       110.867    
  43  0.760912E-01  -2.57582      -1.44532       1.44532       110.495       111.941    
  44  0.709677     -0.342945     -0.192430      0.192430       110.597       110.790    
  45  0.943449     -0.582133E-01 -0.326641E-01  0.326641E-01   110.937       110.970    
  46  0.176370      -1.73517     -0.973624      0.973624       111.652       112.625    
loop,thermsimp(1:2)       69  0.459863      0.159696    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    334        110.72         67.82          1.10         42.00          0.50          0.05        111.46
Just calling func    0   0        111.46


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    110.72
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       69
neval is:      333
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       69      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       70
neval is:      333


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      333     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.988390     -0.116781E-01 -0.655272E-02  0.655272E-02   104.407       104.413    
   2  0.482301     -0.729186     -0.409154      0.409154       104.538       104.947    
   3  0.546964     -0.603372     -0.338558      0.338558       104.387       104.726    
   4  0.543918     -0.608957     -0.341692      0.341692       104.808       105.150    
   5  0.427641     -0.849472     -0.476647      0.476647       104.294       104.771    
   6  0.498345     -0.696462     -0.390792      0.390792       105.487       105.878    
   7  0.989308     -0.107494E-01 -0.603158E-02  0.603158E-02   105.372       105.378    
   8  0.658822     -0.417302     -0.234152      0.234152       105.511       105.746    
   9  0.917808     -0.857673E-01 -0.481249E-01  0.481249E-01   105.004       105.052    
  10  0.914490E-04  -9.29973      -5.21817       5.21817       105.672       110.890    
  11  0.989901     -0.101499E-01 -0.569521E-02  0.569521E-02   105.987       105.993    
  12  0.558183     -0.583069     -0.327166      0.327166       106.398       106.725    
  13  0.706994     -0.346733     -0.194556      0.194556       106.050       106.244    
  14  0.599152     -0.512240     -0.287423      0.287423       106.650       106.938    
  15  0.845909     -0.167343     -0.938979E-01  0.938979E-01   106.444       106.538    
  16  0.655384     -0.422534     -0.237088      0.237088       105.856       106.093    
  17  0.412232E-01  -3.18875      -1.78924       1.78924       107.044       108.833    
  18  0.495401     -0.702387     -0.394117      0.394117       106.582       106.976    
  19  0.378829     -0.970671     -0.544653      0.544653       107.064       107.609    
  20  0.653665E-02  -5.03033      -2.82257       2.82257       107.308       110.130    
  21  0.782670     -0.245045     -0.137497      0.137497       107.201       107.339    
  22  0.945547     -0.559921E-01 -0.314178E-01  0.314178E-01   107.359       107.391    
  23  0.969857     -0.306063E-01 -0.171735E-01  0.171735E-01   107.460       107.477    
  24  0.822249     -0.195712     -0.109816      0.109816       106.255       106.365    
  25  0.265012E-01  -3.63056      -2.03715       2.03715       107.310       109.347    
  26  0.360432E-01  -3.32304      -1.86459       1.86459       108.292       110.157    
  27  0.796418     -0.227631     -0.127726      0.127726       105.936       106.064    
  28  0.292313E-01  -3.53252      -1.98213       1.98213       107.960       109.942    
  29  0.227321      -1.48139     -0.831225      0.831225       108.593       109.424    
  30  0.812637     -0.207471     -0.116414      0.116414       108.464       108.580    
  31  0.930544     -0.719857E-01 -0.403919E-01  0.403919E-01   106.979       107.019    
  32  0.674873     -0.393231     -0.220646      0.220646       109.148       109.369    
  33  0.264030      -1.33169     -0.747226      0.747226       108.345       109.093    
  34  0.807464     -0.213856     -0.119997      0.119997       109.462       109.582    
  35  0.653731     -0.425060     -0.238506      0.238506       109.837       110.076    
  36  0.858536     -0.152527     -0.855844E-01  0.855844E-01   108.870       108.956    
  37  0.538887     -0.618250     -0.346906      0.346906       108.613       108.960    
  38  0.468049     -0.759182     -0.425985      0.425985       110.310       110.736    
  39  0.401324     -0.912987     -0.512286      0.512286       110.113       110.626    
  40  0.363356      -1.01237     -0.568053      0.568053       109.588       110.156    
  41  0.924933     -0.780342E-01 -0.437858E-01  0.437858E-01   110.597       110.641    
  42  0.797289     -0.226538     -0.127113      0.127113       110.750       110.877    
  43  0.200097      -1.60895     -0.902799      0.902799       110.699       111.602    
  44  0.686219     -0.376559     -0.211291      0.211291       110.937       111.148    
  45  0.895629     -0.110230     -0.618509E-01  0.618509E-01   110.495       110.557    
  46  0.331830      -1.10313     -0.618978      0.618978       110.717       111.336    
loop,thermsimp(1:2)       70  0.655272E-02  0.409154    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    335        105.18         67.94          1.09         42.16          0.39          0.05        111.63
Just calling func    0   0        111.64


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    105.18
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       70
neval is:      334
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       70      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       71
neval is:      334


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      334     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.860213     -0.150575     -0.844894E-01  0.844894E-01   104.407       104.491    
   2  0.573661     -0.555717     -0.311818      0.311818       104.387       104.699    
   3  0.499290     -0.694569     -0.389730      0.389730       104.294       104.684    
   4  0.677563     -0.389253     -0.218414      0.218414       104.538       104.756    
   5  0.476566     -0.741149     -0.415866      0.415866       105.004       105.420    
   6  0.153036      -1.87708      -1.05325       1.05325       104.808       105.861    
   7  0.626270     -0.467973     -0.262585      0.262585       105.372       105.635    
   8  0.794744     -0.229735     -0.128907      0.128907       105.511       105.640    
   9  0.111868E-01  -4.49302      -2.52108       2.52108       105.487       108.008    
  10  0.643880     -0.440243     -0.247025      0.247025       105.987       106.234    
  11  0.634705     -0.454595     -0.255078      0.255078       105.936       106.191    
  12  0.653568     -0.425308     -0.238645      0.238645       105.856       106.095    
  13  0.888231     -0.118524     -0.665050E-01  0.665050E-01   106.050       106.116    
  14  0.681775E-01  -2.68564      -1.50694       1.50694       106.255       107.762    
  15  0.241248      -1.42193     -0.797860      0.797860       106.444       107.242    
  16  0.208857      -1.56610     -0.878757      0.878757       106.398       107.276    
  17  0.652439     -0.427038     -0.239615      0.239615       106.650       106.890    
  18  0.489833     -0.713691     -0.400459      0.400459       106.582       106.982    
  19  0.719225     -0.329581     -0.184931      0.184931       106.979       107.164    
  20  0.924762     -0.782189E-01 -0.438894E-01  0.438894E-01   107.201       107.245    
  21  0.845502     -0.167825     -0.941683E-01  0.941683E-01   107.359       107.453    
  22  0.665989     -0.406482     -0.228081      0.228081       107.460       107.688    
  23  0.378562     -0.971376     -0.545049      0.545049       107.064       107.609    
  24  0.396889     -0.924098     -0.518521      0.518521       108.464       108.982    
  25  0.158089      -1.84460      -1.03502       1.03502       107.044       108.079    
  26  0.590577     -0.526655     -0.295512      0.295512       108.870       109.166    
  27  0.949513     -0.518061E-01 -0.290689E-01  0.290689E-01   108.613       108.642    
  28  0.518198     -0.657398     -0.368873      0.368873       108.345       108.714    
  29  0.551080     -0.595875     -0.334351      0.334351       107.310       107.644    
  30  0.986285     -0.138097E-01 -0.774879E-02  0.774879E-02   109.148       109.156    
  31  0.920142     -0.832276E-01 -0.466999E-01  0.466999E-01   108.593       108.640    
  32  0.133201      -2.01590      -1.13114       1.13114       109.462       110.593    
  33  0.584507     -0.536987     -0.301309      0.301309       107.960       108.261    
  34  0.790583     -0.234984     -0.131852      0.131852       109.837       109.969    
  35  0.702664     -0.352876     -0.198002      0.198002       107.308       107.506    
  36  0.148885      -1.90458      -1.06868       1.06868       109.588       110.656    
  37  0.290436      -1.23637     -0.693741      0.693741       108.292       108.986    
  38  0.638249     -0.449027     -0.251954      0.251954       110.495       110.747    
  39  0.381605     -0.963369     -0.540556      0.540556       110.113       110.654    
  40  0.823069     -0.194716     -0.109257      0.109257       110.597       110.706    
  41  0.492318     -0.708630     -0.397619      0.397619       110.310       110.708    
  42  0.773199     -0.257218     -0.144328      0.144328       110.750       110.894    
  43  0.289475E-01  -3.54227      -1.98760       1.98760       105.672       107.660    
  44  0.355683      -1.03371     -0.580028      0.580028       110.937       111.517    
  45  0.160396      -1.83011      -1.02689       1.02689       110.717       111.743    
  46  0.972861     -0.275140E-01 -0.154384E-01  0.154384E-01   105.182       105.198    
loop,thermsimp(1:2)       71  0.844894E-01  0.311818    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    336        111.41         67.94          1.11         42.25          0.33          0.05        111.67
Just calling func    0   0        111.67


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    111.41
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       71
neval is:      335
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       71      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       72
neval is:      335


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      335     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.440770     -0.819232     -0.459680      0.459680       104.407       104.866    
   2  0.202294      -1.59803     -0.896672      0.896672       104.294       105.191    
   3  0.873786     -0.134920     -0.757052E-01  0.757052E-01   104.387       104.463    
   4  0.262141      -1.33887     -0.751256      0.751256       104.538       105.289    
   5  0.342005      -1.07293     -0.602031      0.602031       105.182       105.784    
   6  0.421217     -0.864607     -0.485140      0.485140       105.004       105.489    
   7  0.618489     -0.480477     -0.269600      0.269600       105.372       105.642    
   8  0.412552     -0.885393     -0.496803      0.496803       105.511       106.008    
   9  0.951192     -0.500396E-01 -0.280777E-01  0.280777E-01   104.808       104.836    
  10  0.298546      -1.20883     -0.678289      0.678289       105.856       106.534    
  11  0.805120     -0.216763     -0.121628      0.121628       106.050       106.171    
  12  0.208146      -1.56951     -0.880670      0.880670       105.936       106.817    
  13  0.924021     -0.790209E-01 -0.443395E-01  0.443395E-01   105.987       106.032    
  14  0.447624     -0.803802     -0.451022      0.451022       106.650       107.101    
  15  0.667709     -0.403903     -0.226634      0.226634       106.582       106.808    
  16  0.767295E-01  -2.56747      -1.44063       1.44063       106.979       108.419    
  17  0.301582      -1.19871     -0.672610      0.672610       106.444       107.117    
  18  0.788580     -0.237522     -0.133276      0.133276       107.201       107.334    
  19  0.887020     -0.119888     -0.672702E-01  0.672702E-01   106.398       106.465    
  20  0.233035E-01  -3.75915      -2.10930       2.10930       107.359       109.469    
  21  0.899320     -0.106116     -0.595431E-01  0.595431E-01   107.308       107.367    
  22  0.144480      -1.93461      -1.08553       1.08553       107.064       108.150    
  23  0.274629      -1.29233     -0.725142      0.725142       107.310       108.035    
  24  0.831597     -0.184407     -0.103473      0.103473       105.672       105.776    
  25  0.388827     -0.944620     -0.530036      0.530036       107.460       107.990    
  26  0.257578      -1.35643     -0.761109      0.761109       106.255       107.016    
  27  0.427791     -0.849120     -0.476450      0.476450       105.487       105.964    
  28  0.837664E-01  -2.47972      -1.39140       1.39140       107.044       108.435    
  29  0.782727     -0.244972     -0.137456      0.137456       107.960       108.098    
  30  0.259676E-01  -3.65091      -2.04856       2.04856       108.593       110.642    
  31  0.166181      -1.79468      -1.00701       1.00701       108.613       109.620    
  32  0.360749      -1.01957     -0.572093      0.572093       108.345       108.918    
  33  0.369697     -0.995071     -0.558345      0.558345       108.464       109.022    
  34  0.959392     -0.414553E-01 -0.232610E-01  0.232610E-01   108.292       108.315    
  35  0.449170     -0.800353     -0.449087      0.449087       109.148       109.597    
  36  0.655790E-02  -5.02708      -2.82075       2.82075       108.870       111.691    
  37  0.133569      -2.01313      -1.12959       1.12959       109.837       110.967    
  38  0.282061      -1.26563     -0.710159      0.710159       109.462       110.172    
  39  0.431813     -0.839762     -0.471199      0.471199       110.113       110.585    
  40  0.713174     -0.338031     -0.189672      0.189672       109.588       109.777    
  41  0.511305     -0.670790     -0.376387      0.376387       110.597       110.973    
  42  0.264485      -1.32997     -0.746261      0.746261       110.310       111.056    
  43  0.779298     -0.249362     -0.139920      0.139920       110.495       110.635    
  44  0.709352E-02  -4.94857      -2.77670       2.77670       110.750       113.527    
  45  0.770402     -0.260843     -0.146361      0.146361       110.937       111.083    
  46  0.694393     -0.364718     -0.204647      0.204647       111.411       111.615    
loop,thermsimp(1:2)       72  0.459680      0.896672    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    337        105.87         67.98          1.12         42.21          0.33          0.05        111.69
Just calling func    0   0        111.69


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    105.87
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       72
neval is:      336
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       72      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       73
neval is:      336


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      336     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.807892     -0.213326     -0.119700      0.119700       104.387       104.507    
   2  0.554495     -0.589697     -0.330885      0.330885       104.808       105.139    
   3  0.997056     -0.294851E-02 -0.165444E-02  0.165444E-02   104.407       104.408    
   4  0.901183E-01  -2.40663      -1.35039       1.35039       104.294       105.645    
   5  0.296736      -1.21491     -0.681701      0.681701       104.538       105.219    
   6  0.907820     -0.967094E-01 -0.542646E-01  0.542646E-01   105.004       105.058    
   7  0.325542      -1.12226     -0.629713      0.629713       105.372       106.002    
   8  0.947537     -0.538896E-01 -0.302380E-01  0.302380E-01   105.672       105.702    
   9  0.378276     -0.972130     -0.545472      0.545472       105.182       105.728    
  10  0.985613     -0.144920E-01 -0.813158E-02  0.813158E-02   105.487       105.495    
  11  0.167434      -1.78717      -1.00280       1.00280       105.511       106.514    
  12  0.693849E-01  -2.66809      -1.49709       1.49709       105.987       107.484    
  13  0.434983     -0.832447     -0.467095      0.467095       106.050       106.517    
  14  0.998656     -0.134491E-02 -0.754643E-03  0.754643E-03   106.398       106.398    
  15  0.650302     -0.430318     -0.241456      0.241456       105.856       106.098    
  16  0.152610      -1.87987      -1.05481       1.05481       106.582       107.636    
  17  0.273947      -1.29482     -0.726537      0.726537       105.936       106.663    
  18  0.990471     -0.957469E-02 -0.537246E-02  0.537246E-02   106.255       106.261    
  19  0.684493     -0.379077     -0.212704      0.212704       106.650       106.863    
  20  0.864467E-01  -2.44823      -1.37373       1.37373       106.444       107.818    
  21  0.546085     -0.604980     -0.339461      0.339461       107.201       107.541    
  22  0.246642      -1.39982     -0.785451      0.785451       107.308       108.093    
  23  0.484505     -0.724627     -0.406596      0.406596       107.460       107.866    
  24  0.567359     -0.566763     -0.318016      0.318016       107.310       107.628    
  25  0.564371     -0.572043     -0.320979      0.320979       107.960       108.281    
  26  0.825604     -0.191640     -0.107531      0.107531       107.064       107.172    
  27  0.302493      -1.19570     -0.670919      0.670919       108.292       108.963    
  28  0.630396     -0.461407     -0.258900      0.258900       106.979       107.238    
  29  0.886734     -0.120210     -0.674513E-01  0.674513E-01   107.044       107.111    
  30  0.389345     -0.943288     -0.529289      0.529289       108.345       108.875    
  31  0.181391      -1.70710     -0.957872      0.957872       108.464       109.422    
  32  0.933221     -0.691132E-01 -0.387801E-01  0.387801E-01   107.359       107.398    
  33  0.169237E-01  -4.07904      -2.28879       2.28879       109.148       111.437    
  34  0.757788     -0.277351     -0.155625      0.155625       108.613       108.768    
  35  0.300993E-01  -3.50325      -1.96571       1.96571       109.588       111.553    
  36  0.395621     -0.927300     -0.520317      0.520317       109.462       109.982    
  37  0.459505     -0.777605     -0.436322      0.436322       110.113       110.550    
  38  0.733176     -0.310370     -0.174152      0.174152       110.495       110.669    
  39  0.575459     -0.552587     -0.310062      0.310062       108.593       108.903    
  40  0.560889     -0.578233     -0.324452      0.324452       109.837       110.162    
  41  0.428351     -0.847812     -0.475716      0.475716       110.597       111.073    
  42  0.553832     -0.590895     -0.331557      0.331557       110.310       110.642    
  43  0.581118     -0.542801     -0.304571      0.304571       110.937       111.242    
  44  0.319195E-01  -3.44454      -1.93277       1.93277       111.411       113.343    
  45  0.224512E-01  -3.79641      -2.13021       2.13021       108.870       111.001    
  46  0.113637E-01  -4.47733      -2.51228       2.51228       105.870       108.382    
loop,thermsimp(1:2)       73  0.119700      0.330885    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    338        110.56         67.89          1.13         42.65          0.55          0.05        112.27
Just calling func    0   0        112.27


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    110.56
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       73
neval is:      337
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       73      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       74
neval is:      337


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      337     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.889684     -0.116889     -0.655877E-01  0.655877E-01   104.407       104.472    
   2  0.480213     -0.733525     -0.411589      0.411589       104.387       104.799    
   3  0.226156      -1.48653     -0.834108      0.834108       105.004       105.838    
   4  0.633402     -0.456651     -0.256231      0.256231       104.808       105.064    
   5  0.925311     -0.776258E-01 -0.435566E-01  0.435566E-01   104.538       104.581    
   6  0.498405     -0.696343     -0.390725      0.390725       105.487       105.878    
   7  0.133283      -2.01528      -1.13079       1.13079       104.294       105.425    
   8  0.657074E-01  -2.72254      -1.52765       1.52765       105.672       107.200    
   9  0.726758     -0.319162     -0.179085      0.179085       105.182       105.361    
  10  0.398365     -0.920388     -0.516439      0.516439       105.372       105.889    
  11  0.321047E-01  -3.43875      -1.92952       1.92952       105.856       107.786    
  12  0.276307      -1.28624     -0.721724      0.721724       106.255       106.977    
  13  0.483740     -0.726208     -0.407483      0.407483       106.398       106.805    
  14  0.224589      -1.49348     -0.838008      0.838008       105.511       106.349    
  15  0.832041     -0.183874     -0.103173      0.103173       106.050       106.153    
  16  0.939301     -0.626192E-01 -0.351363E-01  0.351363E-01   105.936       105.971    
  17  0.624052     -0.471522     -0.264576      0.264576       106.650       106.915    
  18  0.172753      -1.75589     -0.985251      0.985251       107.044       108.029    
  19  0.468323     -0.758597     -0.425656      0.425656       107.064       107.490    
  20  0.963461     -0.372229E-01 -0.208861E-01  0.208861E-01   106.979       107.000    
  21  0.812092     -0.208142     -0.116791      0.116791       107.359       107.476    
  22  0.376764     -0.976137     -0.547721      0.547721       105.987       106.535    
  23  0.791872E-01  -2.53594      -1.42294       1.42294       107.201       108.624    
  24  0.237003      -1.43968     -0.807821      0.807821       107.310       108.118    
  25  0.320094      -1.13914     -0.639183      0.639183       106.582       107.221    
  26  0.821410E-01  -2.49932      -1.40239       1.40239       106.444       107.847    
  27  0.789147     -0.236802     -0.132872      0.132872       107.460       107.593    
  28  0.734353E-01  -2.61135      -1.46526       1.46526       107.308       108.773    
  29  0.226401      -1.48545     -0.833500      0.833500       107.960       108.794    
  30  0.380831     -0.965399     -0.541695      0.541695       105.870       106.411    
  31  0.264857      -1.32857     -0.745472      0.745472       108.613       109.358    
  32  0.246167      -1.40174     -0.786533      0.786533       108.345       109.132    
  33  0.142133      -1.95099      -1.09472       1.09472       108.593       109.688    
  34  0.123438E-01  -4.39460      -2.46586       2.46586       108.292       110.758    
  35  0.853289     -0.158657     -0.890239E-01  0.890239E-01   108.464       108.553    
  36  0.418603     -0.870831     -0.488633      0.488633       109.462       109.950    
  37  0.235242      -1.44714     -0.812006      0.812006       109.837       110.649    
  38  0.841712     -0.172317     -0.966888E-01  0.966888E-01   110.113       110.210    
  39  0.113373      -2.17707      -1.22158       1.22158       110.310       111.532    
  40  0.617966     -0.481322     -0.270075      0.270075       110.495       110.765    
  41  0.149268      -1.90202      -1.06724       1.06724       108.870       109.938    
  42  0.811010     -0.209475     -0.117539      0.117539       110.597       110.715    
  43  0.571477     -0.559531     -0.313959      0.313959       110.937       111.251    
  44  0.105494      -2.24911      -1.26200       1.26200       109.148       110.410    
  45  0.709548     -0.343127     -0.192532      0.192532       109.588       109.780    
  46  0.535895     -0.623816     -0.350030      0.350030       110.556       110.906    
loop,thermsimp(1:2)       74  0.655877E-01  0.411589    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    339        106.38         67.92          1.08         42.14          0.57          0.05        111.76
Just calling func    0   0        111.76


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    106.38
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       74
neval is:      338
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       74      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       75
neval is:      338


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      338     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.645801     -0.437264     -0.245353      0.245353       104.407       104.652    
   2  0.108032      -2.22533      -1.24865       1.24865       104.538       105.786    
   3  0.908790     -0.956413E-01 -0.536653E-01  0.536653E-01   104.387       104.441    
   4  0.987883     -0.121914E-01 -0.684070E-02  0.684070E-02   104.808       104.815    
   5  0.318380      -1.14451     -0.642196      0.642196       105.182       105.825    
   6  0.924426     -0.785824E-01 -0.440934E-01  0.440934E-01   104.294       104.338    
   7  0.965220     -0.353996E-01 -0.198631E-01  0.198631E-01   105.004       105.024    
   8  0.852248     -0.159878     -0.897093E-01  0.897093E-01   105.487       105.577    
   9  0.329186      -1.11113     -0.623468      0.623468       105.372       105.996    
  10  0.282479      -1.26415     -0.709329      0.709329       105.936       106.646    
  11  0.818943     -0.199740     -0.112076      0.112076       106.050       106.162    
  12  0.842569     -0.171300     -0.961180E-01  0.961180E-01   105.511       105.608    
  13  0.370966     -0.991644     -0.556422      0.556422       105.870       106.426    
  14  0.362233      -1.01547     -0.569789      0.569789       105.987       106.557    
  15  0.356944E-01  -3.33276      -1.87005       1.87005       106.398       108.268    
  16  0.149119      -1.90301      -1.06780       1.06780       106.650       107.718    
  17  0.127170      -2.06223      -1.15714       1.15714       106.255       107.412    
  18  0.589256     -0.528895     -0.296768      0.296768       106.979       107.276    
  19  0.702139     -0.353624     -0.198422      0.198422       105.672       105.871    
  20  0.713819     -0.337127     -0.189165      0.189165       106.582       106.771    
  21  0.121783      -2.10552      -1.18143       1.18143       107.359       108.541    
  22  0.992321     -0.770837E-02 -0.432524E-02  0.432524E-02   107.064       107.068    
  23  0.622746     -0.473616     -0.265751      0.265751       107.460       107.725    
  24  0.388486     -0.945499     -0.530529      0.530529       105.856       106.387    
  25  0.365204      -1.00730     -0.565206      0.565206       106.444       107.009    
  26  0.416566     -0.875710     -0.491370      0.491370       107.044       107.535    
  27  0.250735      -1.38336     -0.776216      0.776216       107.310       108.086    
  28  0.243824      -1.41131     -0.791901      0.791901       108.464       109.256    
  29  0.177195      -1.73050     -0.971003      0.971003       107.201       108.172    
  30  0.723685     -0.323399     -0.181462      0.181462       107.308       107.489    
  31  0.157256      -1.84988      -1.03799       1.03799       107.960       108.998    
  32  0.941988     -0.597623E-01 -0.335332E-01  0.335332E-01   108.345       108.379    
  33  0.110785      -2.20016      -1.23453       1.23453       108.613       109.847    
  34  0.200758      -1.60566     -0.900950      0.900950       108.593       109.494    
  35  0.873323     -0.135450     -0.760024E-01  0.760024E-01   109.588       109.664    
  36  0.842283     -0.171639     -0.963083E-01  0.963083E-01   108.870       108.967    
  37  0.326633      -1.11892     -0.627836      0.627836       109.462       110.089    
  38  0.648559     -0.433003     -0.242962      0.242962       110.113       110.356    
  39  0.460689E-01  -3.07762      -1.72688       1.72688       109.148       110.875    
  40  0.676614     -0.390654     -0.219200      0.219200       109.837       110.057    
  41  0.863029     -0.147307     -0.826555E-01  0.826555E-01   110.597       110.680    
  42  0.646727     -0.435831     -0.244549      0.244549       108.292       108.537    
  43  0.310616      -1.16920     -0.656049      0.656049       110.495       111.151    
  44  0.521840     -0.650394     -0.364943      0.364943       110.556       110.921    
  45  0.381245     -0.964312     -0.541086      0.541086       110.937       111.478    
  46  0.815908     -0.203453     -0.114160      0.114160       106.384       106.498    
loop,thermsimp(1:2)       75  0.245353       1.24865    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    340        107.57         67.84          1.12         42.23          0.44          0.05        111.68
Just calling func    0   0        111.68


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    107.57
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       75
neval is:      339
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       75      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       76
neval is:      339


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      339     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.202436      -1.59733     -0.896279      0.896279       104.294       105.190    
   2  0.337724      -1.08553     -0.609100      0.609100       104.387       104.996    
   3  0.870295     -0.138923     -0.779513E-01  0.779513E-01   104.407       104.484    
   4  0.837087     -0.177827     -0.997806E-01  0.997806E-01   104.808       104.908    
   5  0.512110     -0.669215     -0.375504      0.375504       105.004       105.380    
   6  0.998742     -0.125879E-02 -0.706321E-03  0.706321E-03   105.487       105.488    
   7  0.203490      -1.59214     -0.893366      0.893366       105.511       106.405    
   8  0.525951E-01  -2.94513      -1.65254       1.65254       104.538       106.190    
   9  0.474810     -0.744841     -0.417938      0.417938       105.182       105.600    
  10  0.440755     -0.819266     -0.459699      0.459699       105.672       106.132    
  11  0.225689      -1.48860     -0.835268      0.835268       105.372       106.208    
  12  0.902704     -0.102360     -0.574353E-01  0.574353E-01   106.050       106.107    
  13  0.663331     -0.410481     -0.230325      0.230325       105.856       106.086    
  14  0.511480     -0.670447     -0.376195      0.376195       105.870       106.246    
  15  0.625297     -0.469528     -0.263457      0.263457       106.384       106.647    
  16  0.812907     -0.207139     -0.116228      0.116228       105.987       106.104    
  17  0.979453     -0.207607E-01 -0.116490E-01  0.116490E-01   105.936       105.948    
  18  0.255329      -1.36520     -0.766030      0.766030       106.582       107.348    
  19  0.856654     -0.154722     -0.868159E-01  0.868159E-01   106.444       106.531    
  20  0.610394     -0.493650     -0.276992      0.276992       107.064       107.341    
  21  0.703614     -0.351525     -0.197244      0.197244       106.979       107.176    
  22  0.623403     -0.472562     -0.265159      0.265159       106.255       106.520    
  23  0.375727     -0.978893     -0.549267      0.549267       107.308       107.857    
  24  0.870528     -0.138656     -0.778011E-01  0.778011E-01   107.044       107.121    
  25  0.175838E-01  -4.04078      -2.26732       2.26732       106.650       108.918    
  26  0.237914      -1.43585     -0.805668      0.805668       107.460       108.265    
  27  0.464352     -0.767112     -0.430434      0.430434       107.310       107.740    
  28  0.776873     -0.252478     -0.141668      0.141668       107.201       107.343    
  29  0.380679     -0.965800     -0.541920      0.541920       106.398       106.940    
  30  0.391295     -0.938295     -0.526487      0.526487       108.345       108.872    
  31  0.369488     -0.995636     -0.558662      0.558662       108.292       108.851    
  32  0.302398      -1.19601     -0.671093      0.671093       107.359       108.030    
  33  0.809138     -0.211786     -0.118835      0.118835       108.870       108.989    
  34  0.675473     -0.392342     -0.220147      0.220147       107.960       108.180    
  35  0.486217     -0.721100     -0.404617      0.404617       108.464       108.869    
  36  0.937468     -0.645730E-01 -0.362326E-01  0.362326E-01   108.593       108.629    
  37  0.741025     -0.299721     -0.168176      0.168176       109.588       109.756    
  38  0.155236      -1.86281      -1.04524       1.04524       108.613       109.658    
  39  0.407249     -0.898331     -0.504063      0.504063       109.837       110.341    
  40  0.348550E-01  -3.35656      -1.88340       1.88340       109.462       111.345    
  41  0.178548      -1.72290     -0.966736      0.966736       110.113       111.080    
  42  0.127429      -2.06020      -1.15600       1.15600       110.597       111.753    
  43  0.919888     -0.835037E-01 -0.468548E-01  0.468548E-01   109.148       109.195    
  44  0.520080     -0.653772     -0.366838      0.366838       110.556       110.923    
  45  0.574092     -0.554965     -0.311397      0.311397       110.495       110.807    
  46  0.893427     -0.112690     -0.632317E-01  0.632317E-01   107.572       107.635    
loop,thermsimp(1:2)       76  0.896279      0.609100    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    341        105.77         67.97          1.11         42.62          0.26          0.05        112.00
Just calling func    0   0        112.00


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  340    105.77       0.3820     -3.158      2.546     -102.6     0.8051E-01
                       1.108     0.4807     -99.70      4.764      1.344    

                       1.397     -2.531      1.540      7907.      7000.    

                      0.5775      0.000      0.000      0.000     -1.221    



                      -2.278      0.000      0.000      7000.      731.3    

                       2.382     -4.464     -7.096     -8.758      8.355    

                      -18.93     -7.637      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.3776    -0.9119      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.4922     -1.189      7000.    



                      -1.961     -1.881     -1.981     -1.936    -0.3807    

                     -0.3252      9.271      8.797    -0.1491E+05 -4.800    

                     -0.7868     -3.829      9.405      8.878    -0.1969E+05



                      -6.000     0.5624    -0.7312E-02  9.008      8.947    

                     -0.1944E+05 -6.000     -1.239    -0.2650      9.118    

                       8.859    -0.1891E+05 -6.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    105.77
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       76
neval is:      340
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       76      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       77
neval is:      340


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      340     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.608851     -0.496181     -0.278412      0.278412       104.407       104.685    
   2  0.437836     -0.825911     -0.463427      0.463427       104.808       105.271    
   3  0.123560      -2.09103      -1.17330       1.17330       104.387       105.561    
   4  0.943438     -0.582242E-01 -0.326702E-01  0.326702E-01   104.294       104.327    
   5  0.215054      -1.53686     -0.862350      0.862350       105.004       105.866    
   6  0.984763     -0.153546E-01 -0.861562E-02  0.861562E-02   105.487       105.496    
   7  0.154160E-01  -4.17235      -2.34115       2.34115       105.182       107.523    
   8  0.231957      -1.46120     -0.819896      0.819896       105.936       106.756    
   9  0.476349     -0.741605     -0.416122      0.416122       105.856       106.272    
  10  0.620436     -0.477333     -0.267836      0.267836       105.987       106.255    
  11  0.456145     -0.784945     -0.440441      0.440441       106.050       106.490    
  12  0.507296     -0.678660     -0.380803      0.380803       105.672       106.053    
  13  0.910123     -0.941755E-01 -0.528428E-01  0.528428E-01   104.538       104.590    
  14  0.323556      -1.12838     -0.633147      0.633147       105.372       106.005    
  15  0.666279     -0.406046     -0.227837      0.227837       105.870       106.097    
  16  0.781920     -0.246002     -0.138034      0.138034       105.511       105.649    
  17  0.921689     -0.815478E-01 -0.457573E-01  0.457573E-01   106.255       106.301    
  18  0.152544      -1.88030      -1.05506       1.05506       106.444       107.499    
  19  0.265926      -1.32454     -0.743212      0.743212       106.384       107.127    
  20  0.812409     -0.207751     -0.116571      0.116571       106.398       106.514    
  21  0.517560E-01  -2.96121      -1.66157       1.66157       107.044       108.705    
  22  0.559187     -0.581271     -0.326157      0.326157       106.979       107.305    
  23  0.708792     -0.344194     -0.193131      0.193131       107.064       107.257    
  24  0.287762      -1.24562     -0.698932      0.698932       107.201       107.900    
  25  0.896953     -0.108752     -0.610221E-01  0.610221E-01   106.582       106.643    
  26  0.305048      -1.18729     -0.666199      0.666199       107.572       108.238    
  27  0.752428     -0.284450     -0.159608      0.159608       107.310       107.469    
  28  0.248159      -1.39369     -0.782012      0.782012       107.308       108.090    
  29  0.997822     -0.217989E-02 -0.122316E-02  0.122316E-02   107.359       107.360    
  30  0.706427     -0.347535     -0.195005      0.195005       107.960       108.155    
  31  0.885217     -0.121923     -0.684121E-01  0.684121E-01   107.460       107.528    
  32  0.448301     -0.802290     -0.450173      0.450173       108.593       109.043    
  33  0.316275      -1.15114     -0.645919      0.645919       108.292       108.938    
  34  0.682241     -0.382372     -0.214553      0.214553       108.464       108.678    
  35  0.655896     -0.421752     -0.236650      0.236650       108.345       108.582    
  36  0.129575      -2.04350      -1.14663       1.14663       106.650       107.797    
  37  0.236133      -1.44336     -0.809885      0.809885       108.870       109.680    
  38  0.481338     -0.731186     -0.410276      0.410276       109.148       109.558    
  39  0.825902     -0.191279     -0.107329      0.107329       108.613       108.720    
  40  0.818029     -0.200857     -0.112703      0.112703       109.588       109.700    
  41  0.135951E-01  -4.29805      -2.41168       2.41168       109.837       112.249    
  42  0.535484     -0.624585     -0.350461      0.350461       110.495       110.846    
  43  0.451882     -0.794334     -0.445709      0.445709       110.556       111.002    
  44  0.591282     -0.525463     -0.294843      0.294843       110.113       110.408    
  45  0.220584      -1.51148     -0.848105      0.848105       109.462       110.310    
  46  0.217569      -1.52524     -0.855826      0.855826       105.770       106.626    
loop,thermsimp(1:2)       77  0.278412      0.463427    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    342        107.28         67.98          1.10         42.34          0.17          0.05        111.64
Just calling func    0   0        111.64


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    107.28
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       77
neval is:      341
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       77      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       78
neval is:      341


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      341     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.980204E-01  -2.32258      -1.30322       1.30322       104.294       105.597    
   2  0.700279     -0.356277     -0.199911      0.199911       104.538       104.738    
   3  0.681564     -0.383366     -0.215111      0.215111       104.407       104.622    
   4  0.838213E-01  -2.47907      -1.39103       1.39103       104.808       106.199    
   5  0.708687     -0.344341     -0.193213      0.193213       105.487       105.680    
   6  0.253966      -1.37055     -0.769032      0.769032       104.387       105.156    
   7  0.210796      -1.55686     -0.873572      0.873572       105.511       106.385    
   8  0.967741     -0.327906E-01 -0.183991E-01  0.183991E-01   105.004       105.022    
   9  0.901331     -0.103882     -0.582895E-01  0.582895E-01   105.372       105.431    
  10  0.985067     -0.150452E-01 -0.844200E-02  0.844200E-02   105.672       105.681    
  11  0.153899      -1.87146      -1.05010       1.05010       105.870       106.920    
  12  0.297572      -1.21210     -0.680120      0.680120       105.987       106.667    
  13  0.111036      -2.19790      -1.23326       1.23326       105.856       107.089    
  14  0.489011     -0.715370     -0.401401      0.401401       106.255       106.657    
  15  0.970731     -0.297058E-01 -0.166683E-01  0.166683E-01   106.050       106.066    
  16  0.246322      -1.40112     -0.786180      0.786180       106.398       107.184    
  17  0.293332      -1.22645     -0.688173      0.688173       105.770       106.458    
  18  0.545752     -0.605591     -0.339803      0.339803       106.582       106.921    
  19  0.455999     -0.785265     -0.440620      0.440620       105.936       106.377    
  20  0.427211     -0.850477     -0.477211      0.477211       106.384       106.861    
  21  0.185046E-01  -3.98974      -2.23868       2.23868       107.064       109.303    
  22  0.768936     -0.262748     -0.147430      0.147430       106.979       107.126    
  23  0.870591     -0.138583     -0.777606E-01  0.777606E-01   107.359       107.437    
  24  0.563023     -0.574436     -0.322322      0.322322       107.310       107.632    
  25  0.132150E-01  -4.32640      -2.42759       2.42759       106.444       108.872    
  26  0.890415     -0.116068     -0.651268E-01  0.651268E-01   105.182       105.247    
  27  0.163417      -1.81145      -1.01643       1.01643       107.460       108.476    
  28  0.360288      -1.02085     -0.572810      0.572810       106.650       107.223    
  29  0.622131     -0.474604     -0.266305      0.266305       107.201       107.467    
  30  0.942630     -0.590811E-01 -0.331510E-01  0.331510E-01   107.308       107.341    
  31  0.135626      -1.99785      -1.12102       1.12102       107.960       109.081    
  32  0.369646     -0.995208     -0.558422      0.558422       107.572       108.130    
  33  0.501457     -0.690237     -0.387299      0.387299       108.345       108.733    
  34  0.459762     -0.777047     -0.436009      0.436009       108.464       108.900    
  35  0.489970     -0.713411     -0.400302      0.400302       107.044       107.444    
  36  0.504194     -0.684794     -0.384245      0.384245       108.613       108.997    
  37  0.543102E-01  -2.91304      -1.63454       1.63454       108.292       109.927    
  38  0.873609     -0.135122     -0.758184E-01  0.758184E-01   108.593       108.669    
  39  0.425787     -0.853816     -0.479085      0.479085       109.148       109.627    
  40  0.792406     -0.232682     -0.130560      0.130560       108.870       109.001    
  41  0.691102     -0.369469     -0.207313      0.207313       109.588       109.795    
  42  0.752290     -0.284633     -0.159711      0.159711       109.462       109.621    
  43  0.279962      -1.27310     -0.714350      0.714350       110.113       110.828    
  44  0.315915E-01  -3.45487      -1.93856       1.93856       110.495       112.434    
  45  0.266419      -1.32269     -0.742172      0.742172       110.556       111.298    
  46  0.949868     -0.514319E-01 -0.288589E-01  0.288589E-01   107.283       107.312    
loop,thermsimp(1:2)       78   1.30322      0.199911    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    343        111.02         67.98          1.09         42.10          0.49          0.05        111.71
Just calling func    0   0        111.71


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    111.02
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       78
neval is:      342
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       78      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       79
neval is:      342


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      342     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.190215      -1.65960     -0.931219      0.931219       104.407       105.338    
   2  0.812983     -0.207045     -0.116175      0.116175       104.538       104.654    
   3  0.820046E-01  -2.50098      -1.40333       1.40333       105.004       106.407    
   4  0.863006     -0.147333     -0.826702E-01  0.826702E-01   104.387       104.470    
   5  0.647901     -0.434017     -0.243532      0.243532       105.182       105.426    
   6  0.650063E-01  -2.73327      -1.53367       1.53367       105.372       106.906    
   7  0.407685E-02  -5.50243      -3.08747       3.08747       104.294       107.382    
   8  0.935930     -0.662149E-01 -0.371539E-01  0.371539E-01   105.487       105.524    
   9  0.158531      -1.84180      -1.03346       1.03346       105.672       106.706    
  10  0.846482     -0.166666     -0.935181E-01  0.935181E-01   106.050       106.143    
  11  0.252208      -1.37750     -0.772931      0.772931       104.808       105.581    
  12  0.781651E-02  -4.85152      -2.72224       2.72224       105.936       108.659    
  13  0.990286     -0.976134E-02 -0.547719E-02  0.547719E-02   105.511       105.517    
  14  0.550116     -0.597625     -0.335334      0.335334       105.770       106.105    
  15  0.483066     -0.727601     -0.408264      0.408264       106.255       106.663    
  16  0.196160      -1.62883     -0.913951      0.913951       105.987       106.901    
  17  0.469455     -0.756184     -0.424302      0.424302       106.384       106.808    
  18  0.624392     -0.470977     -0.264270      0.264270       105.870       106.134    
  19  0.743593     -0.296262     -0.166235      0.166235       106.582       106.748    
  20  0.348439      -1.05429     -0.591574      0.591574       105.856       106.448    
  21  0.779083     -0.249637     -0.140074      0.140074       106.979       107.119    
  22  0.989010     -0.110506E-01 -0.620061E-02  0.620061E-02   106.398       106.404    
  23  0.655432E-01  -2.72505      -1.52905       1.52905       106.650       108.179    
  24  0.470908     -0.753092     -0.422568      0.422568       107.283       107.705    
  25  0.685537     -0.377553     -0.211849      0.211849       107.308       107.520    
  26  0.863060E-02  -4.75244      -2.66664       2.66664       107.359       110.026    
  27  0.526195     -0.642084     -0.360280      0.360280       107.044       107.404    
  28  0.767692     -0.264367     -0.148339      0.148339       107.201       107.350    
  29  0.380048     -0.967459     -0.542851      0.542851       107.310       107.853    
  30  0.337508E-01  -3.38875      -1.90146       1.90146       107.572       109.473    
  31  0.683667     -0.380285     -0.213382      0.213382       107.460       107.673    
  32  0.245511      -1.40441     -0.788032      0.788032       108.593       109.381    
  33  0.294388      -1.22286     -0.686157      0.686157       108.345       109.032    
  34  0.159040      -1.83860      -1.03166       1.03166       106.444       107.476    
  35  0.613798     -0.488089     -0.273872      0.273872       108.464       108.738    
  36  0.863839E-01  -2.44895      -1.37413       1.37413       108.613       109.987    
  37  0.118930      -2.12922      -1.19473       1.19473       108.870       110.065    
  38  0.961460     -0.393026E-01 -0.220531E-01  0.220531E-01   107.960       107.982    
  39  0.457884     -0.781140     -0.438306      0.438306       107.064       107.502    
  40  0.312963      -1.16167     -0.651825      0.651825       109.462       110.113    
  41  0.892553     -0.113669     -0.637808E-01  0.637808E-01   109.148       109.212    
  42  0.448774     -0.801235     -0.449581      0.449581       109.588       110.037    
  43  0.942987E-01  -2.36129      -1.32494       1.32494       108.292       109.617    
  44  0.848599     -0.164169     -0.921167E-01  0.921167E-01   110.113       110.206    
  45  0.665342     -0.407455     -0.228627      0.228627       110.556       110.785    
  46  0.894010     -0.112039     -0.628660E-01  0.628660E-01   111.025       111.087    
loop,thermsimp(1:2)       79  0.931219      0.116175    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    344        110.50         67.83          1.10         42.23          0.26          0.05        111.48
Just calling func    0   0        111.48


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    110.50
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       79
neval is:      343
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       79      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       80
neval is:      343


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      343     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.337114      -1.08733     -0.610114      0.610114       104.387       104.997    
   2  0.744737     -0.294724     -0.165373      0.165373       104.538       104.703    
   3  0.361564E-01  -3.31990      -1.86283       1.86283       104.407       106.269    
   4  0.312099      -1.16444     -0.653377      0.653377       105.182       105.836    
   5  0.119132      -2.12752      -1.19378       1.19378       105.511       106.705    
   6  0.617735     -0.481696     -0.270284      0.270284       105.487       105.757    
   7  0.117626      -2.14025      -1.20091       1.20091       104.808       106.009    
   8  0.258570      -1.35259     -0.758952      0.758952       105.770       106.529    
   9  0.851854E-01  -2.46293      -1.38197       1.38197       105.870       107.251    
  10  0.220620      -1.51131     -0.848013      0.848013       106.050       106.898    
  11  0.648876     -0.432513     -0.242688      0.242688       106.398       106.640    
  12  0.958689     -0.421884E-01 -0.236724E-01  0.236724E-01   105.004       105.028    
  13  0.240652      -1.42440     -0.799247      0.799247       105.856       106.655    
  14  0.975871     -0.244252E-01 -0.137052E-01  0.137052E-01   106.255       106.269    
  15  0.467835     -0.759639     -0.426241      0.426241       105.672       106.098    
  16  0.398205     -0.920788     -0.516664      0.516664       106.582       107.098    
  17  0.757338E-01  -2.58053      -1.44796       1.44796       106.384       107.832    
  18  0.654643     -0.423666     -0.237723      0.237723       105.987       106.225    
  19  0.305298      -1.18647     -0.665738      0.665738       105.372       106.038    
  20  0.435768     -0.830645     -0.466083      0.466083       106.979       107.445    
  21  0.689410     -0.371920     -0.208688      0.208688       107.201       107.410    
  22  0.267500      -1.31864     -0.739900      0.739900       104.294       105.034    
  23  0.590747     -0.526367     -0.295350      0.295350       107.044       107.339    
  24  0.108947E-01  -4.51948      -2.53592       2.53592       106.444       108.980    
  25  0.236025      -1.44382     -0.810142      0.810142       107.064       107.874    
  26  0.590760     -0.526345     -0.295338      0.295338       107.308       107.603    
  27  0.782443     -0.245334     -0.137659      0.137659       107.460       107.597    
  28  0.702257     -0.353456     -0.198328      0.198328       107.283       107.481    
  29  0.764991     -0.267891     -0.150317      0.150317       107.310       107.460    
  30  0.753362     -0.283210     -0.158912      0.158912       107.960       108.119    
  31  0.961949E-01  -2.34138      -1.31377       1.31377       106.650       107.964    
  32  0.541564     -0.613294     -0.344126      0.344126       105.936       106.280    
  33  0.474786     -0.744891     -0.417966      0.417966       108.464       108.882    
  34  0.242842      -1.41534     -0.794164      0.794164       108.345       109.140    
  35  0.495414     -0.702361     -0.394102      0.394102       109.148       109.542    
  36  0.636645     -0.451543     -0.253366      0.253366       108.593       108.846    
  37  0.758087     -0.276957     -0.155404      0.155404       107.572       107.727    
  38  0.209321      -1.56389     -0.877513      0.877513       108.292       109.170    
  39  0.484343     -0.724961     -0.406783      0.406783       108.613       109.019    
  40  0.499790     -0.693567     -0.389168      0.389168       107.359       107.748    
  41  0.316628      -1.15003     -0.645293      0.645293       109.588       110.233    
  42  0.705469     -0.348892     -0.195767      0.195767       108.870       109.066    
  43  0.514591     -0.664383     -0.372792      0.372792       109.462       109.834    
  44  0.869006     -0.140406     -0.787831E-01  0.787831E-01   110.113       110.192    
  45  0.112600      -2.18392      -1.22542       1.22542       110.556       111.781    
  46  0.511991     -0.669449     -0.375635      0.375635       110.495       110.871    
loop,thermsimp(1:2)       80  0.610114      0.165373    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    345        112.94         67.89          1.09         42.31          0.39          0.05        111.73
Just calling func    0   0        111.73


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    346        106.12         67.90          1.09         41.96          0.76          0.05        111.77
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    106.12
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       80
neval is:      345
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       80      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       81
neval is:      345


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      345     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.343927      -1.06733     -0.598888      0.598888       104.538       105.137    
   2  0.822787     -0.195058     -0.109449      0.109449       104.387       104.497    
   3  0.320831E-01  -3.43942      -1.92990       1.92990       105.004       106.934    
   4  0.224034      -1.49596     -0.839398      0.839398       104.294       105.134    
   5  0.200770      -1.60559     -0.900915      0.900915       105.487       106.388    
   6  0.983846     -0.162863E-01 -0.913839E-02  0.913839E-02   105.182       105.191    
   7  0.762274     -0.271449     -0.152313      0.152313       104.808       104.960    
   8  0.872649     -0.136221     -0.764353E-01  0.764353E-01   105.372       105.449    
   9  0.366891      -1.00269     -0.562620      0.562620       105.672       106.235    
  10  0.800852     -0.222079     -0.124611      0.124611       105.987       106.112    
  11  0.755695     -0.280117     -0.157176      0.157176       106.255       106.412    
  12  0.595174     -0.518902     -0.291161      0.291161       104.407       104.698    
  13  0.316509      -1.15040     -0.645503      0.645503       105.936       106.582    
  14  0.847901     -0.164991     -0.925781E-01  0.925781E-01   105.770       105.862    
  15  0.116195      -2.15248      -1.20778       1.20778       106.398       107.605    
  16  0.121963      -2.10403      -1.18060       1.18060       105.856       107.037    
  17  0.298485      -1.20903     -0.678402      0.678402       105.511       106.190    
  18  0.698751     -0.358461     -0.201136      0.201136       106.050       106.251    
  19  0.248186      -1.39358     -0.781950      0.781950       106.582       107.364    
  20  0.717251     -0.332329     -0.186473      0.186473       105.870       106.056    
  21  0.591856     -0.524491     -0.294297      0.294297       107.044       107.338    
  22  0.780177E-01  -2.55082      -1.43129       1.43129       107.201       108.632    
  23  0.314281      -1.15747     -0.649467      0.649467       106.979       107.628    
  24  0.565423E-01  -2.87277      -1.61194       1.61194       107.310       108.922    
  25  0.964829     -0.358044E-01 -0.200902E-01  0.200902E-01   107.283       107.303    
  26  0.900157     -0.105186     -0.590211E-01  0.590211E-01   107.460       107.519    
  27  0.656998     -0.420074     -0.235708      0.235708       107.308       107.544    
  28  0.888436E-01  -2.42088      -1.35838       1.35838       107.572       108.930    
  29  0.853838     -0.158014     -0.886633E-01  0.886633E-01   107.359       107.448    
  30  0.704842     -0.349782     -0.196266      0.196266       106.384       106.580    
  31  0.890111     -0.116409     -0.653182E-01  0.653182E-01   107.064       107.129    
  32  0.424397     -0.857087     -0.480920      0.480920       106.650       107.131    
  33  0.959371     -0.414778E-01 -0.232736E-01  0.232736E-01   107.960       107.983    
  34  0.323832      -1.12753     -0.632670      0.632670       108.593       109.226    
  35  0.943913     -0.577217E-01 -0.323882E-01  0.323882E-01   108.464       108.496    
  36  0.119048      -2.12823      -1.19417       1.19417       106.444       107.638    
  37  0.427842E-01  -3.15159      -1.76839       1.76839       108.613       110.381    
  38  0.433544     -0.835761     -0.468954      0.468954       108.870       109.339    
  39  0.773173     -0.257253     -0.144347      0.144347       108.345       108.490    
  40  0.455657     -0.786014     -0.441041      0.441041       108.292       108.733    
  41  0.362132      -1.01575     -0.569945      0.569945       109.148       109.718    
  42  0.775394     -0.254384     -0.142737      0.142737       109.462       109.604    
  43  0.889906     -0.116639     -0.654475E-01  0.654475E-01   110.113       110.179    
  44  0.415923     -0.877255     -0.492237      0.492237       109.588       110.080    
  45  0.374532E-01  -3.28466      -1.84306       1.84306       110.495       112.338    
  46  0.904805     -0.100036     -0.561312E-01  0.561312E-01   106.120       106.176    
loop,thermsimp(1:2)       81  0.598888      0.109449    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    347        110.62         68.00          1.11         42.33          0.38          0.05        111.87
Just calling func    0   0        111.87


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    110.62
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       81
neval is:      346
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       81      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       82
neval is:      346


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      346     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.556446     -0.586184     -0.328914      0.328914       104.387       104.716    
   2  0.926592     -0.762421E-01 -0.427802E-01  0.427802E-01   104.407       104.449    
   3  0.766762     -0.265579     -0.149019      0.149019       104.808       104.957    
   4  0.627980     -0.465247     -0.261055      0.261055       104.294       104.555    
   5  0.647527     -0.434594     -0.243855      0.243855       104.538       104.781    
   6  0.639464     -0.447125     -0.250886      0.250886       105.182       105.433    
   7  0.168437      -1.78119     -0.999446      0.999446       105.372       106.372    
   8  0.725133     -0.321400     -0.180341      0.180341       105.770       105.950    
   9  0.620073     -0.477917     -0.268164      0.268164       105.870       106.138    
  10  0.837394     -0.177461     -0.995750E-01  0.995750E-01   105.987       106.087    
  11  0.763326     -0.270070     -0.151539      0.151539       106.120       106.272    
  12  0.216703      -1.52923     -0.858066      0.858066       105.511       106.370    
  13  0.846730     -0.166373     -0.933537E-01  0.933537E-01   105.672       105.765    
  14  0.712127     -0.339499     -0.190497      0.190497       106.050       106.240    
  15  0.731222     -0.313039     -0.175649      0.175649       105.487       105.663    
  16  0.131329      -2.03005      -1.13908       1.13908       106.255       107.394    
  17  0.946517     -0.549662E-01 -0.308421E-01  0.308421E-01   106.384       106.414    
  18  0.303743      -1.19157     -0.668605      0.668605       105.936       106.605    
  19  0.452199     -0.793633     -0.445316      0.445316       105.004       105.449    
  20  0.176302      -1.73556     -0.973838      0.973838       105.856       106.830    
  21  0.569871     -0.562345     -0.315537      0.315537       107.064       107.380    
  22  0.267873      -1.31724     -0.739119      0.739119       106.650       107.389    
  23  0.295877      -1.21781     -0.683326      0.683326       107.283       107.966    
  24  0.658567     -0.417689     -0.234369      0.234369       107.044       107.278    
  25  0.633120     -0.457096     -0.256481      0.256481       106.582       106.838    
  26  0.655522     -0.422324     -0.236970      0.236970       107.359       107.596    
  27  0.532295     -0.630558     -0.353813      0.353813       107.460       107.814    
  28  0.611209     -0.492317     -0.276244      0.276244       107.308       107.584    
  29  0.768812E-01  -2.56549      -1.43952       1.43952       106.398       107.837    
  30  0.845132     -0.168262     -0.944135E-01  0.944135E-01   106.979       107.073    
  31  0.133696      -2.01219      -1.12906       1.12906       106.444       107.573    
  32  0.850522E-01  -2.46449      -1.38285       1.38285       107.960       109.343    
  33  0.901960     -0.103185     -0.578980E-01  0.578980E-01   108.345       108.403    
  34  0.394454E-01  -3.23284      -1.81398       1.81398       108.464       110.278    
  35  0.152819      -1.87850      -1.05404       1.05404       107.201       108.255    
  36  0.951369     -0.498538E-01 -0.279735E-01  0.279735E-01   108.292       108.320    
  37  0.909075     -0.953273E-01 -0.534892E-01  0.534892E-01   107.310       107.363    
  38  0.552964     -0.592462     -0.332437      0.332437       107.572       107.904    
  39  0.904748     -0.100099     -0.561666E-01  0.561666E-01   108.593       108.649    
  40  0.434860     -0.832731     -0.467254      0.467254       108.870       109.338    
  41  0.807557E-01  -2.51633      -1.41194       1.41194       109.462       110.873    
  42  0.245089      -1.40614     -0.788997      0.788997       109.148       109.937    
  43  0.566857     -0.567648     -0.318513      0.318513       109.588       109.906    
  44  0.154441      -1.86794      -1.04812       1.04812       110.113       111.162    
  45  0.961849     -0.388974E-01 -0.218257E-01  0.218257E-01   108.613       108.635    
  46  0.267234      -1.31963     -0.740459      0.740459       110.617       111.358    
loop,thermsimp(1:2)       82  0.328914      0.427802E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    348        110.50         67.87          1.12         42.02          0.65          0.05        111.72
Just calling func    0   0        111.72


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    110.50
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       82
neval is:      347
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       82      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       83
neval is:      347


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      347     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.620562     -0.477129     -0.267722      0.267722       104.407       104.674    
   2  0.835522     -0.179699     -0.100831      0.100831       104.294       104.395    
   3  0.626661     -0.467350     -0.262235      0.262235       104.387       104.649    
   4  0.197939      -1.61980     -0.908884      0.908884       104.538       105.447    
   5  0.842637     -0.171219     -0.960727E-01  0.960727E-01   104.808       104.904    
   6  0.873669     -0.135053     -0.757799E-01  0.757799E-01   105.182       105.258    
   7  0.298180E-01  -3.51264      -1.97098       1.97098       105.004       106.975    
   8  0.548374     -0.600797     -0.337114      0.337114       105.487       105.824    
   9  0.407469E-01  -3.20037      -1.79576       1.79576       105.672       107.468    
  10  0.210105E-02  -6.16532      -3.45942       3.45942       105.770       109.229    
  11  0.631577     -0.459536     -0.257850      0.257850       105.987       106.245    
  12  0.944026     -0.576013E-01 -0.323207E-01  0.323207E-01   105.870       105.902    
  13  0.492775     -0.707703     -0.397099      0.397099       106.050       106.447    
  14  0.195107      -1.63421     -0.916970      0.916970       106.120       107.037    
  15  0.775688     -0.254005     -0.142525      0.142525       105.511       105.654    
  16  0.763907     -0.269310     -0.151112      0.151112       105.372       105.523    
  17  0.797499     -0.226275     -0.126965      0.126965       106.384       106.511    
  18  0.639217     -0.447511     -0.251103      0.251103       105.936       106.187    
  19  0.775225     -0.254602     -0.142860      0.142860       105.856       105.999    
  20  0.680633     -0.384733     -0.215877      0.215877       106.582       106.797    
  21  0.532184     -0.630766     -0.353929      0.353929       106.979       107.333    
  22  0.843009     -0.170778     -0.958254E-01  0.958254E-01   107.044       107.139    
  23  0.943186     -0.584913E-01 -0.328201E-01  0.328201E-01   107.310       107.343    
  24  0.601611     -0.508143     -0.285125      0.285125       107.064       107.349    
  25  0.259021      -1.35084     -0.757973      0.757973       106.650       107.408    
  26  0.855132     -0.156500     -0.878137E-01  0.878137E-01   106.255       106.343    
  27  0.351229      -1.04632     -0.587099      0.587099       106.444       107.031    
  28  0.950362     -0.509122E-01 -0.285673E-01  0.285673E-01   107.308       107.336    
  29  0.447301     -0.804524     -0.451427      0.451427       107.359       107.811    
  30  0.325509      -1.12237     -0.629771      0.629771       107.460       108.090    
  31  0.717010     -0.332666     -0.186662      0.186662       106.398       106.584    
  32  0.676718     -0.390500     -0.219114      0.219114       107.572       107.791    
  33  0.493623     -0.705983     -0.396135      0.396135       107.283       107.679    
  34  0.155805E-01  -4.16174      -2.33519       2.33519       107.201       109.536    
  35  0.417708     -0.872973     -0.489834      0.489834       108.292       108.782    
  36  0.395067     -0.928699     -0.521103      0.521103       108.345       108.867    
  37  0.977835     -0.224139E-01 -0.125767E-01  0.125767E-01   108.613       108.625    
  38  0.603414     -0.505151     -0.283446      0.283446       108.593       108.877    
  39  0.173810      -1.74979     -0.981826      0.981826       108.870       109.852    
  40  0.979719     -0.204895E-01 -0.114969E-01  0.114969E-01   107.960       107.972    
  41  0.234071      -1.45213     -0.814805      0.814805       109.588       110.402    
  42  0.264051      -1.33161     -0.747182      0.747182       109.148       109.895    
  43  0.756353     -0.279247     -0.156689      0.156689       108.464       108.621    
  44  0.980782     -0.194046E-01 -0.108881E-01  0.108881E-01   109.462       109.472    
  45  0.444591E-01  -3.11319      -1.74684       1.74684       110.113       111.860    
  46  0.276895      -1.28412     -0.720531      0.720531       110.495       111.216    
loop,thermsimp(1:2)       83  0.267722      0.100831    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    349        107.33         67.97          1.09         42.14          0.36          0.05        111.62
Just calling func    0   0        111.62


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    107.33
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       83
neval is:      348
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       83      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       84
neval is:      348


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      348     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.573743     -0.555573     -0.311738      0.311738       104.294       104.606    
   2  0.583943E-01  -2.84054      -1.59385       1.59385       104.387       105.981    
   3  0.377108     -0.975224     -0.547208      0.547208       104.407       104.954    
   4  0.117758      -2.13912      -1.20028       1.20028       104.808       106.008    
   5  0.531627     -0.631812     -0.354516      0.354516       105.182       105.537    
   6  0.348101      -1.05526     -0.592118      0.592118       104.538       105.130    
   7  0.713050     -0.338204     -0.189770      0.189770       105.372       105.562    
   8  0.895286     -0.110612     -0.620656E-01  0.620656E-01   105.511       105.574    
   9  0.873863     -0.134831     -0.756552E-01  0.756552E-01   105.487       105.563    
  10  0.225074      -1.49132     -0.836798      0.836798       105.870       106.706    
  11  0.542220     -0.612083     -0.343446      0.343446       105.856       106.200    
  12  0.262707      -1.33672     -0.750046      0.750046       105.936       106.686    
  13  0.864358E-01  -2.44835      -1.37380       1.37380       105.987       107.361    
  14  0.468331     -0.758581     -0.425647      0.425647       106.255       106.681    
  15  0.896509     -0.109247     -0.612997E-01  0.612997E-01   106.050       106.111    
  16  0.169842E-01  -4.07547      -2.28679       2.28679       106.384       108.670    
  17  0.980158     -0.200410E-01 -0.112452E-01  0.112452E-01   106.398       106.409    
  18  0.252821      -1.37507     -0.771567      0.771567       106.582       107.353    
  19  0.556823     -0.585507     -0.328534      0.328534       105.004       105.333    
  20  0.520304     -0.653342     -0.366597      0.366597       106.444       106.811    
  21  0.956705E-01  -2.34685      -1.31684       1.31684       106.120       107.437    
  22  0.458762     -0.779224     -0.437230      0.437230       107.044       107.481    
  23  0.684654     -0.378842     -0.212572      0.212572       106.979       107.191    
  24  0.749393     -0.288492     -0.161876      0.161876       107.308       107.470    
  25  0.112724      -2.18282      -1.22480       1.22480       107.310       108.535    
  26  0.642114     -0.442989     -0.248566      0.248566       107.064       107.313    
  27  0.881888     -0.125691     -0.705263E-01  0.705263E-01   106.650       106.721    
  28  0.933845     -0.684452E-01 -0.384053E-01  0.384053E-01   105.672       105.711    
  29  0.124482      -2.08359      -1.16912       1.16912       107.283       108.452    
  30  0.189487      -1.66344     -0.933371      0.933371       107.572       108.505    
  31  0.526869     -0.640804     -0.359562      0.359562       107.359       107.719    
  32  0.490162     -0.713020     -0.400083      0.400083       107.960       108.360    
  33  0.292049      -1.23083     -0.690634      0.690634       107.460       108.150    
  34  0.646685     -0.435896     -0.244586      0.244586       108.464       108.708    
  35  0.738289     -0.303420     -0.170252      0.170252       108.613       108.783    
  36  0.379268     -0.969513     -0.544004      0.544004       108.292       108.836    
  37  0.691037     -0.369562     -0.207365      0.207365       108.345       108.553    
  38  0.566288     -0.568653     -0.319077      0.319077       108.593       108.912    
  39  0.130734      -2.03459      -1.14163       1.14163       105.770       106.911    
  40  0.298876      -1.20773     -0.677667      0.677667       109.462       110.139    
  41  0.369194     -0.996434     -0.559110      0.559110       107.201       107.760    
  42  0.291325      -1.23331     -0.692026      0.692026       108.870       109.562    
  43  0.828296     -0.188384     -0.105704      0.105704       109.148       109.254    
  44  0.540492E-01  -2.91786      -1.63724       1.63724       109.588       111.225    
  45  0.979889     -0.203162E-01 -0.113996E-01  0.113996E-01   110.495       110.507    
  46  0.411533     -0.887866     -0.498191      0.498191       107.327       107.825    
loop,thermsimp(1:2)       84  0.311738       1.59385    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    350        114.82         67.86          1.08         41.97          0.87          0.05        111.84
Just calling func    0   0        111.84


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    351        107.19         67.95          1.11         42.14          0.38          0.05        111.62
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    107.19
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       84
neval is:      350
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       84      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       85
neval is:      350


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      350     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.936701     -0.653915E-01 -0.366918E-01  0.366918E-01   104.294       104.331    
   2  0.765516     -0.267206     -0.149932      0.149932       104.407       104.556    
   3  0.899266     -0.106176     -0.595764E-01  0.595764E-01   104.538       104.597    
   4  0.953341     -0.477822E-01 -0.268111E-01  0.268111E-01   105.004       105.031    
   5  0.642356     -0.442612     -0.248354      0.248354       105.182       105.431    
   6  0.265713      -1.32534     -0.743662      0.743662       105.372       106.116    
   7  0.379937     -0.967749     -0.543014      0.543014       105.487       106.030    
   8  0.449606     -0.799384     -0.448543      0.448543       105.511       105.960    
   9  0.810725     -0.209826     -0.117736      0.117736       105.672       105.790    
  10  0.218977      -1.51879     -0.852209      0.852209       104.387       105.239    
  11  0.456613     -0.783919     -0.439865      0.439865       104.808       105.248    
  12  0.439289E-02  -5.42777      -3.04558       3.04558       106.050       109.095    
  13  0.710409     -0.341914     -0.191852      0.191852       105.856       106.048    
  14  0.385315     -0.953695     -0.535128      0.535128       106.398       106.933    
  15  0.116701      -2.14814      -1.20535       1.20535       106.255       107.461    
  16  0.985237     -0.148728E-01 -0.834526E-02  0.834526E-02   105.936       105.945    
  17  0.856588     -0.154798     -0.868586E-01  0.868586E-01   105.870       105.956    
  18  0.155419      -1.86163      -1.04458       1.04458       106.650       107.695    
  19  0.257525      -1.35664     -0.761225      0.761225       106.444       107.205    
  20  0.548716     -0.600174     -0.336764      0.336764       105.770       106.106    
  21  0.589698     -0.528145     -0.296347      0.296347       106.979       107.275    
  22  0.884364     -0.122887     -0.689529E-01  0.689529E-01   107.064       107.133    
  23  0.871018E-01  -2.44068      -1.36949       1.36949       106.582       107.951    
  24  0.486795     -0.719912     -0.403950      0.403950       105.987       106.391    
  25  0.161417      -1.82376      -1.02333       1.02333       106.120       107.143    
  26  0.598774     -0.512871     -0.287777      0.287777       107.308       107.596    
  27  0.483527     -0.726647     -0.407729      0.407729       107.044       107.451    
  28  0.715961     -0.334130     -0.187484      0.187484       107.359       107.547    
  29  0.771801     -0.259029     -0.145344      0.145344       107.201       107.347    
  30  0.458713     -0.779330     -0.437290      0.437290       107.327       107.764    
  31  0.235181      -1.44740     -0.812151      0.812151       107.460       108.272    
  32  0.488220     -0.716988     -0.402310      0.402310       107.960       108.362    
  33  0.365473      -1.00656     -0.564793      0.564793       107.283       107.847    
  34  0.191311      -1.65386     -0.927996      0.927996       107.572       108.500    
  35  0.484999     -0.723609     -0.406025      0.406025       107.310       107.716    
  36  0.799086     -0.224286     -0.125849      0.125849       108.345       108.471    
  37  0.811458     -0.208923     -0.117229      0.117229       106.384       106.501    
  38  0.829885E-01  -2.48905      -1.39663       1.39663       108.464       109.861    
  39  0.731085     -0.313226     -0.175754      0.175754       108.613       108.788    
  40  0.854012     -0.157810     -0.885486E-01  0.885486E-01   108.292       108.381    
  41  0.699629     -0.357205     -0.200432      0.200432       108.593       108.793    
  42  0.918965     -0.845069E-01 -0.474177E-01  0.474177E-01   109.148       109.196    
  43  0.463498     -0.768952     -0.431467      0.431467       108.870       109.302    
  44  0.758690E-01  -2.57875      -1.44696       1.44696       109.462       110.908    
  45  0.577757     -0.548602     -0.307826      0.307826       110.495       110.803    
  46  0.897332     -0.108329     -0.607846E-01  0.607846E-01   107.189       107.250    
loop,thermsimp(1:2)       85  0.366918E-01  0.149932    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    352        107.11         67.92          1.11         42.16          0.55          0.05        111.78
Just calling func    0   0        111.78


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    107.11
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       85
neval is:      351
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       85      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       86
neval is:      351


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      351     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.334399      -1.09542     -0.614652      0.614652       104.294       104.909    
   2  0.140144      -1.96508      -1.10263       1.10263       104.407       105.509    
   3  0.520913     -0.652172     -0.365940      0.365940       104.538       104.904    
   4  0.628337     -0.464678     -0.260736      0.260736       105.004       105.265    
   5  0.203324      -1.59296     -0.893824      0.893824       104.387       105.281    
   6  0.481205     -0.731462     -0.410431      0.410431       104.808       105.218    
   7  0.948759     -0.526009E-01 -0.295149E-01  0.295149E-01   105.182       105.212    
   8  0.251825      -1.37902     -0.773782      0.773782       105.672       106.446    
   9  0.363806      -1.01114     -0.567358      0.567358       105.936       106.504    
  10  0.465077     -0.765552     -0.429559      0.429559       105.870       106.299    
  11  0.580920     -0.543143     -0.304763      0.304763       105.511       105.816    
  12  0.957129     -0.438167E-01 -0.245860E-01  0.245860E-01   105.487       105.512    
  13  0.345007      -1.06419     -0.597128      0.597128       105.856       106.453    
  14  0.177852E-01  -4.02939      -2.26093       2.26093       105.770       108.031    
  15  0.843779     -0.169864     -0.953125E-01  0.953125E-01   105.372       105.468    
  16  0.765452     -0.267288     -0.149978      0.149978       105.987       106.137    
  17  0.453925     -0.789824     -0.443178      0.443178       106.384       106.827    
  18  0.378234     -0.972243     -0.545535      0.545535       106.398       106.943    
  19  0.167312      -1.78790      -1.00321       1.00321       107.064       108.067    
  20  0.240345      -1.42568     -0.799963      0.799963       106.120       106.920    
  21  0.868226     -0.141303     -0.792867E-01  0.792867E-01   106.444       106.523    
  22  0.907002     -0.976102E-01 -0.547701E-01  0.547701E-01   107.189       107.243    
  23  0.433040     -0.836925     -0.469607      0.469607       106.979       107.448    
  24  0.291080      -1.23416     -0.692498      0.692498       107.201       107.894    
  25  0.391091     -0.938815     -0.526779      0.526779       107.044       107.570    
  26  0.541803     -0.612853     -0.343878      0.343878       106.255       106.599    
  27  0.494251     -0.704711     -0.395421      0.395421       107.359       107.755    
  28  0.617376     -0.482277     -0.270610      0.270610       107.308       107.578    
  29  0.919515     -0.839094E-01 -0.470825E-01  0.470825E-01   106.650       106.697    
  30  0.836216     -0.178868     -0.100365      0.100365       107.310       107.410    
  31  0.436173     -0.829716     -0.465562      0.465562       107.327       107.793    
  32  0.175211      -1.74176     -0.977321      0.977321       107.283       108.260    
  33  0.304297      -1.18975     -0.667581      0.667581       106.582       107.249    
  34  0.996125     -0.388259E-02 -0.217856E-02  0.217856E-02   107.460       107.462    
  35  0.146253      -1.92242      -1.07869       1.07869       107.960       109.039    
  36  0.110666      -2.20124      -1.23514       1.23514       108.292       109.527    
  37  0.481190E-01  -3.03408      -1.70245       1.70245       108.345       110.048    
  38  0.342728      -1.07082     -0.600846      0.600846       107.572       108.173    
  39  0.998409E-01  -2.30418      -1.29290       1.29290       108.613       109.906    
  40  0.509248     -0.674821     -0.378649      0.378649       108.593       108.972    
  41  0.974159     -0.261804E-01 -0.146901E-01  0.146901E-01   106.050       106.064    
  42  0.950347     -0.509279E-01 -0.285762E-01  0.285762E-01   109.148       109.177    
  43  0.333494      -1.09813     -0.616172      0.616172       108.870       109.487    
  44  0.914660     -0.892024E-01 -0.500524E-01  0.500524E-01   108.464       108.514    
  45  0.249678      -1.38758     -0.778588      0.778588       110.495       111.274    
  46  0.512508     -0.668440     -0.375068      0.375068       107.114       107.489    
loop,thermsimp(1:2)       86  0.614652       1.10263    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    353        110.98         68.00          1.13         42.27          0.32          0.05        111.77
Just calling func    0   0        111.77


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    354        106.58         67.94          1.11         42.22          0.38          0.05        111.70
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    106.58
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       86
neval is:      353
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       86      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       87
neval is:      353


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      353     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.447127E-01  -3.10750      -1.74365       1.74365       104.538       106.281    
   2  0.682805     -0.381545     -0.214089      0.214089       104.294       104.508    
   3  0.699780     -0.356989     -0.200310      0.200310       105.182       105.383    
   4  0.515086     -0.663422     -0.372253      0.372253       104.808       105.180    
   5  0.402461     -0.910157     -0.510699      0.510699       105.004       105.515    
   6  0.652803     -0.426480     -0.239303      0.239303       104.387       104.627    
   7  0.483213     -0.727297     -0.408094      0.408094       105.372       105.780    
   8  0.873684     -0.135037     -0.757705E-01  0.757705E-01   104.407       104.482    
   9  0.142648      -1.94738      -1.09269       1.09269       105.487       106.580    
  10  0.844357     -0.169180     -0.949288E-01  0.949288E-01   105.511       105.606    
  11  0.154187      -1.86959      -1.04904       1.04904       106.050       107.099    
  12  0.437314E-01  -3.12969      -1.75610       1.75610       105.987       107.743    
  13  0.455393E-02  -5.39176      -3.02537       3.02537       105.870       108.895    
  14  0.236800      -1.44054     -0.808302      0.808302       105.672       106.480    
  15  0.660181     -0.415241     -0.232996      0.232996       105.856       106.089    
  16  0.652586     -0.426813     -0.239489      0.239489       105.936       106.176    
  17  0.153101      -1.87666      -1.05301       1.05301       106.444       107.497    
  18  0.753412     -0.283143     -0.158874      0.158874       106.255       106.414    
  19  0.240839      -1.42363     -0.798811      0.798811       106.650       107.449    
  20  0.684622     -0.378888     -0.212598      0.212598       106.384       106.596    
  21  0.243018      -1.41462     -0.793758      0.793758       106.120       106.914    
  22  0.815539     -0.203906     -0.114414      0.114414       106.398       106.512    
  23  0.589355     -0.528726     -0.296674      0.296674       107.189       107.485    
  24  0.243009      -1.41466     -0.793779      0.793779       106.582       107.375    
  25  0.821886     -0.196154     -0.110064      0.110064       107.310       107.420    
  26  0.261401      -1.34170     -0.752842      0.752842       106.979       107.732    
  27  0.571134     -0.560131     -0.314295      0.314295       107.460       107.774    
  28  0.406429E-01  -3.20293      -1.79720       1.79720       107.114       108.911    
  29  0.341463      -1.07451     -0.602921      0.602921       107.044       107.647    
  30  0.252643      -1.37578     -0.771964      0.771964       107.308       108.080    
  31  0.503366     -0.686439     -0.385168      0.385168       107.359       107.744    
  32  0.247804      -1.39512     -0.782814      0.782814       107.327       108.110    
  33  0.902392     -0.102706     -0.576293E-01  0.576293E-01   107.201       107.259    
  34  0.198330E-01  -3.92041      -2.19978       2.19978       105.770       107.969    
  35  0.695627     -0.362942     -0.203650      0.203650       107.064       107.268    
  36  0.833441     -0.182192     -0.102230      0.102230       107.572       107.674    
  37  0.720954     -0.327181     -0.183584      0.183584       107.283       107.466    
  38  0.155604      -1.86044      -1.04391       1.04391       108.464       109.508    
  39  0.496580E-01  -3.00260      -1.68479       1.68479       108.593       110.278    
  40  0.804644     -0.217356     -0.121961      0.121961       107.960       108.082    
  41  0.329241      -1.11097     -0.623374      0.623374       109.148       109.772    
  42  0.889596     -0.116988     -0.656432E-01  0.656432E-01   108.870       108.936    
  43  0.857341     -0.153920     -0.863660E-01  0.863660E-01   108.292       108.379    
  44  0.238258      -1.43440     -0.804856      0.804856       108.613       109.418    
  45  0.998437     -0.156448E-02 -0.877845E-03  0.877845E-03   108.345       108.346    
  46  0.280889      -1.26979     -0.712495      0.712495       106.577       107.289    
loop,thermsimp(1:2)       87   1.74365      0.214089    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    355        109.81         68.01          1.10         42.32          0.17          0.05        111.64
Just calling func    0   0        111.64


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    109.81
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       87
neval is:      354
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       87      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       88
neval is:      354


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      354     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.471068     -0.752752     -0.422377      0.422377       104.407       104.829    
   2  0.531040     -0.632917     -0.355136      0.355136       104.294       104.649    
   3  0.592986E-01  -2.82517      -1.58523       1.58523       104.387       105.972    
   4  0.247694      -1.39556     -0.783065      0.783065       104.808       105.591    
   5  0.131832      -2.02623      -1.13694       1.13694       105.182       106.319    
   6  0.928797E-01  -2.37645      -1.33345       1.33345       105.004       106.338    
   7  0.638590     -0.448492     -0.251654      0.251654       105.511       105.763    
   8  0.220145      -1.51347     -0.849224      0.849224       105.372       106.222    
   9  0.764323     -0.268765     -0.150807      0.150807       105.856       106.007    
  10  0.223429      -1.49866     -0.840914      0.840914       105.936       106.777    
  11  0.705665     -0.348615     -0.195611      0.195611       104.538       104.733    
  12  0.812667     -0.207434     -0.116394      0.116394       106.255       106.372    
  13  0.344167      -1.06663     -0.598496      0.598496       105.672       106.271    
  14  0.691720     -0.368573     -0.206810      0.206810       106.398       106.604    
  15  0.601584     -0.508189     -0.285150      0.285150       105.487       105.772    
  16  0.323598      -1.12825     -0.633074      0.633074       106.384       107.017    
  17  0.536181     -0.623284     -0.349731      0.349731       106.120       106.470    
  18  0.224445      -1.49412     -0.838368      0.838368       106.050       106.888    
  19  0.967837     -0.326916E-01 -0.183436E-01  0.183436E-01   107.201       107.220    
  20  0.982234     -0.179257E-01 -0.100583E-01  0.100583E-01   107.064       107.074    
  21  0.656459     -0.420894     -0.236168      0.236168       106.577       106.813    
  22  0.138036      -1.98024      -1.11113       1.11113       106.582       107.693    
  23  0.698821     -0.358360     -0.201080      0.201080       107.310       107.511    
  24  0.603237     -0.505446     -0.283611      0.283611       106.650       106.934    
  25  0.253585      -1.37205     -0.769874      0.769874       107.283       108.053    
  26  0.404885     -0.904153     -0.507329      0.507329       107.189       107.696    
  27  0.802083     -0.220543     -0.123749      0.123749       106.444       106.568    
  28  0.756447     -0.279123     -0.156619      0.156619       107.044       107.200    
  29  0.390929     -0.939231     -0.527012      0.527012       107.572       108.099    
  30  0.260757      -1.34417     -0.754226      0.754226       106.979       107.733    
  31  0.177681      -1.72776     -0.969467      0.969467       105.987       106.957    
  32  0.806362     -0.215223     -0.120764      0.120764       107.359       107.480    
  33  0.222380      -1.50337     -0.843554      0.843554       107.460       108.303    
  34  0.969986     -0.304736E-01 -0.170990E-01  0.170990E-01   105.770       105.787    
  35  0.417166     -0.874272     -0.490563      0.490563       107.308       107.798    
  36  0.212672      -1.54800     -0.868601      0.868601       107.960       108.829    
  37  0.141187      -1.95767      -1.09847       1.09847       107.327       108.425    
  38  0.750343     -0.287224     -0.161164      0.161164       108.345       108.507    
  39  0.628172     -0.464941     -0.260883      0.260883       108.292       108.553    
  40  0.466629     -0.762221     -0.427690      0.427690       105.870       106.297    
  41  0.120425      -2.11672      -1.18772       1.18772       107.114       108.301    
  42  0.179567      -1.71721     -0.963544      0.963544       108.870       109.834    
  43  0.209268      -1.56414     -0.877655      0.877655       108.613       109.490    
  44  0.730304E-01  -2.61688      -1.46836       1.46836       108.464       109.932    
  45  0.985392     -0.147157E-01 -0.825715E-02  0.825715E-02   109.148       109.156    
  46  0.726759E-01  -2.62175      -1.47109       1.47109       109.814       111.285    
loop,thermsimp(1:2)       88  0.422377      0.355136    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    356        108.59         67.91          1.12         42.10          0.24          0.05        111.43
Just calling func    0   0        111.43


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    108.59
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       88
neval is:      355
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       88      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       89
neval is:      355


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      355     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.350369      -1.04877     -0.588475      0.588475       104.294       104.883    
   2  0.650675     -0.429745     -0.241134      0.241134       104.538       104.779    
   3  0.849247     -0.163405     -0.916884E-01  0.916884E-01   104.407       104.498    
   4  0.910703     -0.935381E-01 -0.524852E-01  0.524852E-01   104.808       104.860    
   5  0.188892      -1.66658     -0.935134      0.935134       105.511       106.447    
   6  0.256564      -1.36038     -0.763322      0.763322       105.487       106.250    
   7  0.465488E-01  -3.06725      -1.72107       1.72107       105.770       107.491    
   8  0.824855     -0.192548     -0.108041      0.108041       104.387       104.495    
   9  0.730565     -0.313937     -0.176153      0.176153       105.856       106.032    
  10  0.888077     -0.118697     -0.666020E-01  0.666020E-01   105.372       105.439    
  11  0.898172     -0.107394     -0.602599E-01  0.602599E-01   105.672       105.732    
  12  0.314974      -1.15527     -0.648232      0.648232       105.870       106.518    
  13  0.247979      -1.39441     -0.782418      0.782418       105.182       105.965    
  14  0.330032E-01  -3.41115      -1.91403       1.91403       105.004       106.918    
  15  0.570783E-01  -2.86333      -1.60664       1.60664       106.255       107.862    
  16  0.694187     -0.365014     -0.204813      0.204813       106.120       106.325    
  17  0.314834      -1.15571     -0.648480      0.648480       106.444       107.093    
  18  0.917621     -0.859711E-01 -0.482393E-01  0.482393E-01   106.398       106.446    
  19  0.613858     -0.487991     -0.273817      0.273817       105.936       106.210    
  20  0.744084E-01  -2.59819      -1.45787       1.45787       106.577       108.035    
  21  0.454198     -0.789221     -0.442840      0.442840       106.050       106.492    
  22  0.118203E-01  -4.43793      -2.49017       2.49017       106.650       109.140    
  23  0.746996     -0.291695     -0.163673      0.163673       105.987       106.151    
  24  0.416160     -0.876686     -0.491918      0.491918       106.384       106.876    
  25  0.339178E-01  -3.38381      -1.89869       1.89869       107.064       108.963    
  26  0.824080     -0.193487     -0.108568      0.108568       107.044       107.152    
  27  0.589652     -0.528223     -0.296391      0.296391       107.201       107.498    
  28  0.680293     -0.385231     -0.216157      0.216157       107.359       107.575    
  29  0.864872E-01  -2.44776      -1.37346       1.37346       107.310       108.683    
  30  0.672988     -0.396027     -0.222215      0.222215       106.582       106.804    
  31  0.797049E-01  -2.52942      -1.41929       1.41929       107.189       108.608    
  32  0.831708     -0.184273     -0.103398      0.103398       106.979       107.082    
  33  0.280253E-01  -3.57465      -2.00577       2.00577       107.308       109.314    
  34  0.131717      -2.02710      -1.13743       1.13743       107.283       108.420    
  35  0.343675      -1.06806     -0.599299      0.599299       107.572       108.171    
  36  0.280745      -1.27031     -0.712784      0.712784       107.114       107.826    
  37  0.322275      -1.13235     -0.635374      0.635374       107.460       108.095    
  38  0.769830E-01  -2.56417      -1.43878       1.43878       107.327       108.766    
  39  0.851798     -0.160406     -0.900052E-01  0.900052E-01   108.345       108.435    
  40  0.864683     -0.145392     -0.815809E-01  0.815809E-01   108.292       108.374    
  41  0.157880      -1.84592      -1.03576       1.03576       107.960       108.996    
  42  0.371895     -0.989143     -0.555018      0.555018       109.148       109.703    
  43  0.861425     -0.149167     -0.836992E-01  0.836992E-01   108.613       108.696    
  44  0.778275E-01  -2.55326      -1.43266       1.43266       108.870       110.303    
  45  0.450106     -0.798272     -0.447919      0.447919       108.464       108.912    
  46  0.188928      -1.66639     -0.935029      0.935029       108.593       109.528    
loop,thermsimp(1:2)       89  0.588475      0.241134    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    357        104.51         67.96          1.10         41.90          0.63          0.05        111.65
Just calling func    0   0        111.65


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    358        111.05         68.03          1.10         42.01          0.58          0.05        111.78
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    104.51
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       89
neval is:      357
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       89      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       90
neval is:      357


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      357     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.131617      -2.02786      -1.13785       1.13785       104.387       105.525    
   2  0.314760      -1.15594     -0.648612      0.648612       104.407       105.055    
   3  0.748375     -0.289851     -0.162638      0.162638       104.538       104.700    
   4  0.632472     -0.458119     -0.257055      0.257055       104.808       105.065    
   5  0.677472     -0.389387     -0.218489      0.218489       104.294       104.513    
   6  0.433475     -0.835921     -0.469044      0.469044       105.372       105.841    
   7  0.458976     -0.778758     -0.436969      0.436969       105.672       106.109    
   8  0.411427E-02  -5.49329      -3.08234       3.08234       105.182       108.265    
   9  0.904989     -0.998322E-01 -0.560169E-01  0.560169E-01   105.856       105.912    
  10  0.480311     -0.733322     -0.411474      0.411474       105.987       106.399    
  11  0.277870      -1.28060     -0.718558      0.718558       105.936       106.655    
  12  0.958372     -0.425196E-01 -0.238582E-01  0.238582E-01   105.487       105.511    
  13  0.321639      -1.13432     -0.636481      0.636481       106.120       106.757    
  14  0.562333     -0.575660     -0.323009      0.323009       106.398       106.721    
  15  0.665565     -0.407119     -0.228438      0.228438       105.511       105.740    
  16  0.307614      -1.17891     -0.661499      0.661499       106.050       106.711    
  17  0.504790E-01  -2.98620      -1.67559       1.67559       105.870       107.545    
  18  0.361959      -1.01622     -0.570214      0.570214       106.582       107.152    
  19  0.470787     -0.753350     -0.422713      0.422713       106.384       106.806    
  20  0.312221      -1.16404     -0.653156      0.653156       105.004       105.657    
  21  0.156792      -1.85283      -1.03964       1.03964       106.979       108.018    
  22  0.445216     -0.809196     -0.454048      0.454048       106.444       106.898    
  23  0.999492     -0.508321E-03 -0.285224E-03  0.285224E-03   107.044       107.044    
  24  0.167067      -1.78936      -1.00403       1.00403       105.770       106.774    
  25  0.435083     -0.832219     -0.466967      0.466967       107.201       107.668    
  26  0.110403      -2.20362      -1.23647       1.23647       107.359       108.596    
  27  0.704194     -0.350701     -0.196782      0.196782       107.114       107.310    
  28  0.767816     -0.264205     -0.148248      0.148248       106.255       106.403    
  29  0.231293      -1.46407     -0.821504      0.821504       106.577       107.398    
  30  0.965513     -0.350953E-01 -0.196923E-01  0.196923E-01   107.460       107.479    
  31  0.674440     -0.393873     -0.221006      0.221006       107.572       107.793    
  32  0.248626      -1.39181     -0.780957      0.780957       108.292       109.073    
  33  0.461218     -0.773884     -0.434234      0.434234       107.283       107.717    
  34  0.778910     -0.249859     -0.140199      0.140199       108.345       108.486    
  35  0.665530     -0.407172     -0.228468      0.228468       107.189       107.417    
  36  0.383296     -0.958947     -0.538075      0.538075       107.310       107.848    
  37  0.492311     -0.708645     -0.397628      0.397628       108.613       109.010    
  38  0.631911     -0.459006     -0.257553      0.257553       107.327       107.585    
  39  0.150454E-01  -4.19668      -2.35480       2.35480       108.464       110.819    
  40  0.958677     -0.422006E-01 -0.236792E-01  0.236792E-01   107.064       107.088    
  41  0.411899     -0.886977     -0.497692      0.497692       107.960       108.458    
  42  0.466999     -0.761428     -0.427245      0.427245       106.650       107.078    
  43  0.622674     -0.473731     -0.265816      0.265816       107.308       107.574    
  44  0.497710     -0.697737     -0.391507      0.391507       108.593       108.985    
  45  0.763352E-01  -2.57262      -1.44352       1.44352       109.148       110.592    
  46  0.192360      -1.64839     -0.924926      0.924926       104.509       105.434    
loop,thermsimp(1:2)       90   1.13785      0.648612    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    359        104.72         67.97          1.11         42.64          0.67          0.05        112.44
Just calling func    0   0        112.44


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    104.72
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       90
neval is:      358
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       90      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       91
neval is:      358


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      358     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.920377     -0.829717E-01 -0.465563E-01  0.465563E-01   104.294       104.341    
   2  0.393393     -0.932946     -0.523485      0.523485       104.538       105.061    
   3  0.317218      -1.14817     -0.644248      0.644248       104.407       105.051    
   4  0.324247      -1.12625     -0.631950      0.631950       104.808       105.440    
   5  0.515746E-01  -2.96473      -1.66354       1.66354       104.509       106.173    
   6  0.143224      -1.94335      -1.09043       1.09043       105.487       106.578    
   7  0.512136     -0.669164     -0.375475      0.375475       104.387       104.763    
   8  0.993896     -0.612239E-02 -0.343534E-02  0.343534E-02   105.004       105.007    
   9  0.440900     -0.818937     -0.459514      0.459514       105.511       105.971    
  10  0.861233     -0.149390     -0.838245E-01  0.838245E-01   105.372       105.456    
  11  0.690005     -0.371056     -0.208204      0.208204       105.856       106.064    
  12  0.192792      -1.64614     -0.923668      0.923668       105.672       106.596    
  13  0.975175     -0.251388E-01 -0.141056E-01  0.141056E-01   105.987       106.001    
  14  0.595327E-01  -2.82123      -1.58302       1.58302       106.255       107.838    
  15  0.142661      -1.94729      -1.09264       1.09264       105.936       107.029    
  16  0.141610      -1.95468      -1.09679       1.09679       106.050       107.146    
  17  0.976591     -0.236872E-01 -0.132912E-01  0.132912E-01   106.398       106.411    
  18  0.894748     -0.111213     -0.624030E-01  0.624030E-01   106.120       106.183    
  19  0.747310     -0.291275     -0.163437      0.163437       105.770       105.933    
  20  0.434887     -0.832670     -0.467220      0.467220       106.384       106.851    
  21  0.673581     -0.395146     -0.221721      0.221721       106.444       106.666    
  22  0.624944     -0.470094     -0.263775      0.263775       107.044       107.307    
  23  0.617967     -0.481321     -0.270074      0.270074       106.650       106.920    
  24  0.659853     -0.415739     -0.233275      0.233275       107.064       107.297    
  25  0.963159E-01  -2.34012      -1.31307       1.31307       106.582       107.895    
  26  0.179190      -1.71931     -0.964722      0.964722       107.114       108.078    
  27  0.251042      -1.38213     -0.775529      0.775529       106.577       107.352    
  28  0.116711      -2.14806      -1.20530       1.20530       107.189       108.394    
  29  0.890376     -0.116112     -0.651515E-01  0.651515E-01   107.460       107.525    
  30  0.880065E-02  -4.73293      -2.65570       2.65570       105.870       108.525    
  31  0.613810     -0.488070     -0.273861      0.273861       107.308       107.582    
  32  0.960436E-01  -2.34295      -1.31465       1.31465       107.327       108.642    
  33  0.768907E-02  -4.86796      -2.73146       2.73146       107.201       109.933    
  34  0.316163      -1.15150     -0.646116      0.646116       107.283       107.929    
  35  0.195769      -1.63082     -0.915068      0.915068       107.572       108.487    
  36  0.813020     -0.207000     -0.116150      0.116150       107.310       107.426    
  37  0.578245     -0.547758     -0.307353      0.307353       106.979       107.286    
  38  0.711511     -0.340365     -0.190982      0.190982       105.182       105.373    
  39  0.565886     -0.569362     -0.319475      0.319475       107.960       108.280    
  40  0.874556     -0.134039     -0.752107E-01  0.752107E-01   108.345       108.421    
  41  0.335685      -1.09158     -0.612497      0.612497       107.359       107.972    
  42  0.861776     -0.148759     -0.834705E-01  0.834705E-01   108.593       108.677    
  43  0.634500     -0.454918     -0.255259      0.255259       108.613       108.868    
  44  0.211879      -1.55174     -0.870698      0.870698       108.292       109.163    
  45  0.789454     -0.236414     -0.132655      0.132655       109.148       109.281    
  46  0.726316E-01  -2.62235      -1.47143       1.47143       104.724       106.196    
loop,thermsimp(1:2)       91  0.465563E-01  0.523485    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    360        105.33         67.94          1.11         42.18          0.47          0.05        111.76
Just calling func    0   0        111.76


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    361        110.16         68.06          1.11         42.20          0.30          0.05        111.72
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  360    110.16       0.5848     -3.588      2.578     -102.6    -0.5886    
                      0.9710     0.1631     -99.70      4.380      1.248    

                       1.965     -2.595      1.540      8067.      7000.    

                      0.6624      0.000      0.000      0.000     -1.221    



                      -2.506      0.000      0.000      7000.      271.1    

                       1.972     -4.457     -8.828     -9.387      7.796    

                      -18.13     -10.20      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.3943    -0.9584      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.4646     -1.213      7000.    



                      -2.073     -2.153     -1.880     -1.943    -0.3807    

                     -0.3252      9.679      8.829    -0.1459E+05 -4.607    

                      -1.435     -3.725      9.443      8.926    -0.1969E+05



                      -6.000     0.5479     0.3446E-01  9.045      8.923    

                     -0.1944E+05 -6.000     -1.340    -0.3293      9.135    

                       8.903    -0.1891E+05 -6.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    105.33
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       91
neval is:      360
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       91      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       92
neval is:      360


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      360     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.313932      -1.15858     -0.650090      0.650090       104.294       104.944    
   2  0.484866     -0.723883     -0.406178      0.406178       104.387       104.793    
   3  0.743257     -0.296713     -0.166489      0.166489       105.004       105.171    
   4  0.476659     -0.740953     -0.415756      0.415756       104.407       104.822    
   5  0.895662E-01  -2.41278      -1.35383       1.35383       104.538       105.891    
   6  0.100541      -2.29719      -1.28897       1.28897       105.182       106.471    
   7  0.394309     -0.930621     -0.522181      0.522181       104.808       105.330    
   8  0.856201     -0.155250     -0.871123E-01  0.871123E-01   105.372       105.459    
   9  0.903325     -0.101673     -0.570498E-01  0.570498E-01   105.770       105.827    
  10  0.849389     -0.163238     -0.915944E-01  0.915944E-01   105.511       105.603    
  11  0.245876      -1.40293     -0.787198      0.787198       105.987       106.775    
  12  0.535664     -0.624247     -0.350272      0.350272       105.856       106.206    
  13  0.509317     -0.674685     -0.378572      0.378572       104.509       104.888    
  14  0.103141      -2.27166      -1.27465       1.27465       106.120       107.395    
  15  0.822327     -0.195617     -0.109763      0.109763       104.724       104.834    
  16  0.293454      -1.22603     -0.687940      0.687940       106.398       107.086    
  17  0.610098E-01  -2.79672      -1.56927       1.56927       105.487       107.056    
  18  0.467864E-01  -3.06216      -1.71821       1.71821       105.672       107.390    
  19  0.888641     -0.118062     -0.662456E-01  0.662456E-01   106.444       106.510    
  20  0.371769     -0.989482     -0.555209      0.555209       106.384       106.939    
  21  0.770202     -0.261103     -0.146507      0.146507       106.650       106.797    
  22  0.752967E-01  -2.58632      -1.45121       1.45121       105.936       107.388    
  23  0.787365E-01  -2.54165      -1.42615       1.42615       106.050       107.476    
  24  0.516026     -0.661597     -0.371229      0.371229       106.979       107.350    
  25  0.133613      -2.01281      -1.12941       1.12941       107.064       108.193    
  26  0.705575     -0.348742     -0.195683      0.195683       107.044       107.239    
  27  0.747326     -0.291254     -0.163426      0.163426       106.577       106.740    
  28  0.941066E-01  -2.36333      -1.32609       1.32609       107.310       108.636    
  29  0.243001      -1.41469     -0.793797      0.793797       107.460       108.254    
  30  0.186020      -1.68190     -0.943732      0.943732       107.308       108.252    
  31  0.707073     -0.346621     -0.194493      0.194493       106.255       106.450    
  32  0.820399     -0.197964     -0.111080      0.111080       106.582       106.693    
  33  0.169787E-01  -4.07580      -2.28697       2.28697       107.283       109.570    
  34  0.196118      -1.62904     -0.914071      0.914071       107.359       108.273    
  35  0.910420E-01  -2.39643      -1.34466       1.34466       107.114       108.458    
  36  0.101963      -2.28314      -1.28110       1.28110       107.960       109.241    
  37  0.816143     -0.203166     -0.113998      0.113998       107.189       107.303    
  38  0.921931     -0.812847E-01 -0.456097E-01  0.456097E-01   108.345       108.391    
  39  0.867385     -0.142273     -0.798306E-01  0.798306E-01   107.572       107.652    
  40  0.534867     -0.625737     -0.351108      0.351108       105.870       106.221    
  41  0.354961      -1.03575     -0.581169      0.581169       107.327       107.908    
  42  0.707205     -0.346435     -0.194388      0.194388       108.593       108.787    
  43  0.341296      -1.07501     -0.603197      0.603197       108.613       109.216    
  44  0.615332     -0.485594     -0.272472      0.272472       108.292       108.565    
  45  0.100325      -2.29934      -1.29018       1.29018       109.148       110.438    
  46  0.218012      -1.52321     -0.854686      0.854686       105.331       106.186    
loop,thermsimp(1:2)       92  0.650090      0.406178    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    362        105.83         67.83          1.08         42.24          0.34          0.05        111.54
Just calling func    0   0        111.54


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    105.83
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       92
neval is:      361
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       92      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       93
neval is:      361


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      361
neval,tstepnext:      361     361

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.642285E-02  -5.04789      -2.83242       2.83242       104.387       107.220    
   2  0.977343     -0.229176E-01 -0.128593E-01  0.128593E-01   104.407       104.419    
   3  0.515611     -0.662402     -0.371681      0.371681       104.724       105.096    
   4  0.985018     -0.150949E-01 -0.846993E-02  0.846993E-02   104.509       104.518    
   5  0.909744E-01  -2.39718      -1.34508       1.34508       104.294       105.639    
   6  0.163485      -1.81103      -1.01619       1.01619       105.004       106.020    
   7  0.709610     -0.343039     -0.192483      0.192483       104.808       105.000    
   8  0.639309     -0.447368     -0.251023      0.251023       105.372       105.623    
   9  0.500633     -0.691882     -0.388222      0.388222       105.511       105.900    
  10  0.623218     -0.472859     -0.265326      0.265326       105.770       106.035    
  11  0.974620     -0.257075E-01 -0.144247E-01  0.144247E-01   104.538       104.552    
  12  0.940866     -0.609540E-01 -0.342019E-01  0.342019E-01   105.331       105.366    
  13  0.268848      -1.31361     -0.737079      0.737079       105.856       106.593    
  14  0.131404      -2.02948      -1.13876       1.13876       105.870       107.008    
  15  0.242045      -1.41863     -0.796009      0.796009       106.255       107.051    
  16  0.333489      -1.09815     -0.616181      0.616181       105.182       105.798    
  17  0.540917     -0.614489     -0.344796      0.344796       106.444       106.789    
  18  0.935945     -0.661981E-01 -0.371445E-01  0.371445E-01   106.582       106.619    
  19  0.948265     -0.531218E-01 -0.298072E-01  0.298072E-01   106.577       106.607    
  20  0.306672      -1.18198     -0.663220      0.663220       105.987       106.651    
  21  0.674766E-01  -2.69597      -1.51274       1.51274       106.650       108.163    
  22  0.304885      -1.18782     -0.666499      0.666499       106.384       107.050    
  23  0.987276     -0.128055E-01 -0.718527E-02  0.718527E-02   105.487       105.494    
  24  0.866309     -0.143514     -0.805272E-01  0.805272E-01   106.398       106.478    
  25  0.325072      -1.12371     -0.630524      0.630524       107.044       107.674    
  26  0.882651     -0.124826     -0.700411E-01  0.700411E-01   107.189       107.259    
  27  0.608994E-02  -5.10112      -2.86229       2.86229       106.979       109.841    
  28  0.956776     -0.441859E-01 -0.247931E-01  0.247931E-01   105.936       105.961    
  29  0.680690E-01  -2.68723      -1.50783       1.50783       105.672       107.180    
  30  0.870194     -0.139039     -0.780162E-01  0.780162E-01   106.120       106.198    
  31  0.154954      -1.86463      -1.04626       1.04626       106.050       107.096    
  32  0.533144     -0.628963     -0.352918      0.352918       107.572       107.925    
  33  0.848128     -0.164724     -0.924282E-01  0.924282E-01   107.327       107.419    
  34  0.302343E-01  -3.49878      -1.96320       1.96320       107.064       109.027    
  35  0.670768     -0.399332     -0.224069      0.224069       107.308       107.532    
  36  0.575709     -0.552152     -0.309818      0.309818       107.460       107.770    
  37  0.961243     -0.395278E-01 -0.221795E-01  0.221795E-01   107.359       107.381    
  38  0.174287      -1.74705     -0.980290      0.980290       108.345       109.326    
  39  0.450902     -0.796506     -0.446928      0.446928       107.114       107.561    
  40  0.807155     -0.214240     -0.120212      0.120212       108.292       108.412    
  41  0.245094E-01  -3.70870      -2.08099       2.08099       107.310       109.391    
  42  0.840819     -0.173379     -0.972845E-01  0.972845E-01   108.593       108.690    
  43  0.418157     -0.871899     -0.489232      0.489232       108.613       109.102    
  44  0.795491     -0.228796     -0.128380      0.128380       107.960       108.088    
  45  0.675445E-01  -2.69497      -1.51217       1.51217       107.283       108.795    
  46  0.158617      -1.84126      -1.03315       1.03315       105.832       106.865    
loop,thermsimp(1:2)       93   2.83242      0.128593E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    363        105.70         67.93          1.12         42.19          0.56          0.05        111.85
Just calling func    0   0        111.85


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    105.70
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.561110               361
loop is:       93
neval is:      362
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       93      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.561110               361
loop is:       94
neval is:      362


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 




neval>tstepnex so lower away!t
---> lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
     new SAtemp,tstepnext are :   0.280555               406

 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      362     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.415683     -0.877831     -0.246280      0.246280       104.407       104.653    
   2  0.262668E-01  -3.63945      -1.02107       1.02107       104.509       105.530    
   3  0.620248     -0.477636     -0.134003      0.134003       104.538       104.672    
   4  0.249183      -1.38957     -0.389850      0.389850       104.808       105.198    
   5  0.999872     -0.128438E-03 -0.360339E-04  0.360339E-04   104.724       104.724    
   6  0.933252     -0.690802E-01 -0.193808E-01  0.193808E-01   105.331       105.351    
   7  0.857047     -0.154263     -0.432793E-01  0.432793E-01   105.487       105.530    
   8  0.365787      -1.00570     -0.282155      0.282155       105.372       105.654    
   9  0.499682     -0.693784     -0.194645      0.194645       104.294       104.489    
  10  0.761560     -0.272387     -0.764195E-01  0.764195E-01   105.182       105.259    
  11  0.793904E-01  -2.53338     -0.710752      0.710752       105.511       106.222    
  12  0.514449     -0.664659     -0.186473      0.186473       105.936       106.123    
  13  0.678176     -0.388349     -0.108953      0.108953       105.004       105.113    
  14  0.257558      -1.35651     -0.380576      0.380576       105.770       106.150    
  15  0.832067E-01  -2.48643     -0.697580      0.697580       106.120       106.818    
  16  0.272851      -1.29883     -0.364394      0.364394       106.398       106.762    
  17  0.255245      -1.36553     -0.383107      0.383107       105.856       106.239    
  18  0.419883     -0.867779     -0.243460      0.243460       106.577       106.820    
  19  0.870346     -0.138865     -0.389592E-01  0.389592E-01   106.582       106.621    
  20  0.814510E-01  -2.50775     -0.703563      0.703563       105.987       106.691    
  21  0.560000     -0.579819     -0.162671      0.162671       106.444       106.607    
  22  0.860285     -0.150492     -0.422213E-01  0.422213E-01   105.832       105.874    
  23  0.538601     -0.618780     -0.173602      0.173602       105.870       106.043    
  24  0.542321     -0.611898     -0.171671      0.171671       106.384       106.555    
  25  0.836575     -0.178440     -0.500621E-01  0.500621E-01   106.255       106.305    
  26  0.705694     -0.348574     -0.977943E-01  0.977943E-01   106.050       106.147    
  27  0.301063      -1.20043     -0.336788      0.336788       105.672       106.009    
  28  0.125899      -2.07227     -0.581387      0.581387       104.387       104.969    
  29  0.476747     -0.740770     -0.207827      0.207827       107.189       107.397    
  30  0.676103     -0.391410     -0.109812      0.109812       107.359       107.469    
  31  0.385349     -0.953606     -0.267539      0.267539       107.327       107.595    
  32  0.141470      -1.95567     -0.548672      0.548672       107.308       107.857    
  33  0.146971      -1.91752     -0.537971      0.537971       107.114       107.652    
  34  0.616396     -0.483866     -0.135751      0.135751       107.044       107.179    
  35  0.962361     -0.383659E-01 -0.107638E-01  0.107638E-01   107.460       107.470    
  36  0.618266     -0.480836     -0.134901      0.134901       107.572       107.707    
  37  0.369072     -0.996763     -0.279647      0.279647       107.960       108.240    
  38  0.312675      -1.16259     -0.326171      0.326171       106.650       106.976    
  39  0.367326      -1.00150     -0.280977      0.280977       108.292       108.573    
  40  0.184422      -1.69053     -0.474287      0.474287       108.593       109.067    
  41  0.113088      -2.17959     -0.611496      0.611496       107.283       107.894    
  42  0.333487      -1.09815     -0.308092      0.308092       107.064       107.372    
  43  0.407562     -0.897562     -0.251816      0.251816       108.613       108.864    
  44  0.443434     -0.813206     -0.228149      0.228149       108.345       108.574    
  45  0.265046      -1.32785     -0.372536      0.372536       107.310       107.682    
  46  0.444603     -0.810573     -0.227410      0.227410       105.698       105.926    
loop,thermsimp(1:2)       94  0.246280       1.02107    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    364        109.80         67.96          1.10         42.04          0.63          0.05        111.79
Just calling func    0   0        111.79


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    365        106.00         67.97          1.11         42.07          0.41          0.05        111.61
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    106.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       94
neval is:      364
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       94      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       95
neval is:      364


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      364     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.292887      -1.22797     -0.344513      0.344513       104.294       104.639    
   2  0.225242      -1.49058     -0.418190      0.418190       104.407       104.825    
   3  0.946430E-01  -2.35764     -0.661449      0.661449       104.538       105.199    
   4  0.371694     -0.989684     -0.277661      0.277661       104.724       105.002    
   5  0.933291     -0.690381E-01 -0.193690E-01  0.193690E-01   104.387       104.407    
   6  0.926571     -0.762651E-01 -0.213966E-01  0.213966E-01   105.004       105.025    
   7  0.138048      -1.98015     -0.555542      0.555542       104.808       105.363    
   8  0.113008E-01  -4.48288      -1.25770       1.25770       105.182       106.440    
   9  0.405736     -0.902053     -0.253076      0.253076       105.331       105.584    
  10  0.390885     -0.939341     -0.263537      0.263537       104.509       104.773    
  11  0.873008     -0.135810     -0.381022E-01  0.381022E-01   105.487       105.525    
  12  0.945037     -0.565316E-01 -0.158602E-01  0.158602E-01   105.372       105.388    
  13  0.642194E-01  -2.74545     -0.770250      0.770250       105.832       106.602    
  14  0.322052E-01  -3.43563     -0.963883      0.963883       105.698       106.662    
  15  0.521559     -0.650933     -0.182623      0.182623       105.672       105.855    
  16  0.271788      -1.30273     -0.365489      0.365489       105.870       106.235    
  17  0.153503      -1.87403     -0.525770      0.525770       105.936       106.462    
  18  0.219303      -1.51730     -0.425687      0.425687       106.050       106.475    
  19  0.476616     -0.741044     -0.207904      0.207904       105.770       105.978    
  20  0.510024     -0.673297     -0.188897      0.188897       105.511       105.700    
  21  0.393388     -0.932959     -0.261746      0.261746       105.856       106.118    
  22  0.947927     -0.534776E-01 -0.150034E-01  0.150034E-01   106.255       106.270    
  23  0.472009     -0.750758     -0.210629      0.210629       106.384       106.594    
  24  0.678717     -0.387551     -0.108729      0.108729       106.444       106.553    
  25  0.617620     -0.481882     -0.135195      0.135195       106.582       106.717    
  26  0.138594E-01  -4.27879      -1.20044       1.20044       105.987       107.188    
  27  0.588445     -0.530273     -0.148771      0.148771       106.398       106.546    
  28  0.950805     -0.504465E-01 -0.141530E-01  0.141530E-01   106.120       106.134    
  29  0.444108     -0.811687     -0.227723      0.227723       106.577       106.804    
  30  0.299195      -1.20666     -0.338535      0.338535       106.650       106.989    
  31  0.808517E-01  -2.51514     -0.705635      0.705635       107.044       107.749    
  32  0.493903     -0.705415     -0.197908      0.197908       107.064       107.262    
  33  0.973584     -0.267710E-01 -0.751073E-02  0.751073E-02   107.189       107.196    
  34  0.219889      -1.51463     -0.424938      0.424938       107.359       107.784    
  35  0.872114     -0.136835     -0.383899E-01  0.383899E-01   107.460       107.498    
  36  0.413991     -0.881912     -0.247425      0.247425       107.327       107.574    
  37  0.155656      -1.86011     -0.521863      0.521863       107.114       107.636    
  38  0.744603     -0.294905     -0.827370E-01  0.827370E-01   107.310       107.393    
  39  0.627736     -0.465635     -0.130636      0.130636       107.572       107.702    
  40  0.137880      -1.98137     -0.555883      0.555883       107.308       107.864    
  41  0.270817      -1.30631     -0.366493      0.366493       107.283       107.649    
  42  0.271872      -1.30243     -0.365402      0.365402       107.960       108.325    
  43  0.988104     -0.119670E-01 -0.335740E-02  0.335740E-02   108.292       108.296    
  44  0.837729E-01  -2.47965     -0.695677      0.695677       108.345       109.041    
  45  0.731806     -0.312240     -0.876007E-01  0.876007E-01   108.613       108.700    
  46  0.520356     -0.653242     -0.183270      0.183270       106.001       106.184    
loop,thermsimp(1:2)       95  0.344513      0.418190    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    366        103.68         67.93          1.09         42.20          0.42          0.05        111.70
Just calling func    0   0        111.70


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    367        112.32         67.86          1.07         42.20          0.31          0.05        111.49
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    103.68
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       95
neval is:      366
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       95      95
 right before GO TO 250



 right after: 250 IF (loop < nloop) CYCLE Main_loop 
loop,nloop:       95      95
loop was equal to nloop so did not start main cycle again, now will do the following: 




calculate mean & stdev of func values for current simplex (hmean,hstd)
 write hstd
 RMS of function values of last simplex =   1.13328    

hmean,hstd :    106.135       1.13328    


writing best so far by calling functn2 
 but just writing params not moments. see the change in functn2
hmean,hstd :    106.135       1.13328    
h(1),h(best1),h(np1) :    104.387       103.681       103.681    
htherm(1),htherm(best1),htherm(np1) :    104.407       109.041       109.041    


 CHECK hstd>?stopcr
---------> IF hstd>stopcr (and maxfn,neval.nevalp conditions as well) then set iflag and loop to zero and go to the start of the main cycle again 
---------> IF hstd<=stopcr then find the centroid of the current simplex and get the function value there 
 ............
 ............
 ............
 ............
  .NOT. (hstd > stopcr .AND. (((maxfn>=0).AND.(neval <= maxfn)).OR.((maxfn<0).AND.(nevalp <= -1*maxfn))  )) 
  so find the centroid of current simplex and get teh function value there 
  call functn(p,func) 
  neval = neval + 1
  nevalp = nevalp + 1
  IF ((iprint > 0).AND.(realrank==0)) THEN 
     IF (MOD(neval,iprint) == 0) WRITE (lout,5100) neval, func, p 
  END IF  
  CHECK wtr the no. of func values allowed, maxfn, has been overrun. if so, exit with ifault= 1 
  IF maxfn>0 check based on neval. if maxfn<0 check based on nevalp. 
  i.e.: ---->IF (((maxfn>=0).AND.(neval > maxfn)).OR.((maxfn<0).AND.(nevalp > -1*maxfn))) THEN
        ---->IF the above if statement true then something ... RETURN 
        ---->IF the above if statement not true then you get out of that if statement ... CONVGENCE CRTI SATISFIED - RETURN 
 ............
 ............
iter,obj,time:    368        103.84         67.87          1.11         42.24          0.41          0.05        111.68

 EVIDENCE OF CONVERGENCE

 Centroid of last simplex =
   0.58933      -3.0578       2.5254      -102.60      0.28409       1.1040    

   0.58672      -99.700       4.5879       1.1688       1.5813      -2.4815    

    1.5400       7673.5       7000.0      0.46476       0.0000       0.0000    

    0.0000      -1.2210      -2.3093       0.0000       0.0000       7000.0    


    611.46       1.8659      -4.5897      -6.3653      -8.1846       7.8744    

   -17.935      -7.4434       5362.0       0.0000       6393.0       2126.0    

    6450.0       6136.0       2928.0       4107.0       3756.0      0.11050E-01

   0.25440     -0.33480E-01  0.15100     -0.24860     -0.14460      0.13940    


   0.80450E-01  0.91570E-01 -0.38214     -0.87314       0.0000      0.84570E-01

  -0.39310E-01 -0.46970E-01  0.14310     -0.71160     -0.11410      0.26950    

   0.32880E-01  0.15250E-02 -0.50799      -1.1725       7000.0      -1.8167    

   -1.6997      -1.9990      -1.9431     -0.38070     -0.32520       9.2614    


    8.7935      -15057.      -5.0179     -0.71650      -3.3937       9.3900    

    8.8841      -19690.      -6.0000      0.57708     -0.48386E-01   8.9932    

    8.9576      -19440.      -6.0000      -1.2092     -0.33173       9.1293    

    8.8617      -18910.      -6.0000    
 Function value at centroid =   103.843    

beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:        1
neval is:      367


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      367     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.195490      -1.63225     -0.457935      0.457935       104.387       104.845    
   2  0.313379      -1.16034     -0.325540      0.325540       104.294       104.620    
   3  0.769177     -0.262434     -0.736272E-01  0.736272E-01   104.509       104.583    
   4  0.884560E-01  -2.42525     -0.680416      0.680416       104.407       105.087    
   5  0.890596     -0.115865     -0.325065E-01  0.325065E-01   104.724       104.757    
   6  0.657268     -0.419664     -0.117739      0.117739       105.004       105.122    
   7  0.960898     -0.398874E-01 -0.111906E-01  0.111906E-01   104.538       104.549    
   8  0.613422E-01  -2.79129     -0.783110      0.783110       104.808       105.591    
   9  0.264483E-01  -3.63256      -1.01913       1.01913       105.372       106.391    
  10  0.304822      -1.18803     -0.333308      0.333308       105.487       105.820    
  11  0.977907     -0.223409E-01 -0.626785E-02  0.626785E-02   105.331       105.338    
  12  0.746737     -0.292042     -0.819340E-01  0.819340E-01   105.511       105.593    
  13  0.450918E-01  -3.09905     -0.869456      0.869456       105.672       106.542    
  14  0.625433     -0.469311     -0.131668      0.131668       105.770       105.901    
  15  0.990029     -0.100208E-01 -0.281138E-02  0.281138E-02   105.856       105.859    
  16  0.985060     -0.150527E-01 -0.422311E-02  0.422311E-02   106.120       106.124    
  17  0.691362     -0.369092     -0.103551      0.103551       106.001       106.104    
  18  0.864323E-02  -4.75098      -1.33291       1.33291       105.870       107.202    
  19  0.908027E-01  -2.39907     -0.673071      0.673071       106.255       106.928    
  20  0.500093     -0.692962     -0.194414      0.194414       105.182       105.377    
  21  0.806913     -0.214539     -0.601901E-01  0.601901E-01   105.936       105.997    
  22  0.317749      -1.14649     -0.321655      0.321655       106.050       106.371    
  23  0.753050     -0.283623     -0.795720E-01  0.795720E-01   106.398       106.477    
  24  0.850048     -0.162463     -0.455797E-01  0.455797E-01   106.444       106.490    
  25  0.346718      -1.05924     -0.297176      0.297176       106.384       106.681    
  26  0.731558     -0.312579     -0.876955E-01  0.876955E-01   105.832       105.920    
  27  0.226645      -1.48437     -0.416448      0.416448       105.698       106.115    
  28  0.887805     -0.119003     -0.333868E-01  0.333868E-01   106.582       106.615    
  29  0.277731      -1.28110     -0.359420      0.359420       106.577       106.936    
  30  0.914814     -0.890349E-01 -0.249792E-01  0.249792E-01   106.650       106.675    
  31  0.298911      -1.20761     -0.338801      0.338801       105.987       106.326    
  32  0.469757     -0.755540     -0.211971      0.211971       107.189       107.401    
  33  0.217087      -1.52746     -0.428536      0.428536       107.064       107.493    
  34  0.143996      -1.93797     -0.543708      0.543708       107.310       107.853    
  35  0.873815     -0.134887     -0.378431E-01  0.378431E-01   107.460       107.498    
  36  0.102289      -2.27995     -0.639651      0.639651       107.327       107.967    
  37  0.583483     -0.538740     -0.151146      0.151146       107.114       107.265    
  38  0.308185      -1.17705     -0.330229      0.330229       107.283       107.613    
  39  0.129509      -2.04400     -0.573456      0.573456       107.572       108.145    
  40  0.858329     -0.152767     -0.428597E-01  0.428597E-01   107.044       107.086    
  41  0.247121      -1.39788     -0.392181      0.392181       107.359       107.751    
  42  0.672462     -0.396810     -0.111327      0.111327       107.308       107.419    
  43  0.978226     -0.220145E-01 -0.617628E-02  0.617628E-02   108.292       108.298    
  44  0.571205     -0.560006     -0.157113      0.157113       107.960       108.117    
  45  0.390724E-01  -3.24234     -0.909655      0.909655       108.613       109.522    
  46  0.773307     -0.257080     -0.721250E-01  0.721250E-01   103.681       103.753    
loop,thermsimp(1:2)        1  0.457935      0.325540    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    369        106.11         67.97          1.10         42.54          0.50          0.05        112.16
Just calling func    0   0        112.16


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    106.11
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:        1
neval is:      368
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        1      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:        2
neval is:      368


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      368     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.233544      -1.45438     -0.408035      0.408035       103.681       104.089    
   2  0.293881      -1.22458     -0.343562      0.343562       104.538       104.881    
   3  0.833435     -0.182199     -0.511170E-01  0.511170E-01   104.509       104.560    
   4  0.931284     -0.711905E-01 -0.199729E-01  0.199729E-01   104.294       104.314    
   5  0.965536     -0.350722E-01 -0.983970E-02  0.983970E-02   104.724       104.734    
   6  0.534034     -0.627296     -0.175991      0.175991       104.387       104.563    
   7  0.975689     -0.246118E-01 -0.690495E-02  0.690495E-02   104.407       104.413    
   8  0.958131     -0.427704E-01 -0.119995E-01  0.119995E-01   105.004       105.016    
   9  0.487835     -0.717779     -0.201377      0.201377       105.331       105.533    
  10  0.941751     -0.600144E-01 -0.168373E-01  0.168373E-01   105.182       105.199    
  11  0.764698     -0.268274     -0.752656E-01  0.752656E-01   104.808       104.883    
  12  0.282403      -1.26442     -0.354739      0.354739       105.511       105.866    
  13  0.694349     -0.364781     -0.102341      0.102341       105.487       105.589    
  14  0.257622      -1.35626     -0.380506      0.380506       105.856       106.237    
  15  0.401572     -0.912369     -0.255970      0.255970       105.770       106.026    
  16  0.828654     -0.187952     -0.527309E-01  0.527309E-01   105.832       105.885    
  17  0.113844      -2.17292     -0.609625      0.609625       105.936       106.546    
  18  0.383967     -0.957199     -0.268547      0.268547       106.001       106.269    
  19  0.767294     -0.264886     -0.743150E-01  0.743150E-01   105.698       105.773    
  20  0.230085      -1.46930     -0.412221      0.412221       106.120       106.532    
  21  0.248551      -1.39211     -0.390563      0.390563       105.987       106.378    
  22  0.739043     -0.302399     -0.848395E-01  0.848395E-01   106.050       106.134    
  23  0.427702     -0.849328     -0.238283      0.238283       105.372       105.611    
  24  0.217549      -1.52533     -0.427939      0.427939       106.398       106.826    
  25  0.126759      -2.06546     -0.579477      0.579477       106.444       107.024    
  26  0.278624      -1.27789     -0.358520      0.358520       105.672       106.031    
  27  0.736668     -0.305618     -0.857426E-01  0.857426E-01   106.582       106.667    
  28  0.183809      -1.69386     -0.475220      0.475220       106.650       107.126    
  29  0.915242     -0.885666E-01 -0.248478E-01  0.248478E-01   106.384       106.408    
  30  0.864610     -0.145477     -0.408143E-01  0.408143E-01   106.255       106.296    
  31  0.996457     -0.354911E-02 -0.995721E-03  0.995721E-03   106.577       106.578    
  32  0.937047     -0.650222E-01 -0.182423E-01  0.182423E-01   107.044       107.062    
  33  0.664908     -0.408106     -0.114496      0.114496       105.870       105.984    
  34  0.409422     -0.893009     -0.250538      0.250538       107.114       107.364    
  35  0.293825E-01  -3.52736     -0.989618      0.989618       107.189       108.178    
  36  0.528099     -0.638471     -0.179126      0.179126       107.308       107.487    
  37  0.582244E-01  -2.84345     -0.797745      0.797745       107.064       107.862    
  38  0.394879     -0.929175     -0.260685      0.260685       107.460       107.720    
  39  0.619316     -0.479139     -0.134425      0.134425       107.283       107.417    
  40  0.760056     -0.274363     -0.769740E-01  0.769740E-01   107.359       107.436    
  41  0.322606      -1.13132     -0.317399      0.317399       107.310       107.627    
  42  0.806034     -0.215629     -0.604959E-01  0.604959E-01   107.327       107.387    
  43  0.158197      -1.84391     -0.517319      0.517319       107.960       108.477    
  44  0.964399     -0.362497E-01 -0.101700E-01  0.101700E-01   107.572       107.582    
  45  0.891984     -0.114307     -0.320693E-01  0.320693E-01   108.292       108.324    
  46  0.896576E-01  -2.41176     -0.676631      0.676631       106.107       106.783    
loop,thermsimp(1:2)        2  0.408035      0.343562    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    370        102.21         67.84          1.09         42.19          0.30          0.05        111.46
Just calling func    0   0        111.46


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    371        108.89         67.80          1.09         42.09          0.26          0.05        111.29
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    102.21
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:        2
neval is:      370
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        2      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:        3
neval is:      370


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      370     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.402951     -0.908939     -0.255008      0.255008       103.681       103.936    
   2  0.995767     -0.424237E-02 -0.119022E-02  0.119022E-02   104.294       104.295    
   3  0.232708      -1.45797     -0.409041      0.409041       104.407       104.816    
   4  0.844104     -0.169480     -0.475485E-01  0.475485E-01   104.509       104.557    
   5  0.835080     -0.180228     -0.505638E-01  0.505638E-01   104.387       104.438    
   6  0.492927     -0.707395     -0.198463      0.198463       104.724       104.923    
   7  0.669838     -0.400719     -0.112424      0.112424       104.538       104.650    
   8  0.161727      -1.82184     -0.511128      0.511128       104.808       105.319    
   9  0.712877     -0.338447     -0.949530E-01  0.949530E-01   105.004       105.099    
  10  0.187101      -1.67610     -0.470240      0.470240       105.182       105.653    
  11  0.152475      -1.88075     -0.527655      0.527655       105.331       105.859    
  12  0.299805      -1.20462     -0.337963      0.337963       105.487       105.825    
  13  0.388928     -0.944360     -0.264945      0.264945       105.372       105.637    
  14  0.396030     -0.926264     -0.259868      0.259868       105.698       105.958    
  15  0.795332     -0.228996     -0.642460E-01  0.642460E-01   105.511       105.576    
  16  0.209301      -1.56398     -0.438783      0.438783       105.832       106.271    
  17  0.292717      -1.22855     -0.344676      0.344676       105.870       106.214    
  18  0.128603E-01  -4.35361      -1.22143       1.22143       105.770       106.991    
  19  0.386579E-01  -3.25301     -0.912647      0.912647       105.672       106.585    
  20  0.284417      -1.25731     -0.352746      0.352746       106.050       106.402    
  21  0.962037     -0.387027E-01 -0.108582E-01  0.108582E-01   105.856       105.867    
  22  0.340824      -1.07639     -0.301986      0.301986       106.001       106.303    
  23  0.463892     -0.768103     -0.215495      0.215495       106.255       106.471    
  24  0.772349     -0.258319     -0.724728E-01  0.724728E-01   105.987       106.060    
  25  0.580884     -0.543204     -0.152399      0.152399       106.384       106.536    
  26  0.519264     -0.655343     -0.183860      0.183860       106.120       106.304    
  27  0.336321      -1.08969     -0.305718      0.305718       105.936       106.242    
  28  0.975360     -0.249491E-01 -0.699959E-02  0.699959E-02   106.577       106.584    
  29  0.768530     -0.263276     -0.738634E-01  0.738634E-01   106.582       106.655    
  30  0.536540     -0.622614     -0.174677      0.174677       106.107       106.281    
  31  0.922732     -0.804161E-01 -0.225611E-01  0.225611E-01   106.398       106.420    
  32  0.603353     -0.505252     -0.141751      0.141751       106.444       106.586    
  33  0.927279E-01  -2.37809     -0.667184      0.667184       107.044       107.711    
  34  0.180890      -1.70987     -0.479712      0.479712       106.650       107.130    
  35  0.933825E-01  -2.37105     -0.665211      0.665211       107.114       107.779    
  36  0.343444      -1.06873     -0.299838      0.299838       107.327       107.627    
  37  0.102193      -2.28089     -0.639915      0.639915       107.283       107.923    
  38  0.397576     -0.922370     -0.258776      0.258776       107.359       107.618    
  39  0.455007     -0.787443     -0.220921      0.220921       107.308       107.529    
  40  0.559910     -0.579979     -0.162716      0.162716       107.572       107.735    
  41  0.901058     -0.104186     -0.292299E-01  0.292299E-01   107.310       107.339    
  42  0.849435     -0.163184     -0.457820E-01  0.457820E-01   107.460       107.506    
  43  0.231812      -1.46183     -0.410123      0.410123       107.064       107.474    
  44  0.119620      -2.12344     -0.595741      0.595741       107.189       107.784    
  45  0.885994     -0.121045     -0.339597E-01  0.339597E-01   108.292       108.326    
  46  0.166933      -1.79016     -0.502240      0.502240       102.207       102.709    
loop,thermsimp(1:2)        3  0.255008      0.119022E-02

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    372        114.77         68.05          1.12         42.54          0.34          0.05        112.11
Just calling func    0   0        112.11


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    373        106.37         67.93          1.09         42.21          0.29          0.05        111.58
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    106.37
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:        3
neval is:      372
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        3      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:        4
neval is:      372


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      372     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.344716      -1.06504     -0.298801      0.298801       102.207       102.506    
   2  0.337825      -1.08523     -0.304466      0.304466       103.681       103.986    
   3  0.129257      -2.04595     -0.574003      0.574003       104.294       104.868    
   4  0.218013      -1.52320     -0.427342      0.427342       104.387       104.815    
   5  0.764988     -0.267896     -0.751595E-01  0.751595E-01   104.509       104.584    
   6  0.134235      -2.00816     -0.563400      0.563400       104.538       105.101    
   7  0.921891     -0.813288E-01 -0.228172E-01  0.228172E-01   104.407       104.429    
   8  0.879140E-01  -2.43140     -0.682141      0.682141       104.724       105.406    
   9  0.853506     -0.158403     -0.444406E-01  0.444406E-01   105.004       105.048    
  10  0.781888     -0.246043     -0.690287E-01  0.690287E-01   104.808       104.877    
  11  0.572060     -0.558512     -0.156693      0.156693       105.511       105.668    
  12  0.370929     -0.991745     -0.278239      0.278239       105.372       105.651    
  13  0.659208     -0.416716     -0.116912      0.116912       105.182       105.299    
  14  0.192080      -1.64984     -0.462872      0.462872       105.487       105.950    
  15  0.834249     -0.181224     -0.508432E-01  0.508432E-01   105.331       105.382    
  16  0.275735      -1.28831     -0.361443      0.361443       105.856       106.218    
  17  0.899896     -0.105476     -0.295918E-01  0.295918E-01   105.698       105.728    
  18  0.263842      -1.33241     -0.373813      0.373813       105.987       106.361    
  19  0.542051     -0.612396     -0.171811      0.171811       105.870       106.041    
  20  0.883103     -0.124314     -0.348768E-01  0.348768E-01   105.936       105.971    
  21  0.603547     -0.504931     -0.141661      0.141661       105.832       105.974    
  22  0.461006     -0.774344     -0.217246      0.217246       106.107       106.324    
  23  0.640920     -0.444850     -0.124805      0.124805       106.001       106.125    
  24  0.787319     -0.239122     -0.670869E-01  0.670869E-01   106.120       106.187    
  25  0.258775E-01  -3.65438      -1.02526       1.02526       106.050       107.075    
  26  0.838926     -0.175633     -0.492747E-01  0.492747E-01   106.398       106.447    
  27  0.184807      -1.68845     -0.473702      0.473702       106.255       106.729    
  28  0.642750     -0.441999     -0.124005      0.124005       106.384       106.508    
  29  0.962815     -0.378938E-01 -0.106313E-01  0.106313E-01   106.577       106.587    
  30  0.866393     -0.143417     -0.402363E-01  0.402363E-01   105.672       105.712    
  31  0.652626     -0.426751     -0.119727      0.119727       106.444       106.564    
  32  0.170956      -1.76635     -0.495558      0.495558       106.582       107.077    
  33  0.769008     -0.262654     -0.736889E-01  0.736889E-01   105.770       105.843    
  34  0.156770      -1.85298     -0.519862      0.519862       106.650       107.170    
  35  0.256549E-01  -3.66302      -1.02768       1.02768       107.310       108.337    
  36  0.726661     -0.319295     -0.895798E-01  0.895798E-01   107.064       107.154    
  37  0.556665     -0.585792     -0.164347      0.164347       107.460       107.624    
  38  0.381201     -0.964427     -0.270575      0.270575       107.308       107.578    
  39  0.312648      -1.16268     -0.326195      0.326195       107.359       107.685    
  40  0.523641     -0.646949     -0.181505      0.181505       107.327       107.508    
  41  0.525107     -0.644154     -0.180721      0.180721       107.044       107.224    
  42  0.577096     -0.549746     -0.154234      0.154234       107.572       107.726    
  43  0.218919      -1.51905     -0.426178      0.426178       107.114       107.540    
  44  0.406968     -0.899021     -0.252225      0.252225       107.189       107.441    
  45  0.269244      -1.31214     -0.368127      0.368127       107.283       107.651    
  46  0.150666      -1.89269     -0.531003      0.531003       106.370       106.901    
loop,thermsimp(1:2)        4  0.298801      0.304466    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    374        104.73         68.00          1.11         42.12          0.36          0.05        111.65
Just calling func    0   0        111.65


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    104.73
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:        4
neval is:      373
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        4      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:        5
neval is:      373


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      373     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.993880     -0.613850E-02 -0.172219E-02  0.172219E-02   102.207       102.209    
   2  0.544036     -0.608740     -0.170785      0.170785       103.681       103.852    
   3  0.752151     -0.284818     -0.799071E-01  0.799071E-01   104.407       104.486    
   4  0.128894      -2.04876     -0.574791      0.574791       104.509       105.084    
   5  0.954586     -0.464781E-01 -0.130397E-01  0.130397E-01   104.387       104.400    
   6  0.699109     -0.357949     -0.100424      0.100424       104.294       104.395    
   7  0.158831      -1.83992     -0.516198      0.516198       104.808       105.324    
   8  0.317803      -1.14632     -0.321607      0.321607       105.004       105.326    
   9  0.533633     -0.628047     -0.176202      0.176202       104.538       104.714    
  10  0.232061      -1.46076     -0.409823      0.409823       105.182       105.592    
  11  0.798671     -0.224806     -0.630704E-01  0.630704E-01   105.331       105.394    
  12  0.629719     -0.462482     -0.129752      0.129752       104.724       104.854    
  13  0.285415      -1.25381     -0.351763      0.351763       105.372       105.724    
  14  0.101345      -2.28923     -0.642254      0.642254       105.511       106.154    
  15  0.523846     -0.646557     -0.181395      0.181395       105.672       105.854    
  16  0.570798     -0.560721     -0.157313      0.157313       105.698       105.856    
  17  0.471006     -0.752884     -0.211225      0.211225       105.770       105.981    
  18  0.439034     -0.823179     -0.230947      0.230947       105.487       105.718    
  19  0.755118     -0.280881     -0.788027E-01  0.788027E-01   105.936       106.015    
  20  0.987033     -0.130515E-01 -0.366166E-02  0.366166E-02   105.832       105.836    
  21  0.800390E-01  -2.52524     -0.708469      0.708469       105.870       106.578    
  22  0.739282     -0.302075     -0.847488E-01  0.847488E-01   106.001       106.085    
  23  0.367536      -1.00093     -0.280817      0.280817       106.120       106.401    
  24  0.397431     -0.922735     -0.258878      0.258878       105.856       106.115    
  25  0.338773      -1.08242     -0.303680      0.303680       106.107       106.410    
  26  0.388721     -0.944893     -0.265095      0.265095       105.987       106.252    
  27  0.298998      -1.20732     -0.338719      0.338719       106.398       106.736    
  28  0.668470     -0.402763     -0.112997      0.112997       106.384       106.497    
  29  0.604587     -0.503210     -0.141178      0.141178       106.444       106.585    
  30  0.455577     -0.786190     -0.220570      0.220570       106.577       106.797    
  31  0.842360     -0.171548     -0.481288E-01  0.481288E-01   106.255       106.303    
  32  0.452047     -0.793969     -0.222752      0.222752       106.370       106.593    
  33  0.994488     -0.552709E-02 -0.155065E-02  0.155065E-02   106.050       106.051    
  34  0.309000E-02  -5.77958      -1.62149       1.62149       106.582       108.203    
  35  0.171789      -1.76149     -0.494194      0.494194       107.064       107.558    
  36  0.567417     -0.566661     -0.158980      0.158980       106.650       106.809    
  37  0.885121     -0.122031     -0.342364E-01  0.342364E-01   107.044       107.078    
  38  0.342608      -1.07117     -0.300521      0.300521       107.189       107.489    
  39  0.954017     -0.470733E-01 -0.132067E-01  0.132067E-01   107.327       107.340    
  40  0.439346     -0.822467     -0.230747      0.230747       107.114       107.344    
  41  0.237365E-01  -3.74074      -1.04948       1.04948       107.308       108.357    
  42  0.100236      -2.30023     -0.645341      0.645341       107.460       108.105    
  43  0.539338     -0.617412     -0.173218      0.173218       107.283       107.456    
  44  0.825393     -0.191896     -0.538375E-01  0.538375E-01   107.359       107.413    
  45  0.252744      -1.37538     -0.385869      0.385869       107.572       107.958    
  46  0.676050     -0.391488     -0.109834      0.109834       104.731       104.841    
loop,thermsimp(1:2)        5  0.172219E-02  0.170785    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    375        107.27         67.87          1.08         42.34          0.67          0.05        112.02
Just calling func    0   0        112.02


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    107.27
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:        5
neval is:      374
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        5      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:        6
neval is:      374


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      374     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.342475      -1.07156     -0.300631      0.300631       102.207       102.508    
   2  0.738210     -0.303527     -0.851562E-01  0.851562E-01   103.681       103.766    
   3  0.254388      -1.36889     -0.384051      0.384051       104.294       104.678    
   4  0.184184      -1.69182     -0.474648      0.474648       104.387       104.862    
   5  0.467311     -0.760760     -0.213435      0.213435       104.407       104.620    
   6  0.718957     -0.329953     -0.925701E-01  0.925701E-01   104.538       104.630    
   7  0.233172      -1.45598     -0.408482      0.408482       104.731       105.139    
   8  0.855319     -0.156281     -0.438454E-01  0.438454E-01   104.724       104.768    
   9  0.331323      -1.10466     -0.309918      0.309918       104.509       104.819    
  10  0.737635E-01  -2.60689     -0.731377      0.731377       104.808       105.539    
  11  0.960656     -0.401393E-01 -0.112613E-01  0.112613E-01   105.004       105.015    
  12  0.312287      -1.16383     -0.326519      0.326519       105.331       105.658    
  13  0.252190      -1.37757     -0.386485      0.386485       105.182       105.569    
  14  0.775876     -0.253763     -0.711944E-01  0.711944E-01   105.487       105.558    
  15  0.397248     -0.923194     -0.259007      0.259007       105.372       105.631    
  16  0.587084E-01  -2.83517     -0.795422      0.795422       105.832       106.627    
  17  0.923214     -0.798941E-01 -0.224147E-01  0.224147E-01   105.672       105.695    
  18  0.147001      -1.91731     -0.537912      0.537912       105.698       106.236    
  19  0.275551      -1.28898     -0.361631      0.361631       105.770       106.131    
  20  0.157032      -1.85131     -0.519394      0.519394       105.936       106.456    
  21  0.468534     -0.758146     -0.212702      0.212702       106.050       106.262    
  22  0.101055      -2.29209     -0.643057      0.643057       106.001       106.644    
  23  0.891765     -0.114553     -0.321383E-01  0.321383E-01   105.856       105.888    
  24  0.756241     -0.279395     -0.783857E-01  0.783857E-01   105.511       105.590    
  25  0.212181E-01  -3.85290      -1.08095       1.08095       105.987       107.068    
  26  0.807607     -0.213679     -0.599489E-01  0.599489E-01   106.255       106.315    
  27  0.233854      -1.45306     -0.407663      0.407663       106.120       106.528    
  28  0.622600     -0.473852     -0.132942      0.132942       106.107       106.240    
  29  0.188561      -1.66833     -0.468059      0.468059       106.384       106.852    
  30  0.938432E-01  -2.36613     -0.663830      0.663830       105.870       106.533    
  31  0.846333     -0.166843     -0.468085E-01  0.468085E-01   106.444       106.491    
  32  0.258796      -1.35172     -0.379231      0.379231       106.370       106.750    
  33  0.503854     -0.685469     -0.192312      0.192312       106.398       106.590    
  34  0.577410     -0.549202     -0.154081      0.154081       106.577       106.731    
  35  0.282259E-01  -3.56751      -1.00088       1.00088       106.650       107.651    
  36  0.618901     -0.479811     -0.134613      0.134613       107.044       107.178    
  37  0.563982     -0.572733     -0.160683      0.160683       107.327       107.488    
  38  0.290650      -1.23563     -0.346664      0.346664       107.114       107.460    
  39  0.165662      -1.79781     -0.504384      0.504384       107.359       107.864    
  40  0.871949E-01  -2.43961     -0.684445      0.684445       107.283       107.967    
  41  0.494744     -0.703714     -0.197431      0.197431       107.189       107.386    
  42  0.156326      -1.85581     -0.520657      0.520657       107.064       107.585    
  43  0.558357     -0.582757     -0.163495      0.163495       107.572       107.735    
  44  0.974745     -0.255792E-01 -0.717637E-02  0.717637E-02   107.460       107.467    
  45  0.399321     -0.917991     -0.257547      0.257547       106.582       106.839    
  46  0.649792     -0.431103     -0.120948      0.120948       107.265       107.386    
loop,thermsimp(1:2)        6  0.300631      0.851562E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    376        105.32         67.84          1.10         42.17          0.51          0.04        111.67
Just calling func    0   0        111.67


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    105.32
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:        6
neval is:      375
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        6      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:        7
neval is:      375


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      375     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.667416     -0.404342     -0.113440      0.113440       102.207       102.320    
   2  0.361364E-01  -3.32046     -0.931571      0.931571       103.681       104.613    
   3  0.167171      -1.78874     -0.501839      0.501839       104.407       104.908    
   4  0.268590E-01  -3.61716      -1.01481       1.01481       104.538       105.552    
   5  0.979339     -0.208774E-01 -0.585726E-02  0.585726E-02   104.294       104.300    
   6  0.285956E-01  -3.55450     -0.997234      0.997234       104.724       105.721    
   7  0.614036     -0.487701     -0.136827      0.136827       104.509       104.646    
   8  0.291622      -1.23230     -0.345727      0.345727       104.387       104.733    
   9  0.495778     -0.701626     -0.196845      0.196845       105.004       105.201    
  10  0.289385      -1.24000     -0.347888      0.347888       104.731       105.079    
  11  0.601390     -0.508511     -0.142665      0.142665       104.808       104.951    
  12  0.868837     -0.140599     -0.394458E-01  0.394458E-01   105.487       105.527    
  13  0.289097E-01  -3.54358     -0.994169      0.994169       105.182       106.176    
  14  0.999895     -0.104574E-03 -0.293389E-04  0.293389E-04   105.511       105.511    
  15  0.547924     -0.601620     -0.168787      0.168787       105.372       105.541    
  16  0.562607     -0.575175     -0.161368      0.161368       105.331       105.493    
  17  0.422387     -0.861832     -0.241791      0.241791       105.672       105.914    
  18  0.934703     -0.675264E-01 -0.189449E-01  0.189449E-01   105.856       105.875    
  19  0.484044     -0.725579     -0.203565      0.203565       105.770       105.973    
  20  0.362136      -1.01574     -0.284970      0.284970       105.698       105.983    
  21  0.826677     -0.190341     -0.534011E-01  0.534011E-01   106.107       106.160    
  22  0.383965     -0.957204     -0.268549      0.268549       106.050       106.318    
  23  0.403854     -0.906702     -0.254380      0.254380       106.255       106.510    
  24  0.375365     -0.979857     -0.274904      0.274904       105.936       106.211    
  25  0.335540      -1.09201     -0.306370      0.306370       106.444       106.751    
  26  0.744256     -0.295370     -0.828675E-01  0.828675E-01   106.120       106.203    
  27  0.611040     -0.492593     -0.138199      0.138199       105.870       106.008    
  28  0.361728      -1.01686     -0.285286      0.285286       106.398       106.683    
  29  0.381582     -0.963430     -0.270295      0.270295       105.832       106.102    
  30  0.738884E-01  -2.60520     -0.730902      0.730902       106.001       106.732    
  31  0.185722E-01  -3.98609      -1.11832       1.11832       106.577       107.695    
  32  0.470279     -0.754429     -0.211659      0.211659       106.370       106.582    
  33  0.499505     -0.694139     -0.194744      0.194744       106.582       106.776    
  34  0.641578     -0.443824     -0.124517      0.124517       106.384       106.508    
  35  0.462400     -0.771325     -0.216399      0.216399       105.987       106.204    
  36  0.953656     -0.474527E-01 -0.133131E-01  0.133131E-01   107.044       107.057    
  37  0.305321E-01  -3.48898     -0.978850      0.978850       107.189       108.168    
  38  0.281396      -1.26799     -0.355742      0.355742       107.265       107.621    
  39  0.642231     -0.442807     -0.124232      0.124232       107.114       107.238    
  40  0.506226     -0.680772     -0.190994      0.190994       107.460       107.651    
  41  0.152451      -1.88091     -0.527700      0.527700       107.327       107.855    
  42  0.825356     -0.191941     -0.538499E-01  0.538499E-01   107.064       107.118    
  43  0.895901     -0.109926     -0.308402E-01  0.308402E-01   106.650       106.681    
  44  0.706880     -0.346894     -0.973230E-01  0.973230E-01   107.572       107.669    
  45  0.810453     -0.210162     -0.589621E-01  0.589621E-01   107.359       107.418    
  46  0.463153     -0.769698     -0.215943      0.215943       105.323       105.539    
loop,thermsimp(1:2)        7  0.113440      0.931571    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    377        102.91         67.89          1.10         42.19          0.42          0.05        111.64
Just calling func    0   0        111.64


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    102.91
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:        7
neval is:      376
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        7      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:        8
neval is:      376


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      376     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.832859     -0.182891     -0.513112E-01  0.513112E-01   102.207       102.258    
   2  0.610299     -0.493806     -0.138540      0.138540       104.294       104.433    
   3  0.652915     -0.426308     -0.119603      0.119603       103.681       103.801    
   4  0.273016      -1.29823     -0.364224      0.364224       104.509       104.874    
   5  0.570853     -0.560623     -0.157286      0.157286       104.387       104.545    
   6  0.107477E-01  -4.53306      -1.27177       1.27177       104.407       105.678    
   7  0.651717     -0.428145     -0.120118      0.120118       104.808       104.928    
   8  0.214404      -1.53989     -0.432025      0.432025       104.731       105.163    
   9  0.132680      -2.01982     -0.566670      0.566670       105.004       105.571    
  10  0.370727     -0.992290     -0.278392      0.278392       105.331       105.610    
  11  0.330444      -1.10732     -0.310663      0.310663       105.511       105.822    
  12  0.462713     -0.770647     -0.216209      0.216209       105.487       105.703    
  13  0.514022     -0.665489     -0.186706      0.186706       105.323       105.509    
  14  0.644984     -0.438530     -0.123032      0.123032       105.372       105.495    
  15  0.813975     -0.205826     -0.577456E-01  0.577456E-01   104.538       104.595    
  16  0.434803     -0.832863     -0.233664      0.233664       104.724       104.958    
  17  0.212985      -1.54653     -0.433888      0.433888       105.856       106.290    
  18  0.796179     -0.227931     -0.639471E-01  0.639471E-01   105.672       105.736    
  19  0.259948      -1.34727     -0.377984      0.377984       105.770       106.148    
  20  0.526723     -0.641081     -0.179859      0.179859       105.698       105.878    
  21  0.392691     -0.934731     -0.262244      0.262244       105.870       106.132    
  22  0.949472     -0.518494E-01 -0.145466E-01  0.145466E-01   105.832       105.847    
  23  0.665479E-01  -2.70983     -0.760258      0.760258       106.107       106.867    
  24  0.927466E-01  -2.37788     -0.667128      0.667128       105.182       105.849    
  25  0.630503     -0.461237     -0.129402      0.129402       106.120       106.250    
  26  0.714749     -0.335823     -0.942170E-01  0.942170E-01   105.987       106.082    
  27  0.450999     -0.796290     -0.223403      0.223403       105.936       106.160    
  28  0.184997      -1.68742     -0.473414      0.473414       106.050       106.523    
  29  0.989607     -0.104473E-01 -0.293105E-02  0.293105E-02   106.384       106.387    
  30  0.530766     -0.633434     -0.177713      0.177713       106.255       106.433    
  31  0.495227     -0.702738     -0.197157      0.197157       106.370       106.568    
  32  0.787696     -0.238642     -0.669524E-01  0.669524E-01   106.650       106.717    
  33  0.168123      -1.78306     -0.500247      0.500247       106.398       106.898    
  34  0.205580      -1.58192     -0.443816      0.443816       106.001       106.444    
  35  0.182087      -1.70327     -0.477862      0.477862       106.444       106.922    
  36  0.320489      -1.13791     -0.319246      0.319246       106.582       106.901    
  37  0.591526     -0.525050     -0.147305      0.147305       107.044       107.191    
  38  0.374258     -0.982811     -0.275733      0.275733       107.064       107.340    
  39  0.578871     -0.546675     -0.153372      0.153372       107.114       107.267    
  40  0.542113     -0.612280     -0.171778      0.171778       107.359       107.531    
  41  0.123399      -2.09233     -0.587015      0.587015       107.265       107.852    
  42  0.874747     -0.133820     -0.375440E-01  0.375440E-01   107.460       107.497    
  43  0.521146     -0.651725     -0.182845      0.182845       107.572       107.755    
  44  0.160493      -1.82950     -0.513276      0.513276       106.577       107.090    
  45  0.606451     -0.500131     -0.140314      0.140314       107.327       107.467    
  46  0.947463     -0.539676E-01 -0.151409E-01  0.151409E-01   102.913       102.928    
loop,thermsimp(1:2)        8  0.513112E-01  0.138540    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    378        107.32         67.83          1.08         41.97          0.57          0.05        111.50
Just calling func    0   0        111.50


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    107.32
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:        8
neval is:      377
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        8      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:        9
neval is:      377


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      377     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.193078      -1.64466     -0.461418      0.461418       102.207       102.668    
   2  0.822950     -0.194860     -0.546690E-01  0.546690E-01   102.913       102.967    
   3  0.396787     -0.924357     -0.259333      0.259333       103.681       103.940    
   4  0.141060      -1.95857     -0.549487      0.549487       104.294       104.844    
   5  0.673747     -0.394901     -0.110792      0.110792       104.387       104.498    
   6  0.142835      -1.94606     -0.545978      0.545978       104.538       105.084    
   7  0.707555     -0.345940     -0.970552E-01  0.970552E-01   104.509       104.606    
   8  0.957483     -0.434474E-01 -0.121894E-01  0.121894E-01   104.808       104.820    
   9  0.524586     -0.645145     -0.180999      0.180999       104.724       104.905    
  10  0.692024     -0.368135     -0.103282      0.103282       104.731       104.834    
  11  0.936675E-01  -2.36800     -0.664356      0.664356       105.372       106.037    
  12  0.216270      -1.53123     -0.429594      0.429594       105.323       105.752    
  13  0.329369      -1.11058     -0.311578      0.311578       105.004       105.316    
  14  0.670774     -0.399323     -0.112032      0.112032       105.331       105.443    
  15  0.263445      -1.33391     -0.374235      0.374235       104.407       104.781    
  16  0.150248      -1.89547     -0.531783      0.531783       105.487       106.019    
  17  0.357034      -1.02992     -0.288951      0.288951       105.672       105.961    
  18  0.833286E-01  -2.48496     -0.697169      0.697169       105.511       106.209    
  19  0.431395     -0.840731     -0.235872      0.235872       105.832       106.068    
  20  0.304550      -1.18892     -0.333558      0.333558       105.182       105.516    
  21  0.930203     -0.723520E-01 -0.202987E-01  0.202987E-01   105.698       105.719    
  22  0.443091     -0.813979     -0.228366      0.228366       105.987       106.216    
  23  0.361548      -1.01736     -0.285426      0.285426       105.870       106.155    
  24  0.603851     -0.504427     -0.141520      0.141520       105.770       105.911    
  25  0.825014     -0.192355     -0.539661E-01  0.539661E-01   105.936       105.990    
  26  0.658742     -0.417424     -0.117110      0.117110       106.120       106.237    
  27  0.938632     -0.633319E-01 -0.177681E-01  0.177681E-01   105.856       105.874    
  28  0.264383E-01  -3.63294      -1.01924       1.01924       106.384       107.403    
  29  0.770543     -0.260660     -0.731295E-01  0.731295E-01   106.255       106.328    
  30  0.536385     -0.622903     -0.174759      0.174759       106.001       106.175    
  31  0.173997      -1.74872     -0.490612      0.490612       106.050       106.540    
  32  0.876286     -0.132063     -0.370509E-01  0.370509E-01   106.370       106.407    
  33  0.447573     -0.803915     -0.225543      0.225543       106.650       106.876    
  34  0.521740E-01  -2.95317     -0.828527      0.828527       106.107       106.935    
  35  0.509285     -0.674747     -0.189304      0.189304       106.398       106.587    
  36  0.135259      -2.00056     -0.561268      0.561268       106.582       107.143    
  37  0.238321      -1.43414     -0.402354      0.402354       106.444       106.847    
  38  0.146995      -1.91735     -0.537924      0.537924       106.577       107.115    
  39  0.166047      -1.79549     -0.503733      0.503733       107.044       107.547    
  40  0.830113     -0.186194     -0.522376E-01  0.522376E-01   107.114       107.166    
  41  0.638960     -0.447914     -0.125665      0.125665       107.064       107.190    
  42  0.156696      -1.85345     -0.519995      0.519995       107.327       107.847    
  43  0.956507     -0.444668E-01 -0.124754E-01  0.124754E-01   107.460       107.472    
  44  0.313979      -1.15843     -0.325004      0.325004       107.359       107.684    
  45  0.185265      -1.68597     -0.473007      0.473007       107.572       108.045    
  46  0.952300     -0.488757E-01 -0.137123E-01  0.137123E-01   107.323       107.336    
loop,thermsimp(1:2)        9  0.461418      0.546690E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    379        112.55         68.09          1.10         42.52          0.29          0.05        112.06
Just calling func    0   0        112.06


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    380        106.34         68.02          1.12         42.03          0.60          0.05        111.82
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    106.34
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:        9
neval is:      379
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:        9      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       10
neval is:      379


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      379     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.516123     -0.661410     -0.185562      0.185562       102.207       102.393    
   2  0.677402     -0.389491     -0.109274      0.109274       102.913       103.022    
   3  0.899541     -0.105871     -0.297026E-01  0.297026E-01   103.681       103.711    
   4  0.235706      -1.44517     -0.405450      0.405450       104.387       104.793    
   5  0.194769      -1.63594     -0.458972      0.458972       104.509       104.968    
   6  0.814930     -0.204653     -0.574165E-01  0.574165E-01   104.407       104.464    
   7  0.727423E-01  -2.62083     -0.735288      0.735288       104.808       105.543    
   8  0.126759      -2.06547     -0.579478      0.579478       104.731       105.310    
   9  0.592876     -0.522770     -0.146666      0.146666       104.294       104.441    
  10  0.131380      -2.02966     -0.569433      0.569433       104.724       105.294    
  11  0.394760E-01  -3.23206     -0.906772      0.906772       104.538       105.444    
  12  0.539964     -0.616252     -0.172893      0.172893       105.004       105.177    
  13  0.127256      -2.06155     -0.578380      0.578380       105.331       105.910    
  14  0.245583      -1.40412     -0.393933      0.393933       105.182       105.576    
  15  0.236145E-01  -3.74590      -1.05093       1.05093       105.698       106.749    
  16  0.791943     -0.233266     -0.654439E-01  0.654439E-01   105.323       105.388    
  17  0.223014      -1.50052     -0.420979      0.420979       105.856       106.277    
  18  0.943370     -0.582970E-01 -0.163555E-01  0.163555E-01   105.770       105.786    
  19  0.844237     -0.169322     -0.475041E-01  0.475041E-01   105.672       105.720    
  20  0.600301     -0.510323     -0.143174      0.143174       105.936       106.080    
  21  0.742625E-01  -2.60015     -0.729485      0.729485       105.487       106.217    
  22  0.288925E-01  -3.54417     -0.994336      0.994336       105.372       106.367    
  23  0.325834      -1.12137     -0.314605      0.314605       105.832       106.147    
  24  0.317147      -1.14839     -0.322186      0.322186       105.870       106.192    
  25  0.655873     -0.421788     -0.118335      0.118335       106.001       106.119    
  26  0.259034      -1.35080     -0.378973      0.378973       105.511       105.890    
  27  0.639742E-01  -2.74927     -0.771323      0.771323       105.987       106.759    
  28  0.110416E-01  -4.50609      -1.26421       1.26421       106.120       107.384    
  29  0.768965E-01  -2.56529     -0.719707      0.719707       106.255       106.975    
  30  0.757182     -0.278151     -0.780368E-01  0.780368E-01   106.370       106.448    
  31  0.788615     -0.237477     -0.666253E-01  0.666253E-01   106.050       106.116    
  32  0.724297     -0.322554     -0.904941E-01  0.904941E-01   106.398       106.488    
  33  0.807261     -0.214109     -0.600693E-01  0.600693E-01   106.444       106.504    
  34  0.356497      -1.03143     -0.289373      0.289373       106.650       106.940    
  35  0.685602     -0.377458     -0.105898      0.105898       106.107       106.213    
  36  0.681617     -0.383288     -0.107533      0.107533       106.577       106.684    
  37  0.323748      -1.12779     -0.316407      0.316407       106.582       106.898    
  38  0.622817     -0.473503     -0.132844      0.132844       107.114       107.246    
  39  0.534584     -0.626266     -0.175702      0.175702       107.064       107.240    
  40  0.130255E-02  -6.64343      -1.86385       1.86385       107.323       109.187    
  41  0.357398      -1.02891     -0.288665      0.288665       106.384       106.672    
  42  0.290986      -1.23448     -0.346340      0.346340       107.460       107.806    
  43  0.182566      -1.70064     -0.477125      0.477125       107.044       107.521    
  44  0.695597     -0.362984     -0.101837      0.101837       107.359       107.461    
  45  0.612287     -0.490555     -0.137628      0.137628       107.327       107.465    
  46  0.845780     -0.167496     -0.469918E-01  0.469918E-01   106.343       106.390    
loop,thermsimp(1:2)       10  0.185562      0.109274    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    381        108.05         67.92          1.09         42.14          0.48          0.05        111.68
Just calling func    0   0        111.68


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    382        104.27         67.92          1.09         42.21          0.50          0.05        111.76
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  380    108.05       0.5974     -3.359      2.443     -102.6    -0.1833    
                      0.6081     0.3826     -99.70      4.372      1.251    

                       1.347     -2.826      1.540      7929.      7000.    

                      0.5580      0.000      0.000      0.000     -1.221    



                      -2.326      0.000      0.000      7000.      539.4    

                       2.030     -4.253     -5.227     -7.763      8.056    

                      -16.73     -6.459      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.3728    -0.9236      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.4933     -1.108      7000.    



                      -1.900     -1.514     -1.878     -1.945    -0.3807    

                     -0.3252      9.271      8.824    -0.1372E+05 -4.801    

                     -0.3977     -7.458      9.481      8.905    -0.1969E+05



                      -6.000     0.7374     0.3646E-01  9.044      8.938    

                     -0.1944E+05 -6.000     -1.023    -0.2784      9.096    

                       8.885    -0.1891E+05 -6.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    104.27
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       10
neval is:      381
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       10      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       11
neval is:      381


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      381     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.737263     -0.304811     -0.855163E-01  0.855163E-01   102.207       102.293    
   2  0.372515     -0.987477     -0.277042      0.277042       102.913       103.190    
   3  0.197611E-01  -3.92404      -1.10091       1.10091       103.681       104.782    
   4  0.939239     -0.626858E-01 -0.175868E-01  0.175868E-01   104.294       104.312    
   5  0.212506      -1.54879     -0.434520      0.434520       104.407       104.841    
   6  0.141762      -1.95360     -0.548093      0.548093       104.387       104.935    
   7  0.183632      -1.69482     -0.475492      0.475492       104.509       104.985    
   8  0.479067     -0.735915     -0.206465      0.206465       105.004       105.211    
   9  0.113189      -2.17870     -0.611245      0.611245       104.724       105.335    
  10  0.314091      -1.15807     -0.324903      0.324903       104.731       105.056    
  11  0.457761     -0.781409     -0.219228      0.219228       105.323       105.542    
  12  0.923744     -0.793200E-01 -0.222536E-01  0.222536E-01   104.538       104.560    
  13  0.805387     -0.216433     -0.607213E-01  0.607213E-01   104.808       104.869    
  14  0.979257     -0.209609E-01 -0.588068E-02  0.588068E-02   105.182       105.188    
  15  0.634716E-01  -2.75716     -0.773536      0.773536       105.672       106.446    
  16  0.502866     -0.687432     -0.192863      0.192863       105.770       105.963    
  17  0.844986     -0.168435     -0.472553E-01  0.472553E-01   105.511       105.559    
  18  0.548347     -0.600848     -0.168571      0.168571       105.331       105.500    
  19  0.825472     -0.191800     -0.538104E-01  0.538104E-01   105.936       105.990    
  20  0.806424     -0.215145     -0.603601E-01  0.603601E-01   106.050       106.110    
  21  0.497450E-01  -3.00085     -0.841903      0.841903       106.001       106.843    
  22  0.407289     -0.898233     -0.252004      0.252004       105.832       106.084    
  23  0.522833     -0.648493     -0.181938      0.181938       105.870       106.051    
  24  0.763038     -0.270448     -0.758756E-01  0.758756E-01   106.107       106.183    
  25  0.706120     -0.347970     -0.976249E-01  0.976249E-01   105.487       105.585    
  26  0.540862     -0.614591     -0.172427      0.172427       105.856       106.029    
  27  0.807340E-01  -2.51660     -0.706044      0.706044       105.372       106.078    
  28  0.310756      -1.16875     -0.327898      0.327898       106.343       106.671    
  29  0.689192     -0.372235     -0.104433      0.104433       106.370       106.475    
  30  0.634973     -0.454174     -0.127421      0.127421       106.398       106.525    
  31  0.598432     -0.513442     -0.144049      0.144049       106.444       106.588    
  32  0.393639     -0.932321     -0.261567      0.261567       106.384       106.645    
  33  0.369460     -0.995714     -0.279353      0.279353       106.577       106.856    
  34  0.129274      -2.04582     -0.573965      0.573965       105.698       106.272    
  35  0.250376      -1.38479     -0.388511      0.388511       105.987       106.376    
  36  0.536641     -0.622425     -0.174625      0.174625       106.582       106.756    
  37  0.495942     -0.701296     -0.196752      0.196752       106.650       106.847    
  38  0.650684     -0.429731     -0.120563      0.120563       106.255       106.376    
  39  0.889212     -0.117420     -0.329427E-01  0.329427E-01   107.064       107.097    
  40  0.314936      -1.15539     -0.324150      0.324150       107.114       107.438    
  41  0.943567     -0.580875E-01 -0.162967E-01  0.162967E-01   106.120       106.136    
  42  0.672016     -0.397473     -0.111513      0.111513       107.359       107.471    
  43  0.133907      -2.01061     -0.564088      0.564088       107.327       107.891    
  44  0.259017      -1.35086     -0.378991      0.378991       107.044       107.423    
  45  0.112444      -2.18530     -0.613097      0.613097       107.460       108.073    
  46  0.235994      -1.44395     -0.405107      0.405107       104.268       104.673    
loop,thermsimp(1:2)       11  0.855163E-01  0.277042    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    383        103.05         67.96          1.10         42.16          0.28          0.05        111.55
Just calling func    0   0        111.55


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    103.05
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       11
neval is:      382
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       11      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       12
neval is:      382


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      382     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.783491     -0.243995     -0.684541E-01  0.684541E-01   102.207       102.275    
   2  0.973841     -0.265069E-01 -0.743664E-02  0.743664E-02   102.913       102.920    
   3  0.294662      -1.22193     -0.342817      0.342817       104.294       104.637    
   4  0.702628     -0.352928     -0.990158E-01  0.990158E-01   104.538       104.637    
   5  0.763280     -0.270131     -0.757865E-01  0.757865E-01   104.268       104.344    
   6  0.578080E-01  -2.85063     -0.799759      0.799759       103.681       104.481    
   7  0.834037     -0.181478     -0.509146E-01  0.509146E-01   104.407       104.457    
   8  0.976312     -0.239730E-01 -0.672575E-02  0.672575E-02   104.808       104.815    
   9  0.603670     -0.504728     -0.141604      0.141604       104.387       104.529    
  10  0.458546     -0.779695     -0.218747      0.218747       104.509       104.728    
  11  0.201917      -1.59990     -0.448860      0.448860       104.731       105.180    
  12  0.362727      -1.01411     -0.284512      0.284512       105.182       105.467    
  13  0.466909E-01  -3.06421     -0.859679      0.859679       105.004       105.864    
  14  0.602192     -0.507180     -0.142292      0.142292       104.724       104.866    
  15  0.332545      -1.10098     -0.308886      0.308886       105.331       105.640    
  16  0.758378     -0.276574     -0.775942E-01  0.775942E-01   105.323       105.400    
  17  0.834950     -0.180384     -0.506076E-01  0.506076E-01   105.511       105.562    
  18  0.910410     -0.938599E-01 -0.263329E-01  0.263329E-01   105.487       105.513    
  19  0.825418E-01  -2.49445     -0.699831      0.699831       105.770       106.470    
  20  0.639611     -0.446894     -0.125379      0.125379       105.936       106.062    
  21  0.345418      -1.06300     -0.298230      0.298230       105.856       106.154    
  22  0.961674     -0.390802E-01 -0.109642E-01  0.109642E-01   105.870       105.880    
  23  0.274135      -1.29413     -0.363076      0.363076       105.372       105.735    
  24  0.275236      -1.29013     -0.361952      0.361952       105.832       106.194    
  25  0.373550     -0.984704     -0.276264      0.276264       106.050       106.326    
  26  0.407178     -0.898505     -0.252080      0.252080       106.120       106.372    
  27  0.908773     -0.956602E-01 -0.268380E-01  0.268380E-01   106.107       106.134    
  28  0.578518     -0.547286     -0.153544      0.153544       105.698       105.852    
  29  0.674288     -0.394098     -0.110566      0.110566       106.255       106.366    
  30  0.758166     -0.276853     -0.776725E-01  0.776725E-01   105.987       106.065    
  31  0.764349E-01  -2.57132     -0.721396      0.721396       105.672       106.394    
  32  0.962342     -0.383853E-01 -0.107692E-01  0.107692E-01   106.370       106.381    
  33  0.918960     -0.845125E-01 -0.237104E-01  0.237104E-01   106.398       106.421    
  34  0.617888     -0.481448     -0.135073      0.135073       106.444       106.579    
  35  0.227646      -1.47996     -0.415211      0.415211       106.384       106.799    
  36  0.262001      -1.33941     -0.375777      0.375777       106.343       106.719    
  37  0.589438     -0.528586     -0.148298      0.148298       106.582       106.730    
  38  0.201352      -1.60270     -0.449646      0.449646       106.001       106.450    
  39  0.350279      -1.04903     -0.294310      0.294310       106.650       106.945    
  40  0.647374     -0.434831     -0.121994      0.121994       106.577       106.699    
  41  0.604508     -0.503341     -0.141215      0.141215       107.064       107.205    
  42  0.700946     -0.355325     -0.996882E-01  0.996882E-01   107.044       107.143    
  43  0.575270     -0.552915     -0.155123      0.155123       107.114       107.269    
  44  0.554419     -0.589835     -0.165481      0.165481       107.359       107.525    
  45  0.375300     -0.980029     -0.274952      0.274952       107.327       107.602    
  46  0.605541     -0.501632     -0.140736      0.140736       103.047       103.188    
loop,thermsimp(1:2)       12  0.684541E-01  0.743664E-02

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    384        105.23         67.86          1.11         42.24          0.27          0.05        111.52
Just calling func    0   0        111.52


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    105.23
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       12
neval is:      383
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       12      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       13
neval is:      383


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      383     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.964298     -0.363545E-01 -0.101994E-01  0.101994E-01   102.207       102.217    
   2  0.963371     -0.373169E-01 -0.104694E-01  0.104694E-01   102.913       102.923    
   3  0.851172E-02  -4.76631      -1.33721       1.33721       103.047       104.384    
   4  0.731929E-01  -2.61466     -0.733556      0.733556       104.268       105.002    
   5  0.491869     -0.709543     -0.199066      0.199066       104.407       104.606    
   6  0.625436     -0.469306     -0.131666      0.131666       103.681       103.813    
   7  0.139469      -1.96991     -0.552670      0.552670       104.387       104.940    
   8  0.464987     -0.765746     -0.214834      0.214834       104.538       104.752    
   9  0.192956      -1.64529     -0.461596      0.461596       104.294       104.756    
  10  0.184589E-01  -3.99221      -1.12003       1.12003       104.509       105.629    
  11  0.327387      -1.11661     -0.313271      0.313271       104.808       105.121    
  12  0.447570     -0.803921     -0.225544      0.225544       104.724       104.950    
  13  0.282132      -1.26538     -0.355009      0.355009       104.731       105.086    
  14  0.991234     -0.880510E-02 -0.247032E-02  0.247032E-02   105.323       105.325    
  15  0.574009     -0.555110     -0.155739      0.155739       105.182       105.338    
  16  0.884017     -0.123279     -0.345865E-01  0.345865E-01   105.487       105.522    
  17  0.332578      -1.10088     -0.308858      0.308858       105.511       105.820    
  18  0.294524      -1.22240     -0.342949      0.342949       105.331       105.674    
  19  0.865605     -0.144326     -0.404915E-01  0.404915E-01   105.372       105.413    
  20  0.441883E-01  -3.11930     -0.875134      0.875134       105.698       106.574    
  21  0.652915     -0.426309     -0.119603      0.119603       105.004       105.124    
  22  0.712636E-01  -2.64137     -0.741050      0.741050       105.870       106.611    
  23  0.211397      -1.55402     -0.435988      0.435988       105.936       106.372    
  24  0.836672E-01  -2.48091     -0.696031      0.696031       105.987       106.683    
  25  0.397953     -0.921422     -0.258510      0.258510       106.107       106.365    
  26  0.545442     -0.606159     -0.170061      0.170061       105.856       106.026    
  27  0.628874     -0.463825     -0.130129      0.130129       105.832       105.962    
  28  0.243035      -1.41455     -0.396860      0.396860       106.050       106.446    
  29  0.700237     -0.356336     -0.999719E-01  0.999719E-01   106.255       106.355    
  30  0.887974     -0.118813     -0.333336E-01  0.333336E-01   106.120       106.153    
  31  0.354481      -1.03710     -0.290964      0.290964       106.370       106.661    
  32  0.579479     -0.545626     -0.153078      0.153078       105.672       105.825    
  33  0.873601E-01  -2.43772     -0.683914      0.683914       106.398       107.082    
  34  0.414510     -0.880658     -0.247073      0.247073       106.001       106.248    
  35  0.263485      -1.33376     -0.374193      0.374193       105.770       106.144    
  36  0.174560E-01  -4.04807      -1.13571       1.13571       106.444       107.580    
  37  0.461287     -0.773735     -0.217075      0.217075       106.577       106.794    
  38  0.914554     -0.893185E-01 -0.250588E-01  0.250588E-01   106.343       106.368    
  39  0.551497     -0.595119     -0.166964      0.166964       106.582       106.749    
  40  0.751145     -0.286157     -0.802827E-01  0.802827E-01   106.384       106.464    
  41  0.838814     -0.175766     -0.493120E-01  0.493120E-01   106.650       106.700    
  42  0.494321     -0.704571     -0.197671      0.197671       107.044       107.241    
  43  0.878137     -0.129953     -0.364589E-01  0.364589E-01   107.064       107.100    
  44  0.249667      -1.38763     -0.389306      0.389306       107.114       107.503    
  45  0.569995     -0.562128     -0.157708      0.157708       107.359       107.517    
  46  0.338221      -1.08406     -0.304138      0.304138       105.229       105.533    
loop,thermsimp(1:2)       13  0.101994E-01  0.104694E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    385        105.55         67.90          1.11         42.23          0.24          0.05        111.53
Just calling func    0   0        111.52


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    105.55
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       13
neval is:      384
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       13      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       14
neval is:      384


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      384     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.536122     -0.623393     -0.174896      0.174896       102.207       102.382    
   2  0.902010     -0.103129     -0.289335E-01  0.289335E-01   102.913       102.942    
   3  0.918906     -0.845717E-01 -0.237270E-01  0.237270E-01   103.681       103.705    
   4  0.300977E-01  -3.50330     -0.982870      0.982870       103.047       104.030    
   5  0.180939      -1.70960     -0.479636      0.479636       104.407       104.886    
   6  0.996736     -0.326981E-02 -0.917361E-03  0.917361E-03   104.538       104.539    
   7  0.974749     -0.255749E-01 -0.717516E-02  0.717516E-02   104.294       104.301    
   8  0.259085      -1.35060     -0.378918      0.378918       104.387       104.766    
   9  0.237439      -1.43784     -0.403395      0.403395       104.724       105.128    
  10  0.733816     -0.309497     -0.868310E-01  0.868310E-01   104.268       104.355    
  11  0.458028     -0.780824     -0.219064      0.219064       104.731       104.950    
  12  0.623300     -0.472727     -0.132626      0.132626       104.808       104.941    
  13  0.789074     -0.236895     -0.664622E-01  0.664622E-01   105.004       105.071    
  14  0.718847     -0.330107     -0.926131E-01  0.926131E-01   105.323       105.415    
  15  0.414258     -0.881266     -0.247244      0.247244       105.182       105.430    
  16  0.121880E-01  -4.40730      -1.23649       1.23649       105.372       106.609    
  17  0.976927     -0.233433E-01 -0.654907E-02  0.654907E-02   105.487       105.494    
  18  0.998133     -0.186873E-02 -0.524282E-03  0.524282E-03   105.229       105.230    
  19  0.582806     -0.539901     -0.151472      0.151472       104.509       104.661    
  20  0.461010     -0.774335     -0.217244      0.217244       105.331       105.549    
  21  0.748404     -0.289812     -0.813082E-01  0.813082E-01   105.511       105.593    
  22  0.627394     -0.466180     -0.130789      0.130789       105.672       105.803    
  23  0.823247     -0.194499     -0.545678E-01  0.545678E-01   105.832       105.887    
  24  0.696302     -0.361971     -0.101553      0.101553       105.856       105.958    
  25  0.571207     -0.560004     -0.157112      0.157112       105.770       105.927    
  26  0.189272      -1.66457     -0.467004      0.467004       106.120       106.587    
  27  0.534816     -0.625833     -0.175581      0.175581       106.001       106.176    
  28  0.846241     -0.166951     -0.468390E-01  0.468390E-01   106.255       106.302    
  29  0.157466      -1.84855     -0.518619      0.518619       106.107       106.625    
  30  0.123756      -2.08945     -0.586205      0.586205       106.343       106.929    
  31  0.458067     -0.780739     -0.219040      0.219040       105.936       106.155    
  32  0.989772     -0.102804E-01 -0.288421E-02  0.288421E-02   106.050       106.052    
  33  0.292614      -1.22890     -0.344774      0.344774       106.384       106.728    
  34  0.707885     -0.345474     -0.969245E-01  0.969245E-01   105.698       105.795    
  35  0.686290     -0.376455     -0.105616      0.105616       105.870       105.975    
  36  0.752747     -0.284026     -0.796850E-01  0.796850E-01   106.370       106.450    
  37  0.577950E-01  -2.85085     -0.799821      0.799821       105.987       106.787    
  38  0.496568E-02  -5.30521      -1.48840       1.48840       106.650       108.139    
  39  0.632817     -0.457575     -0.128375      0.128375       106.582       106.710    
  40  0.306568      -1.18232     -0.331705      0.331705       106.577       106.908    
  41  0.800757     -0.222198     -0.623387E-01  0.623387E-01   106.398       106.460    
  42  0.754206     -0.282090     -0.791417E-01  0.791417E-01   107.064       107.143    
  43  0.875958     -0.132437     -0.371560E-01  0.371560E-01   107.044       107.081    
  44  0.411581     -0.887750     -0.249063      0.249063       107.114       107.363    
  45  0.784837     -0.242279     -0.679727E-01  0.679727E-01   107.359       107.427    
  46  0.615964     -0.484567     -0.135948      0.135948       105.555       105.691    
loop,thermsimp(1:2)       14  0.174896      0.289335E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    386        105.35         67.92          1.11         42.24          0.41          0.05        111.73
Just calling func    0   0        111.73


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    105.35
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       14
neval is:      385
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       14      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       15
neval is:      385


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      385     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.210086      -1.56024     -0.437733      0.437733       102.207       102.645    
   2  0.682169     -0.382478     -0.107306      0.107306       102.913       103.020    
   3  0.831163     -0.184930     -0.518830E-01  0.518830E-01   103.681       103.733    
   4  0.625179     -0.469718     -0.131782      0.131782       103.047       103.179    
   5  0.907522     -0.970376E-01 -0.272244E-01  0.272244E-01   104.294       104.321    
   6  0.406703     -0.899672     -0.252408      0.252408       104.268       104.520    
   7  0.463060     -0.769899     -0.215999      0.215999       104.538       104.754    
   8  0.206056      -1.57961     -0.443167      0.443167       104.509       104.952    
   9  0.303716      -1.19166     -0.334327      0.334327       104.387       104.722    
  10  0.843889     -0.169734     -0.476199E-01  0.476199E-01   104.407       104.454    
  11  0.273678      -1.29580     -0.363544      0.363544       104.808       105.171    
  12  0.571842     -0.558892     -0.156800      0.156800       104.731       104.888    
  13  0.803131     -0.219238     -0.615083E-01  0.615083E-01   105.004       105.066    
  14  0.330375      -1.10753     -0.310722      0.310722       104.724       105.035    
  15  0.155557      -1.86074     -0.522042      0.522042       105.229       105.751    
  16  0.878823     -0.129172     -0.362399E-01  0.362399E-01   105.323       105.359    
  17  0.781654     -0.246343     -0.691128E-01  0.691128E-01   105.182       105.251    
  18  0.782655     -0.245064     -0.687538E-01  0.687538E-01   105.487       105.556    
  19  0.682155     -0.382499     -0.107312      0.107312       105.331       105.439    
  20  0.899702     -0.105691     -0.296522E-01  0.296522E-01   105.511       105.541    
  21  0.444808     -0.810113     -0.227281      0.227281       105.555       105.782    
  22  0.495252     -0.702688     -0.197143      0.197143       105.698       105.896    
  23  0.640834     -0.444984     -0.124843      0.124843       105.672       105.797    
  24  0.314465      -1.15688     -0.324569      0.324569       105.832       106.157    
  25  0.368564     -0.998140     -0.280033      0.280033       105.770       106.050    
  26  0.572254E-02  -5.16334      -1.44860       1.44860       105.856       107.305    
  27  0.468080E-01  -3.06170     -0.858976      0.858976       105.870       106.729    
  28  0.598693E-01  -2.81559     -0.789929      0.789929       106.050       106.840    
  29  0.658687     -0.417508     -0.117134      0.117134       105.936       106.053    
  30  0.449565     -0.799475     -0.224297      0.224297       106.001       106.225    
  31  0.799405     -0.223887     -0.628127E-01  0.628127E-01   106.255       106.318    
  32  0.414416     -0.880885     -0.247137      0.247137       106.370       106.618    
  33  0.395703E-01  -3.22968     -0.906102      0.906102       106.398       107.304    
  34  0.704129E-01  -2.65338     -0.744419      0.744419       106.120       106.865    
  35  0.336217      -1.09000     -0.305805      0.305805       105.372       105.678    
  36  0.169926      -1.77239     -0.497253      0.497253       106.107       106.604    
  37  0.846601E-01  -2.46911     -0.692722      0.692722       106.582       107.274    
  38  0.798628     -0.224860     -0.630856E-01  0.630856E-01   106.384       106.447    
  39  0.377891     -0.973150     -0.273022      0.273022       105.987       106.260    
  40  0.183739      -1.69424     -0.475327      0.475327       106.577       107.052    
  41  0.930280     -0.722695E-01 -0.202756E-01  0.202756E-01   106.343       106.363    
  42  0.280682      -1.27053     -0.356455      0.356455       107.044       107.400    
  43  0.475397     -0.743606     -0.208622      0.208622       107.064       107.273    
  44  0.705714     -0.348545     -0.977862E-01  0.977862E-01   107.114       107.211    
  45  0.307479      -1.17935     -0.330873      0.330873       107.359       107.690    
  46  0.408291     -0.895776     -0.251314      0.251314       105.353       105.605    
loop,thermsimp(1:2)       15  0.437733      0.107306    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    387        108.31         67.96          1.09         42.21          0.31          0.05        111.61
Just calling func    0   0        111.61


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    388        106.18         67.99          1.11         42.11          0.25          0.05        111.52
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    106.18
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       15
neval is:      387
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       15      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       16
neval is:      387


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      387     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.652831E-01  -2.72902     -0.765641      0.765641       102.207       102.973    
   2  0.388935     -0.944342     -0.264940      0.264940       102.913       103.178    
   3  0.716732     -0.333053     -0.934398E-01  0.934398E-01   103.047       103.140    
   4  0.375936     -0.978336     -0.274477      0.274477       103.681       103.956    
   5  0.518505E-01  -2.95939     -0.830272      0.830272       104.294       105.124    
   6  0.892279     -0.113976     -0.319766E-01  0.319766E-01   104.407       104.438    
   7  0.145412      -1.92818     -0.540962      0.540962       104.268       104.809    
   8  0.759376E-01  -2.57784     -0.723227      0.723227       104.387       105.110    
   9  0.799111     -0.224255     -0.629158E-01  0.629158E-01   104.538       104.601    
  10  0.566636     -0.568038     -0.159366      0.159366       104.731       104.890    
  11  0.957834     -0.430803E-01 -0.120864E-01  0.120864E-01   104.509       104.521    
  12  0.421133     -0.864808     -0.242626      0.242626       104.724       104.967    
  13  0.965171     -0.354495E-01 -0.994555E-02  0.994555E-02   105.004       105.014    
  14  0.527073     -0.640416     -0.179672      0.179672       104.808       104.988    
  15  0.221584      -1.50695     -0.422783      0.422783       105.182       105.605    
  16  0.675180     -0.392776     -0.110195      0.110195       105.323       105.433    
  17  0.462159     -0.771846     -0.216545      0.216545       105.331       105.548    
  18  0.134826      -2.00377     -0.562167      0.562167       105.511       106.074    
  19  0.869165     -0.140222     -0.393400E-01  0.393400E-01   105.487       105.526    
  20  0.898965     -0.106511     -0.298821E-01  0.298821E-01   105.353       105.383    
  21  0.174160      -1.74778     -0.490349      0.490349       105.372       105.863    
  22  0.463810     -0.768281     -0.215545      0.215545       105.229       105.445    
  23  0.145870      -1.92504     -0.540079      0.540079       105.555       106.095    
  24  0.525172     -0.644029     -0.180686      0.180686       105.672       105.853    
  25  0.667609     -0.404052     -0.113359      0.113359       105.698       105.812    
  26  0.964408     -0.362405E-01 -0.101675E-01  0.101675E-01   105.770       105.780    
  27  0.981636     -0.185350E-01 -0.520008E-02  0.520008E-02   105.936       105.942    
  28  0.585742     -0.534875     -0.150062      0.150062       105.832       105.982    
  29  0.956106     -0.448864E-01 -0.125931E-01  0.125931E-01   106.001       106.013    
  30  0.153686      -1.87284     -0.525436      0.525436       105.987       106.513    
  31  0.937356     -0.646920E-01 -0.181497E-01  0.181497E-01   106.255       106.273    
  32  0.821414     -0.196728     -0.551931E-01  0.551931E-01   106.343       106.398    
  33  0.901583     -0.103603     -0.290664E-01  0.290664E-01   106.384       106.413    
  34  0.145469      -1.92779     -0.540852      0.540852       106.107       106.648    
  35  0.944310     -0.573011E-01 -0.160761E-01  0.160761E-01   106.370       106.386    
  36  0.639748     -0.446680     -0.125318      0.125318       105.870       105.995    
  37  0.533071     -0.629101     -0.176497      0.176497       106.050       106.226    
  38  0.708805     -0.344175     -0.965601E-01  0.965601E-01   106.120       106.217    
  39  0.953023     -0.481167E-01 -0.134994E-01  0.134994E-01   106.577       106.590    
  40  0.606832     -0.499502     -0.140138      0.140138       107.114       107.254    
  41  0.791257     -0.234132     -0.656870E-01  0.656870E-01   107.064       107.130    
  42  0.203064      -1.59423     -0.447270      0.447270       106.582       107.029    
  43  0.168642      -1.77998     -0.499382      0.499382       106.398       106.897    
  44  0.718173     -0.331045     -0.928765E-01  0.928765E-01   105.856       105.949    
  45  0.976939E-02  -4.62850      -1.29855       1.29855       107.044       108.342    
  46  0.211685      -1.55265     -0.435605      0.435605       106.184       106.620    
loop,thermsimp(1:2)       16  0.765641      0.264940    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    389        104.00         67.88          1.09         42.21          0.26          0.05        111.49
Just calling func    0   0        111.49


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    104.00
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       16
neval is:      388
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       16      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       17
neval is:      388


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      388     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.488972     -0.715450     -0.200723      0.200723       102.207       102.408    
   2  0.243137      -1.41413     -0.396741      0.396741       103.047       103.444    
   3  0.530653     -0.633646     -0.177773      0.177773       102.913       103.090    
   4  0.926282     -0.765763E-01 -0.214839E-01  0.214839E-01   103.681       103.703    
   5  0.374288     -0.982729     -0.275710      0.275710       104.407       104.682    
   6  0.675293     -0.392608     -0.110148      0.110148       104.509       104.619    
   7  0.605942     -0.500970     -0.140550      0.140550       104.538       104.678    
   8  0.280229      -1.27215     -0.356907      0.356907       104.268       104.625    
   9  0.297259      -1.21315     -0.340356      0.340356       104.731       105.071    
  10  0.697504E-01  -2.66283     -0.747071      0.747071       104.724       105.471    
  11  0.824348     -0.193163     -0.541929E-01  0.541929E-01   104.808       104.862    
  12  0.750452     -0.287080     -0.805417E-01  0.805417E-01   105.004       105.085    
  13  0.120595      -2.11532     -0.593463      0.593463       104.387       104.981    
  14  0.935324     -0.668625E-01 -0.187586E-01  0.187586E-01   104.294       104.313    
  15  0.215551      -1.53456     -0.430528      0.430528       105.353       105.784    
  16  0.708821     -0.344153     -0.965538E-01  0.965538E-01   105.323       105.419    
  17  0.402499     -0.910063     -0.255323      0.255323       105.229       105.484    
  18  0.836443     -0.178597     -0.501063E-01  0.501063E-01   105.487       105.537    
  19  0.969979E-01  -2.33307     -0.654554      0.654554       105.331       105.986    
  20  0.178795      -1.72152     -0.482980      0.482980       105.182       105.665    
  21  0.140077      -1.96556     -0.551448      0.551448       105.770       106.321    
  22  0.375507     -0.979479     -0.274798      0.274798       105.698       105.973    
  23  0.831487     -0.184540     -0.517736E-01  0.517736E-01   105.672       105.724    
  24  0.815951     -0.203401     -0.570651E-01  0.570651E-01   105.372       105.429    
  25  0.468603     -0.757998     -0.212660      0.212660       105.936       106.149    
  26  0.677551     -0.389270     -0.109212      0.109212       105.856       105.965    
  27  0.169538      -1.77468     -0.497895      0.497895       105.832       106.330    
  28  0.950448     -0.508223E-01 -0.142585E-01  0.142585E-01   105.870       105.884    
  29  0.981726     -0.184427E-01 -0.517420E-02  0.517420E-02   106.001       106.006    
  30  0.442406     -0.815527     -0.228800      0.228800       105.511       105.740    
  31  0.531953     -0.631200     -0.177086      0.177086       105.555       105.732    
  32  0.363692      -1.01145     -0.283767      0.283767       106.120       106.404    
  33  0.144511E-01  -4.23698      -1.18871       1.18871       106.050       107.238    
  34  0.748780     -0.289310     -0.811674E-01  0.811674E-01   106.255       106.336    
  35  0.195075      -1.63437     -0.458531      0.458531       106.370       106.829    
  36  0.440325     -0.820241     -0.230123      0.230123       106.343       106.573    
  37  0.805864     -0.215841     -0.605553E-01  0.605553E-01   106.384       106.444    
  38  0.921415     -0.818451E-01 -0.229621E-01  0.229621E-01   105.987       106.010    
  39  0.296293      -1.21641     -0.341269      0.341269       106.577       106.918    
  40  0.645874E-01  -2.73974     -0.768647      0.768647       106.184       106.953    
  41  0.488279     -0.716868     -0.201121      0.201121       106.107       106.308    
  42  0.573105     -0.556686     -0.156181      0.156181       106.398       106.554    
  43  0.967891     -0.326356E-01 -0.915607E-02  0.915607E-02   106.582       106.591    
  44  0.780434E-01  -2.55049     -0.715553      0.715553       107.064       107.780    
  45  0.968859     -0.316363E-01 -0.887573E-02  0.887573E-02   107.114       107.123    
  46  0.858835     -0.152178     -0.426944E-01  0.426944E-01   103.996       104.039    
loop,thermsimp(1:2)       17  0.200723      0.396741    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    390        104.73         67.99          1.11         42.62          0.33          0.05        112.09
Just calling func    0   0        112.09


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    104.73
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       17
neval is:      389
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       17      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       18
neval is:      389


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      389     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.490618     -0.712090     -0.199781      0.199781       102.207       102.407    
   2  0.486668     -0.720173     -0.202048      0.202048       102.913       103.115    
   3  0.319995E-01  -3.44203     -0.965680      0.965680       103.047       104.013    
   4  0.957863     -0.430503E-01 -0.120780E-01  0.120780E-01   103.681       103.693    
   5  0.713202E-01  -2.64058     -0.740827      0.740827       103.996       104.737    
   6  0.677570     -0.389242     -0.109204      0.109204       104.294       104.403    
   7  0.533853     -0.627634     -0.176086      0.176086       104.509       104.685    
   8  0.963967     -0.366984E-01 -0.102959E-01  0.102959E-01   104.268       104.278    
   9  0.590118     -0.527432     -0.147974      0.147974       104.538       104.686    
  10  0.102350      -2.27936     -0.639485      0.639485       104.407       105.046    
  11  0.313487      -1.16000     -0.325443      0.325443       104.808       105.133    
  12  0.876181     -0.132183     -0.370845E-01  0.370845E-01   104.387       104.424    
  13  0.780541     -0.247768     -0.695125E-01  0.695125E-01   104.731       104.800    
  14  0.222922      -1.50093     -0.421094      0.421094       105.004       105.425    
  15  0.913991     -0.899351E-01 -0.252317E-01  0.252317E-01   105.323       105.348    
  16  0.493176     -0.706888     -0.198321      0.198321       105.372       105.571    
  17  0.884766     -0.122432     -0.343489E-01  0.343489E-01   104.724       104.759    
  18  0.576549E-01  -2.85328     -0.800503      0.800503       105.229       106.030    
  19  0.398597     -0.919804     -0.258056      0.258056       105.487       105.745    
  20  0.980633     -0.195573E-01 -0.548690E-02  0.548690E-02   105.182       105.188    
  21  0.304985      -1.18749     -0.333157      0.333157       105.672       106.005    
  22  0.628666     -0.464156     -0.130221      0.130221       105.555       105.685    
  23  0.367895     -0.999957     -0.280543      0.280543       105.511       105.792    
  24  0.442302     -0.815762     -0.228866      0.228866       105.353       105.582    
  25  0.656121     -0.421410     -0.118229      0.118229       105.870       105.988    
  26  0.229893      -1.47014     -0.412455      0.412455       105.856       106.269    
  27  0.475469     -0.743453     -0.208580      0.208580       105.698       105.907    
  28  0.801985     -0.220665     -0.619087E-01  0.619087E-01   105.331       105.393    
  29  0.454630     -0.788272     -0.221154      0.221154       106.001       106.222    
  30  0.858022     -0.153126     -0.429602E-01  0.429602E-01   105.987       106.030    
  31  0.692704     -0.367153     -0.103007      0.103007       105.936       106.039    
  32  0.466274     -0.762981     -0.214058      0.214058       106.107       106.321    
  33  0.682446     -0.382072     -0.107192      0.107192       105.770       105.877    
  34  0.660760     -0.414365     -0.116252      0.116252       105.832       105.948    
  35  0.957519     -0.434092E-01 -0.121787E-01  0.121787E-01   106.255       106.267    
  36  0.108167      -2.22408     -0.623977      0.623977       106.120       106.744    
  37  0.846378     -0.166789     -0.467936E-01  0.467936E-01   106.384       106.430    
  38  0.621158E-01  -2.77876     -0.779594      0.779594       106.398       107.177    
  39  0.988945E-01  -2.31370     -0.649121      0.649121       106.343       106.992    
  40  0.253472      -1.37250     -0.385063      0.385063       106.582       106.967    
  41  0.915015     -0.888152E-01 -0.249176E-01  0.249176E-01   106.370       106.395    
  42  0.662342     -0.411973     -0.115581      0.115581       106.577       106.692    
  43  0.210223      -1.55959     -0.437551      0.437551       106.184       106.622    
  44  0.141043      -1.95869     -0.549522      0.549522       107.114       107.663    
  45  0.839834     -0.174551     -0.489713E-01  0.489713E-01   106.050       106.099    
  46  0.132358      -2.02225     -0.567352      0.567352       104.734       105.301    
loop,thermsimp(1:2)       18  0.199781      0.202048    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    391        104.86         67.95          1.11         42.11          0.26          0.05        111.47
Just calling func    0   0        111.47


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    104.86
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       18
neval is:      390
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       18      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       19
neval is:      390


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      390     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.155141      -1.86342     -0.522792      0.522792       102.207       102.730    
   2  0.881882     -0.125697     -0.352651E-01  0.352651E-01   102.913       102.948    
   3  0.908319     -0.961592E-01 -0.269780E-01  0.269780E-01   103.681       103.708    
   4  0.732380     -0.311455     -0.873804E-01  0.873804E-01   103.047       103.134    
   5  0.367412      -1.00127     -0.280912      0.280912       104.268       104.549    
   6  0.624330     -0.471077     -0.132163      0.132163       104.294       104.426    
   7  0.833858     -0.181693     -0.509748E-01  0.509748E-01   104.387       104.438    
   8  0.194603E-02  -6.24197      -1.75122       1.75122       104.509       106.261    
   9  0.995416     -0.459497E-02 -0.128914E-02  0.128914E-02   104.538       104.539    
  10  0.665599     -0.407068     -0.114205      0.114205       103.996       104.110    
  11  0.747574     -0.290922     -0.816197E-01  0.816197E-01   104.724       104.806    
  12  0.539692     -0.616756     -0.173034      0.173034       104.731       104.904    
  13  0.958323     -0.425700E-01 -0.119432E-01  0.119432E-01   104.407       104.418    
  14  0.111027      -2.19798     -0.616656      0.616656       104.808       105.425    
  15  0.520965     -0.652072     -0.182942      0.182942       105.182       105.365    
  16  0.177207E-01  -4.03302      -1.13148       1.13148       104.734       105.865    
  17  0.860365     -0.150398     -0.421951E-01  0.421951E-01   105.323       105.365    
  18  0.383700     -0.957895     -0.268742      0.268742       105.331       105.600    
  19  0.524904     -0.644539     -0.180829      0.180829       105.004       105.185    
  20  0.589629     -0.528262     -0.148207      0.148207       105.372       105.521    
  21  0.125125      -2.07844     -0.583118      0.583118       105.353       105.936    
  22  0.154207      -1.86946     -0.524487      0.524487       105.555       106.079    
  23  0.752747     -0.284026     -0.796850E-01  0.796850E-01   105.487       105.567    
  24  0.551286     -0.595501     -0.167071      0.167071       105.511       105.679    
  25  0.733343     -0.310142     -0.870119E-01  0.870119E-01   105.770       105.857    
  26  0.904985     -0.998368E-01 -0.280097E-01  0.280097E-01   105.698       105.726    
  27  0.987632     -0.124455E-01 -0.349166E-02  0.349166E-02   105.832       105.836    
  28  0.228587      -1.47584     -0.414054      0.414054       105.870       106.284    
  29  0.384883     -0.954815     -0.267878      0.267878       105.672       105.940    
  30  0.781910     -0.246015     -0.690209E-01  0.690209E-01   105.229       105.298    
  31  0.402051E-02  -5.51635      -1.54764       1.54764       105.987       107.535    
  32  0.880575     -0.127180     -0.356811E-01  0.356811E-01   105.936       105.972    
  33  0.427180     -0.850550     -0.238626      0.238626       106.050       106.288    
  34  0.613064     -0.489286     -0.137272      0.137272       106.001       106.138    
  35  0.529053     -0.636668     -0.178620      0.178620       106.255       106.434    
  36  0.973505     -0.268519E-01 -0.753345E-02  0.753345E-02   105.856       105.864    
  37  0.889868     -0.116682     -0.327358E-01  0.327358E-01   106.107       106.140    
  38  0.133989      -2.01000     -0.563915      0.563915       106.370       106.934    
  39  0.289828      -1.23847     -0.347458      0.347458       106.384       106.731    
  40  0.724995     -0.321591     -0.902239E-01  0.902239E-01   106.184       106.274    
  41  0.547932     -0.601605     -0.168783      0.168783       106.577       106.745    
  42  0.608240E-01  -2.79977     -0.785490      0.785490       106.120       106.906    
  43  0.481259E-01  -3.03393     -0.851186      0.851186       106.582       107.433    
  44  0.356843      -1.03046     -0.289100      0.289100       106.343       106.632    
  45  0.417411     -0.873685     -0.245117      0.245117       106.398       106.643    
  46  0.918903     -0.845742E-01 -0.237277E-01  0.237277E-01   104.856       104.880    
loop,thermsimp(1:2)       19  0.522792      0.352651E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    392        105.03         67.95          1.08         42.29          0.65          0.05        112.01
Just calling func    0   0        112.01


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    105.03
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       19
neval is:      391
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       19      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       20
neval is:      391


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      391     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.272787      -1.29906     -0.364459      0.364459       102.207       102.571    
   2  0.284829      -1.25587     -0.352340      0.352340       102.913       103.265    
   3  0.422534E-01  -3.16407     -0.887696      0.887696       103.047       103.935    
   4  0.788018E-01  -2.54082     -0.712840      0.712840       103.681       104.394    
   5  0.396626E-01  -3.22735     -0.905449      0.905449       103.996       104.902    
   6  0.412432     -0.885684     -0.248483      0.248483       104.407       104.655    
   7  0.390866     -0.939390     -0.263551      0.263551       104.294       104.558    
   8  0.853334     -0.158604     -0.444971E-01  0.444971E-01   104.387       104.432    
   9  0.506127     -0.680968     -0.191049      0.191049       104.538       104.729    
  10  0.254200      -1.36963     -0.384258      0.384258       104.268       104.652    
  11  0.643116     -0.441430     -0.123846      0.123846       104.724       104.848    
  12  0.897721     -0.107896     -0.302709E-01  0.302709E-01   104.856       104.886    
  13  0.830899     -0.185247     -0.519721E-01  0.519721E-01   104.731       104.783    
  14  0.357312      -1.02915     -0.288732      0.288732       105.004       105.293    
  15  0.525942     -0.642564     -0.180275      0.180275       105.229       105.409    
  16  0.742929     -0.297155     -0.833683E-01  0.833683E-01   105.323       105.406    
  17  0.970959     -0.294711E-01 -0.826828E-02  0.826828E-02   105.182       105.191    
  18  0.235894      -1.44437     -0.405226      0.405226       104.808       105.213    
  19  0.723381E-01  -2.62640     -0.736851      0.736851       105.372       106.109    
  20  0.190915      -1.65593     -0.464579      0.464579       105.487       105.952    
  21  0.524670     -0.644986     -0.180954      0.180954       105.331       105.512    
  22  0.536043     -0.623540     -0.174937      0.174937       105.511       105.686    
  23  0.281730      -1.26681     -0.355409      0.355409       105.698       106.054    
  24  0.747791     -0.290632     -0.815382E-01  0.815382E-01   105.832       105.914    
  25  0.255771      -1.36347     -0.382529      0.382529       105.770       106.152    
  26  0.194866      -1.63544     -0.458832      0.458832       105.856       106.315    
  27  0.639630     -0.446865     -0.125370      0.125370       104.734       104.859    
  28  0.485808     -0.721941     -0.202544      0.202544       105.353       105.556    
  29  0.659147     -0.416809     -0.116938      0.116938       105.672       105.789    
  30  0.196308      -1.62807     -0.456763      0.456763       105.936       106.393    
  31  0.308964      -1.17453     -0.329520      0.329520       105.555       105.884    
  32  0.181287      -1.70768     -0.479097      0.479097       106.001       106.480    
  33  0.386667     -0.950191     -0.266581      0.266581       106.107       106.373    
  34  0.947825     -0.535853E-01 -0.150336E-01  0.150336E-01   104.509       104.524    
  35  0.699942     -0.356758     -0.100090      0.100090       106.184       106.284    
  36  0.208747      -1.56663     -0.439526      0.439526       105.870       106.309    
  37  0.717648     -0.331775     -0.930813E-01  0.930813E-01   106.050       106.143    
  38  0.734922     -0.307991     -0.864084E-01  0.864084E-01   106.255       106.342    
  39  0.862816     -0.147554     -0.413970E-01  0.413970E-01   106.343       106.384    
  40  0.677494     -0.389354     -0.109235      0.109235       106.398       106.507    
  41  0.829375     -0.187082     -0.524869E-01  0.524869E-01   106.384       106.436    
  42  0.393856     -0.931770     -0.261413      0.261413       106.577       106.838    
  43  0.447370     -0.804370     -0.225670      0.225670       106.120       106.346    
  44  0.485389     -0.722806     -0.202787      0.202787       106.370       106.573    
  45  0.522363     -0.649392     -0.182190      0.182190       106.582       106.764    
  46  0.740056E-01  -2.60361     -0.730457      0.730457       105.027       105.758    
loop,thermsimp(1:2)       20  0.364459      0.352340    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    393        104.97         67.84          1.09         42.09          0.40          0.05        111.47
Just calling func    0   0        111.47


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    104.97
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       20
neval is:      392
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       20      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       21
neval is:      392


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      392     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.633870E-01  -2.75850     -0.773911      0.773911       102.207       102.981    
   2  0.713782     -0.337177     -0.945969E-01  0.945969E-01   102.913       103.007    
   3  0.851614     -0.160622     -0.450634E-01  0.450634E-01   103.047       103.092    
   4  0.721769     -0.326050     -0.914749E-01  0.914749E-01   103.681       103.773    
   5  0.954937     -0.461102E-01 -0.129364E-01  0.129364E-01   104.387       104.400    
   6  0.302532E-01  -3.49815     -0.981425      0.981425       104.509       105.491    
   7  0.942920E-01  -2.36136     -0.662492      0.662492       104.294       104.957    
   8  0.515750E-01  -2.96472     -0.831767      0.831767       104.268       105.100    
   9  0.612753     -0.489794     -0.137414      0.137414       104.407       104.544    
  10  0.758041     -0.277018     -0.777188E-01  0.777188E-01   104.538       104.615    
  11  0.530485E-01  -2.93655     -0.823864      0.823864       104.731       105.555    
  12  0.941175     -0.606258E-01 -0.170089E-01  0.170089E-01   104.724       104.741    
  13  0.167539      -1.78654     -0.501223      0.501223       104.734       105.235    
  14  0.738662E-01  -2.60550     -0.730987      0.730987       104.856       105.587    
  15  0.822155     -0.195827     -0.549402E-01  0.549402E-01   103.996       104.051    
  16  0.578765     -0.546859     -0.153424      0.153424       105.182       105.336    
  17  0.912739E-01  -2.39389     -0.671618      0.671618       104.808       105.480    
  18  0.949215     -0.521197E-01 -0.146224E-01  0.146224E-01   105.004       105.019    
  19  0.485124     -0.723351     -0.202940      0.202940       105.323       105.526    
  20  0.359009      -1.02441     -0.287403      0.287403       105.229       105.516    
  21  0.747559     -0.290942     -0.816254E-01  0.816254E-01   105.331       105.413    
  22  0.482847     -0.728056     -0.204260      0.204260       105.353       105.558    
  23  0.994301     -0.571526E-02 -0.160345E-02  0.160345E-02   105.511       105.513    
  24  0.937801     -0.642177E-01 -0.180166E-01  0.180166E-01   105.027       105.045    
  25  0.699033     -0.358058     -0.100455      0.100455       105.672       105.773    
  26  0.358162      -1.02677     -0.288066      0.288066       105.555       105.843    
  27  0.746418     -0.292470     -0.820538E-01  0.820538E-01   105.832       105.914    
  28  0.532195     -0.630744     -0.176959      0.176959       105.487       105.664    
  29  0.727066     -0.318738     -0.894237E-01  0.894237E-01   105.698       105.788    
  30  0.461510     -0.773252     -0.216940      0.216940       105.372       105.589    
  31  0.285112      -1.25487     -0.352061      0.352061       106.050       106.402    
  32  0.316830      -1.14939     -0.322467      0.322467       105.770       106.092    
  33  0.835731     -0.179448     -0.503451E-01  0.503451E-01   106.184       106.235    
  34  0.516269E-02  -5.26630      -1.47749       1.47749       105.870       107.347    
  35  0.309002      -1.17441     -0.329486      0.329486       105.856       106.186    
  36  0.770766     -0.260370     -0.730482E-01  0.730482E-01   106.255       106.328    
  37  0.878913     -0.129069     -0.362109E-01  0.362109E-01   106.120       106.156    
  38  0.981341E-01  -2.32142     -0.651286      0.651286       106.107       106.758    
  39  0.634060     -0.455612     -0.127824      0.127824       106.343       106.471    
  40  0.359967      -1.02174     -0.286655      0.286655       105.936       106.223    
  41  0.480002     -0.733964     -0.205917      0.205917       106.384       106.590    
  42  0.706923     -0.346834     -0.973061E-01  0.973061E-01   106.001       106.098    
  43  0.497828     -0.697501     -0.195687      0.195687       106.398       106.593    
  44  0.885038     -0.122125     -0.342627E-01  0.342627E-01   106.370       106.405    
  45  0.504752     -0.683689     -0.191812      0.191812       106.582       106.773    
  46  0.719262     -0.329529     -0.924512E-01  0.924512E-01   104.969       105.061    
loop,thermsimp(1:2)       21  0.773911      0.945969E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    394        104.39         67.79          1.08         42.23          0.56          0.05        111.70
Just calling func    0   0        111.70


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    104.39
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       21
neval is:      393
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       21      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       22
neval is:      393


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      393     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.434858     -0.832735     -0.233628      0.233628       102.207       102.441    
   2  0.380177E-01  -3.26970     -0.917332      0.917332       102.913       103.830    
   3  0.198795      -1.61548     -0.453232      0.453232       103.047       103.500    
   4  0.880944E-01  -2.42935     -0.681566      0.681566       103.681       104.363    
   5  0.279105      -1.27617     -0.358035      0.358035       103.996       104.354    
   6  0.379482     -0.968948     -0.271843      0.271843       104.387       104.659    
   7  0.510142     -0.673065     -0.188832      0.188832       104.407       104.595    
   8  0.869007     -0.140404     -0.393910E-01  0.393910E-01   104.538       104.577    
   9  0.905256     -0.995378E-01 -0.279258E-01  0.279258E-01   104.724       104.752    
  10  0.587200     -0.532390     -0.149365      0.149365       104.294       104.444    
  11  0.309008      -1.17439     -0.329481      0.329481       105.004       105.334    
  12  0.210718      -1.55723     -0.436890      0.436890       105.027       105.464    
  13  0.362152      -1.01569     -0.284958      0.284958       104.969       105.254    
  14  0.465452     -0.764747     -0.214554      0.214554       104.268       104.483    
  15  0.155270E-01  -4.16518      -1.16856       1.16856       104.734       105.902    
  16  0.632166     -0.458603     -0.128663      0.128663       105.182       105.311    
  17  0.171028      -1.76593     -0.495441      0.495441       105.331       105.827    
  18  0.926401     -0.764482E-01 -0.214479E-01  0.214479E-01   104.808       104.829    
  19  0.130449      -2.03678     -0.571428      0.571428       104.509       105.081    
  20  0.536069     -0.623492     -0.174924      0.174924       105.511       105.686    
  21  0.128128      -2.05472     -0.576464      0.576464       105.229       105.806    
  22  0.729730     -0.315081     -0.883976E-01  0.883976E-01   105.323       105.411    
  23  0.982387     -0.177702E-01 -0.498552E-02  0.498552E-02   104.731       104.736    
  24  0.707707     -0.345726     -0.969952E-01  0.969952E-01   105.353       105.450    
  25  0.643878     -0.440245     -0.123513      0.123513       104.856       104.979    
  26  0.136721      -1.98982     -0.558253      0.558253       105.372       105.931    
  27  0.146320      -1.92196     -0.539216      0.539216       105.487       106.026    
  28  0.214169      -1.54099     -0.432333      0.432333       105.672       106.104    
  29  0.774008     -0.256172     -0.718705E-01  0.718705E-01   105.698       105.770    
  30  0.487333     -0.718808     -0.201665      0.201665       105.555       105.756    
  31  0.594481E-01  -2.82265     -0.791910      0.791910       105.832       106.624    
  32  0.305368      -1.18624     -0.332805      0.332805       105.770       106.102    
  33  0.206200      -1.57891     -0.442971      0.442971       106.001       106.444    
  34  0.185235      -1.68613     -0.473052      0.473052       106.120       106.593    
  35  0.945154     -0.564077E-01 -0.158255E-01  0.158255E-01   105.856       105.872    
  36  0.657328     -0.419572     -0.117713      0.117713       105.936       106.054    
  37  0.932191     -0.702171E-01 -0.196998E-01  0.196998E-01   106.184       106.204    
  38  0.258055      -1.35458     -0.380035      0.380035       106.255       106.635    
  39  0.525568E-01  -2.94586     -0.826477      0.826477       106.050       106.876    
  40  0.692807     -0.367004     -0.102965      0.102965       106.370       106.473    
  41  0.691658     -0.368664     -0.103431      0.103431       106.343       106.446    
  42  0.163447      -1.81127     -0.508160      0.508160       106.384       106.892    
  43  0.462923     -0.770194     -0.216082      0.216082       106.398       106.614    
  44  0.758611     -0.276266     -0.775077E-01  0.775077E-01   106.107       106.184    
  45  0.278938      -1.27677     -0.358203      0.358203       106.582       106.940    
  46  0.726655     -0.319304     -0.895824E-01  0.895824E-01   104.389       104.479    
loop,thermsimp(1:2)       22  0.233628      0.917332    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    395        103.28         67.91          1.12         42.13          0.25          0.05        111.47
Just calling func    0   0        111.47


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    103.28
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       22
neval is:      394
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       22      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       23
neval is:      394


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      394     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.262849      -1.33618     -0.374871      0.374871       102.207       102.582    
   2  0.388449     -0.945595     -0.265291      0.265291       103.047       103.312    
   3  0.827051     -0.189889     -0.532744E-01  0.532744E-01   102.913       102.966    
   4  0.958395     -0.424951E-01 -0.119222E-01  0.119222E-01   103.996       104.008    
   5  0.125400      -2.07625     -0.582502      0.582502       103.681       104.264    
   6  0.524174     -0.645931     -0.181219      0.181219       104.294       104.475    
   7  0.783721     -0.243702     -0.683719E-01  0.683719E-01   104.389       104.458    
   8  0.183361      -1.69630     -0.475906      0.475906       104.268       104.744    
   9  0.122208      -2.10203     -0.589735      0.589735       104.538       105.127    
  10  0.913915     -0.900182E-01 -0.252551E-01  0.252551E-01   104.407       104.432    
  11  0.273776      -1.29545     -0.363444      0.363444       104.387       104.751    
  12  0.779874     -0.248622     -0.697523E-01  0.697523E-01   104.731       104.801    
  13  0.305314      -1.18641     -0.332854      0.332854       104.724       105.057    
  14  0.720732     -0.327488     -0.918785E-01  0.918785E-01   104.808       104.900    
  15  0.222329      -1.50360     -0.421842      0.421842       104.856       105.278    
  16  0.826299     -0.190798     -0.535294E-01  0.535294E-01   104.509       104.563    
  17  0.581574     -0.542017     -0.152066      0.152066       104.969       105.121    
  18  0.616258     -0.484089     -0.135814      0.135814       105.182       105.318    
  19  0.604230     -0.503801     -0.141344      0.141344       105.004       105.145    
  20  0.333333      -1.09861     -0.308222      0.308222       105.323       105.631    
  21  0.289888E-01  -3.54085     -0.993402      0.993402       105.353       106.347    
  22  0.396892     -0.924091     -0.259259      0.259259       105.027       105.287    
  23  0.910378     -0.938957E-01 -0.263429E-01  0.263429E-01   105.511       105.538    
  24  0.998355     -0.164683E-02 -0.462026E-03  0.462026E-03   105.555       105.555    
  25  0.735990     -0.306539     -0.860010E-01  0.860010E-01   105.698       105.784    
  26  0.779044     -0.249688     -0.700513E-01  0.700513E-01   105.229       105.299    
  27  0.498268     -0.696618     -0.195440      0.195440       105.331       105.527    
  28  0.693129     -0.366539     -0.102834      0.102834       105.856       105.959    
  29  0.691370     -0.369080     -0.103547      0.103547       104.734       104.837    
  30  0.519398     -0.655086     -0.183788      0.183788       105.372       105.556    
  31  0.365801      -1.00567     -0.282145      0.282145       105.487       105.769    
  32  0.352392      -1.04301     -0.292622      0.292622       105.936       106.229    
  33  0.176642      -1.73363     -0.486379      0.486379       105.770       106.256    
  34  0.982977     -0.171697E-01 -0.481704E-02  0.481704E-02   105.672       105.677    
  35  0.466781     -0.761894     -0.213753      0.213753       106.107       106.321    
  36  0.481130     -0.731617     -0.205259      0.205259       106.184       106.389    
  37  0.238852      -1.43191     -0.401730      0.401730       106.001       106.402    
  38  0.453247     -0.791318     -0.222008      0.222008       106.343       106.565    
  39  0.579188     -0.546129     -0.153219      0.153219       106.370       106.524    
  40  0.802776E-01  -2.52226     -0.707634      0.707634       106.120       106.828    
  41  0.819632     -0.198900     -0.558025E-01  0.558025E-01   106.398       106.453    
  42  0.917023     -0.866231E-01 -0.243026E-01  0.243026E-01   105.832       105.856    
  43  0.328296      -1.11384     -0.312494      0.312494       106.255       106.568    
  44  0.751681     -0.285443     -0.800824E-01  0.800824E-01   106.050       106.130    
  45  0.760454     -0.273840     -0.768272E-01  0.768272E-01   106.384       106.460    
  46  0.655053     -0.423039     -0.118686      0.118686       103.278       103.396    
loop,thermsimp(1:2)       23  0.374871      0.265291    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    396        103.07         67.95          1.11         42.71          0.19          0.05        112.00
Just calling func    0   0        112.00


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    103.07
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       23
neval is:      395
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       23      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       24
neval is:      395


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      395     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.562447     -0.575458     -0.161448      0.161448       102.207       102.368    
   2  0.429755     -0.844539     -0.236940      0.236940       102.913       103.150    
   3  0.598807     -0.512815     -0.143873      0.143873       103.047       103.191    
   4  0.757798     -0.277339     -0.778088E-01  0.778088E-01   103.278       103.355    
   5  0.954130E-01  -2.34954     -0.659176      0.659176       103.996       104.655    
   6  0.968708E-01  -2.33438     -0.654921      0.654921       103.681       104.336    
   7  0.196924      -1.62494     -0.455884      0.455884       104.407       104.862    
   8  0.616654     -0.483447     -0.135633      0.135633       104.389       104.525    
   9  0.181969      -1.70392     -0.478044      0.478044       104.294       104.772    
  10  0.383918     -0.957326     -0.268583      0.268583       104.509       104.778    
  11  0.377012     -0.975478     -0.273675      0.273675       104.268       104.542    
  12  0.899192     -0.106259     -0.298114E-01  0.298114E-01   104.387       104.417    
  13  0.409833     -0.892005     -0.250257      0.250257       104.731       104.981    
  14  0.728621     -0.316601     -0.888240E-01  0.888240E-01   104.734       104.822    
  15  0.568233     -0.565224     -0.158577      0.158577       104.808       104.967    
  16  0.647091     -0.435269     -0.122117      0.122117       104.724       104.846    
  17  0.118896      -2.12951     -0.597444      0.597444       104.969       105.566    
  18  0.910801     -0.934313E-01 -0.262126E-01  0.262126E-01   104.538       104.564    
  19  0.484176     -0.725308     -0.203489      0.203489       105.004       105.208    
  20  0.327343      -1.11675     -0.313309      0.313309       104.856       105.169    
  21  0.674995     -0.393050     -0.110272      0.110272       105.027       105.138    
  22  0.234857      -1.44878     -0.406463      0.406463       105.229       105.636    
  23  0.800837     -0.222098     -0.623107E-01  0.623107E-01   105.182       105.245    
  24  0.619975     -0.478077     -0.134127      0.134127       105.331       105.465    
  25  0.578519     -0.547284     -0.153543      0.153543       105.511       105.665    
  26  0.837214     -0.177675     -0.498478E-01  0.498478E-01   105.555       105.604    
  27  0.935915     -0.662302E-01 -0.185812E-01  0.185812E-01   105.372       105.391    
  28  0.779751     -0.248781     -0.697967E-01  0.697967E-01   105.323       105.392    
  29  0.801557     -0.221199     -0.620586E-01  0.620586E-01   105.672       105.734    
  30  0.827533E-01  -2.49189     -0.699113      0.699113       105.487       106.186    
  31  0.640581     -0.445379     -0.124953      0.124953       105.698       105.823    
  32  0.226382      -1.48553     -0.416773      0.416773       105.832       106.249    
  33  0.198814E-01  -3.91797      -1.09921       1.09921       105.856       106.955    
  34  0.147003      -1.91730     -0.537908      0.537908       106.050       106.587    
  35  0.568592     -0.564592     -0.158399      0.158399       105.936       106.095    
  36  0.650717     -0.429680     -0.120549      0.120549       105.770       105.890    
  37  0.259092      -1.35057     -0.378910      0.378910       106.107       106.486    
  38  0.935898     -0.662490E-01 -0.185865E-01  0.185865E-01   105.353       105.372    
  39  0.702433     -0.353205     -0.990935E-01  0.990935E-01   106.184       106.283    
  40  0.622661     -0.473753     -0.132914      0.132914       106.001       106.134    
  41  0.546960     -0.603380     -0.169281      0.169281       106.398       106.567    
  42  0.883578     -0.123775     -0.347259E-01  0.347259E-01   106.384       106.418    
  43  0.728206E-02  -4.92234      -1.38099       1.38099       106.370       107.751    
  44  0.112001      -2.18925     -0.614205      0.614205       106.343       106.957    
  45  0.689494     -0.371797     -0.104310      0.104310       106.255       106.360    
  46  0.872629     -0.136244     -0.382241E-01  0.382241E-01   103.075       103.113    
loop,thermsimp(1:2)       24  0.161448      0.236940    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    397        104.30         67.86          1.11         42.19          0.26          0.05        111.46
Just calling func    0   0        111.46


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    104.30
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       24
neval is:      396
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       24      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       25
neval is:      396


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      396     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.756122     -0.279553     -0.784300E-01  0.784300E-01   102.207       102.285    
   2  0.693006     -0.366716     -0.102884      0.102884       103.075       103.178    
   3  0.647780     -0.434203     -0.121818      0.121818       102.913       103.034    
   4  0.895769     -0.110072     -0.308814E-01  0.308814E-01   103.047       103.078    
   5  0.775956     -0.253659     -0.711653E-01  0.711653E-01   103.278       103.349    
   6  0.891264     -0.115114     -0.322959E-01  0.322959E-01   103.681       103.713    
   7  0.553736     -0.591068     -0.165827      0.165827       104.387       104.553    
   8  0.646797     -0.435723     -0.122244      0.122244       104.389       104.512    
   9  0.646048     -0.436881     -0.122569      0.122569       104.268       104.391    
  10  0.160937      -1.82675     -0.512503      0.512503       104.538       105.050    
  11  0.840732     -0.173482     -0.486712E-01  0.486712E-01   103.996       104.045    
  12  0.377447     -0.974325     -0.273352      0.273352       104.294       104.568    
  13  0.214649      -1.53875     -0.431705      0.431705       104.509       104.941    
  14  0.424093     -0.857804     -0.240661      0.240661       104.734       104.974    
  15  0.693510     -0.365990     -0.102680      0.102680       104.724       104.827    
  16  0.252894      -1.37478     -0.385703      0.385703       104.407       104.792    
  17  0.765441     -0.267303     -0.749933E-01  0.749933E-01   104.808       104.883    
  18  0.481029     -0.731828     -0.205318      0.205318       104.731       104.936    
  19  0.211808      -1.55207     -0.435443      0.435443       105.027       105.463    
  20  0.616599E-01  -2.78612     -0.781661      0.781661       104.856       105.637    
  21  0.110259      -2.20492     -0.618602      0.618602       105.004       105.623    
  22  0.475319     -0.743769     -0.208668      0.208668       105.182       105.391    
  23  0.500411E-01  -2.99491     -0.840237      0.840237       105.353       106.194    
  24  0.126445      -2.06795     -0.580173      0.580173       105.372       105.952    
  25  0.693760     -0.365629     -0.102579      0.102579       105.323       105.425    
  26  0.876607E-01  -2.43428     -0.682950      0.682950       105.331       106.014    
  27  0.564718     -0.571429     -0.160317      0.160317       104.969       105.129    
  28  0.572706     -0.557383     -0.156377      0.156377       105.555       105.711    
  29  0.739618     -0.301621     -0.846215E-01  0.846215E-01   105.229       105.314    
  30  0.428028     -0.848566     -0.238070      0.238070       105.511       105.750    
  31  0.864224     -0.145923     -0.409395E-01  0.409395E-01   105.672       105.713    
  32  0.326884      -1.11815     -0.313703      0.313703       105.698       106.012    
  33  0.626295     -0.467933     -0.131281      0.131281       105.770       105.901    
  34  0.576680     -0.550467     -0.154436      0.154436       105.936       106.091    
  35  0.988375     -0.116929E-01 -0.328051E-02  0.328051E-02   106.001       106.004    
  36  0.834431     -0.181006     -0.507821E-01  0.507821E-01   105.487       105.538    
  37  0.944839     -0.567403E-01 -0.159188E-01  0.159188E-01   105.832       105.848    
  38  0.182182      -1.70275     -0.477715      0.477715       106.184       106.662    
  39  0.882984     -0.124449     -0.349147E-01  0.349147E-01   106.255       106.290    
  40  0.756839     -0.278604     -0.781639E-01  0.781639E-01   106.384       106.462    
  41  0.530350     -0.634218     -0.177933      0.177933       106.107       106.285    
  42  0.257866      -1.35531     -0.380240      0.380240       106.398       106.778    
  43  0.575794     -0.552006     -0.154868      0.154868       106.050       106.204    
  44  0.907029     -0.975811E-01 -0.273769E-01  0.273769E-01   105.856       105.883    
  45  0.385513     -0.953180     -0.267419      0.267419       106.343       106.610    
  46  0.352081      -1.04389     -0.292870      0.292870       104.298       104.591    
loop,thermsimp(1:2)       25  0.784300E-01  0.102884    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    398        104.63         67.89          1.10         42.18          0.55          0.05        111.77
Just calling func    0   0        111.77


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    104.63
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       25
neval is:      397
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       25      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       26
neval is:      397


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      397     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.409890     -0.891867     -0.250218      0.250218       102.207       102.457    
   2  0.389332     -0.943323     -0.264654      0.264654       102.913       103.177    
   3  0.765657     -0.267021     -0.749142E-01  0.749142E-01   103.047       103.122    
   4  0.505025     -0.683148     -0.191661      0.191661       103.075       103.266    
   5  0.681598     -0.383316     -0.107541      0.107541       103.278       103.385    
   6  0.895525     -0.110345     -0.309578E-01  0.309578E-01   103.681       103.712    
   7  0.540074     -0.616050     -0.172836      0.172836       103.996       104.169    
   8  0.125370      -2.07648     -0.582568      0.582568       104.268       104.851    
   9  0.306095      -1.18386     -0.332138      0.332138       104.389       104.721    
  10  0.898677     -0.106831     -0.299721E-01  0.299721E-01   104.387       104.417    
  11  0.355276      -1.03486     -0.290336      0.290336       104.294       104.584    
  12  0.855641     -0.155905     -0.437399E-01  0.437399E-01   104.298       104.342    
  13  0.894333E-01  -2.41426     -0.677334      0.677334       104.407       105.084    
  14  0.291038      -1.23430     -0.346290      0.346290       104.724       105.070    
  15  0.848476E-01  -2.46690     -0.692101      0.692101       104.808       105.500    
  16  0.655469     -0.422404     -0.118508      0.118508       104.731       104.849    
  17  0.181028      -1.70910     -0.479498      0.479498       104.509       104.989    
  18  0.801189     -0.221659     -0.621875E-01  0.621875E-01   104.734       104.796    
  19  0.659702     -0.415967     -0.116702      0.116702       104.538       104.654    
  20  0.500397     -0.692354     -0.194243      0.194243       104.969       105.163    
  21  0.901964     -0.103181     -0.289480E-01  0.289480E-01   105.229       105.258    
  22  0.331186      -1.10508     -0.310034      0.310034       105.182       105.492    
  23  0.572805E-01  -2.85979     -0.802330      0.802330       105.323       106.125    
  24  0.511624     -0.670164     -0.188018      0.188018       105.027       105.215    
  25  0.953295     -0.478312E-01 -0.134193E-01  0.134193E-01   105.487       105.501    
  26  0.454382     -0.788818     -0.221307      0.221307       105.004       105.225    
  27  0.697217E-01  -2.66324     -0.747187      0.747187       104.856       105.603    
  28  0.269239      -1.31216     -0.368133      0.368133       105.555       105.923    
  29  0.855725     -0.155806     -0.437123E-01  0.437123E-01   105.672       105.716    
  30  0.408332E-02  -5.50085      -1.54329       1.54329       105.511       107.055    
  31  0.926366     -0.764862E-01 -0.214586E-01  0.214586E-01   105.832       105.853    
  32  0.356547      -1.03129     -0.289333      0.289333       105.856       106.145    
  33  0.550351     -0.597200     -0.167547      0.167547       105.770       105.937    
  34  0.475063     -0.744308     -0.208819      0.208819       105.372       105.581    
  35  0.420107     -0.867246     -0.243310      0.243310       106.001       106.244    
  36  0.521034     -0.651939     -0.182905      0.182905       105.698       105.881    
  37  0.979034     -0.211889E-01 -0.594466E-02  0.594466E-02   105.331       105.337    
  38  0.599858     -0.511062     -0.143381      0.143381       105.936       106.080    
  39  0.800850     -0.222082     -0.623062E-01  0.623062E-01   105.353       105.416    
  40  0.823189     -0.194570     -0.545875E-01  0.545875E-01   106.050       106.104    
  41  0.709226E-01  -2.64617     -0.742396      0.742396       106.107       106.849    
  42  0.555654     -0.587609     -0.164857      0.164857       106.255       106.420    
  43  0.920379     -0.829696E-01 -0.232775E-01  0.232775E-01   106.384       106.407    
  44  0.904537     -0.100332     -0.281486E-01  0.281486E-01   106.343       106.371    
  45  0.990568     -0.947695E-02 -0.265881E-02  0.265881E-02   106.184       106.187    
  46  0.647203     -0.435096     -0.122068      0.122068       104.627       104.749    
loop,thermsimp(1:2)       26  0.250218      0.264654    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    399        103.94         67.88          1.10         42.32          0.24          0.05        111.60
Just calling func    0   0        111.60


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    103.94
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       26
neval is:      398
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       26      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       27
neval is:      398


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      398     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.478820     -0.736431     -0.206610      0.206610       102.207       102.414    
   2  0.431280     -0.840999     -0.235947      0.235947       103.047       103.283    
   3  0.231120      -1.46482     -0.410963      0.410963       102.913       103.324    
   4  0.306155      -1.18366     -0.332083      0.332083       103.075       103.407    
   5  0.514107     -0.665324     -0.186660      0.186660       103.278       103.464    
   6  0.784944E-01  -2.54473     -0.713936      0.713936       103.681       104.395    
   7  0.767893     -0.264105     -0.740960E-01  0.740960E-01   103.996       104.070    
   8  0.240450E-02  -6.03041      -1.69186       1.69186       104.298       105.990    
   9  0.185505      -1.68467     -0.472643      0.472643       104.387       104.860    
  10  0.405909     -0.901627     -0.252956      0.252956       104.294       104.547    
  11  0.681143     -0.383983     -0.107728      0.107728       104.538       104.645    
  12  0.529175     -0.636436     -0.178556      0.178556       104.389       104.568    
  13  0.873060     -0.135751     -0.380857E-01  0.380857E-01   104.627       104.665    
  14  0.457661     -0.781625     -0.219289      0.219289       104.734       104.953    
  15  0.564230     -0.572293     -0.160560      0.160560       104.731       104.892    
  16  0.949800     -0.515039E-01 -0.144497E-01  0.144497E-01   104.268       104.282    
  17  0.581003E-01  -2.84558     -0.798344      0.798344       104.509       105.308    
  18  0.180069      -1.71442     -0.480988      0.480988       104.724       105.205    
  19  0.222412      -1.50322     -0.421737      0.421737       104.407       104.828    
  20  0.821703     -0.196377     -0.550945E-01  0.550945E-01   104.969       105.024    
  21  0.948363     -0.530176E-01 -0.148744E-01  0.148744E-01   105.027       105.042    
  22  0.796186     -0.227922     -0.639447E-01  0.639447E-01   105.004       105.068    
  23  0.881546     -0.126078     -0.353717E-01  0.353717E-01   105.229       105.264    
  24  0.702001     -0.353821     -0.992663E-01  0.992663E-01   105.331       105.431    
  25  0.878483     -0.129559     -0.363485E-01  0.363485E-01   105.353       105.390    
  26  0.158251      -1.84358     -0.517225      0.517225       105.182       105.700    
  27  0.759310E-02  -4.88052      -1.36925       1.36925       104.808       106.177    
  28  0.549090     -0.599492     -0.168191      0.168191       105.487       105.655    
  29  0.294083      -1.22389     -0.343370      0.343370       105.372       105.716    
  30  0.358851      -1.02485     -0.287526      0.287526       104.856       105.143    
  31  0.591031E-01  -2.82847     -0.793543      0.793543       105.672       106.466    
  32  0.413139     -0.883972     -0.248003      0.248003       105.832       106.080    
  33  0.564800     -0.571284     -0.160277      0.160277       105.698       105.859    
  34  0.472034     -0.750704     -0.210614      0.210614       105.555       105.765    
  35  0.270343      -1.30806     -0.366984      0.366984       105.770       106.137    
  36  0.704266     -0.350600     -0.983626E-01  0.983626E-01   105.936       106.035    
  37  0.317895E-01  -3.44862     -0.967528      0.967528       106.050       107.017    
  38  0.489641     -0.714083     -0.200340      0.200340       105.323       105.523    
  39  0.558309     -0.582843     -0.163520      0.163520       105.856       106.020    
  40  0.239099      -1.43088     -0.401440      0.401440       106.184       106.586    
  41  0.387399     -0.948301     -0.266051      0.266051       106.001       106.267    
  42  0.434686     -0.833131     -0.233739      0.233739       106.343       106.577    
  43  0.713921     -0.336983     -0.945425E-01  0.945425E-01   106.384       106.478    
  44  0.655374     -0.422550     -0.118549      0.118549       106.255       106.374    
  45  0.739749     -0.301444     -0.845717E-01  0.845717E-01   106.107       106.191    
  46  0.758411     -0.276530     -0.775819E-01  0.775819E-01   103.941       104.018    
loop,thermsimp(1:2)       27  0.206610      0.235947    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    400        103.20         67.86          1.12         42.15          0.28          0.05        111.46
Just calling func    0   0        111.45


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    103.20
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       27
neval is:      399
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       27      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       28
neval is:      399


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      399     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.382581     -0.960815     -0.269562      0.269562       102.207       102.477    
   2  0.718155     -0.331070     -0.928835E-01  0.928835E-01   103.047       103.140    
   3  0.581515     -0.542118     -0.152094      0.152094       102.913       103.065    
   4  0.230175E-01  -3.77150      -1.05811       1.05811       103.075       104.133    
   5  0.506601     -0.680031     -0.190786      0.190786       103.278       103.468    
   6  0.209297      -1.56400     -0.438789      0.438789       103.941       104.379    
   7  0.757725     -0.277434     -0.778357E-01  0.778357E-01   103.996       104.074    
   8  0.230972      -1.46546     -0.411142      0.411142       104.268       104.679    
   9  0.495080     -0.703037     -0.197241      0.197241       103.681       103.878    
  10  0.947190     -0.542553E-01 -0.152216E-01  0.152216E-01   104.294       104.309    
  11  0.977432     -0.228269E-01 -0.640420E-02  0.640420E-02   104.389       104.396    
  12  0.320616      -1.13751     -0.319134      0.319134       104.538       104.857    
  13  0.252125      -1.37783     -0.386557      0.386557       104.627       105.013    
  14  0.871535     -0.137499     -0.385761E-01  0.385761E-01   104.407       104.445    
  15  0.856468E-02  -4.76011      -1.33547       1.33547       104.387       105.723    
  16  0.352534      -1.04261     -0.292509      0.292509       104.731       105.023    
  17  0.750419     -0.287124     -0.805542E-01  0.805542E-01   104.734       104.814    
  18  0.215691      -1.53391     -0.430346      0.430346       104.969       105.399    
  19  0.833929     -0.181606     -0.509506E-01  0.509506E-01   105.027       105.078    
  20  0.714656E-01  -2.63854     -0.740256      0.740256       105.004       105.744    
  21  0.758349     -0.276612     -0.776050E-01  0.776050E-01   104.856       104.933    
  22  0.571963     -0.558680     -0.156741      0.156741       104.724       104.881    
  23  0.472398     -0.749934     -0.210398      0.210398       105.229       105.439    
  24  0.606854     -0.499467     -0.140128      0.140128       104.509       104.649    
  25  0.247109      -1.39793     -0.392196      0.392196       105.353       105.746    
  26  0.581778     -0.541666     -0.151967      0.151967       105.331       105.483    
  27  0.455447     -0.786476     -0.220650      0.220650       105.323       105.543    
  28  0.606617     -0.499857     -0.140237      0.140237       105.487       105.627    
  29  0.620033     -0.477983     -0.134100      0.134100       105.182       105.316    
  30  0.367527      -1.00096     -0.280824      0.280824       105.372       105.653    
  31  0.611260     -0.492233     -0.138099      0.138099       105.555       105.693    
  32  0.310332      -1.17011     -0.328281      0.328281       105.698       106.027    
  33  0.611387     -0.492025     -0.138040      0.138040       104.298       104.437    
  34  0.584386     -0.537193     -0.150712      0.150712       105.856       106.007    
  35  0.950350     -0.509246E-01 -0.142871E-01  0.142871E-01   105.936       105.951    
  36  0.228570      -1.47591     -0.414075      0.414075       105.832       106.246    
  37  0.879867     -0.127985     -0.359067E-01  0.359067E-01   105.770       105.806    
  38  0.390808E-01  -3.24212     -0.909595      0.909595       104.808       105.718    
  39  0.104244      -2.26102     -0.634341      0.634341       106.107       106.741    
  40  0.922634     -0.805225E-01 -0.225910E-01  0.225910E-01   106.001       106.023    
  41  0.559015     -0.581578     -0.163165      0.163165       106.255       106.418    
  42  0.809074     -0.211865     -0.594400E-01  0.594400E-01   105.672       105.732    
  43  0.840951     -0.173222     -0.485983E-01  0.485983E-01   106.384       106.432    
  44  0.384796     -0.955043     -0.267942      0.267942       106.343       106.611    
  45  0.471744     -0.751318     -0.210786      0.210786       106.184       106.395    
  46  0.750950     -0.286417     -0.803556E-01  0.803556E-01   103.201       103.282    
loop,thermsimp(1:2)       28  0.269562      0.928835E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    401        105.34         67.86          1.12         42.11          0.41          0.05        111.54
Just calling func    0   0        111.54


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  400    105.34       0.5122     -3.003      2.509     -102.6     0.2984    
                       1.039     0.6938     -99.70      4.489      1.234    

                       1.687     -2.464      1.540      7534.      7000.    

                      0.4274      0.000      0.000      0.000     -1.221    



                      -2.315      0.000      0.000      7000.      665.0    

                       1.891     -4.426     -4.328     -7.441      8.060    

                      -17.29     -6.440      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.3781    -0.8596      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.5034     -1.095      7000.    



                      -1.730     -1.436     -2.009     -1.930    -0.3807    

                     -0.3252      9.276      8.801    -0.1519E+05 -5.204    

                      -1.890     -3.784      9.372      8.907    -0.1969E+05



                      -6.000     0.6421    -0.3207E-01  8.998      8.971    

                     -0.1944E+05 -6.000     -1.121    -0.3630      9.108    

                       8.832    -0.1891E+05 -6.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    105.34
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       28
neval is:      400
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       28      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       29
neval is:      400


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      400     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.571653     -0.559223     -0.156893      0.156893       102.207       102.364    
   2  0.243540      -1.41247     -0.396277      0.396277       102.913       103.309    
   3  0.374772     -0.981437     -0.275347      0.275347       103.047       103.322    
   4  0.700054     -0.356598     -0.100046      0.100046       103.201       103.302    
   5  0.301581      -1.19872     -0.336306      0.336306       103.278       103.614    
   6  0.531818     -0.631454     -0.177158      0.177158       103.681       103.858    
   7  0.185013      -1.68733     -0.473390      0.473390       103.996       104.470    
   8  0.107050      -2.23446     -0.626890      0.626890       103.075       103.702    
   9  0.979566     -0.206453E-01 -0.579213E-02  0.579213E-02   104.294       104.300    
  10  0.706074     -0.348035     -0.976430E-01  0.976430E-01   103.941       104.038    
  11  0.112110      -2.18827     -0.613931      0.613931       104.389       105.003    
  12  0.212442      -1.54908     -0.434604      0.434604       104.298       104.733    
  13  0.625740     -0.468820     -0.131530      0.131530       104.407       104.538    
  14  0.265918      -1.32457     -0.371614      0.371614       104.509       104.881    
  15  0.369004     -0.996947     -0.279699      0.279699       104.268       104.548    
  16  0.531799     -0.631491     -0.177168      0.177168       104.734       104.911    
  17  0.227318      -1.48140     -0.415615      0.415615       104.538       104.953    
  18  0.512871     -0.667732     -0.187336      0.187336       104.724       104.911    
  19  0.394785     -0.929415     -0.260752      0.260752       104.856       105.117    
  20  0.720084     -0.328388     -0.921310E-01  0.921310E-01   104.627       104.719    
  21  0.185505      -1.68467     -0.472644      0.472644       104.731       105.204    
  22  0.658242     -0.418183     -0.117323      0.117323       105.027       105.145    
  23  0.888593     -0.118116     -0.331380E-01  0.331380E-01   105.182       105.215    
  24  0.773453     -0.256890     -0.720718E-01  0.720718E-01   104.969       105.041    
  25  0.594480E-01  -2.82265     -0.791910      0.791910       105.229       106.021    
  26  0.112908      -2.18118     -0.611942      0.611942       105.331       105.943    
  27  0.940300     -0.615559E-01 -0.172698E-01  0.172698E-01   105.323       105.340    
  28  0.990261     -0.978663E-02 -0.274569E-02  0.274569E-02   105.487       105.490    
  29  0.686451     -0.376220     -0.105550      0.105550       105.372       105.478    
  30  0.558815     -0.581936     -0.163265      0.163265       105.555       105.718    
  31  0.574196     -0.554784     -0.155648      0.155648       104.808       104.964    
  32  0.678960     -0.387193     -0.108629      0.108629       104.387       104.496    
  33  0.306232      -1.18341     -0.332013      0.332013       105.672       106.004    
  34  0.969485     -0.309907E-01 -0.869459E-02  0.869459E-02   105.004       105.013    
  35  0.520627     -0.652722     -0.183125      0.183125       105.353       105.536    
  36  0.870581     -0.138594     -0.388833E-01  0.388833E-01   105.770       105.809    
  37  0.127650      -2.05846     -0.577512      0.577512       105.936       106.514    
  38  0.276190      -1.28667     -0.360981      0.360981       105.856       106.217    
  39  0.842544     -0.171330     -0.480674E-01  0.480674E-01   106.001       106.049    
  40  0.336933      -1.08787     -0.305208      0.305208       105.698       106.004    
  41  0.685284     -0.377921     -0.106028      0.106028       105.832       105.938    
  42  0.555142     -0.588531     -0.165115      0.165115       106.184       106.349    
  43  0.857048     -0.154261     -0.432787E-01  0.432787E-01   106.255       106.299    
  44  0.612111E-01  -2.79343     -0.783710      0.783710       106.384       107.167    
  45  0.672500     -0.396753     -0.111311      0.111311       106.343       106.454    
  46  0.820423E-01  -2.50052     -0.701534      0.701534       105.342       106.044    
loop,thermsimp(1:2)       29  0.156893      0.396277    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    402        104.15         67.79          1.10         42.15          0.29          0.05        111.38
Just calling func    0   0        111.38


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    104.15
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       29
neval is:      401
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       29      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       30
neval is:      401


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      401     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.218498      -1.52098     -0.426718      0.426718       102.207       102.634    
   2  0.142120      -1.95108     -0.547386      0.547386       103.201       103.749    
   3  0.240947      -1.42318     -0.399279      0.399279       102.913       103.312    
   4  0.622235     -0.474438     -0.133106      0.133106       103.047       103.180    
   5  0.167679      -1.78570     -0.500988      0.500988       103.278       103.779    
   6  0.712985E-01  -2.64088     -0.740913      0.740913       103.075       103.816    
   7  0.861645E-02  -4.75408      -1.33378       1.33378       103.681       105.015    
   8  0.820106     -0.198321     -0.556401E-01  0.556401E-01   103.941       103.996    
   9  0.882469     -0.125032     -0.350783E-01  0.350783E-01   104.294       104.329    
  10  0.530124     -0.634644     -0.178053      0.178053       103.996       104.174    
  11  0.920027E-01  -2.38594     -0.669387      0.669387       104.387       105.057    
  12  0.669458     -0.401287     -0.112583      0.112583       104.407       104.519    
  13  0.348419      -1.05435     -0.295803      0.295803       104.268       104.564    
  14  0.979616     -0.205944E-01 -0.577787E-02  0.577787E-02   104.627       104.633    
  15  0.661083     -0.413875     -0.116115      0.116115       104.298       104.415    
  16  0.535120     -0.625265     -0.175421      0.175421       104.509       104.685    
  17  0.929679E-01  -2.37550     -0.666459      0.666459       104.734       105.400    
  18  0.580221     -0.544346     -0.152719      0.152719       104.724       104.877    
  19  0.652449     -0.427023     -0.119803      0.119803       104.538       104.657    
  20  0.252328      -1.37703     -0.386332      0.386332       104.808       105.194    
  21  0.364859      -1.00824     -0.282868      0.282868       104.389       104.672    
  22  0.205873      -1.58049     -0.443416      0.443416       105.004       105.447    
  23  0.404183E-01  -3.20847     -0.900154      0.900154       104.969       105.869    
  24  0.922242     -0.809474E-01 -0.227102E-01  0.227102E-01   104.856       104.878    
  25  0.164359      -1.80570     -0.506599      0.506599       105.027       105.534    
  26  0.606051     -0.500791     -0.140500      0.140500       104.731       104.871    
  27  0.461849E-01  -3.07510     -0.862736      0.862736       105.182       106.045    
  28  0.761223     -0.272829     -0.765436E-01  0.765436E-01   105.323       105.399    
  29  0.170682      -1.76796     -0.496009      0.496009       105.372       105.868    
  30  0.501713     -0.689726     -0.193506      0.193506       105.487       105.681    
  31  0.892390E-01  -2.41644     -0.677944      0.677944       105.353       106.031    
  32  0.281632E-01  -3.56974      -1.00151       1.00151       105.555       106.556    
  33  0.664381     -0.408899     -0.114719      0.114719       105.770       105.884    
  34  0.124936      -2.07995     -0.583542      0.583542       105.832       106.416    
  35  0.623262     -0.472788     -0.132643      0.132643       105.331       105.464    
  36  0.876206     -0.132154     -0.370765E-01  0.370765E-01   105.698       105.736    
  37  0.744183     -0.295469     -0.828953E-01  0.828953E-01   105.672       105.755    
  38  0.251914      -1.37867     -0.386792      0.386792       105.229       105.616    
  39  0.391818     -0.936959     -0.262869      0.262869       105.342       105.605    
  40  0.131094      -2.03184     -0.570044      0.570044       106.001       106.571    
  41  0.887574     -0.119263     -0.334598E-01  0.334598E-01   105.856       105.890    
  42  0.682509     -0.381980     -0.107166      0.107166       106.255       106.362    
  43  0.184805      -1.68846     -0.473705      0.473705       106.184       106.658    
  44  0.258729      -1.35197     -0.379303      0.379303       106.343       106.722    
  45  0.275506      -1.28915     -0.361677      0.361677       105.936       106.298    
  46  0.718710     -0.330297     -0.926666E-01  0.926666E-01   104.151       104.244    
loop,thermsimp(1:2)       30  0.426718      0.547386    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    403        104.10         67.89          1.11         42.25          0.23          0.05        111.53
Just calling func    0   0        111.53


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    104.10
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       30
neval is:      402
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       30      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       31
neval is:      402


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      402     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.179824      -1.71578     -0.481370      0.481370       102.207       102.688    
   2  0.422562     -0.861418     -0.241675      0.241675       103.047       103.288    
   3  0.186245      -1.68069     -0.471527      0.471527       102.913       103.384    
   4  0.567236     -0.566979     -0.159069      0.159069       103.201       103.361    
   5  0.464464E-01  -3.06946     -0.861152      0.861152       103.278       104.139    
   6  0.349374      -1.05161     -0.295036      0.295036       103.075       103.370    
   7  0.336208      -1.09002     -0.305812      0.305812       103.941       104.246    
   8  0.631615     -0.459475     -0.128908      0.128908       103.996       104.125    
   9  0.225630E-01  -3.79144      -1.06371       1.06371       104.151       105.215    
  10  0.221391      -1.50782     -0.423028      0.423028       104.294       104.717    
  11  0.635199     -0.453817     -0.127321      0.127321       104.298       104.426    
  12  0.957727     -0.431923E-01 -0.121178E-01  0.121178E-01   104.407       104.419    
  13  0.284413      -1.25733     -0.352750      0.352750       104.268       104.621    
  14  0.814352     -0.205363     -0.576155E-01  0.576155E-01   104.627       104.684    
  15  0.699052     -0.358030     -0.100447      0.100447       104.538       104.638    
  16  0.145269      -1.92917     -0.541238      0.541238       104.389       104.931    
  17  0.397569     -0.922386     -0.258780      0.258780       104.509       104.768    
  18  0.610583     -0.493342     -0.138410      0.138410       104.731       104.869    
  19  0.737372     -0.304663     -0.854747E-01  0.854747E-01   104.724       104.810    
  20  0.230083      -1.46931     -0.412223      0.412223       104.856       105.268    
  21  0.721698     -0.326149     -0.915028E-01  0.915028E-01   103.681       103.773    
  22  0.469765     -0.755524     -0.211966      0.211966       104.387       104.599    
  23  0.148742      -1.90554     -0.534610      0.534610       104.808       105.343    
  24  0.631872     -0.459069     -0.128794      0.128794       105.323       105.451    
  25  0.456921     -0.783245     -0.219743      0.219743       104.734       104.953    
  26  0.631874E-01  -2.76165     -0.774795      0.774795       105.004       105.779    
  27  0.470948     -0.753008     -0.211260      0.211260       105.331       105.543    
  28  0.313695      -1.15933     -0.325257      0.325257       105.027       105.353    
  29  0.856516     -0.154883     -0.434532E-01  0.434532E-01   105.342       105.386    
  30  0.487159     -0.719166     -0.201766      0.201766       105.229       105.431    
  31  0.383726     -0.957827     -0.268723      0.268723       105.487       105.756    
  32  0.242248      -1.41779     -0.397770      0.397770       105.698       106.096    
  33  0.760305     -0.274035     -0.768819E-01  0.768819E-01   105.672       105.749    
  34  0.524314     -0.645664     -0.181144      0.181144       105.372       105.553    
  35  0.759572     -0.275001     -0.771529E-01  0.771529E-01   104.969       105.046    
  36  0.784019     -0.243322     -0.682653E-01  0.682653E-01   105.770       105.838    
  37  0.430930     -0.841810     -0.236174      0.236174       105.856       106.092    
  38  0.670659     -0.399494     -0.112080      0.112080       105.353       105.465    
  39  0.458005     -0.780876     -0.219079      0.219079       105.182       105.401    
  40  0.413739     -0.882521     -0.247596      0.247596       105.936       106.184    
  41  0.388661     -0.945048     -0.265138      0.265138       106.255       106.520    
  42  0.753750     -0.282694     -0.793112E-01  0.793112E-01   105.832       105.911    
  43  0.505767     -0.681679     -0.191248      0.191248       105.555       105.746    
  44  0.759664     -0.274878     -0.771186E-01  0.771186E-01   106.001       106.078    
  45  0.468968     -0.757221     -0.212442      0.212442       106.184       106.397    
  46  0.740796     -0.300031     -0.841751E-01  0.841751E-01   104.097       104.182    
loop,thermsimp(1:2)       31  0.481370      0.241675    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    404        104.07         67.87          1.09         42.14          0.14          0.05        111.28
Just calling func    0   0        111.28


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    104.07
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       31
neval is:      403
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       31      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       32
neval is:      403


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      403     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.574970E-01  -2.85602     -0.801272      0.801272       102.207       103.008    
   2  0.695439     -0.363212     -0.101901      0.101901       103.047       103.149    
   3  0.338668      -1.08273     -0.303767      0.303767       103.201       103.505    
   4  0.494821     -0.703559     -0.197387      0.197387       103.075       103.272    
   5  0.433638E-02  -5.44072      -1.52642       1.52642       102.913       104.439    
   6  0.270974      -1.30573     -0.366330      0.366330       103.681       104.047    
   7  0.926362E-01  -2.37907     -0.667462      0.667462       103.996       104.664    
   8  0.437858     -0.825861     -0.231700      0.231700       103.278       103.509    
   9  0.297746      -1.21151     -0.339896      0.339896       104.097       104.437    
  10  0.948309     -0.530750E-01 -0.148905E-01  0.148905E-01   103.941       103.956    
  11  0.845139     -0.168254     -0.472046E-01  0.472046E-01   104.407       104.454    
  12  0.930128     -0.724325E-01 -0.203213E-01  0.203213E-01   104.298       104.319    
  13  0.921850     -0.813732E-01 -0.228297E-01  0.228297E-01   104.387       104.410    
  14  0.447950     -0.803074     -0.225307      0.225307       104.268       104.493    
  15  0.712740     -0.338638     -0.950066E-01  0.950066E-01   104.538       104.633    
  16  0.574809     -0.553717     -0.155348      0.155348       104.627       104.782    
  17  0.136104      -1.99433     -0.559520      0.559520       104.294       104.854    
  18  0.340340      -1.07781     -0.302385      0.302385       104.509       104.812    
  19  0.149160      -1.90274     -0.533823      0.533823       104.724       105.258    
  20  0.433234E-01  -3.13906     -0.880680      0.880680       104.731       105.612    
  21  0.909134     -0.952630E-01 -0.267265E-01  0.267265E-01   104.389       104.416    
  22  0.619739     -0.478456     -0.134233      0.134233       104.734       104.868    
  23  0.726693     -0.319251     -0.895674E-01  0.895674E-01   104.969       105.059    
  24  0.962860     -0.378471E-01 -0.106182E-01  0.106182E-01   104.151       104.162    
  25  0.615108     -0.485958     -0.136338      0.136338       104.856       104.992    
  26  0.500401     -0.692346     -0.194241      0.194241       104.808       105.002    
  27  0.402080     -0.911104     -0.255615      0.255615       105.027       105.283    
  28  0.749737     -0.288033     -0.808091E-01  0.808091E-01   105.342       105.423    
  29  0.926553     -0.762839E-01 -0.214019E-01  0.214019E-01   105.182       105.204    
  30  0.519037     -0.655779     -0.183982      0.183982       105.229       105.413    
  31  0.498178E-01  -2.99938     -0.841492      0.841492       105.323       106.164    
  32  0.473692     -0.747197     -0.209630      0.209630       105.353       105.563    
  33  0.574927E-02  -5.15868      -1.44729       1.44729       105.331       106.779    
  34  0.349575      -1.05104     -0.294874      0.294874       105.372       105.667    
  35  0.661333     -0.413498     -0.116009      0.116009       105.555       105.671    
  36  0.314247E-01  -3.46016     -0.970766      0.970766       105.672       106.643    
  37  0.318841      -1.14306     -0.320692      0.320692       105.487       105.808    
  38  0.111349E-01  -4.49767      -1.26185       1.26185       105.004       106.266    
  39  0.845234E-02  -4.77331      -1.33918       1.33918       105.770       107.109    
  40  0.704975E-01  -2.65218     -0.744082      0.744082       105.832       106.576    
  41  0.126423      -2.06812     -0.580223      0.580223       106.001       106.581    
  42  0.120140      -2.11910     -0.594524      0.594524       105.856       106.451    
  43  0.664865     -0.408172     -0.114515      0.114515       105.698       105.813    
  44  0.829336     -0.187130     -0.525002E-01  0.525002E-01   105.936       105.989    
  45  0.656735     -0.420475     -0.117966      0.117966       106.184       106.302    
  46  0.955374     -0.456526E-01 -0.128081E-01  0.128081E-01   104.070       104.083    
loop,thermsimp(1:2)       32  0.801272      0.101901    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    405        103.81         67.80          1.10         42.12          0.42          0.05        111.50
Just calling func    0   0        111.50


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    103.81
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       32
neval is:      404
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       32      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       33
neval is:      404


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      404     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.806752     -0.214739     -0.602461E-01  0.602461E-01   102.207       102.267    
   2  0.549594     -0.598576     -0.167934      0.167934       103.047       103.215    
   3  0.631143     -0.460223     -0.129118      0.129118       103.075       103.204    
   4  0.268455      -1.31507     -0.368950      0.368950       103.201       103.570    
   5  0.513519     -0.666468     -0.186981      0.186981       103.278       103.465    
   6  0.886725     -0.120220     -0.337283E-01  0.337283E-01   103.941       103.974    
   7  0.568618     -0.564546     -0.158386      0.158386       103.681       103.840    
   8  0.443178     -0.813783     -0.228311      0.228311       104.070       104.298    
   9  0.898491     -0.107039     -0.300303E-01  0.300303E-01   104.151       104.181    
  10  0.235118      -1.44767     -0.406150      0.406150       104.298       104.705    
  11  0.509444     -0.674434     -0.189216      0.189216       104.387       104.576    
  12  0.223921      -1.49646     -0.419840      0.419840       104.389       104.809    
  13  0.188995      -1.66603     -0.467414      0.467414       104.097       104.565    
  14  0.969568     -0.309049E-01 -0.867052E-02  0.867052E-02   102.913       102.921    
  15  0.287265      -1.24735     -0.349951      0.349951       104.407       104.756    
  16  0.559573E-01  -2.88317     -0.808887      0.808887       104.268       105.077    
  17  0.668393     -0.402878     -0.113030      0.113030       104.538       104.651    
  18  0.488393     -0.716635     -0.201056      0.201056       103.996       104.197    
  19  0.605591     -0.501551     -0.140713      0.140713       104.627       104.768    
  20  0.490783     -0.711753     -0.199686      0.199686       104.509       104.709    
  21  0.313180      -1.16098     -0.325718      0.325718       104.294       104.620    
  22  0.200234      -1.60827     -0.451208      0.451208       104.734       105.185    
  23  0.575811     -0.551975     -0.154860      0.154860       104.856       105.011    
  24  0.856965     -0.154358     -0.433058E-01  0.433058E-01   104.808       104.851    
  25  0.310774      -1.16869     -0.327881      0.327881       104.969       105.297    
  26  0.836513     -0.178513     -0.500828E-01  0.500828E-01   105.182       105.232    
  27  0.286335      -1.25059     -0.350861      0.350861       104.724       105.075    
  28  0.240507      -1.42500     -0.399792      0.399792       105.027       105.427    
  29  0.103511E-01  -4.57066      -1.28232       1.28232       105.229       106.511    
  30  0.516897     -0.659912     -0.185142      0.185142       105.342       105.527    
  31  0.237615      -1.43710     -0.403187      0.403187       105.353       105.757    
  32  0.602330     -0.506950     -0.142227      0.142227       104.731       104.873    
  33  0.677792     -0.388915     -0.109112      0.109112       105.372       105.481    
  34  0.965031     -0.355954E-01 -0.998647E-02  0.998647E-02   105.555       105.565    
  35  0.851769     -0.160440     -0.450123E-01  0.450123E-01   105.487       105.532    
  36  0.998637     -0.136415E-02 -0.382719E-03  0.382719E-03   105.698       105.699    
  37  0.690071E-01  -2.67355     -0.750077      0.750077       105.936       106.686    
  38  0.865316E-02  -4.74983      -1.33259       1.33259       105.323       106.655    
  39  0.657551     -0.419234     -0.117618      0.117618       105.004       105.122    
  40  0.249918      -1.38662     -0.389024      0.389024       106.184       106.573    
  41  0.762839     -0.270708     -0.759485E-01  0.759485E-01   105.856       105.932    
  42  0.875176     -0.133331     -0.374066E-01  0.374066E-01   105.832       105.869    
  43  0.805569     -0.216207     -0.606579E-01  0.606579E-01   106.001       106.061    
  44  0.308797      -1.17507     -0.329672      0.329672       105.672       106.002    
  45  0.255763      -1.36350     -0.382538      0.382538       105.331       105.714    
  46  0.218508      -1.52093     -0.426706      0.426706       103.811       104.238    
loop,thermsimp(1:2)       33  0.602461E-01  0.167934    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    406        103.45         67.88          1.10         42.10          0.45          0.05        111.57
Just calling func    0   0        111.57


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    103.45
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       33
neval is:      405
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       33      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       34
neval is:      405


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      405     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.375893     -0.978451     -0.274509      0.274509       102.207       102.482    
   2  0.356800      -1.03058     -0.289135      0.289135       102.913       103.202    
   3  0.686180     -0.376616     -0.105662      0.105662       103.075       103.180    
   4  0.443986     -0.811963     -0.227800      0.227800       103.047       103.275    
   5  0.837544     -0.177281     -0.497372E-01  0.497372E-01   103.278       103.327    
   6  0.902394     -0.102704     -0.288141E-01  0.288141E-01   103.201       103.230    
   7  0.509658E-01  -2.97660     -0.835101      0.835101       103.681       104.516    
   8  0.662569     -0.411631     -0.115485      0.115485       103.941       104.056    
   9  0.226311      -1.48585     -0.416862      0.416862       104.151       104.568    
  10  0.336196      -1.09006     -0.305822      0.305822       103.996       104.302    
  11  0.122038      -2.10342     -0.590125      0.590125       103.811       104.401    
  12  0.323275      -1.12925     -0.316817      0.316817       104.070       104.387    
  13  0.326513      -1.11929     -0.314022      0.314022       104.097       104.411    
  14  0.904434     -0.100446     -0.281806E-01  0.281806E-01   104.387       104.415    
  15  0.856476     -0.154928     -0.434660E-01  0.434660E-01   104.294       104.338    
  16  0.873700     -0.135019     -0.378802E-01  0.378802E-01   104.538       104.576    
  17  0.989627     -0.104267E-01 -0.292527E-02  0.292527E-02   104.298       104.301    
  18  0.546745     -0.603772     -0.169391      0.169391       104.509       104.679    
  19  0.731718     -0.312360     -0.876342E-01  0.876342E-01   104.407       104.494    
  20  0.859154     -0.151807     -0.425902E-01  0.425902E-01   104.627       104.669    
  21  0.419381     -0.868976     -0.243796      0.243796       104.389       104.633    
  22  0.587067     -0.532617     -0.149428      0.149428       104.808       104.957    
  23  0.460289E-01  -3.07849     -0.863685      0.863685       104.731       105.595    
  24  0.522902     -0.648362     -0.181901      0.181901       104.856       105.038    
  25  0.398671     -0.919618     -0.258004      0.258004       104.724       104.982    
  26  0.881302     -0.126355     -0.354495E-01  0.354495E-01   104.268       104.303    
  27  0.226039      -1.48705     -0.417198      0.417198       105.004       105.421    
  28  0.124144      -2.08631     -0.585325      0.585325       104.734       105.319    
  29  0.542680     -0.611235     -0.171485      0.171485       105.182       105.354    
  30  0.167496      -1.78679     -0.501294      0.501294       104.969       105.470    
  31  0.619825     -0.478318     -0.134195      0.134195       105.027       105.161    
  32  0.169564      -1.77452     -0.497852      0.497852       105.372       105.870    
  33  0.781291     -0.246807     -0.692430E-01  0.692430E-01   105.342       105.411    
  34  0.486264     -0.721004     -0.202281      0.202281       105.487       105.689    
  35  0.895366     -0.110522     -0.310076E-01  0.310076E-01   105.555       105.586    
  36  0.321503      -1.13475     -0.318360      0.318360       105.698       106.017    
  37  0.607862E-01  -2.80039     -0.785665      0.785665       105.331       106.117    
  38  0.365124      -1.00752     -0.282664      0.282664       105.353       105.636    
  39  0.110107      -2.20630     -0.618990      0.618990       105.832       106.451    
  40  0.905082     -0.997294E-01 -0.279796E-01  0.279796E-01   105.856       105.884    
  41  0.960140     -0.406759E-01 -0.114118E-01  0.114118E-01   105.672       105.684    
  42  0.320200      -1.13881     -0.319499      0.319499       106.001       106.320    
  43  0.396920     -0.924021     -0.259239      0.259239       105.229       105.488    
  44  0.674668     -0.393534     -0.110408      0.110408       106.184       106.295    
  45  0.894300     -0.111715     -0.313421E-01  0.313421E-01   105.323       105.354    
  46  0.875669     -0.132767     -0.372486E-01  0.372486E-01   103.448       103.486    
loop,thermsimp(1:2)       34  0.274509      0.289135    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    407        106.22         68.00          1.15         41.83          0.57          0.05        111.60
Just calling func    0   0        111.60


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    106.22
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       34
neval is:      406
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       34      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       35
neval is:      406


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      406
neval,tstepnext:      406     406

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.478411     -0.737285     -0.206849      0.206849       102.207       102.414    
   2  0.380700     -0.965745     -0.270945      0.270945       103.075       103.346    
   3  0.821138     -0.197064     -0.552873E-01  0.552873E-01   102.913       102.968    
   4  0.728654     -0.316557     -0.888117E-01  0.888117E-01   103.201       103.290    
   5  0.670900     -0.399135     -0.111979      0.111979       103.047       103.159    
   6  0.175262      -1.74147     -0.488579      0.488579       103.278       103.766    
   7  0.709150     -0.343688     -0.964235E-01  0.964235E-01   103.448       103.545    
   8  0.247481      -1.39642     -0.391773      0.391773       103.941       104.332    
   9  0.231597      -1.46276     -0.410384      0.410384       104.298       104.709    
  10  0.764757     -0.268198     -0.752442E-01  0.752442E-01   103.996       104.071    
  11  0.798540     -0.224970     -0.631164E-01  0.631164E-01   104.268       104.331    
  12  0.903782     -0.101167     -0.283830E-01  0.283830E-01   104.294       104.323    
  13  0.136634      -1.99045     -0.558431      0.558431       104.070       104.628    
  14  0.141955      -1.95225     -0.547713      0.547713       103.811       104.359    
  15  0.658650     -0.417563     -0.117149      0.117149       104.097       104.215    
  16  0.265370      -1.32663     -0.372193      0.372193       104.387       104.759    
  17  0.439277E-01  -3.12521     -0.876794      0.876794       104.407       105.283    
  18  0.451732     -0.794667     -0.222948      0.222948       103.681       103.904    
  19  0.475868     -0.742615     -0.208345      0.208345       104.151       104.360    
  20  0.336185      -1.09009     -0.305831      0.305831       104.538       104.843    
  21  0.519277     -0.655317     -0.183853      0.183853       104.389       104.573    
  22  0.455030     -0.787393     -0.220907      0.220907       104.627       104.848    
  23  0.272148E-01  -3.60399      -1.01112       1.01112       104.509       105.520    
  24  0.125510      -2.07537     -0.582256      0.582256       104.808       105.390    
  25  0.687868     -0.374159     -0.104972      0.104972       104.724       104.829    
  26  0.271894      -1.30234     -0.365379      0.365379       104.856       105.221    
  27  0.641335     -0.444204     -0.124624      0.124624       105.027       105.152    
  28  0.858838E-01  -2.45476     -0.688696      0.688696       104.734       105.422    
  29  0.579605     -0.545408     -0.153017      0.153017       105.182       105.335    
  30  0.249942      -1.38653     -0.388998      0.388998       105.323       105.712    
  31  0.938016     -0.639885E-01 -0.179523E-01  0.179523E-01   105.342       105.360    
  32  0.453695     -0.790330     -0.221731      0.221731       105.004       105.226    
  33  0.319751      -1.14021     -0.319893      0.319893       104.969       105.289    
  34  0.346149      -1.06089     -0.297637      0.297637       105.229       105.527    
  35  0.870951     -0.138169     -0.387642E-01  0.387642E-01   105.555       105.593    
  36  0.187313      -1.67497     -0.469922      0.469922       104.731       105.201    
  37  0.984950     -0.151645E-01 -0.425449E-02  0.425449E-02   105.353       105.358    
  38  0.524062     -0.646145     -0.181279      0.181279       105.672       105.853    
  39  0.432392     -0.838423     -0.235224      0.235224       105.487       105.722    
  40  0.687254     -0.375052     -0.105223      0.105223       105.372       105.478    
  41  0.869131     -0.140262     -0.393512E-01  0.393512E-01   105.856       105.895    
  42  0.350749      -1.04769     -0.293934      0.293934       105.698       105.992    
  43  0.663152E-01  -2.71334     -0.761240      0.761240       105.331       106.093    
  44  0.306857      -1.18137     -0.331440      0.331440       106.184       106.516    
  45  0.925728     -0.771751E-01 -0.216519E-01  0.216519E-01   106.001       106.022    
  46  0.649899     -0.430939     -0.120902      0.120902       106.218       106.339    
loop,thermsimp(1:2)       35  0.206849      0.270945    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    408        104.32         67.86          1.11         42.05          0.67          0.05        111.73
Just calling func    0   0        111.73


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    104.32
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.280555               406
loop is:       35
neval is:      407
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       35      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.280555               406
loop is:       36
neval is:      407


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 




neval>tstepnex so lower away!t
---> lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
     new SAtemp,tstepnext are :   0.140278               451

 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      407     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.943705     -0.579419E-01 -0.812796E-02  0.812796E-02   102.207       102.215    
   2  0.628336     -0.464680     -0.651842E-01  0.651842E-01   102.913       102.978    
   3  0.261321      -1.34200     -0.188253      0.188253       103.047       103.235    
   4  0.256100      -1.36219     -0.191084      0.191084       103.201       103.393    
   5  0.318070      -1.14548     -0.160686      0.160686       103.075       103.235    
   6  0.895943     -0.109878     -0.154135E-01  0.154135E-01   103.448       103.464    
   7  0.856491     -0.154912     -0.217307E-01  0.217307E-01   103.278       103.299    
   8  0.269953      -1.30951     -0.183695      0.183695       103.681       103.865    
   9  0.663616     -0.410051     -0.575210E-01  0.575210E-01   103.996       104.054    
  10  0.249338E-01  -3.69153     -0.517839      0.517839       104.097       104.615    
  11  0.362852      -1.01376     -0.142208      0.142208       104.294       104.436    
  12  0.868529E-02  -4.74612     -0.665775      0.665775       104.268       104.934    
  13  0.705785     -0.348444     -0.488789E-01  0.488789E-01   103.941       103.990    
  14  0.527358     -0.639875     -0.897601E-01  0.897601E-01   103.811       103.901    
  15  0.831399     -0.184645     -0.259015E-01  0.259015E-01   104.151       104.177    
  16  0.594963     -0.519255     -0.728399E-01  0.728399E-01   104.389       104.462    
  17  0.501981     -0.689193     -0.966783E-01  0.966783E-01   104.070       104.167    
  18  0.594311     -0.520353     -0.729938E-01  0.729938E-01   104.298       104.371    
  19  0.618124     -0.481066     -0.674828E-01  0.674828E-01   104.387       104.455    
  20  0.959578E-01  -2.34385     -0.328789      0.328789       104.724       105.053    
  21  0.776845     -0.252514     -0.354221E-01  0.354221E-01   104.538       104.573    
  22  0.458742     -0.779266     -0.109314      0.109314       104.627       104.736    
  23  0.645084     -0.438374     -0.614941E-01  0.614941E-01   105.027       105.089    
  24  0.545194     -0.606614     -0.850943E-01  0.850943E-01   104.731       104.816    
  25  0.618072     -0.481151     -0.674947E-01  0.674947E-01   104.856       104.923    
  26  0.390168     -0.941179     -0.132026      0.132026       105.004       105.136    
  27  0.122318      -2.10113     -0.294742      0.294742       104.407       104.701    
  28  0.823049     -0.194740     -0.273176E-01  0.273176E-01   104.969       104.996    
  29  0.817844E-01  -2.50367     -0.351209      0.351209       105.182       105.534    
  30  0.189400      -1.66389     -0.233407      0.233407       105.353       105.587    
  31  0.257378      -1.35721     -0.190386      0.190386       105.342       105.533    
  32  0.854384     -0.157375     -0.220762E-01  0.220762E-01   104.808       104.830    
  33  0.128350      -2.05300     -0.287989      0.287989       104.734       105.022    
  34  0.410790     -0.889673     -0.124801      0.124801       105.372       105.497    
  35  0.645584     -0.437599     -0.613854E-01  0.613854E-01   104.509       104.571    
  36  0.309517      -1.17274     -0.164509      0.164509       105.229       105.394    
  37  0.568550     -0.564667     -0.792101E-01  0.792101E-01   105.555       105.634    
  38  0.702184     -0.353560     -0.495966E-01  0.495966E-01   105.323       105.372    
  39  0.939991     -0.618850E-01 -0.868108E-02  0.868108E-02   105.487       105.496    
  40  0.944105     -0.575180E-01 -0.806848E-02  0.806848E-02   105.672       105.680    
  41  0.202943      -1.59483     -0.223719      0.223719       105.856       106.080    
  42  0.948631E-02  -4.65791     -0.653400      0.653400       105.698       106.352    
  43  0.568674     -0.564449     -0.791795E-01  0.791795E-01   106.001       106.080    
  44  0.216733      -1.52909     -0.214497      0.214497       105.331       105.546    
  45  0.385755     -0.952553     -0.133622      0.133622       106.218       106.352    
  46  0.894850E-01  -2.41368     -0.338586      0.338586       104.316       104.655    
loop,thermsimp(1:2)       36  0.812796E-02  0.651842E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    409        104.57         67.86          1.10         42.20          0.46          0.04        111.67
Just calling func    0   0        111.67


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    104.57
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       36
neval is:      408
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       36      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       37
neval is:      408


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      408     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.577652     -0.548784     -0.769820E-01  0.769820E-01   102.207       102.284    
   2  0.954687     -0.463716E-01 -0.650489E-02  0.650489E-02   102.913       102.919    
   3  0.530232     -0.634441     -0.889978E-01  0.889978E-01   103.047       103.136    
   4  0.762581     -0.271046     -0.380217E-01  0.380217E-01   103.075       103.113    
   5  0.261488      -1.34137     -0.188164      0.188164       103.278       103.466    
   6  0.639820     -0.446569     -0.626436E-01  0.626436E-01   103.201       103.264    
   7  0.527286     -0.640012     -0.897793E-01  0.897793E-01   103.448       103.538    
   8  0.819676     -0.198846     -0.278936E-01  0.278936E-01   103.681       103.709    
   9  0.564974     -0.570976     -0.800952E-01  0.800952E-01   103.811       103.891    
  10  0.313261      -1.16072     -0.162823      0.162823       103.941       104.103    
  11  0.741013     -0.299737     -0.420464E-01  0.420464E-01   103.996       104.038    
  12  0.286155      -1.25122     -0.175518      0.175518       104.070       104.245    
  13  0.145515      -1.92747     -0.270382      0.270382       104.151       104.422    
  14  0.417445     -0.873602     -0.122547      0.122547       104.298       104.421    
  15  0.110117      -2.20621     -0.309482      0.309482       104.294       104.604    
  16  0.798228     -0.225361     -0.316131E-01  0.316131E-01   104.387       104.419    
  17  0.981317     -0.188596E-01 -0.264558E-02  0.264558E-02   104.389       104.392    
  18  0.947313     -0.541256E-01 -0.759261E-02  0.759261E-02   104.509       104.517    
  19  0.979175     -0.210453E-01 -0.295218E-02  0.295218E-02   104.538       104.541    
  20  0.507968     -0.677337     -0.950151E-01  0.950151E-01   104.097       104.192    
  21  0.313327      -1.16051     -0.162793      0.162793       104.316       104.479    
  22  0.174912      -1.74347     -0.244570      0.244570       104.407       104.651    
  23  0.278222      -1.27933     -0.179462      0.179462       104.627       104.806    
  24  0.551320     -0.595439     -0.835268E-01  0.835268E-01   104.731       104.814    
  25  0.509281     -0.674756     -0.946531E-01  0.946531E-01   104.808       104.903    
  26  0.202795E-01  -3.89814     -0.546822      0.546822       104.856       105.403    
  27  0.394215     -0.930860     -0.130579      0.130579       104.268       104.399    
  28  0.463302     -0.769377     -0.107926      0.107926       104.969       105.077    
  29  0.132020      -2.02480     -0.284034      0.284034       104.734       105.018    
  30  0.330810      -1.10621     -0.155177      0.155177       104.724       104.879    
  31  0.415110     -0.879212     -0.123334      0.123334       105.027       105.151    
  32  0.381803     -0.962850     -0.135066      0.135066       105.004       105.139    
  33  0.209798E-01  -3.86420     -0.542060      0.542060       105.323       105.865    
  34  0.906539     -0.981217E-01 -0.137643E-01  0.137643E-01   105.229       105.243    
  35  0.507460     -0.678337     -0.951554E-01  0.951554E-01   105.487       105.582    
  36  0.694619     -0.364392     -0.511160E-01  0.511160E-01   105.372       105.423    
  37  0.704259     -0.350610     -0.491827E-01  0.491827E-01   105.342       105.391    
  38  0.953152     -0.479806E-01 -0.673060E-02  0.673060E-02   105.182       105.189    
  39  0.393408     -0.932907     -0.130866      0.130866       105.331       105.462    
  40  0.361825      -1.01659     -0.142605      0.142605       105.353       105.496    
  41  0.420592     -0.866091     -0.121493      0.121493       105.555       105.676    
  42  0.474514     -0.745463     -0.104572      0.104572       105.672       105.777    
  43  0.769306     -0.262267     -0.367901E-01  0.367901E-01   105.856       105.893    
  44  0.881065     -0.126624     -0.177624E-01  0.177624E-01   106.001       106.018    
  45  0.298206      -1.20997     -0.169732      0.169732       106.218       106.388    
  46  0.364982E-01  -3.31049     -0.464388      0.464388       104.571       105.035    
loop,thermsimp(1:2)       37  0.769820E-01  0.650489E-02

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    410        105.89         67.80          1.08         42.17          0.55          0.05        111.64
Just calling func    0   0        111.64


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    105.89
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       37
neval is:      409
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       37      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       38
neval is:      409


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      409     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.708199     -0.345030     -0.483999E-01  0.483999E-01   102.207       102.255    
   2  0.656861     -0.420283     -0.589563E-01  0.589563E-01   102.913       102.972    
   3  0.531016     -0.632963     -0.887905E-01  0.887905E-01   103.075       103.163    
   4  0.259645      -1.34844     -0.189156      0.189156       103.047       103.236    
   5  0.509285E-01  -2.97733     -0.417653      0.417653       103.201       103.619    
   6  0.222403      -1.50327     -0.210874      0.210874       103.278       103.489    
   7  0.883122E-01  -2.42688     -0.340436      0.340436       103.448       103.789    
   8  0.689941     -0.371150     -0.520640E-01  0.520640E-01   103.681       103.733    
   9  0.811351     -0.209054     -0.293256E-01  0.293256E-01   103.811       103.841    
  10  0.252526      -1.37624     -0.193056      0.193056       103.996       104.189    
  11  0.229840      -1.47037     -0.206260      0.206260       103.941       104.147    
  12  0.108257      -2.22324     -0.311871      0.311871       104.097       104.409    
  13  0.933379E-02  -4.67411     -0.655673      0.655673       104.070       104.726    
  14  0.685050E-01  -2.68085     -0.376063      0.376063       104.389       104.765    
  15  0.875782     -0.132638     -0.186062E-01  0.186062E-01   104.268       104.287    
  16  0.592250     -0.523826     -0.734810E-01  0.734810E-01   104.387       104.461    
  17  0.259190E-01  -3.65278     -0.512403      0.512403       104.298       104.811    
  18  0.411624     -0.887646     -0.124517      0.124517       104.151       104.276    
  19  0.215731      -1.53372     -0.215147      0.215147       104.316       104.532    
  20  0.104157      -2.26185     -0.317287      0.317287       104.509       104.827    
  21  0.796475     -0.227560     -0.319216E-01  0.319216E-01   104.538       104.570    
  22  0.316732      -1.14970     -0.161277      0.161277       104.294       104.455    
  23  0.868566     -0.140911     -0.197667E-01  0.197667E-01   104.407       104.426    
  24  0.932817     -0.695461E-01 -0.975576E-02  0.975576E-02   104.627       104.637    
  25  0.704796E-01  -2.65243     -0.372077      0.372077       104.731       105.103    
  26  0.584289     -0.537360     -0.753796E-01  0.753796E-01   104.724       104.800    
  27  0.345306      -1.06332     -0.149160      0.149160       104.808       104.957    
  28  0.367589E-01  -3.30338     -0.463390      0.463390       104.734       105.197    
  29  0.470285     -0.754417     -0.105828      0.105828       104.571       104.677    
  30  0.303718      -1.19165     -0.167162      0.167162       104.969       105.136    
  31  0.298675      -1.20840     -0.169511      0.169511       105.004       105.174    
  32  0.506100     -0.681022     -0.955321E-01  0.955321E-01   105.027       105.123    
  33  0.240488      -1.42508     -0.199907      0.199907       105.182       105.382    
  34  0.673726     -0.394932     -0.554001E-01  0.554001E-01   105.229       105.284    
  35  0.303531      -1.19227     -0.167249      0.167249       105.342       105.510    
  36  0.450278     -0.797890     -0.111926      0.111926       104.856       104.968    
  37  0.850970     -0.161378     -0.226377E-01  0.226377E-01   105.372       105.395    
  38  0.370442     -0.993060     -0.139304      0.139304       105.331       105.471    
  39  0.328520      -1.11316     -0.156151      0.156151       105.353       105.510    
  40  0.194991      -1.63480     -0.229326      0.229326       105.487       105.716    
  41  0.547740     -0.601955     -0.844407E-01  0.844407E-01   105.555       105.639    
  42  0.574734     -0.553847     -0.776924E-01  0.776924E-01   105.672       105.750    
  43  0.900615     -0.104678     -0.146840E-01  0.146840E-01   105.323       105.337    
  44  0.316870      -1.14926     -0.161216      0.161216       105.856       106.017    
  45  0.961546     -0.392133E-01 -0.550075E-02  0.550075E-02   106.001       106.006    
  46  0.714054     -0.336796     -0.472449E-01  0.472449E-01   105.887       105.934    
loop,thermsimp(1:2)       38  0.483999E-01  0.589563E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    411        103.59         67.83          1.10         42.24          0.35          0.05        111.57
Just calling func    0   0        111.57


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    103.59
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       38
neval is:      410
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       38      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       39
neval is:      410


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      410     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.796195     -0.227912     -0.319709E-01  0.319709E-01   102.207       102.239    
   2  0.306803      -1.18155     -0.165745      0.165745       102.913       103.078    
   3  0.857946     -0.153214     -0.214925E-01  0.214925E-01   103.075       103.096    
   4  0.363815      -1.01111     -0.141836      0.141836       103.047       103.189    
   5  0.755322E-01  -2.58320     -0.362364      0.362364       103.278       103.640    
   6  0.345998E-01  -3.36391     -0.471881      0.471881       103.201       103.673    
   7  0.280587      -1.27087     -0.178275      0.178275       103.681       103.859    
   8  0.907418     -0.971519E-01 -0.136282E-01  0.136282E-01   103.448       103.462    
   9  0.696180     -0.362147     -0.508011E-01  0.508011E-01   103.811       103.862    
  10  0.640049     -0.446211     -0.625934E-01  0.625934E-01   103.941       104.003    
  11  0.620842     -0.476679     -0.668674E-01  0.668674E-01   103.996       104.063    
  12  0.850691     -0.161706     -0.226838E-01  0.226838E-01   104.151       104.174    
  13  0.308317      -1.17663     -0.165054      0.165054       104.268       104.433    
  14  0.198496      -1.61698     -0.226827      0.226827       104.097       104.324    
  15  0.119809      -2.12186     -0.297649      0.297649       104.407       104.704    
  16  0.905871     -0.988582E-01 -0.138676E-01  0.138676E-01   104.294       104.308    
  17  0.386344     -0.951028     -0.133408      0.133408       104.387       104.521    
  18  0.112809      -2.18206     -0.306094      0.306094       104.316       104.622    
  19  0.682866     -0.381457     -0.535099E-01  0.535099E-01   104.538       104.591    
  20  0.819362     -0.199230     -0.279475E-01  0.279475E-01   104.627       104.655    
  21  0.412742     -0.884933     -0.124136      0.124136       104.571       104.695    
  22  0.211811E-01  -3.85464     -0.540720      0.540720       104.070       104.611    
  23  0.422800     -0.860857     -0.120759      0.120759       104.389       104.510    
  24  0.826028     -0.191126     -0.268107E-01  0.268107E-01   104.724       104.751    
  25  0.457858     -0.781197     -0.109584      0.109584       104.298       104.408    
  26  0.551067     -0.595900     -0.835913E-01  0.835913E-01   104.509       104.593    
  27  0.160440      -1.82984     -0.256685      0.256685       104.808       105.065    
  28  0.240310      -1.42582     -0.200011      0.200011       104.856       105.056    
  29  0.614859     -0.486362     -0.682257E-01  0.682257E-01   104.731       104.799    
  30  0.489204     -0.714976     -0.100295      0.100295       105.027       105.128    
  31  0.151691      -1.88591     -0.264551      0.264551       104.969       105.234    
  32  0.221776      -1.50609     -0.211270      0.211270       105.004       105.215    
  33  0.333050      -1.09946     -0.154230      0.154230       104.734       104.888    
  34  0.905001     -0.998190E-01 -0.140024E-01  0.140024E-01   105.229       105.243    
  35  0.598599     -0.513164     -0.719854E-01  0.719854E-01   105.323       105.395    
  36  0.603742     -0.504608     -0.707851E-01  0.707851E-01   105.182       105.253    
  37  0.989214     -0.108448E-01 -0.152128E-02  0.152128E-02   105.372       105.374    
  38  0.175887      -1.73792     -0.243791      0.243791       105.331       105.575    
  39  0.708621     -0.344434     -0.483164E-01  0.483164E-01   105.342       105.391    
  40  0.940581     -0.612570E-01 -0.859298E-02  0.859298E-02   105.353       105.362    
  41  0.870068     -0.139184     -0.195243E-01  0.195243E-01   105.555       105.574    
  42  0.260264      -1.34606     -0.188822      0.188822       105.487       105.676    
  43  0.216654      -1.52946     -0.214548      0.214548       105.672       105.887    
  44  0.553762     -0.591020     -0.829068E-01  0.829068E-01   105.887       105.970    
  45  0.891465     -0.114889     -0.161164E-01  0.161164E-01   106.001       106.017    
  46  0.320048      -1.13928     -0.159816      0.159816       103.589       103.748    
loop,thermsimp(1:2)       39  0.319709E-01  0.165745    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    412        104.35         67.85          1.10         42.14          0.25          0.05        111.39
Just calling func    0   0        111.39


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    104.35
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       39
neval is:      411
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       39      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       40
neval is:      411


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      411     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.783363     -0.244159     -0.342500E-01  0.342500E-01   102.207       102.241    
   2  0.179321      -1.71858     -0.241078      0.241078       102.913       103.154    
   3  0.331080      -1.10539     -0.155062      0.155062       103.075       103.230    
   4  0.130870      -2.03355     -0.285262      0.285262       103.047       103.332    
   5  0.604904     -0.502686     -0.705155E-01  0.705155E-01   103.448       103.519    
   6  0.140568      -1.96207     -0.275234      0.275234       103.278       103.553    
   7  0.127414      -2.06031     -0.289016      0.289016       103.201       103.490    
   8  0.389565     -0.942725     -0.132243      0.132243       103.589       103.721    
   9  0.835608     -0.179595     -0.251932E-01  0.251932E-01   103.681       103.706    
  10  0.934873     -0.673445E-01 -0.944693E-02  0.944693E-02   103.811       103.821    
  11  0.639074     -0.447735     -0.628072E-01  0.628072E-01   103.941       104.003    
  12  0.349757      -1.05052     -0.147364      0.147364       103.996       104.144    
  13  0.175521      -1.74000     -0.244082      0.244082       104.151       104.395    
  14  0.761611     -0.272320     -0.382004E-01  0.382004E-01   104.294       104.332    
  15  0.162952      -1.81430     -0.254505      0.254505       104.097       104.352    
  16  0.542858     -0.610907     -0.856965E-01  0.856965E-01   104.298       104.384    
  17  0.715099     -0.335334     -0.470398E-01  0.470398E-01   104.268       104.315    
  18  0.996052     -0.395608E-02 -0.554949E-03  0.554949E-03   104.389       104.390    
  19  0.668265     -0.403070     -0.565417E-01  0.565417E-01   104.387       104.444    
  20  0.294619      -1.22207     -0.171430      0.171430       104.538       104.709    
  21  0.721551     -0.326352     -0.457798E-01  0.457798E-01   104.509       104.555    
  22  0.216610      -1.52966     -0.214577      0.214577       104.070       104.284    
  23  0.649086     -0.432191     -0.606266E-01  0.606266E-01   104.316       104.377    
  24  0.692922E-01  -2.66942     -0.374460      0.374460       104.627       105.001    
  25  0.271271      -1.30464     -0.183011      0.183011       104.571       104.754    
  26  0.407239     -0.898355     -0.126019      0.126019       104.407       104.533    
  27  0.435034     -0.832331     -0.116757      0.116757       104.724       104.841    
  28  0.638725     -0.448281     -0.628838E-01  0.628838E-01   104.731       104.794    
  29  0.932325     -0.700735E-01 -0.982975E-02  0.982975E-02   104.734       104.743    
  30  0.958672     -0.422065E-01 -0.592063E-02  0.592063E-02   104.856       104.862    
  31  0.336870      -1.08806     -0.152630      0.152630       104.808       104.961    
  32  0.453036     -0.791783     -0.111069      0.111069       105.027       105.138    
  33  0.422569     -0.861402     -0.120835      0.120835       105.004       105.125    
  34  0.596674     -0.516385     -0.724372E-01  0.724372E-01   104.969       105.041    
  35  0.586088     -0.534286     -0.749483E-01  0.749483E-01   105.229       105.304    
  36  0.174805      -1.74409     -0.244656      0.244656       105.182       105.427    
  37  0.854432     -0.157318     -0.220682E-01  0.220682E-01   105.353       105.375    
  38  0.754323     -0.281935     -0.395492E-01  0.395492E-01   105.372       105.412    
  39  0.956897     -0.440598E-01 -0.618061E-02  0.618061E-02   105.342       105.348    
  40  0.334431      -1.09533     -0.153650      0.153650       105.323       105.476    
  41  0.750609     -0.286871     -0.402415E-01  0.402415E-01   105.555       105.595    
  42  0.778602     -0.250255     -0.351051E-01  0.351051E-01   105.331       105.366    
  43  0.330765      -1.10635     -0.155196      0.155196       105.487       105.642    
  44  0.601104     -0.508987     -0.713995E-01  0.713995E-01   105.672       105.744    
  45  0.578570     -0.547197     -0.767594E-01  0.767594E-01   105.887       105.964    
  46  0.381025     -0.964891     -0.135353      0.135353       104.354       104.489    
loop,thermsimp(1:2)       40  0.342500E-01  0.241078    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    413        106.35         67.89          1.12         41.95          0.50          0.05        111.51
Just calling func    0   0        111.51


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    414        103.83         67.84          1.10         42.10          0.76          0.05        111.84
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    103.83
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       40
neval is:      413
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       40      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       41
neval is:      413


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      413     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.762547     -0.271091     -0.380280E-01  0.380280E-01   102.207       102.245    
   2  0.700395     -0.356110     -0.499543E-01  0.499543E-01   102.913       102.963    
   3  0.110610      -2.20174     -0.308855      0.308855       103.075       103.384    
   4  0.542261     -0.612007     -0.858509E-01  0.858509E-01   103.047       103.133    
   5  0.993402     -0.662023E-02 -0.928670E-03  0.928670E-03   103.201       103.202    
   6  0.370923     -0.991761     -0.139122      0.139122       103.448       103.587    
   7  0.311008      -1.16794     -0.163835      0.163835       103.278       103.441    
   8  0.120775      -2.11383     -0.296523      0.296523       103.681       103.978    
   9  0.496739     -0.699690     -0.981509E-01  0.981509E-01   103.589       103.687    
  10  0.823539     -0.194144     -0.272341E-01  0.272341E-01   103.811       103.838    
  11  0.401420     -0.912746     -0.128038      0.128038       103.941       104.069    
  12  0.467810E-01  -3.06228     -0.429569      0.429569       103.996       104.426    
  13  0.104633      -2.25729     -0.316648      0.316648       104.070       104.387    
  14  0.233534      -1.45443     -0.204024      0.204024       104.268       104.472    
  15  0.959269     -0.415834E-01 -0.583321E-02  0.583321E-02   104.294       104.300    
  16  0.359845      -1.02208     -0.143375      0.143375       104.097       104.241    
  17  0.141753E-01  -4.25626     -0.597057      0.597057       104.316       104.913    
  18  0.566935     -0.567510     -0.796090E-01  0.796090E-01   104.298       104.378    
  19  0.901077     -0.104164     -0.146119E-01  0.146119E-01   104.389       104.404    
  20  0.465285     -0.765104     -0.107327      0.107327       104.151       104.259    
  21  0.315152      -1.15470     -0.161979      0.161979       104.387       104.549    
  22  0.954826     -0.462256E-01 -0.648442E-02  0.648442E-02   104.354       104.360    
  23  0.110663      -2.20127     -0.308789      0.308789       104.407       104.715    
  24  0.851067     -0.161264     -0.226217E-01  0.226217E-01   104.509       104.532    
  25  0.768372     -0.263481     -0.369605E-01  0.369605E-01   104.538       104.575    
  26  0.243081      -1.41436     -0.198403      0.198403       104.734       104.932    
  27  0.434279     -0.834069     -0.117001      0.117001       104.571       104.688    
  28  0.855138     -0.156492     -0.219524E-01  0.219524E-01   104.731       104.753    
  29  0.238302      -1.43422     -0.201189      0.201189       104.724       104.925    
  30  0.445547     -0.808452     -0.113408      0.113408       104.856       104.969    
  31  0.290285      -1.23689     -0.173508      0.173508       104.808       104.981    
  32  0.479492     -0.735029     -0.103108      0.103108       104.627       104.730    
  33  0.359712      -1.02245     -0.143427      0.143427       104.969       105.112    
  34  0.429040     -0.846204     -0.118703      0.118703       105.004       105.123    
  35  0.570900     -0.560541     -0.786314E-01  0.786314E-01   105.027       105.106    
  36  0.151312      -1.88841     -0.264902      0.264902       105.229       105.494    
  37  0.671837     -0.397739     -0.557939E-01  0.557939E-01   105.342       105.398    
  38  0.699384     -0.357556     -0.501571E-01  0.501571E-01   105.331       105.382    
  39  0.337756      -1.08543     -0.152262      0.152262       105.353       105.506    
  40  0.508282     -0.676718     -0.949284E-01  0.949284E-01   105.372       105.467    
  41  0.153085      -1.87676     -0.263268      0.263268       105.182       105.446    
  42  0.859571     -0.151322     -0.212271E-01  0.212271E-01   105.323       105.344    
  43  0.240559      -1.42479     -0.199866      0.199866       105.555       105.754    
  44  0.956907     -0.440496E-01 -0.617917E-02  0.617917E-02   105.487       105.493    
  45  0.695010     -0.363829     -0.510371E-01  0.510371E-01   105.672       105.723    
  46  0.258459      -1.35302     -0.189798      0.189798       103.831       104.020    
loop,thermsimp(1:2)       41  0.380280E-01  0.499543E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    415        107.27         67.82          1.10         42.02          0.58          0.05        111.57
Just calling func    0   0        111.57


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    416        105.38         67.83          1.10         42.11          0.23          0.05        111.32
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    105.38
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       41
neval is:      415
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       41      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       42
neval is:      415


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      415     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.633054     -0.457200     -0.641349E-01  0.641349E-01   102.207       102.271    
   2  0.416661     -0.875483     -0.122811      0.122811       102.913       103.035    
   3  0.671058E-01  -2.70149     -0.378958      0.378958       103.047       103.426    
   4  0.701446     -0.354612     -0.497441E-01  0.497441E-01   103.201       103.251    
   5  0.176715      -1.73321     -0.243131      0.243131       103.075       103.318    
   6  0.223035      -1.50042     -0.210476      0.210476       103.278       103.488    
   7  0.907694E-01  -2.39943     -0.336587      0.336587       103.448       103.785    
   8  0.113202      -2.17858     -0.305606      0.305606       103.589       103.894    
   9  0.443192     -0.813753     -0.114151      0.114151       103.811       103.925    
  10  0.999048     -0.952172E-03 -0.133568E-03  0.133568E-03   103.681       103.681    
  11  0.606200     -0.500546     -0.702154E-01  0.702154E-01   103.831       103.901    
  12  0.120370      -2.11718     -0.296993      0.296993       103.941       104.238    
  13  0.448885     -0.800988     -0.112361      0.112361       104.097       104.210    
  14  0.531880     -0.631338     -0.885626E-01  0.885626E-01   104.151       104.240    
  15  0.804789     -0.217176     -0.304649E-01  0.304649E-01   104.294       104.325    
  16  0.427230     -0.850433     -0.119297      0.119297       104.354       104.473    
  17  0.222958      -1.50077     -0.210525      0.210525       104.298       104.509    
  18  0.850765     -0.161619     -0.226715E-01  0.226715E-01   104.070       104.093    
  19  0.926988     -0.758150E-01 -0.106351E-01  0.106351E-01   104.389       104.400    
  20  0.729073     -0.315981     -0.443251E-01  0.443251E-01   103.996       104.041    
  21  0.411512     -0.887916     -0.124555      0.124555       104.268       104.393    
  22  0.692157     -0.367942     -0.516141E-01  0.516141E-01   104.509       104.561    
  23  0.917319     -0.862998E-01 -0.121059E-01  0.121059E-01   104.387       104.399    
  24  0.376398     -0.977107     -0.137066      0.137066       104.538       104.675    
  25  0.276694      -1.28484     -0.180235      0.180235       104.571       104.751    
  26  0.296319      -1.21632     -0.170622      0.170622       104.407       104.577    
  27  0.395623     -0.927294     -0.130079      0.130079       104.627       104.757    
  28  0.397122     -0.923511     -0.129548      0.129548       104.731       104.860    
  29  0.414944     -0.879612     -0.123390      0.123390       104.316       104.440    
  30  0.249325      -1.38900     -0.194845      0.194845       104.724       104.919    
  31  0.668798     -0.402273     -0.564299E-01  0.564299E-01   104.734       104.790    
  32  0.765717     -0.266942     -0.374460E-01  0.374460E-01   104.856       104.893    
  33  0.420183     -0.867066     -0.121630      0.121630       104.808       104.930    
  34  0.851189     -0.161121     -0.226017E-01  0.226017E-01   105.027       105.050    
  35  0.733154     -0.310400     -0.435422E-01  0.435422E-01   104.969       105.013    
  36  0.721185E-01  -2.62944     -0.368852      0.368852       105.004       105.373    
  37  0.356766      -1.03068     -0.144581      0.144581       105.323       105.467    
  38  0.654280     -0.424220     -0.595085E-01  0.595085E-01   105.331       105.391    
  39  0.662515     -0.411712     -0.577539E-01  0.577539E-01   105.342       105.400    
  40  0.164156      -1.80694     -0.253473      0.253473       105.182       105.436    
  41  0.116179      -2.15263     -0.301965      0.301965       105.372       105.674    
  42  0.134772      -2.00417     -0.281141      0.281141       105.487       105.768    
  43  0.298842      -1.20784     -0.169433      0.169433       105.229       105.399    
  44  0.583690     -0.538385     -0.755234E-01  0.755234E-01   105.353       105.429    
  45  0.894896     -0.111047     -0.155775E-01  0.155775E-01   105.672       105.688    
  46  0.148951      -1.90414     -0.267108      0.267108       105.384       105.651    
loop,thermsimp(1:2)       42  0.641349E-01  0.122811    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    417        103.59         67.86          1.10         42.17          0.36          0.05        111.53
Just calling func    0   0        111.53


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    103.59
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       42
neval is:      416
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       42      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       43
neval is:      416


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      416     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.165518      -1.79868     -0.252314      0.252314       102.207       102.459    
   2  0.737067     -0.305077     -0.427955E-01  0.427955E-01   102.913       102.955    
   3  0.332012      -1.10258     -0.154668      0.154668       103.201       103.356    
   4  0.756847     -0.278594     -0.390805E-01  0.390805E-01   103.075       103.114    
   5  0.168413      -1.78134     -0.249882      0.249882       103.047       103.297    
   6  0.422244     -0.862172     -0.120943      0.120943       103.278       103.399    
   7  0.865590     -0.144344     -0.202483E-01  0.202483E-01   103.681       103.701    
   8  0.820021     -0.198425     -0.278346E-01  0.278346E-01   103.448       103.476    
   9  0.681904     -0.382867     -0.537076E-01  0.537076E-01   103.589       103.642    
  10  0.476378E-02  -5.34671     -0.750024      0.750024       103.831       104.581    
  11  0.891588     -0.114751     -0.160970E-01  0.160970E-01   103.811       103.827    
  12  0.583910     -0.538008     -0.754705E-01  0.754705E-01   103.996       104.072    
  13  0.224086      -1.49572     -0.209816      0.209816       104.070       104.280    
  14  0.550831     -0.596327     -0.836514E-01  0.836514E-01   104.097       104.181    
  15  0.109755      -2.20951     -0.309944      0.309944       103.941       104.251    
  16  0.173189      -1.75337     -0.245959      0.245959       104.151       104.397    
  17  0.822854     -0.194976     -0.273508E-01  0.273508E-01   104.294       104.322    
  18  0.792562     -0.232484     -0.326123E-01  0.326123E-01   104.268       104.301    
  19  0.383253     -0.959060     -0.134535      0.134535       104.387       104.522    
  20  0.422533     -0.861488     -0.120847      0.120847       104.389       104.510    
  21  0.811047     -0.209429     -0.293782E-01  0.293782E-01   104.316       104.346    
  22  0.860783     -0.149912     -0.210293E-01  0.210293E-01   104.354       104.375    
  23  0.751011     -0.286335     -0.401664E-01  0.401664E-01   104.298       104.339    
  24  0.358967      -1.02452     -0.143718      0.143718       104.509       104.653    
  25  0.877019     -0.131227     -0.184082E-01  0.184082E-01   104.407       104.425    
  26  0.441658     -0.817220     -0.114638      0.114638       104.538       104.652    
  27  0.259650      -1.34842     -0.189153      0.189153       104.571       104.760    
  28  0.106035      -2.24398     -0.314781      0.314781       104.627       104.942    
  29  0.608421     -0.496887     -0.697022E-01  0.697022E-01   104.734       104.803    
  30  0.143099      -1.94422     -0.272730      0.272730       104.731       105.004    
  31  0.242177      -1.41809     -0.198926      0.198926       104.856       105.055    
  32  0.517081     -0.659556     -0.925210E-01  0.925210E-01   104.724       104.817    
  33  0.492461     -0.708339     -0.993641E-01  0.993641E-01   104.808       104.907    
  34  0.839297     -0.175190     -0.245753E-01  0.245753E-01   104.969       104.994    
  35  0.824305     -0.193215     -0.271037E-01  0.271037E-01   105.027       105.054    
  36  0.742325     -0.297968     -0.417983E-01  0.417983E-01   105.004       105.046    
  37  0.158654      -1.84103     -0.258256      0.258256       105.331       105.590    
  38  0.702604     -0.352962     -0.495126E-01  0.495126E-01   105.229       105.279    
  39  0.324396      -1.12579     -0.157923      0.157923       105.342       105.500    
  40  0.628286     -0.464760     -0.651954E-01  0.651954E-01   105.353       105.419    
  41  0.896889     -0.108823     -0.152654E-01  0.152654E-01   105.182       105.198    
  42  0.325633      -1.12199     -0.157389      0.157389       105.323       105.480    
  43  0.833588     -0.182016     -0.255327E-01  0.255327E-01   105.384       105.410    
  44  0.292459      -1.22943     -0.172462      0.172462       105.372       105.545    
  45  0.625236     -0.469626     -0.658779E-01  0.658779E-01   105.672       105.738    
  46  0.613119     -0.489197     -0.686234E-01  0.686234E-01   103.591       103.659    
loop,thermsimp(1:2)       43  0.252314      0.427955E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    418        108.16         67.99          1.10         42.24          0.26          0.05        111.63
Just calling func    0   0        111.63


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    419        104.30         67.84          1.09         42.16          0.41          0.05        111.55
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    104.30
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       43
neval is:      418
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       43      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       44
neval is:      418


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      418     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.960290E-01  -2.34311     -0.328685      0.328685       102.207       102.536    
   2  0.509377     -0.674566     -0.946265E-01  0.946265E-01   102.913       103.007    
   3  0.960906     -0.398785E-01 -0.559406E-02  0.559406E-02   103.075       103.080    
   4  0.145058      -1.93062     -0.270823      0.270823       103.047       103.318    
   5  0.584668     -0.536711     -0.752886E-01  0.752886E-01   103.201       103.277    
   6  0.137819      -1.98182     -0.278005      0.278005       103.278       103.556    
   7  0.829899     -0.186451     -0.261549E-01  0.261549E-01   103.448       103.475    
   8  0.249142      -1.38973     -0.194948      0.194948       103.589       103.783    
   9  0.471049     -0.752793     -0.105600      0.105600       103.591       103.696    
  10  0.744784E-01  -2.59725     -0.364335      0.364335       103.681       104.045    
  11  0.233158      -1.45604     -0.204250      0.204250       103.811       104.015    
  12  0.714243E-01  -2.63912     -0.370209      0.370209       103.996       104.366    
  13  0.749743     -0.288025     -0.404035E-01  0.404035E-01   104.097       104.138    
  14  0.873534     -0.135209     -0.189667E-01  0.189667E-01   103.941       103.960    
  15  0.265951      -1.32444     -0.185789      0.185789       104.070       104.256    
  16  0.328438      -1.11341     -0.156186      0.156186       104.268       104.424    
  17  0.988010     -0.120622E-01 -0.169206E-02  0.169206E-02   104.294       104.296    
  18  0.737788     -0.304099     -0.426582E-01  0.426582E-01   104.298       104.341    
  19  0.171086E-01  -4.06818     -0.570674      0.570674       104.316       104.887    
  20  0.452693     -0.792540     -0.111176      0.111176       104.354       104.465    
  21  0.922976     -0.801523E-01 -0.112436E-01  0.112436E-01   104.151       104.163    
  22  0.323108      -1.12977     -0.158481      0.158481       104.407       104.565    
  23  0.740032     -0.301062     -0.422322E-01  0.422322E-01   104.389       104.432    
  24  0.606229     -0.500498     -0.702086E-01  0.702086E-01   104.387       104.457    
  25  0.813501     -0.206408     -0.289544E-01  0.289544E-01   103.831       103.859    
  26  0.457664     -0.781621     -0.109644      0.109644       104.538       104.647    
  27  0.848286     -0.164537     -0.230809E-01  0.230809E-01   104.509       104.532    
  28  0.430827E-01  -3.14463     -0.441122      0.441122       104.571       105.012    
  29  0.215038      -1.53694     -0.215598      0.215598       104.734       104.949    
  30  0.955068     -0.459730E-01 -0.644898E-02  0.644898E-02   104.724       104.731    
  31  0.100248      -2.30011     -0.322654      0.322654       104.808       105.131    
  32  0.272794      -1.29904     -0.182226      0.182226       104.627       104.809    
  33  0.796201E-01  -2.53049     -0.354971      0.354971       104.969       105.324    
  34  0.143803      -1.93931     -0.272042      0.272042       104.731       105.003    
  35  0.151473      -1.88734     -0.264752      0.264752       105.004       105.269    
  36  0.212508      -1.54878     -0.217259      0.217259       105.027       105.245    
  37  0.570089     -0.561962     -0.788307E-01  0.788307E-01   104.856       104.935    
  38  0.811663     -0.208669     -0.292716E-01  0.292716E-01   105.182       105.212    
  39  0.652193E-01  -2.73000     -0.382958      0.382958       105.229       105.612    
  40  0.753919     -0.282470     -0.396242E-01  0.396242E-01   105.384       105.424    
  41  0.915721     -0.880434E-01 -0.123505E-01  0.123505E-01   105.353       105.366    
  42  0.689805     -0.371347     -0.520916E-01  0.520916E-01   105.323       105.375    
  43  0.296032      -1.21729     -0.170758      0.170758       105.342       105.513    
  44  0.685645     -0.377395     -0.529401E-01  0.529401E-01   105.372       105.425    
  45  0.931075     -0.714153E-01 -0.100180E-01  0.100180E-01   105.331       105.341    
  46  0.273544      -1.29629     -0.181841      0.181841       104.296       104.477    
loop,thermsimp(1:2)       44  0.328685      0.946265E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    420        104.25         67.91          1.11         42.09          0.45          0.05        111.62
Just calling func    0   0        111.61


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    104.25
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       44
neval is:      419
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       44      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       45
neval is:      419


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      419     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.960257     -0.405547E-01 -0.568892E-02  0.568892E-02   102.207       102.213    
   2  0.700631     -0.355774     -0.499072E-01  0.499072E-01   102.913       102.962    
   3  0.900697     -0.104586     -0.146711E-01  0.146711E-01   103.075       103.089    
   4  0.217613      -1.52504     -0.213929      0.213929       103.201       103.415    
   5  0.247850      -1.39493     -0.195678      0.195678       103.047       103.242    
   6  0.910358     -0.939170E-01 -0.131745E-01  0.131745E-01   103.448       103.462    
   7  0.983752     -0.163817E-01 -0.229799E-02  0.229799E-02   103.278       103.280    
   8  0.161223      -1.82497     -0.256002      0.256002       103.591       103.847    
   9  0.527720     -0.639190     -0.896640E-01  0.896640E-01   103.589       103.678    
  10  0.733734     -0.309609     -0.434312E-01  0.434312E-01   103.831       103.874    
  11  0.406982     -0.898986     -0.126108      0.126108       103.941       104.067    
  12  0.731735     -0.312337     -0.438139E-01  0.438139E-01   103.811       103.855    
  13  0.840576E-01  -2.47625     -0.347363      0.347363       103.681       104.029    
  14  0.505764     -0.681685     -0.956251E-01  0.956251E-01   104.097       104.193    
  15  0.130210      -2.03861     -0.285971      0.285971       104.151       104.437    
  16  0.565496     -0.570053     -0.799656E-01  0.799656E-01   104.070       104.150    
  17  0.944307     -0.573044E-01 -0.803853E-02  0.803853E-02   104.294       104.302    
  18  0.131761      -2.02676     -0.284309      0.284309       104.298       104.583    
  19  0.133275      -2.01534     -0.282707      0.282707       103.996       104.279    
  20  0.890936     -0.115482     -0.161996E-01  0.161996E-01   104.268       104.284    
  21  0.650633     -0.429809     -0.602926E-01  0.602926E-01   104.389       104.450    
  22  0.132428      -2.02172     -0.283602      0.283602       104.387       104.671    
  23  0.731494     -0.312666     -0.438600E-01  0.438600E-01   104.354       104.398    
  24  0.171092      -1.76556     -0.247668      0.247668       104.296       104.543    
  25  0.257579      -1.35643     -0.190276      0.190276       104.509       104.700    
  26  0.324882      -1.12429     -0.157713      0.157713       104.407       104.564    
  27  0.526591     -0.641331     -0.899644E-01  0.899644E-01   104.538       104.628    
  28  0.282402E-01  -3.56701     -0.500371      0.500371       104.724       105.225    
  29  0.983943     -0.161877E-01 -0.227077E-02  0.227077E-02   104.627       104.629    
  30  0.629559     -0.462735     -0.649114E-01  0.649114E-01   104.316       104.381    
  31  0.202469      -1.59717     -0.224047      0.224047       104.856       105.080    
  32  0.737565     -0.304401     -0.427006E-01  0.427006E-01   104.734       104.776    
  33  0.388307     -0.945960     -0.132697      0.132697       104.731       104.864    
  34  0.585207E-01  -2.83837     -0.398160      0.398160       104.571       104.969    
  35  0.900578     -0.104719     -0.146897E-01  0.146897E-01   104.808       104.823    
  36  0.420335     -0.866702     -0.121579      0.121579       105.182       105.304    
  37  0.730143     -0.314515     -0.441193E-01  0.441193E-01   105.027       105.071    
  38  0.448331     -0.802224     -0.112534      0.112534       105.004       105.117    
  39  0.344846      -1.06466     -0.149348      0.149348       104.969       105.118    
  40  0.854608     -0.157113     -0.220394E-01  0.220394E-01   105.331       105.353    
  41  0.537300     -0.621198     -0.871402E-01  0.871402E-01   105.353       105.441    
  42  0.164937      -1.80219     -0.252807      0.252807       105.323       105.575    
  43  0.595120E-01  -2.82158     -0.395804      0.395804       105.384       105.780    
  44  0.398267E-01  -3.22322     -0.452145      0.452145       105.372       105.824    
  45  0.183210      -1.69712     -0.238068      0.238068       105.342       105.580    
  46  0.184498      -1.69011     -0.237085      0.237085       104.251       104.488    
loop,thermsimp(1:2)       45  0.568892E-02  0.499072E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    421        102.53         68.18          1.09         42.10          0.37          0.05        111.79
Just calling func    0   0        111.79


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  420    102.53       0.4437     -3.421      2.578     -102.6     0.1082    
                      0.8639     0.6111     -99.70      4.964      1.365    

                       1.836     -2.558      1.540      7786.      7000.    

                      0.4495      0.000      0.000      0.000     -1.221    



                      -2.438      0.000      0.000      7000.      470.5    

                       1.921     -4.534     -6.584     -8.363      8.567    

                      -17.00     -7.198      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.3633    -0.8987      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.4675     -1.114      7000.    



                      -1.959     -1.923     -1.994     -1.933    -0.3807    

                     -0.3252      9.292      8.829    -0.1492E+05 -4.037    

                     -0.9430     -4.168      9.380      8.882    -0.1969E+05



                      -6.000     0.6013     0.4690E-01  9.029      8.943    

                     -0.1944E+05 -6.000     -1.245    -0.1463      9.110    

                       8.833    -0.1891E+05 -6.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    102.53
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       45
neval is:      420
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       45      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       46
neval is:      420


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      420     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.668594     -0.402578     -0.564727E-01  0.564727E-01   102.207       102.264    
   2  0.484900     -0.723813     -0.101535      0.101535       102.913       103.014    
   3  0.814670     -0.204972     -0.287530E-01  0.287530E-01   103.075       103.103    
   4  0.111039      -2.19788     -0.308313      0.308313       103.047       103.355    
   5  0.717773     -0.331602     -0.465164E-01  0.465164E-01   103.278       103.324    
   6  0.751748     -0.285354     -0.400288E-01  0.400288E-01   103.201       103.242    
   7  0.983096E-01  -2.31963     -0.325393      0.325393       103.448       103.774    
   8  0.150083      -1.89656     -0.266045      0.266045       103.589       103.855    
   9  0.733895     -0.309390     -0.434005E-01  0.434005E-01   103.591       103.634    
  10  0.982051     -0.181120E-01 -0.254071E-02  0.254071E-02   103.811       103.814    
  11  0.449336E-01  -3.10257     -0.435221      0.435221       103.831       104.266    
  12  0.929425     -0.731895E-01 -0.102669E-01  0.102669E-01   103.681       103.691    
  13  0.692017E-01  -2.67073     -0.374643      0.374643       103.941       104.315    
  14  0.644652     -0.439045     -0.615882E-01  0.615882E-01   104.070       104.131    
  15  0.661075     -0.413889     -0.580593E-01  0.580593E-01   104.097       104.156    
  16  0.410338     -0.890775     -0.124956      0.124956       103.996       104.121    
  17  0.967767     -0.327642E-01 -0.459609E-02  0.459609E-02   104.268       104.273    
  18  0.496474     -0.700224     -0.982257E-01  0.982257E-01   104.294       104.392    
  19  0.748701     -0.289415     -0.405984E-01  0.405984E-01   104.316       104.357    
  20  0.428668     -0.847073     -0.118825      0.118825       104.354       104.473    
  21  0.922992     -0.801352E-01 -0.112412E-01  0.112412E-01   104.151       104.163    
  22  0.844924     -0.168508     -0.236379E-01  0.236379E-01   104.389       104.413    
  23  0.680136     -0.385463     -0.540718E-01  0.540718E-01   104.251       104.305    
  24  0.136189      -1.99371     -0.279673      0.279673       104.296       104.575    
  25  0.660667     -0.414506     -0.581459E-01  0.581459E-01   104.407       104.465    
  26  0.473941     -0.746672     -0.104741      0.104741       104.298       104.403    
  27  0.792449     -0.232627     -0.326323E-01  0.326323E-01   104.538       104.570    
  28  0.960023     -0.407984E-01 -0.572310E-02  0.572310E-02   104.627       104.633    
  29  0.951587     -0.496238E-01 -0.696110E-02  0.696110E-02   104.387       104.394    
  30  0.197021      -1.62444     -0.227873      0.227873       104.509       104.737    
  31  0.664966     -0.408020     -0.572360E-01  0.572360E-01   104.734       104.791    
  32  0.832360     -0.183491     -0.257396E-01  0.257396E-01   104.808       104.834    
  33  0.589221     -0.528954     -0.742004E-01  0.742004E-01   104.731       104.805    
  34  0.163930      -1.80831     -0.253666      0.253666       104.571       104.824    
  35  0.967185E-01  -2.33595     -0.327682      0.327682       105.027       105.355    
  36  0.386895     -0.949603     -0.133208      0.133208       104.856       104.989    
  37  0.709158     -0.343678     -0.482103E-01  0.482103E-01   105.004       105.052    
  38  0.801784     -0.220916     -0.309895E-01  0.309895E-01   104.969       105.000    
  39  0.631968     -0.458917     -0.643757E-01  0.643757E-01   104.724       104.789    
  40  0.866237     -0.143597     -0.201434E-01  0.201434E-01   105.182       105.202    
  41  0.377203     -0.974972     -0.136767      0.136767       105.331       105.468    
  42  0.261898      -1.33980     -0.187944      0.187944       105.353       105.541    
  43  0.306694      -1.18191     -0.165795      0.165795       105.323       105.488    
  44  0.603055     -0.505747     -0.709449E-01  0.709449E-01   105.342       105.413    
  45  0.146094      -1.92351     -0.269825      0.269825       105.384       105.654    
  46  0.887903     -0.118893     -0.166781E-01  0.166781E-01   102.533       102.550    
loop,thermsimp(1:2)       46  0.564727E-01  0.101535    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    422        102.96         67.95          1.10         42.05          0.66          0.05        111.81
Just calling func    0   0        111.81


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    102.96
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       46
neval is:      421
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       46      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       47
neval is:      421


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      421     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.408943     -0.894179     -0.125433      0.125433       102.207       102.332    
   2  0.431368     -0.840794     -0.117945      0.117945       102.533       102.651    
   3  0.292375      -1.22972     -0.172502      0.172502       102.913       103.085    
   4  0.336431      -1.08936     -0.152813      0.152813       103.075       103.227    
   5  0.370622     -0.992574     -0.139236      0.139236       103.201       103.341    
   6  0.398679     -0.919597     -0.128999      0.128999       103.278       103.407    
   7  0.672261     -0.397108     -0.557054E-01  0.557054E-01   103.047       103.103    
   8  0.451252     -0.795728     -0.111623      0.111623       103.591       103.702    
   9  0.527060     -0.640440     -0.898394E-01  0.898394E-01   103.681       103.771    
  10  0.131951      -2.02533     -0.284108      0.284108       103.448       103.732    
  11  0.903524     -0.101452     -0.142315E-01  0.142315E-01   103.811       103.825    
  12  0.881507E-01  -2.42871     -0.340693      0.340693       103.589       103.929    
  13  0.464884     -0.765968     -0.107448      0.107448       103.996       104.104    
  14  0.985345     -0.147637E-01 -0.207101E-02  0.207101E-02   104.070       104.072    
  15  0.587696     -0.531546     -0.745640E-01  0.745640E-01   104.097       104.172    
  16  0.581244     -0.542585     -0.761124E-01  0.761124E-01   104.151       104.227    
  17  0.137299      -1.98559     -0.278534      0.278534       103.831       104.109    
  18  0.330005      -1.10865     -0.155518      0.155518       104.268       104.424    
  19  0.911104     -0.930980E-01 -0.130596E-01  0.130596E-01   104.251       104.264    
  20  0.487848     -0.717751     -0.100684      0.100684       103.941       104.041    
  21  0.518423     -0.656964     -0.921574E-01  0.921574E-01   104.316       104.409    
  22  0.645499     -0.437732     -0.614040E-01  0.614040E-01   104.294       104.356    
  23  0.914509     -0.893680E-01 -0.125363E-01  0.125363E-01   104.387       104.400    
  24  0.763582E-01  -2.57232     -0.360839      0.360839       104.298       104.659    
  25  0.708063     -0.345222     -0.484270E-01  0.484270E-01   104.389       104.438    
  26  0.719838     -0.328729     -0.461133E-01  0.461133E-01   104.407       104.453    
  27  0.113625E-01  -4.47744     -0.628084      0.628084       104.354       104.982    
  28  0.272258      -1.30101     -0.182502      0.182502       104.538       104.720    
  29  0.211076      -1.55554     -0.218207      0.218207       104.296       104.514    
  30  0.931648     -0.708004E-01 -0.993170E-02  0.993170E-02   104.627       104.637    
  31  0.572966     -0.556929     -0.781247E-01  0.781247E-01   104.509       104.587    
  32  0.116283      -2.15173     -0.301839      0.301839       104.724       105.026    
  33  0.247808      -1.39510     -0.195701      0.195701       104.734       104.929    
  34  0.294404      -1.22280     -0.171532      0.171532       104.731       104.902    
  35  0.252764E-01  -3.67788     -0.515925      0.515925       104.571       105.087    
  36  0.408562     -0.895111     -0.125564      0.125564       104.808       104.933    
  37  0.753478     -0.283056     -0.397064E-01  0.397064E-01   104.856       104.895    
  38  0.680565     -0.384832     -0.539833E-01  0.539833E-01   104.969       105.023    
  39  0.973188     -0.271778E-01 -0.381243E-02  0.381243E-02   105.004       105.008    
  40  0.986871     -0.132158E-01 -0.185388E-02  0.185388E-02   105.182       105.184    
  41  0.363246      -1.01267     -0.142056      0.142056       105.027       105.169    
  42  0.138088      -1.97986     -0.277730      0.277730       105.342       105.620    
  43  0.929547E-01  -2.37564     -0.333249      0.333249       105.331       105.665    
  44  0.781724     -0.246253     -0.345438E-01  0.345438E-01   105.323       105.357    
  45  0.732428     -0.311390     -0.436811E-01  0.436811E-01   105.353       105.397    
  46  0.294929      -1.22102     -0.171282      0.171282       102.963       103.134    
loop,thermsimp(1:2)       47  0.125433      0.117945    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    423        103.37         67.93          1.10         42.00          0.49          0.05        111.57
Just calling func    0   0        111.57


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    103.37
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       47
neval is:      422
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       47      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       48
neval is:      422


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      422     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.813255     -0.206711     -0.289969E-01  0.289969E-01   102.207       102.236    
   2  0.101223E-01  -4.59302     -0.644297      0.644297       102.533       103.177    
   3  0.618937E-01  -2.78234     -0.390299      0.390299       102.913       103.303    
   4  0.206078      -1.57950     -0.221569      0.221569       103.047       103.268    
   5  0.867609     -0.142014     -0.199214E-01  0.199214E-01   102.963       102.983    
   6  0.578282     -0.547694     -0.768292E-01  0.768292E-01   103.075       103.151    
   7  0.531864     -0.631367     -0.885666E-01  0.885666E-01   103.201       103.290    
   8  0.304055      -1.19055     -0.167007      0.167007       103.278       103.445    
   9  0.540739     -0.614819     -0.862453E-01  0.862453E-01   103.591       103.677    
  10  0.476481     -0.741327     -0.103992      0.103992       103.448       103.552    
  11  0.610971     -0.492705     -0.691155E-01  0.691155E-01   103.681       103.750    
  12  0.735015     -0.307865     -0.431865E-01  0.431865E-01   103.811       103.854    
  13  0.961674     -0.390799E-01 -0.548203E-02  0.548203E-02   103.589       103.594    
  14  0.902502     -0.102585     -0.143903E-01  0.143903E-01   103.941       103.955    
  15  0.759072     -0.275659     -0.386688E-01  0.386688E-01   104.070       104.109    
  16  0.380028E-01  -3.27009     -0.458721      0.458721       103.996       104.455    
  17  0.413373     -0.883405     -0.123922      0.123922       103.831       103.954    
  18  0.260354      -1.34571     -0.188773      0.188773       104.097       104.286    
  19  0.170660      -1.76808     -0.248022      0.248022       104.151       104.399    
  20  0.563245     -0.574040     -0.805250E-01  0.805250E-01   104.251       104.332    
  21  0.861075     -0.149573     -0.209818E-01  0.209818E-01   104.294       104.315    
  22  0.797631     -0.226109     -0.317180E-01  0.317180E-01   104.387       104.419    
  23  0.370521E-01  -3.29543     -0.462275      0.462275       104.316       104.779    
  24  0.703530     -0.351645     -0.493279E-01  0.493279E-01   104.268       104.317    
  25  0.791216E-01  -2.53677     -0.355852      0.355852       104.389       104.745    
  26  0.136780      -1.98938     -0.279066      0.279066       104.407       104.686    
  27  0.409465     -0.892903     -0.125254      0.125254       104.296       104.421    
  28  0.476542     -0.741200     -0.103974      0.103974       104.509       104.613    
  29  0.169904      -1.77252     -0.248645      0.248645       104.627       104.875    
  30  0.483026     -0.727684     -0.102078      0.102078       104.298       104.401    
  31  0.740952     -0.299820     -0.420580E-01  0.420580E-01   104.538       104.580    
  32  0.367240      -1.00174     -0.140522      0.140522       104.856       104.996    
  33  0.704436     -0.350358     -0.491474E-01  0.491474E-01   104.731       104.780    
  34  0.703774     -0.351299     -0.492793E-01  0.492793E-01   104.734       104.783    
  35  0.547709     -0.602012     -0.844488E-01  0.844488E-01   104.808       104.892    
  36  0.236071      -1.44362     -0.202508      0.202508       104.354       104.556    
  37  0.512555     -0.668347     -0.937540E-01  0.937540E-01   105.004       105.098    
  38  0.894555     -0.111428     -0.156309E-01  0.156309E-01   104.969       104.985    
  39  0.100347      -2.29912     -0.322515      0.322515       104.724       105.047    
  40  0.689153     -0.372292     -0.522242E-01  0.522242E-01   104.571       104.623    
  41  0.188659      -1.66781     -0.233957      0.233957       105.027       105.261    
  42  0.623666     -0.472140     -0.662306E-01  0.662306E-01   105.182       105.249    
  43  0.610480     -0.493510     -0.692284E-01  0.692284E-01   105.323       105.392    
  44  0.724857     -0.321780     -0.451385E-01  0.451385E-01   105.353       105.399    
  45  0.320963      -1.13643     -0.159416      0.159416       105.342       105.502    
  46  0.287938      -1.24501     -0.174647      0.174647       103.373       103.548    
loop,thermsimp(1:2)       48  0.289969E-01  0.644297    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    424        104.12         67.94          1.09         42.05          0.49          0.05        111.63
Just calling func    0   0        111.63


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    104.12
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       48
neval is:      423
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       48      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       49
neval is:      423


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      423     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.900563     -0.104735     -0.146919E-01  0.146919E-01   102.207       102.222    
   2  0.337202      -1.08707     -0.152492      0.152492       102.963       103.115    
   3  0.201324      -1.60284     -0.224842      0.224842       103.075       103.299    
   4  0.305897      -1.18451     -0.166160      0.166160       102.533       102.699    
   5  0.333562      -1.09793     -0.154015      0.154015       103.047       103.201    
   6  0.708340     -0.344831     -0.483721E-01  0.483721E-01   103.201       103.250    
   7  0.929963     -0.726100E-01 -0.101856E-01  0.101856E-01   102.913       102.923    
   8  0.954883     -0.461669E-01 -0.647618E-02  0.647618E-02   103.278       103.284    
   9  0.709141     -0.343701     -0.482135E-01  0.482135E-01   103.373       103.421    
  10  0.904936     -0.998906E-01 -0.140124E-01  0.140124E-01   103.448       103.462    
  11  0.764543     -0.268477     -0.376613E-01  0.376613E-01   103.589       103.626    
  12  0.297182      -1.21341     -0.170214      0.170214       103.591       103.761    
  13  0.472241     -0.750266     -0.105245      0.105245       103.681       103.786    
  14  0.601817     -0.507801     -0.712332E-01  0.712332E-01   103.811       103.882    
  15  0.274906      -1.29132     -0.181144      0.181144       103.831       104.012    
  16  0.979328     -0.208884E-01 -0.293018E-02  0.293018E-02   103.941       103.944    
  17  0.634279     -0.455267     -0.638638E-01  0.638638E-01   104.070       104.134    
  18  0.238460E-01  -3.73614     -0.524096      0.524096       104.097       104.622    
  19  0.302486      -1.19572     -0.167733      0.167733       104.294       104.462    
  20  0.454285     -0.789030     -0.110683      0.110683       104.268       104.379    
  21  0.850435     -0.162007     -0.227259E-01  0.227259E-01   104.251       104.274    
  22  0.562689     -0.575029     -0.806637E-01  0.806637E-01   104.151       104.232    
  23  0.351622      -1.04520     -0.146618      0.146618       104.298       104.445    
  24  0.978081     -0.221628E-01 -0.310894E-02  0.310894E-02   104.387       104.390    
  25  0.284594      -1.25669     -0.176286      0.176286       104.296       104.472    
  26  0.883683E-01  -2.42624     -0.340347      0.340347       103.996       104.337    
  27  0.217395      -1.52604     -0.214069      0.214069       104.354       104.568    
  28  0.405933     -0.901568     -0.126470      0.126470       104.538       104.664    
  29  0.951690     -0.495156E-01 -0.694593E-02  0.694593E-02   104.509       104.516    
  30  0.570178     -0.561806     -0.788088E-01  0.788088E-01   104.571       104.650    
  31  0.326664      -1.11882     -0.156946      0.156946       104.407       104.563    
  32  0.383874E-01  -3.26003     -0.457308      0.457308       104.389       104.847    
  33  0.630130     -0.461829     -0.647843E-01  0.647843E-01   104.316       104.381    
  34  0.902033     -0.103105     -0.144633E-01  0.144633E-01   104.731       104.745    
  35  0.192240      -1.64901     -0.231319      0.231319       104.734       104.965    
  36  0.836744     -0.178237     -0.250026E-01  0.250026E-01   104.627       104.652    
  37  0.481446     -0.730962     -0.102538      0.102538       104.808       104.910    
  38  0.801468     -0.221310     -0.310448E-01  0.310448E-01   104.969       105.000    
  39  0.929206     -0.734244E-01 -0.102998E-01  0.102998E-01   104.856       104.866    
  40  0.366038      -1.00502     -0.140982      0.140982       104.724       104.865    
  41  0.896697     -0.109037     -0.152955E-01  0.152955E-01   105.004       105.019    
  42  0.175481      -1.74022     -0.244114      0.244114       105.182       105.426    
  43  0.444632E-01  -3.11309     -0.436697      0.436697       105.027       105.464    
  44  0.469791     -0.755467     -0.105975      0.105975       105.323       105.429    
  45  0.475427     -0.743541     -0.104302      0.104302       105.353       105.458    
  46  0.568468     -0.564810     -0.792301E-01  0.792301E-01   104.120       104.199    
loop,thermsimp(1:2)       49  0.146919E-01  0.152492    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    425        105.70         67.88          1.12         42.20          0.16          0.05        111.40
Just calling func    0   0        111.40


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    426        104.52         67.90          1.12         42.02          0.64          0.05        111.73
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    104.52
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       49
neval is:      425
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       49      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       50
neval is:      425


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      425     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.326509      -1.11930     -0.157012      0.157012       102.207       102.364    
   2  0.656045     -0.421526     -0.591307E-01  0.591307E-01   102.533       102.592    
   3  0.702016     -0.353799     -0.496300E-01  0.496300E-01   102.913       102.962    
   4  0.659850     -0.415743     -0.583194E-01  0.583194E-01   102.963       103.021    
   5  0.587501     -0.531877     -0.746104E-01  0.746104E-01   103.047       103.121    
   6  0.118734      -2.13087     -0.298913      0.298913       103.201       103.500    
   7  0.484942     -0.723727     -0.101523      0.101523       103.278       103.379    
   8  0.809010     -0.211944     -0.297310E-01  0.297310E-01   103.075       103.104    
   9  0.107401      -2.23119     -0.312986      0.312986       103.373       103.686    
  10  0.912046     -0.920651E-01 -0.129147E-01  0.129147E-01   103.448       103.461    
  11  0.752441     -0.284433     -0.398995E-01  0.398995E-01   103.589       103.628    
  12  0.389912     -0.941833     -0.132118      0.132118       103.591       103.723    
  13  0.805927     -0.215762     -0.302666E-01  0.302666E-01   103.681       103.711    
  14  0.537328     -0.621147     -0.871330E-01  0.871330E-01   103.811       103.898    
  15  0.276300      -1.28627     -0.180435      0.180435       103.941       104.121    
  16  0.618485     -0.480483     -0.674010E-01  0.674010E-01   103.831       103.898    
  17  0.130066      -2.03972     -0.286126      0.286126       104.070       104.356    
  18  0.885305     -0.121824     -0.170891E-01  0.170891E-01   104.120       104.137    
  19  0.513359     -0.666781     -0.935344E-01  0.935344E-01   104.151       104.245    
  20  0.235519      -1.44596     -0.202836      0.202836       104.251       104.454    
  21  0.693842     -0.365511     -0.512730E-01  0.512730E-01   103.996       104.047    
  22  0.445925     -0.807605     -0.113289      0.113289       104.268       104.381    
  23  0.946501     -0.549828E-01 -0.771286E-02  0.771286E-02   104.316       104.324    
  24  0.108015      -2.22549     -0.312186      0.312186       104.387       104.699    
  25  0.988375     -0.116930E-01 -0.164027E-02  0.164027E-02   104.298       104.300    
  26  0.931439     -0.710246E-01 -0.996316E-02  0.996316E-02   104.294       104.304    
  27  0.915176     -0.886393E-01 -0.124341E-01  0.124341E-01   104.296       104.308    
  28  0.670330     -0.399985     -0.561089E-01  0.561089E-01   104.509       104.565    
  29  0.172595      -1.75681     -0.246441      0.246441       104.407       104.653    
  30  0.496295     -0.700585     -0.982764E-01  0.982764E-01   104.354       104.452    
  31  0.627359     -0.466236     -0.654025E-01  0.654025E-01   104.097       104.163    
  32  0.914384     -0.895052E-01 -0.125556E-01  0.125556E-01   104.571       104.583    
  33  0.197109      -1.62400     -0.227811      0.227811       104.627       104.855    
  34  0.830736     -0.185444     -0.260136E-01  0.260136E-01   104.538       104.564    
  35  0.554634     -0.589446     -0.826861E-01  0.826861E-01   104.731       104.814    
  36  0.386467E-01  -3.25329     -0.456364      0.456364       104.389       104.846    
  37  0.259980      -1.34715     -0.188975      0.188975       104.724       104.913    
  38  0.876870     -0.131396     -0.184319E-01  0.184319E-01   104.856       104.874    
  39  0.651025     -0.429207     -0.602082E-01  0.602082E-01   104.808       104.868    
  40  0.171053      -1.76578     -0.247700      0.247700       104.734       104.981    
  41  0.708910     -0.344027     -0.482593E-01  0.482593E-01   104.969       105.017    
  42  0.501487     -0.690177     -0.968164E-01  0.968164E-01   105.004       105.101    
  43  0.766040     -0.266521     -0.373870E-01  0.373870E-01   105.182       105.220    
  44  0.189113      -1.66541     -0.233620      0.233620       105.323       105.556    
  45  0.250338      -1.38494     -0.194277      0.194277       105.353       105.548    
  46  0.830098     -0.186211     -0.261213E-01  0.261213E-01   104.517       104.543    
loop,thermsimp(1:2)       50  0.157012      0.591307E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    427        102.69         67.98          1.12         42.17          0.26          0.05        111.58
Just calling func    0   0        111.58


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    102.69
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       50
neval is:      426
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       50      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       51
neval is:      426


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      426     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.886088     -0.120938     -0.169650E-01  0.169650E-01   102.207       102.224    
   2  0.953882E-01  -2.34980     -0.329624      0.329624       102.533       102.863    
   3  0.875198     -0.133305     -0.186997E-01  0.186997E-01   102.913       102.931    
   4  0.401319     -0.913000     -0.128073      0.128073       102.963       103.091    
   5  0.288302      -1.24375     -0.174470      0.174470       103.075       103.249    
   6  0.596159E-01  -2.81983     -0.395559      0.395559       103.047       103.442    
   7  0.411979     -0.886782     -0.124396      0.124396       103.278       103.402    
   8  0.157950      -1.84548     -0.258879      0.258879       103.448       103.707    
   9  0.736512     -0.305830     -0.429011E-01  0.429011E-01   103.201       103.244    
  10  0.531935     -0.631235     -0.885481E-01  0.885481E-01   103.589       103.677    
  11  0.557201     -0.584829     -0.820384E-01  0.820384E-01   103.373       103.455    
  12  0.590342     -0.527053     -0.739338E-01  0.739338E-01   103.681       103.755    
  13  0.893645     -0.112447     -0.157737E-01  0.157737E-01   103.591       103.606    
  14  0.899172     -0.106281     -0.149089E-01  0.149089E-01   103.831       103.845    
  15  0.321510      -1.13473     -0.159177      0.159177       103.811       103.970    
  16  0.242259E-01  -3.72033     -0.521879      0.521879       103.996       104.518    
  17  0.646886     -0.435586     -0.611029E-01  0.611029E-01   103.941       104.002    
  18  0.998267     -0.173471E-02 -0.243341E-03  0.243341E-03   104.120       104.120    
  19  0.972297     -0.280942E-01 -0.394099E-02  0.394099E-02   104.097       104.101    
  20  0.309809      -1.17180     -0.164377      0.164377       104.151       104.316    
  21  0.816235     -0.203053     -0.284837E-01  0.284837E-01   104.298       104.327    
  22  0.984764     -0.153535E-01 -0.215376E-02  0.215376E-02   104.294       104.296    
  23  0.881026     -0.126668     -0.177687E-01  0.177687E-01   104.296       104.313    
  24  0.661336E-01  -2.71608     -0.381005      0.381005       104.316       104.697    
  25  0.410325     -0.890806     -0.124960      0.124960       104.070       104.195    
  26  0.104142E-03  -9.16976      -1.28631       1.28631       104.268       105.554    
  27  0.713949     -0.336943     -0.472656E-01  0.472656E-01   104.354       104.401    
  28  0.388242     -0.946126     -0.132720      0.132720       104.251       104.384    
  29  0.684780     -0.378657     -0.531171E-01  0.531171E-01   104.517       104.570    
  30  0.349297      -1.05183     -0.147549      0.147549       104.538       104.685    
  31  0.567533     -0.566456     -0.794610E-01  0.794610E-01   104.509       104.589    
  32  0.157115      -1.85078     -0.259622      0.259622       104.571       104.830    
  33  0.780641     -0.247640     -0.347384E-01  0.347384E-01   104.407       104.441    
  34  0.485397     -0.722789     -0.101391      0.101391       104.387       104.489    
  35  0.682517     -0.381968     -0.535815E-01  0.535815E-01   104.731       104.785    
  36  0.536829     -0.622075     -0.872632E-01  0.872632E-01   104.389       104.477    
  37  0.464187     -0.767467     -0.107658      0.107658       104.627       104.735    
  38  0.519819     -0.654274     -0.917800E-01  0.917800E-01   104.808       104.900    
  39  0.974252     -0.260857E-01 -0.365923E-02  0.365923E-02   104.856       104.859    
  40  0.386009     -0.951894     -0.133529      0.133529       104.724       104.858    
  41  0.217232      -1.52679     -0.214174      0.214174       104.734       104.948    
  42  0.173910      -1.74922     -0.245376      0.245376       104.969       105.214    
  43  0.860958     -0.149709     -0.210009E-01  0.210009E-01   105.004       105.025    
  44  0.893333     -0.112796     -0.158227E-01  0.158227E-01   105.182       105.198    
  45  0.957904     -0.430073E-01 -0.603296E-02  0.603296E-02   105.353       105.359    
  46  0.671164E-01  -2.70133     -0.378936      0.378936       102.688       103.067    
loop,thermsimp(1:2)       51  0.169650E-01  0.329624    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    428        102.68         67.86          1.11         42.11          0.43          0.05        111.55
Just calling func    0   0        111.55


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    102.68
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       51
neval is:      427
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       51      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       52
neval is:      427


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      427     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.827214E-01  -2.49228     -0.349611      0.349611       102.207       102.557    
   2  0.625679E-01  -2.77150     -0.388780      0.388780       102.533       102.922    
   3  0.254112      -1.36998     -0.192177      0.192177       102.913       103.105    
   4  0.582152     -0.541023     -0.758934E-01  0.758934E-01   102.688       102.764    
   5  0.596882     -0.516035     -0.723881E-01  0.723881E-01   102.963       103.035    
   6  0.149943      -1.89750     -0.266177      0.266177       103.201       103.468    
   7  0.496252     -0.700672     -0.982886E-01  0.982886E-01   103.075       103.173    
   8  0.129782      -2.04190     -0.286433      0.286433       103.278       103.564    
   9  0.740869     -0.299931     -0.420736E-01  0.420736E-01   103.047       103.089    
  10  0.124297      -2.08508     -0.292491      0.292491       103.373       103.665    
  11  0.524903     -0.644542     -0.904148E-01  0.904148E-01   103.591       103.681    
  12  0.852180     -0.159958     -0.224385E-01  0.224385E-01   103.589       103.611    
  13  0.823232     -0.194517     -0.272864E-01  0.272864E-01   103.448       103.476    
  14  0.256230      -1.36168     -0.191013      0.191013       103.681       103.872    
  15  0.258393      -1.35327     -0.189834      0.189834       103.831       104.020    
  16  0.324549      -1.12532     -0.157857      0.157857       103.811       103.969    
  17  0.504546     -0.684097     -0.959634E-01  0.959634E-01   103.941       104.037    
  18  0.774284     -0.255817     -0.358854E-01  0.358854E-01   104.097       104.133    
  19  0.452119E-01  -3.09639     -0.434355      0.434355       104.120       104.554    
  20  0.325288      -1.12305     -0.157538      0.157538       104.070       104.227    
  21  0.156855      -1.85244     -0.259855      0.259855       104.294       104.554    
  22  0.440906     -0.818924     -0.114877      0.114877       104.296       104.411    
  23  0.313753E-02  -5.76432     -0.808605      0.808605       104.151       104.960    
  24  0.252529      -1.37623     -0.193054      0.193054       104.298       104.492    
  25  0.799267     -0.224060     -0.314306E-01  0.314306E-01   104.251       104.283    
  26  0.961010     -0.397708E-01 -0.557896E-02  0.557896E-02   104.354       104.359    
  27  0.843711     -0.169946     -0.238396E-01  0.238396E-01   104.407       104.430    
  28  0.120002      -2.12025     -0.297423      0.297423       104.389       104.687    
  29  0.489889     -0.713576     -0.100099      0.100099       104.387       104.487    
  30  0.317246      -1.14808     -0.161050      0.161050       103.996       104.157    
  31  0.761766     -0.272116     -0.381717E-01  0.381717E-01   104.517       104.555    
  32  0.468167     -0.758930     -0.106461      0.106461       104.509       104.616    
  33  0.634908     -0.454275     -0.637246E-01  0.637246E-01   104.538       104.601    
  34  0.410644     -0.890029     -0.124851      0.124851       104.316       104.441    
  35  0.330962      -1.10575     -0.155112      0.155112       104.627       104.782    
  36  0.275422      -1.28945     -0.180881      0.180881       104.731       104.912    
  37  0.186052      -1.68173     -0.235909      0.235909       104.571       104.807    
  38  0.361178      -1.01838     -0.142857      0.142857       104.724       104.867    
  39  0.850100     -0.162402     -0.227813E-01  0.227813E-01   104.856       104.879    
  40  0.649062     -0.432226     -0.606317E-01  0.606317E-01   104.808       104.869    
  41  0.322988      -1.13014     -0.158533      0.158533       104.734       104.892    
  42  0.284964      -1.25539     -0.176104      0.176104       105.004       105.180    
  43  0.685335     -0.377848     -0.530036E-01  0.530036E-01   105.182       105.235    
  44  0.262422      -1.33780     -0.187664      0.187664       104.969       105.157    
  45  0.767375     -0.264780     -0.371427E-01  0.371427E-01   105.353       105.391    
  46  0.109385      -2.21288     -0.310418      0.310418       102.675       102.986    
loop,thermsimp(1:2)       52  0.349611      0.388780    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    429        102.59         67.94          1.11         42.19          0.46          0.05        111.75
Just calling func    0   0        111.75


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    430        103.98         67.98          1.11         41.89          0.47          0.05        111.49
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    102.59
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       52
neval is:      429
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       52      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       53
neval is:      429


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      429     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.265283      -1.32696     -0.186142      0.186142       102.207       102.393    
   2  0.615112     -0.485951     -0.681680E-01  0.681680E-01   102.688       102.756    
   3  0.424286E-01  -3.15993     -0.443268      0.443268       102.533       102.976    
   4  0.726479     -0.319546     -0.448251E-01  0.448251E-01   102.675       102.720    
   5  0.402368     -0.910388     -0.127707      0.127707       102.963       103.091    
   6  0.958941E-01  -2.34451     -0.328882      0.328882       103.047       103.376    
   7  0.137400      -1.98486     -0.278431      0.278431       102.913       103.191    
   8  0.887138     -0.119755     -0.167990E-01  0.167990E-01   103.075       103.091    
   9  0.655001     -0.423119     -0.593541E-01  0.593541E-01   103.201       103.261    
  10  0.304836      -1.18798     -0.166647      0.166647       103.448       103.615    
  11  0.346250      -1.06059     -0.148778      0.148778       103.278       103.426    
  12  0.608663E-01  -2.79908     -0.392648      0.392648       103.589       103.981    
  13  0.307248      -1.18010     -0.165541      0.165541       103.373       103.538    
  14  0.695201     -0.363555     -0.509986E-01  0.509986E-01   103.591       103.642    
  15  0.628698     -0.464104     -0.651034E-01  0.651034E-01   103.681       103.746    
  16  0.609308     -0.495432     -0.694980E-01  0.694980E-01   103.811       103.881    
  17  0.335400      -1.09243     -0.153244      0.153244       103.831       103.984    
  18  0.910258     -0.940273E-01 -0.131899E-01  0.131899E-01   103.941       103.954    
  19  0.439254E-01  -3.12526     -0.438404      0.438404       104.097       104.536    
  20  0.978338     -0.219001E-01 -0.307210E-02  0.307210E-02   103.996       103.999    
  21  0.282939      -1.26252     -0.177104      0.177104       104.070       104.247    
  22  0.763165     -0.270281     -0.379144E-01  0.379144E-01   104.251       104.289    
  23  0.206330      -1.57828     -0.221397      0.221397       104.354       104.575    
  24  0.228687      -1.47540     -0.206966      0.206966       104.296       104.503    
  25  0.634584E-01  -2.75737     -0.386797      0.386797       104.407       104.793    
  26  0.665745E-01  -2.70943     -0.380073      0.380073       104.316       104.696    
  27  0.761759     -0.272125     -0.381731E-01  0.381731E-01   104.387       104.425    
  28  0.636615     -0.451590     -0.633479E-01  0.633479E-01   104.298       104.362    
  29  0.804468     -0.217574     -0.305208E-01  0.305208E-01   104.120       104.150    
  30  0.508586     -0.676120     -0.948445E-01  0.948445E-01   104.294       104.389    
  31  0.232797      -1.45759     -0.204467      0.204467       104.517       104.721    
  32  0.932655     -0.697196E-01 -0.978010E-02  0.978010E-02   104.538       104.547    
  33  0.970411     -0.300359E-01 -0.421336E-02  0.421336E-02   104.509       104.514    
  34  0.151993      -1.88392     -0.264272      0.264272       104.389       104.654    
  35  0.571421     -0.559629     -0.785034E-01  0.785034E-01   104.627       104.705    
  36  0.673371     -0.395458     -0.554739E-01  0.554739E-01   104.571       104.626    
  37  0.828783     -0.187797     -0.263437E-01  0.263437E-01   104.724       104.751    
  38  0.285628      -1.25307     -0.175777      0.175777       104.808       104.984    
  39  0.127849      -2.05691     -0.288538      0.288538       104.856       105.144    
  40  0.101247      -2.29019     -0.321262      0.321262       104.734       105.055    
  41  0.593355     -0.521962     -0.732196E-01  0.732196E-01   104.731       104.804    
  42  0.362303      -1.01527     -0.142420      0.142420       104.151       104.294    
  43  0.754411     -0.281818     -0.395327E-01  0.395327E-01   104.969       105.009    
  44  0.917727     -0.858556E-01 -0.120436E-01  0.120436E-01   105.004       105.016    
  45  0.281495      -1.26764     -0.177822      0.177822       105.182       105.360    
  46  0.757766     -0.277381     -0.389104E-01  0.389104E-01   102.593       102.632    
loop,thermsimp(1:2)       53  0.186142      0.681680E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    431        102.44         67.79          1.11         42.25          0.26          0.05        111.46
Just calling func    0   0        111.46


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    432        107.64         67.75          1.11         42.22          0.15          0.05        111.29
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    102.44
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       53
neval is:      431
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       53      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       54
neval is:      431


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      431     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.551084     -0.595868     -0.835870E-01  0.835870E-01   102.207       102.291    
   2  0.390343     -0.940730     -0.131963      0.131963       102.593       102.725    
   3  0.506127     -0.680968     -0.955246E-01  0.955246E-01   102.675       102.771    
   4  0.964820     -0.358141E-01 -0.502392E-02  0.502392E-02   102.688       102.693    
   5  0.647775     -0.434212     -0.609103E-01  0.609103E-01   102.533       102.594    
   6  0.251459      -1.38048     -0.193650      0.193650       102.963       103.157    
   7  0.908837     -0.955893E-01 -0.134090E-01  0.134090E-01   103.075       103.088    
   8  0.800726     -0.222236     -0.311747E-01  0.311747E-01   102.913       102.944    
   9  0.480867E-01  -3.03475     -0.425707      0.425707       103.201       103.627    
  10  0.859127     -0.151839     -0.212996E-01  0.212996E-01   103.047       103.068    
  11  0.618632     -0.480244     -0.673675E-01  0.673675E-01   103.278       103.345    
  12  0.262118      -1.33896     -0.187826      0.187826       103.373       103.561    
  13  0.373394     -0.985121     -0.138190      0.138190       103.448       103.587    
  14  0.698954     -0.358170     -0.502432E-01  0.502432E-01   103.591       103.641    
  15  0.698639     -0.358621     -0.503065E-01  0.503065E-01   103.681       103.731    
  16  0.683233     -0.380919     -0.534344E-01  0.534344E-01   103.811       103.865    
  17  0.475083     -0.744266     -0.104404      0.104404       103.941       104.045    
  18  0.957666E-01  -2.34584     -0.329069      0.329069       103.589       103.918    
  19  0.767182     -0.265031     -0.371780E-01  0.371780E-01   103.831       103.868    
  20  0.418812     -0.870332     -0.122088      0.122088       103.996       104.118    
  21  0.940661     -0.611725E-01 -0.858113E-02  0.858113E-02   104.120       104.128    
  22  0.827990     -0.188754     -0.264780E-01  0.264780E-01   104.070       104.096    
  23  0.463008     -0.770011     -0.108015      0.108015       104.251       104.359    
  24  0.723352     -0.323860     -0.454302E-01  0.454302E-01   104.151       104.197    
  25  0.330269      -1.10785     -0.155406      0.155406       104.298       104.454    
  26  0.640927E-02  -5.05001     -0.708403      0.708403       104.294       105.003    
  27  0.849682     -0.162893     -0.228503E-01  0.228503E-01   104.387       104.410    
  28  0.457568     -0.781830     -0.109673      0.109673       104.296       104.405    
  29  0.720244     -0.328166     -0.460343E-01  0.460343E-01   104.509       104.555    
  30  0.953392     -0.477287E-01 -0.669527E-02  0.669527E-02   104.097       104.104    
  31  0.322501      -1.13165     -0.158745      0.158745       104.538       104.696    
  32  0.335509      -1.09211     -0.153198      0.153198       104.354       104.507    
  33  0.140389      -1.96334     -0.275413      0.275413       104.571       104.846    
  34  0.429265     -0.845681     -0.118630      0.118630       104.389       104.508    
  35  0.775769E-01  -2.55649     -0.358618      0.358618       104.316       104.675    
  36  0.414811     -0.879933     -0.123435      0.123435       104.627       104.750    
  37  0.183764      -1.69410     -0.237644      0.237644       104.517       104.754    
  38  0.357541      -1.02851     -0.144276      0.144276       104.724       104.868    
  39  0.401419E-02  -5.51792     -0.774040      0.774040       104.407       105.181    
  40  0.399411     -0.917764     -0.128742      0.128742       104.731       104.860    
  41  0.795187     -0.229178     -0.321485E-01  0.321485E-01   104.808       104.840    
  42  0.673332     -0.395517     -0.554822E-01  0.554822E-01   104.969       105.024    
  43  0.898211     -0.107350     -0.150588E-01  0.150588E-01   105.004       105.019    
  44  0.769733     -0.261711     -0.367122E-01  0.367122E-01   104.734       104.770    
  45  0.791938     -0.233272     -0.327228E-01  0.327228E-01   104.856       104.888    
  46  0.537104     -0.621563     -0.871913E-01  0.871913E-01   102.439       102.527    
loop,thermsimp(1:2)       54  0.835870E-01  0.131963    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    433        101.86         67.86          1.10         42.16          0.35          0.05        111.53
Just calling func    0   0        111.53


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    434        100.83         67.84          1.09         42.22          0.22          0.05        111.42
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       1    100.83
 mycase(ii+1)=1: hstar-thermstar(myrank+1) < htherm(1) where htherm(1) is the minimum
 nonparal: hstar < hmin. reflection did well i.e. hstar is lower than the current min (htherm(1))
  ---> expand further i.e. expand pbar in the direction of pstar --> call it pstst
  ---> call functn to get h at expansion pt pstst and call it hstst: PSTST,HSTST
  -------------> if hstst<hstar then return expansion point (pstst) i.e. mypoint(myrank+1,:)=pstst,myval(myrank+1)=hstst
  -------------> if hstst>=hstar then return reflection point (pstar) i.e. mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar



  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       54
neval is:      433
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       54      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       55
neval is:      433


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      433     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.146220      -1.92264     -0.269704      0.269704       102.207       102.477    
   2  0.620947     -0.476510     -0.668437E-01  0.668437E-01   102.439       102.506    
   3  0.177272      -1.73007     -0.242690      0.242690       102.533       102.776    
   4  0.884738     -0.122464     -0.171789E-01  0.171789E-01   102.688       102.706    
   5  0.304829      -1.18800     -0.166650      0.166650       102.593       102.759    
   6  0.555834     -0.587286     -0.823831E-01  0.823831E-01   102.675       102.757    
   7  0.396848     -0.924202     -0.129645      0.129645       102.913       103.042    
   8  0.570840     -0.560646     -0.786460E-01  0.786460E-01   103.047       103.125    
   9  0.726203     -0.319926     -0.448784E-01  0.448784E-01   103.075       103.120    
  10  0.917349E-01  -2.38885     -0.335102      0.335102       102.963       103.298    
  11  0.456603     -0.783941     -0.109969      0.109969       103.278       103.388    
  12  0.602259     -0.507068     -0.711303E-01  0.711303E-01   103.373       103.444    
  13  0.496888E-01  -3.00198     -0.421110      0.421110       103.448       103.869    
  14  0.583997     -0.537860     -0.754497E-01  0.754497E-01   103.201       103.277    
  15  0.200789E-01  -3.90809     -0.548217      0.548217       103.591       104.139    
  16  0.422855     -0.860726     -0.120741      0.120741       103.681       103.802    
  17  0.535645     -0.624284     -0.875731E-01  0.875731E-01   103.811       103.899    
  18  0.413266     -0.883663     -0.123958      0.123958       103.831       103.954    
  19  0.342457      -1.07161     -0.150323      0.150323       103.589       103.739    
  20  0.638345     -0.448876     -0.629673E-01  0.629673E-01   103.941       104.004    
  21  0.655695     -0.422060     -0.592055E-01  0.592055E-01   104.070       104.129    
  22  0.629392     -0.463001     -0.649486E-01  0.649486E-01   104.097       104.162    
  23  0.977606     -0.226486E-01 -0.317709E-02  0.317709E-02   103.996       103.999    
  24  0.752980E-01  -2.58630     -0.362800      0.362800       104.120       104.482    
  25  0.874423     -0.134191     -0.188240E-01  0.188240E-01   104.151       104.170    
  26  0.587202     -0.532387     -0.746819E-01  0.746819E-01   104.251       104.326    
  27  0.880682     -0.127059     -0.178235E-01  0.178235E-01   104.296       104.313    
  28  0.878591E-01  -2.43202     -0.341158      0.341158       104.387       104.728    
  29  0.695678     -0.362869     -0.509024E-01  0.509024E-01   104.298       104.349    
  30  0.124758      -2.08138     -0.291971      0.291971       104.354       104.646    
  31  0.605547     -0.501622     -0.703664E-01  0.703664E-01   104.389       104.460    
  32  0.650291     -0.430335     -0.603664E-01  0.603664E-01   104.509       104.570    
  33  0.639591     -0.446926     -0.626936E-01  0.626936E-01   104.316       104.379    
  34  0.872983     -0.135839     -0.190551E-01  0.190551E-01   104.538       104.557    
  35  0.291503E-01  -3.53529     -0.495922      0.495922       104.627       105.123    
  36  0.290539      -1.23602     -0.173385      0.173385       104.517       104.690    
  37  0.759349     -0.275294     -0.386176E-01  0.386176E-01   104.734       104.772    
  38  0.599537     -0.511597     -0.717656E-01  0.717656E-01   104.808       104.880    
  39  0.948707     -0.526557E-01 -0.738642E-02  0.738642E-02   104.571       104.578    
  40  0.180828      -1.71021     -0.239904      0.239904       104.731       104.971    
  41  0.385708     -0.952674     -0.133639      0.133639       104.724       104.858    
  42  0.299380      -1.20604     -0.169181      0.169181       104.856       105.025    
  43  0.853891     -0.157952     -0.221571E-01  0.221571E-01   104.294       104.316    
  44  0.502000E-01  -2.99174     -0.419674      0.419674       105.004       105.424    
  45  0.510049     -0.673249     -0.944417E-01  0.944417E-01   104.969       105.063    
  46  0.500368     -0.692411     -0.971297E-01  0.971297E-01   100.829       100.926    
loop,thermsimp(1:2)       55  0.269704      0.668437E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    435        103.90         67.93          1.08         42.12          0.42          0.05        111.61
Just calling func    0   0        111.61


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    103.90
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       55
neval is:      434
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       55      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       56
neval is:      434


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      434     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.500984     -0.691182     -0.969573E-01  0.969573E-01   100.829       100.926    
   2  0.324862      -1.12436     -0.157722      0.157722       102.207       102.365    
   3  0.195419      -1.63261     -0.229019      0.229019       102.439       102.668    
   4  0.203731      -1.59096     -0.223175      0.223175       102.688       102.912    
   5  0.177968      -1.72615     -0.242141      0.242141       102.675       102.917    
   6  0.835197     -0.180088     -0.252623E-01  0.252623E-01   102.593       102.618    
   7  0.302476      -1.19575     -0.167737      0.167737       102.533       102.701    
   8  0.352903E-01  -3.34415     -0.469109      0.469109       102.913       103.382    
   9  0.308671      -1.17548     -0.164894      0.164894       103.075       103.240    
  10  0.409306E-01  -3.19588     -0.448310      0.448310       103.047       103.495    
  11  0.615747     -0.484919     -0.680232E-01  0.680232E-01   103.201       103.270    
  12  0.766359     -0.266105     -0.373286E-01  0.373286E-01   102.963       103.000    
  13  0.625912     -0.468545     -0.657264E-01  0.657264E-01   103.278       103.343    
  14  0.435348     -0.831610     -0.116656      0.116656       103.373       103.490    
  15  0.341014      -1.07583     -0.150915      0.150915       103.589       103.739    
  16  0.434268E-01  -3.13668     -0.440006      0.440006       103.681       104.121    
  17  0.604743     -0.502951     -0.705528E-01  0.705528E-01   103.448       103.519    
  18  0.536278     -0.623102     -0.874073E-01  0.874073E-01   103.811       103.899    
  19  0.207674      -1.57179     -0.220486      0.220486       103.831       104.051    
  20  0.985598E-01  -2.31709     -0.325036      0.325036       103.996       104.321    
  21  0.814506     -0.205174     -0.287813E-01  0.287813E-01   103.941       103.969    
  22  0.447321     -0.804478     -0.112850      0.112850       104.070       104.183    
  23  0.741331     -0.299308     -0.419861E-01  0.419861E-01   103.591       103.633    
  24  0.601378     -0.508531     -0.713355E-01  0.713355E-01   104.097       104.169    
  25  0.421939E-01  -3.16548     -0.444046      0.444046       104.151       104.595    
  26  0.837477     -0.177362     -0.248799E-01  0.248799E-01   104.296       104.321    
  27  0.297606      -1.21198     -0.170014      0.170014       104.294       104.464    
  28  0.383069     -0.959540     -0.134602      0.134602       104.251       104.386    
  29  0.291041      -1.23429     -0.173144      0.173144       104.298       104.472    
  30  0.788773     -0.237276     -0.332846E-01  0.332846E-01   104.316       104.350    
  31  0.471794     -0.751213     -0.105378      0.105378       104.389       104.495    
  32  0.313755      -1.15914     -0.162602      0.162602       104.120       104.282    
  33  0.878815     -0.129181     -0.181211E-01  0.181211E-01   104.538       104.556    
  34  0.442284     -0.815802     -0.114439      0.114439       104.509       104.624    
  35  0.577998     -0.548185     -0.768981E-01  0.768981E-01   104.571       104.648    
  36  0.167851      -1.78468     -0.250350      0.250350       104.354       104.604    
  37  0.317031      -1.14875     -0.161145      0.161145       104.517       104.678    
  38  0.645763     -0.437323     -0.613466E-01  0.613466E-01   104.387       104.449    
  39  0.682139     -0.382522     -0.536592E-01  0.536592E-01   104.734       104.787    
  40  0.116437      -2.15041     -0.301654      0.301654       104.724       105.026    
  41  0.510594     -0.672180     -0.942918E-01  0.942918E-01   104.808       104.902    
  42  0.807696E-02  -4.81874     -0.675961      0.675961       104.731       105.407    
  43  0.367650      -1.00062     -0.140365      0.140365       104.856       104.996    
  44  0.446943     -0.805324     -0.112969      0.112969       104.969       105.082    
  45  0.181490      -1.70655     -0.239391      0.239391       104.627       104.866    
  46  0.912521     -0.915438E-01 -0.128415E-01  0.128415E-01   103.904       103.917    
loop,thermsimp(1:2)       56  0.969573E-01  0.157722    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    436        103.85         67.78          1.11         42.06          0.46          0.05        111.46
Just calling func    0   0        111.45


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    103.85
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       56
neval is:      435
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       56      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       57
neval is:      435


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      435     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.842839     -0.170980     -0.239846E-01  0.239846E-01   100.829       100.853    
   2  0.986423     -0.136696E-01 -0.191754E-02  0.191754E-02   102.207       102.209    
   3  0.633540     -0.456433     -0.640273E-01  0.640273E-01   102.593       102.657    
   4  0.518217E-01  -2.95995     -0.415214      0.415214       102.439       102.855    
   5  0.187161      -1.67579     -0.235075      0.235075       102.533       102.768    
   6  0.148298      -1.90853     -0.267725      0.267725       102.688       102.956    
   7  0.438795     -0.823722     -0.115550      0.115550       102.675       102.791    
   8  0.763297     -0.270109     -0.378902E-01  0.378902E-01   102.963       103.001    
   9  0.338275      -1.08390     -0.152046      0.152046       103.075       103.227    
  10  0.918815     -0.846702E-01 -0.118773E-01  0.118773E-01   103.201       103.213    
  11  0.349782      -1.05045     -0.147354      0.147354       103.278       103.425    
  12  0.131188      -2.03112     -0.284921      0.284921       102.913       103.197    
  13  0.961440     -0.393229E-01 -0.551613E-02  0.551613E-02   103.373       103.378    
  14  0.489949     -0.713455     -0.100082      0.100082       103.047       103.147    
  15  0.149956      -1.89742     -0.266165      0.266165       103.448       103.715    
  16  0.684004     -0.379791     -0.532762E-01  0.532762E-01   103.591       103.644    
  17  0.314778      -1.15589     -0.162145      0.162145       103.589       103.751    
  18  0.615260     -0.485711     -0.681343E-01  0.681343E-01   103.811       103.879    
  19  0.432805     -0.837468     -0.117478      0.117478       103.904       104.022    
  20  0.362224      -1.01549     -0.142451      0.142451       103.941       104.083    
  21  0.622697     -0.473696     -0.664489E-01  0.664489E-01   103.831       103.897    
  22  0.486392     -0.720740     -0.101104      0.101104       103.681       103.782    
  23  0.465513     -0.764615     -0.107258      0.107258       104.097       104.205    
  24  0.738251     -0.303471     -0.425701E-01  0.425701E-01   104.070       104.112    
  25  0.384600     -0.955551     -0.134042      0.134042       104.120       104.254    
  26  0.293922      -1.22444     -0.171762      0.171762       104.296       104.467    
  27  0.371803     -0.989390     -0.138789      0.138789       103.996       104.135    
  28  0.237589      -1.43721     -0.201609      0.201609       104.316       104.518    
  29  0.286147      -1.25125     -0.175522      0.175522       104.251       104.427    
  30  0.500459     -0.692230     -0.971043E-01  0.971043E-01   104.387       104.484    
  31  0.134865      -2.00348     -0.281044      0.281044       104.294       104.575    
  32  0.660213     -0.415193     -0.582423E-01  0.582423E-01   104.298       104.357    
  33  0.481817E-01  -3.03278     -0.425430      0.425430       104.389       104.815    
  34  0.683728     -0.380195     -0.533328E-01  0.533328E-01   104.538       104.591    
  35  0.634601     -0.454758     -0.637924E-01  0.637924E-01   104.151       104.215    
  36  0.195153      -1.63397     -0.229210      0.229210       104.354       104.583    
  37  0.176401      -1.73499     -0.243381      0.243381       104.509       104.753    
  38  0.770296     -0.260980     -0.366097E-01  0.366097E-01   104.571       104.607    
  39  0.223005      -1.50056     -0.210495      0.210495       104.517       104.727    
  40  0.530844E-01  -2.93587     -0.411837      0.411837       104.734       105.145    
  41  0.778354     -0.250574     -0.351499E-01  0.351499E-01   104.627       104.662    
  42  0.118362E-02  -6.73917     -0.945355      0.945355       104.808       105.753    
  43  0.658087     -0.418418     -0.586946E-01  0.586946E-01   104.856       104.914    
  44  0.832154E-01  -2.48632     -0.348775      0.348775       104.724       105.073    
  45  0.569178     -0.563562     -0.790551E-01  0.790551E-01   104.969       105.048    
  46  0.511101     -0.671188     -0.941527E-01  0.941527E-01   103.852       103.946    
loop,thermsimp(1:2)       57  0.239846E-01  0.191754E-02

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    437        101.34         67.84          1.09         42.17          0.31          0.05        111.47
Just calling func    0   0        111.47


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    101.34
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       57
neval is:      436
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       57      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       58
neval is:      436


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      436     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.524788     -0.644761     -0.904455E-01  0.904455E-01   100.829       100.919    
   2  0.210443      -1.55854     -0.218629      0.218629       102.207       102.426    
   3  0.930464     -0.720719E-01 -0.101101E-01  0.101101E-01   102.593       102.603    
   4  0.858664     -0.152378     -0.213752E-01  0.213752E-01   102.533       102.555    
   5  0.285726      -1.25272     -0.175729      0.175729       102.675       102.851    
   6  0.144917      -1.93160     -0.270960      0.270960       102.439       102.710    
   7  0.999977     -0.230243E-04 -0.322979E-05  0.322979E-05   102.688       102.688    
   8  0.985482     -0.146243E-01 -0.205146E-02  0.205146E-02   102.963       102.965    
   9  0.204255      -1.58839     -0.222815      0.222815       103.047       103.270    
  10  0.932647     -0.697284E-01 -0.978133E-02  0.978133E-02   102.913       102.922    
  11  0.916829     -0.868346E-01 -0.121809E-01  0.121809E-01   103.201       103.214    
  12  0.468002     -0.759282     -0.106510      0.106510       103.075       103.181    
  13  0.314730      -1.15604     -0.162166      0.162166       103.373       103.535    
  14  0.641708     -0.443621     -0.622301E-01  0.622301E-01   103.278       103.340    
  15  0.829165     -0.187336     -0.262790E-01  0.262790E-01   103.591       103.617    
  16  0.163052E-01  -4.11627     -0.577421      0.577421       103.448       104.026    
  17  0.795714     -0.228516     -0.320556E-01  0.320556E-01   103.589       103.621    
  18  0.933380     -0.689433E-01 -0.967119E-02  0.967119E-02   103.681       103.691    
  19  0.839430E-01  -2.47762     -0.347554      0.347554       103.811       104.159    
  20  0.684979     -0.378367     -0.530764E-01  0.530764E-01   103.831       103.884    
  21  0.473112     -0.748422     -0.104987      0.104987       103.852       103.957    
  22  0.513710     -0.666097     -0.934385E-01  0.934385E-01   103.904       103.998    
  23  0.360837      -1.01933     -0.142989      0.142989       103.941       104.084    
  24  0.427332E-01  -3.15278     -0.442264      0.442264       104.070       104.512    
  25  0.772426     -0.258219     -0.362224E-01  0.362224E-01   103.996       104.032    
  26  0.514081     -0.665375     -0.933371E-01  0.933371E-01   104.097       104.191    
  27  0.794349     -0.230233     -0.322965E-01  0.322965E-01   104.151       104.184    
  28  0.306573      -1.18230     -0.165850      0.165850       104.120       104.285    
  29  0.542954     -0.610731     -0.856719E-01  0.856719E-01   104.298       104.384    
  30  0.309169      -1.17387     -0.164667      0.164667       104.251       104.416    
  31  0.870005     -0.139256     -0.195345E-01  0.195345E-01   104.296       104.315    
  32  0.559982     -0.579850     -0.813399E-01  0.813399E-01   104.387       104.469    
  33  0.779248     -0.249426     -0.349889E-01  0.349889E-01   104.316       104.351    
  34  0.852492     -0.159591     -0.223871E-01  0.223871E-01   104.294       104.317    
  35  0.513103E-01  -2.96986     -0.416605      0.416605       104.354       104.770    
  36  0.843623     -0.170050     -0.238541E-01  0.238541E-01   104.538       104.561    
  37  0.514962E-01  -2.96625     -0.416098      0.416098       104.571       104.987    
  38  0.509762     -0.673812     -0.945207E-01  0.945207E-01   104.627       104.721    
  39  0.511862E-01  -2.97229     -0.416945      0.416945       104.517       104.934    
  40  0.118788      -2.13041     -0.298849      0.298849       104.509       104.808    
  41  0.156747      -1.85312     -0.259951      0.259951       104.389       104.649    
  42  0.715854     -0.334278     -0.468918E-01  0.468918E-01   104.856       104.903    
  43  0.472923     -0.748824     -0.105043      0.105043       104.969       105.074    
  44  0.105826      -2.24596     -0.315057      0.315057       104.724       105.039    
  45  0.214159      -1.54104     -0.216173      0.216173       104.734       104.950    
  46  0.212749      -1.54764     -0.217100      0.217100       101.344       101.561    
loop,thermsimp(1:2)       58  0.904455E-01  0.218629    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    438        102.29         67.92          1.10         42.10          0.58          0.05        111.75
Just calling func    0   0        111.75


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    102.29
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       58
neval is:      437
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       58      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       59
neval is:      437


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      437     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.810144     -0.210543     -0.295345E-01  0.295345E-01   100.829       100.859    
   2  0.897699     -0.107920     -0.151388E-01  0.151388E-01   101.344       101.359    
   3  0.719626     -0.329023     -0.461546E-01  0.461546E-01   102.207       102.253    
   4  0.415410     -0.878490     -0.123232      0.123232       102.533       102.656    
   5  0.991404     -0.863283E-02 -0.121099E-02  0.121099E-02   102.593       102.594    
   6  0.700708     -0.355664     -0.498916E-01  0.498916E-01   102.688       102.738    
   7  0.358389      -1.02614     -0.143944      0.143944       102.439       102.583    
   8  0.726731     -0.319199     -0.447765E-01  0.447765E-01   102.675       102.720    
   9  0.386831     -0.949769     -0.133231      0.133231       102.913       103.046    
  10  0.294784      -1.22151     -0.171351      0.171351       102.963       103.134    
  11  0.315848      -1.15249     -0.161669      0.161669       103.075       103.236    
  12  0.284632E-01  -3.55914     -0.499268      0.499268       103.201       103.701    
  13  0.316608      -1.15009     -0.161332      0.161332       103.047       103.208    
  14  0.309580      -1.17254     -0.164481      0.164481       103.278       103.442    
  15  0.758095     -0.276946     -0.388494E-01  0.388494E-01   103.373       103.412    
  16  0.132565      -2.02068     -0.283456      0.283456       103.591       103.874    
  17  0.963676     -0.369997E-01 -0.519023E-02  0.519023E-02   103.589       103.594    
  18  0.428996     -0.846309     -0.118718      0.118718       103.681       103.800    
  19  0.975676     -0.246243E-01 -0.345423E-02  0.345423E-02   103.831       103.834    
  20  0.475146     -0.744134     -0.104385      0.104385       103.852       103.956    
  21  0.507593     -0.678075     -0.951187E-01  0.951187E-01   103.904       103.999    
  22  0.275170      -1.29037     -0.181009      0.181009       103.448       103.629    
  23  0.475456     -0.743481     -0.104294      0.104294       103.996       104.100    
  24  0.302172      -1.19676     -0.167878      0.167878       103.941       104.109    
  25  0.243313      -1.41341     -0.198269      0.198269       103.811       104.009    
  26  0.356568      -1.03123     -0.144658      0.144658       104.151       104.296    
  27  0.630291     -0.461573     -0.647484E-01  0.647484E-01   104.097       104.162    
  28  0.642369     -0.442593     -0.620859E-01  0.620859E-01   104.120       104.182    
  29  0.593424     -0.521846     -0.732033E-01  0.732033E-01   104.296       104.369    
  30  0.813415     -0.206514     -0.289693E-01  0.289693E-01   104.294       104.323    
  31  0.623760     -0.471989     -0.662095E-01  0.662095E-01   104.316       104.383    
  32  0.314127      -1.15796     -0.162435      0.162435       104.298       104.461    
  33  0.333295      -1.09873     -0.154127      0.154127       104.251       104.405    
  34  0.974282     -0.260545E-01 -0.365486E-02  0.365486E-02   104.387       104.391    
  35  0.217685      -1.52471     -0.213882      0.213882       104.070       104.284    
  36  0.327903      -1.11504     -0.156415      0.156415       104.538       104.694    
  37  0.336622      -1.08880     -0.152734      0.152734       104.389       104.542    
  38  0.569408     -0.563159     -0.789985E-01  0.789985E-01   104.627       104.706    
  39  0.577250E-01  -2.85206     -0.400081      0.400081       104.354       104.754    
  40  0.237530      -1.43746     -0.201644      0.201644       104.509       104.711    
  41  0.622163     -0.474553     -0.665692E-01  0.665692E-01   104.856       104.922    
  42  0.476244     -0.741825     -0.104061      0.104061       104.517       104.621    
  43  0.914828     -0.890196E-01 -0.124874E-01  0.124874E-01   104.734       104.746    
  44  0.555890     -0.587184     -0.823688E-01  0.823688E-01   104.571       104.653    
  45  0.874902     -0.133644     -0.187472E-01  0.187472E-01   104.724       104.743    
  46  0.637871     -0.449619     -0.630715E-01  0.630715E-01   102.289       102.352    
loop,thermsimp(1:2)       59  0.295345E-01  0.151388E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    439        102.23         67.86          1.09         42.18          0.25          0.05        111.44
Just calling func    0   0        111.44


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    102.23
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       59
neval is:      438
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       59      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       60
neval is:      438


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      438     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.421109     -0.864863     -0.121321      0.121321       100.829       100.950    
   2  0.422022     -0.862697     -0.121017      0.121017       101.344       101.465    
   3  0.295550      -1.21892     -0.170987      0.170987       102.207       102.378    
   4  0.624681     -0.470513     -0.660025E-01  0.660025E-01   102.289       102.355    
   5  0.768652     -0.263117     -0.369095E-01  0.369095E-01   102.439       102.476    
   6  0.888855     -0.117822     -0.165277E-01  0.165277E-01   102.593       102.609    
   7  0.509140     -0.675031     -0.946918E-01  0.946918E-01   102.533       102.628    
   8  0.493628     -0.705973     -0.990322E-01  0.990322E-01   102.675       102.774    
   9  0.781578     -0.246440     -0.345701E-01  0.345701E-01   102.688       102.723    
  10  0.617265     -0.482456     -0.676778E-01  0.676778E-01   102.913       102.980    
  11  0.335801      -1.09124     -0.153076      0.153076       102.963       103.116    
  12  0.570262     -0.561660     -0.787883E-01  0.787883E-01   103.047       103.126    
  13  0.159269      -1.83716     -0.257712      0.257712       103.075       103.332    
  14  0.339767      -1.07950     -0.151429      0.151429       103.373       103.524    
  15  0.493989     -0.705242     -0.989297E-01  0.989297E-01   103.278       103.377    
  16  0.839254     -0.175242     -0.245825E-01  0.245825E-01   103.589       103.613    
  17  0.421889E-01  -3.16560     -0.444062      0.444062       103.448       103.892    
  18  0.278070      -1.27988     -0.179539      0.179539       103.201       103.381    
  19  0.942016E-01  -2.36232     -0.331380      0.331380       103.681       104.013    
  20  0.627802E-01  -2.76812     -0.388305      0.388305       103.831       104.219    
  21  0.228221      -1.47744     -0.207252      0.207252       103.591       103.798    
  22  0.929298     -0.733263E-01 -0.102860E-01  0.102860E-01   103.852       103.862    
  23  0.505346     -0.682512     -0.957412E-01  0.957412E-01   103.904       104.000    
  24  0.181316      -1.70751     -0.239526      0.239526       103.811       104.051    
  25  0.430977     -0.841701     -0.118072      0.118072       103.996       104.114    
  26  0.161604      -1.82261     -0.255671      0.255671       103.941       104.196    
  27  0.428774     -0.846826     -0.118791      0.118791       104.097       104.216    
  28  0.178213      -1.72477     -0.241947      0.241947       104.120       104.361    
  29  0.440884E-01  -3.12156     -0.437885      0.437885       104.070       104.508    
  30  0.224754      -1.49275     -0.209399      0.209399       104.151       104.361    
  31  0.174128      -1.74796     -0.245200      0.245200       104.294       104.539    
  32  0.798091     -0.225532     -0.316371E-01  0.316371E-01   104.296       104.327    
  33  0.303667E-01  -3.49441     -0.490187      0.490187       104.316       104.807    
  34  0.256290      -1.36145     -0.190980      0.190980       104.387       104.578    
  35  0.367468      -1.00112     -0.140435      0.140435       104.251       104.392    
  36  0.455395     -0.786590     -0.110341      0.110341       104.298       104.409    
  37  0.618612     -0.480277     -0.673721E-01  0.673721E-01   104.389       104.457    
  38  0.348147      -1.05513     -0.148011      0.148011       104.517       104.665    
  39  0.930736     -0.717801E-01 -0.100691E-01  0.100691E-01   104.571       104.581    
  40  0.822258     -0.195701     -0.274524E-01  0.274524E-01   104.538       104.565    
  41  0.444031     -0.811860     -0.113886      0.113886       104.627       104.741    
  42  0.599515     -0.511634     -0.717708E-01  0.717708E-01   104.509       104.581    
  43  0.866231     -0.143603     -0.201443E-01  0.201443E-01   104.724       104.744    
  44  0.143678      -1.94018     -0.272164      0.272164       104.734       105.006    
  45  0.280081      -1.27267     -0.178528      0.178528       104.354       104.532    
  46  0.834705E-01  -2.48326     -0.348346      0.348346       102.232       102.580    
loop,thermsimp(1:2)       60  0.121321      0.121017    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    440        104.78         67.93          1.12         42.12          0.25          0.05        111.48
Just calling func    0   0        111.48


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    104.78
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       60
neval is:      439
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       60      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       61
neval is:      439


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      439     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.297049      -1.21386     -0.170277      0.170277       100.829       100.999    
   2  0.575341     -0.552793     -0.775445E-01  0.775445E-01   101.344       101.422    
   3  0.202897      -1.59506     -0.223751      0.223751       102.289       102.513    
   4  0.154497      -1.86758     -0.261979      0.261979       102.207       102.469    
   5  0.990348     -0.969851E-02 -0.136048E-02  0.136048E-02   102.439       102.441    
   6  0.189774      -1.66192     -0.233130      0.233130       102.232       102.465    
   7  0.744626     -0.294873     -0.413641E-01  0.413641E-01   102.593       102.634    
   8  0.927855     -0.748799E-01 -0.105040E-01  0.105040E-01   102.533       102.544    
   9  0.730698     -0.313755     -0.440128E-01  0.440128E-01   102.688       102.732    
  10  0.375841     -0.978590     -0.137274      0.137274       102.675       102.812    
  11  0.792754     -0.232243     -0.325784E-01  0.325784E-01   102.913       102.945    
  12  0.232963      -1.45687     -0.204367      0.204367       102.963       103.167    
  13  0.816440     -0.202802     -0.284485E-01  0.284485E-01   103.047       103.075    
  14  0.626790     -0.467144     -0.655298E-01  0.655298E-01   103.075       103.140    
  15  0.943587     -0.580664E-01 -0.814541E-02  0.814541E-02   103.278       103.286    
  16  0.790178     -0.235497     -0.330350E-01  0.330350E-01   103.201       103.235    
  17  0.318791      -1.14322     -0.160368      0.160368       103.373       103.533    
  18  0.982573     -0.175804E-01 -0.246613E-02  0.246613E-02   103.589       103.591    
  19  0.959024     -0.418390E-01 -0.586908E-02  0.586908E-02   103.591       103.597    
  20  0.309588      -1.17251     -0.164477      0.164477       103.852       104.016    
  21  0.255297      -1.36533     -0.191525      0.191525       103.448       103.640    
  22  0.287931      -1.24504     -0.174651      0.174651       103.904       104.079    
  23  0.948191     -0.531995E-01 -0.746270E-02  0.746270E-02   103.681       103.689    
  24  0.231941      -1.46127     -0.204984      0.204984       103.811       104.016    
  25  0.730836E-01  -2.61615     -0.366987      0.366987       103.996       104.363    
  26  0.130964      -2.03283     -0.285161      0.285161       103.941       104.226    
  27  0.199641      -1.61124     -0.226020      0.226020       104.097       104.323    
  28  0.375837     -0.978600     -0.137276      0.137276       103.831       103.968    
  29  0.584992     -0.536158     -0.752109E-01  0.752109E-01   104.296       104.371    
  30  0.505862     -0.681491     -0.955978E-01  0.955978E-01   104.151       104.247    
  31  0.431310     -0.840928     -0.117963      0.117963       104.120       104.237    
  32  0.273049E-01  -3.60069     -0.505096      0.505096       104.251       104.756    
  33  0.865419E-01  -2.44713     -0.343277      0.343277       104.298       104.642    
  34  0.174989      -1.74303     -0.244508      0.244508       104.389       104.634    
  35  0.547517     -0.602362     -0.844979E-01  0.844979E-01   104.070       104.154    
  36  0.562902E-02  -5.17982     -0.726613      0.726613       104.354       105.080    
  37  0.386997     -0.949338     -0.133171      0.133171       104.294       104.427    
  38  0.750107     -0.287539     -0.403353E-01  0.403353E-01   104.538       104.578    
  39  0.218818      -1.51951     -0.213154      0.213154       104.387       104.600    
  40  0.821700     -0.196380     -0.275476E-01  0.275476E-01   104.571       104.598    
  41  0.223897      -1.49657     -0.209935      0.209935       104.509       104.719    
  42  0.744973     -0.294407     -0.412987E-01  0.412987E-01   104.517       104.558    
  43  0.279239      -1.27569     -0.178950      0.178950       104.627       104.806    
  44  0.210659      -1.55751     -0.218484      0.218484       104.724       104.943    
  45  0.998203     -0.179835E-02 -0.252269E-03  0.252269E-03   104.316       104.317    
  46  0.355772      -1.03347     -0.144972      0.144972       104.780       104.925    
loop,thermsimp(1:2)       61  0.170277      0.775445E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    441        103.29         67.96          1.10         42.66          0.38          0.05        112.15
Just calling func    0   0        112.15


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds

  440    103.29       0.4877     -3.341      2.462     -102.6     0.1905    
                       1.023     0.5209     -99.70      4.844      1.325    

                       1.555     -2.569      1.540      7834.      7000.    

                      0.5658      0.000      0.000      0.000     -1.221    



                      -2.342      0.000      0.000      7000.      613.5    

                       1.911     -4.399     -6.827     -8.721      8.557    

                      -17.00     -7.827      5362.      0.000      6393.    



                       2126.      6450.      6136.      2928.      4107.    

                       3756.     0.1105E-01 0.2544    -0.3348E-01 0.1510    

                     -0.2486    -0.1446     0.1394     0.8045E-01 0.9157E-01



                     -0.3585    -0.8793      0.000     0.8457E-01-0.3931E-01

                     -0.4697E-01 0.1431    -0.7116    -0.1141     0.2695    

                      0.3288E-01 0.1525E-02-0.4643     -1.144      7000.    



                      -1.979     -1.950     -2.002     -1.922    -0.3807    

                     -0.3252      9.271      8.803    -0.1489E+05 -4.904    

                     -0.7234     -3.670      9.384      8.894    -0.1969E+05



                      -6.000     0.6023     0.5979E-02  9.018      8.879    

                     -0.1944E+05 -6.000     -1.401    -0.1825      9.136    

                       8.850    -0.1891E+05 -6.000    
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    103.29
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       61
neval is:      440
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       61      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       62
neval is:      440


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      440     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.176971      -1.73177     -0.242929      0.242929       100.829       101.072    
   2  0.163120      -1.81327     -0.254361      0.254361       101.344       101.599    
   3  0.828064     -0.188664     -0.264654E-01  0.264654E-01   102.439       102.466    
   4  0.491219     -0.710866     -0.997185E-01  0.997185E-01   102.232       102.332    
   5  0.473397     -0.747822     -0.104903      0.104903       102.207       102.312    
   6  0.737394     -0.304633     -0.427332E-01  0.427332E-01   102.289       102.332    
   7  0.206273      -1.57855     -0.221436      0.221436       102.533       102.755    
   8  0.354259      -1.03773     -0.145570      0.145570       102.593       102.738    
   9  0.233194      -1.45588     -0.204228      0.204228       102.688       102.893    
  10  0.118120E-01  -4.43864     -0.622642      0.622642       102.675       103.298    
  11  0.918073     -0.854782E-01 -0.119907E-01  0.119907E-01   102.913       102.925    
  12  0.845317     -0.168044     -0.235728E-01  0.235728E-01   103.047       103.070    
  13  0.706964     -0.346775     -0.486448E-01  0.486448E-01   103.075       103.123    
  14  0.779001     -0.249743     -0.350333E-01  0.350333E-01   102.963       102.998    
  15  0.455959     -0.785352     -0.110167      0.110167       103.201       103.312    
  16  0.849694     -0.162880     -0.228483E-01  0.228483E-01   103.278       103.300    
  17  0.516839     -0.660024     -0.925865E-01  0.925865E-01   103.373       103.466    
  18  0.892086     -0.114192     -0.160186E-01  0.160186E-01   103.589       103.605    
  19  0.297598      -1.21201     -0.170018      0.170018       103.591       103.761    
  20  0.719255E-01  -2.63213     -0.369228      0.369228       103.448       103.818    
  21  0.722825     -0.324588     -0.455324E-01  0.455324E-01   103.681       103.727    
  22  0.550765     -0.596446     -0.836680E-01  0.836680E-01   103.831       103.914    
  23  0.988777     -0.112866E-01 -0.158326E-02  0.158326E-02   103.811       103.813    
  24  0.706438     -0.347520     -0.487493E-01  0.487493E-01   103.852       103.901    
  25  0.630672     -0.460969     -0.646637E-01  0.646637E-01   103.904       103.969    
  26  0.377261     -0.974818     -0.136745      0.136745       104.070       104.207    
  27  0.149262E-01  -4.20464     -0.589816      0.589816       103.941       104.530    
  28  0.185115      -1.68678     -0.236617      0.236617       104.120       104.356    
  29  0.836458     -0.178579     -0.250506E-01  0.250506E-01   104.151       104.176    
  30  0.778304     -0.250638     -0.351589E-01  0.351589E-01   104.316       104.352    
  31  0.495633     -0.701920     -0.984636E-01  0.984636E-01   104.097       104.196    
  32  0.795767E-01  -2.53103     -0.355047      0.355047       103.996       104.351    
  33  0.361545      -1.01737     -0.142714      0.142714       104.296       104.438    
  34  0.451858     -0.794387     -0.111435      0.111435       104.294       104.406    
  35  0.923485     -0.796009E-01 -0.111662E-01  0.111662E-01   104.517       104.528    
  36  0.189492      -1.66341     -0.233339      0.233339       104.538       104.771    
  37  0.357280      -1.02924     -0.144379      0.144379       104.571       104.715    
  38  0.113039      -2.18002     -0.305808      0.305808       104.387       104.693    
  39  0.418587     -0.870870     -0.122164      0.122164       104.389       104.511    
  40  0.732527E-01  -2.61384     -0.366663      0.366663       104.298       104.665    
  41  0.768904     -0.262790     -0.368635E-01  0.368635E-01   104.509       104.546    
  42  0.323623      -1.12817     -0.158258      0.158258       104.251       104.409    
  43  0.837193     -0.177701     -0.249275E-01  0.249275E-01   104.627       104.652    
  44  0.656230     -0.421244     -0.590911E-01  0.590911E-01   104.780       104.839    
  45  0.778603     -0.250253     -0.351049E-01  0.351049E-01   104.724       104.759    
  46  0.736391     -0.305994     -0.429240E-01  0.429240E-01   103.293       103.336    
loop,thermsimp(1:2)       62  0.242929      0.254361    

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    442        105.34         68.01          1.10         42.13          0.36          0.05        111.66
Just calling func    0   0        111.66


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

iter,obj,time:    443        102.73         68.25          1.21         41.95          0.08          0.05        111.53
 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       3    102.73
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       62
neval is:      442
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       62      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       63
neval is:      442


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      442     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.278876      -1.27699     -0.179133      0.179133       100.829       101.008    
   2  0.603344     -0.505268     -0.708777E-01  0.708777E-01   101.344       101.415    
   3  0.363780      -1.01121     -0.141849      0.141849       102.207       102.349    
   4  0.298736      -1.20820     -0.169483      0.169483       102.232       102.401    
   5  0.992861     -0.716435E-02 -0.100500E-02  0.100500E-02   102.289       102.290    
   6  0.166164      -1.79478     -0.251767      0.251767       102.439       102.691    
   7  0.416382     -0.876153     -0.122905      0.122905       102.593       102.716    
   8  0.770949     -0.260133     -0.364909E-01  0.364909E-01   102.533       102.570    
   9  0.782423     -0.245359     -0.344184E-01  0.344184E-01   102.688       102.723    
  10  0.115501      -2.15847     -0.302785      0.302785       102.913       103.215    
  11  0.348954      -1.05281     -0.147686      0.147686       102.963       103.111    
  12  0.441818     -0.816857     -0.114587      0.114587       103.047       103.161    
  13  0.888072     -0.118703     -0.166514E-01  0.166514E-01   103.075       103.091    
  14  0.808059     -0.213120     -0.298960E-01  0.298960E-01   102.675       102.705    
  15  0.432540E-01  -3.14067     -0.440565      0.440565       103.278       103.718    
  16  0.369483     -0.995652     -0.139668      0.139668       103.201       103.341    
  17  0.262535      -1.33737     -0.187603      0.187603       103.293       103.481    
  18  0.873783     -0.134923     -0.189267E-01  0.189267E-01   103.373       103.392    
  19  0.636654     -0.451528     -0.633393E-01  0.633393E-01   103.589       103.652    
  20  0.534780     -0.625901     -0.877998E-01  0.877998E-01   103.681       103.769    
  21  0.557733     -0.583875     -0.819046E-01  0.819046E-01   103.591       103.673    
  22  0.929598     -0.730032E-01 -0.102407E-01  0.102407E-01   103.811       103.821    
  23  0.350245      -1.04912     -0.147168      0.147168       103.448       103.596    
  24  0.391945     -0.936633     -0.131389      0.131389       103.852       103.983    
  25  0.123996      -2.08751     -0.292830      0.292830       103.831       104.123    
  26  0.609578E-01  -2.79757     -0.392437      0.392437       103.904       104.297    
  27  0.165807      -1.79693     -0.252069      0.252069       104.151       104.403    
  28  0.766484     -0.265941     -0.373056E-01  0.373056E-01   104.097       104.135    
  29  0.629881     -0.462224     -0.648397E-01  0.648397E-01   104.070       104.135    
  30  0.273641      -1.29594     -0.181791      0.181791       103.996       104.178    
  31  0.344034E-01  -3.36960     -0.472679      0.472679       104.316       104.789    
  32  0.747187     -0.291440     -0.408824E-01  0.408824E-01   104.120       104.160    
  33  0.511998     -0.669435     -0.939068E-01  0.939068E-01   104.294       104.388    
  34  0.544406     -0.608061     -0.852973E-01  0.852973E-01   104.251       104.336    
  35  0.272552      -1.29993     -0.182351      0.182351       104.296       104.478    
  36  0.605186     -0.502220     -0.704502E-01  0.704502E-01   104.389       104.460    
  37  0.923323     -0.797758E-01 -0.111908E-01  0.111908E-01   104.517       104.528    
  38  0.373879     -0.983822     -0.138008      0.138008       103.941       104.079    
  39  0.325119      -1.12356     -0.157611      0.157611       104.509       104.667    
  40  0.746995E-01  -2.59428     -0.363920      0.363920       104.627       104.991    
  41  0.465030     -0.765653     -0.107404      0.107404       104.298       104.406    
  42  0.150040      -1.89685     -0.266086      0.266086       104.387       104.653    
  43  0.127827E-01  -4.35967     -0.611563      0.611563       104.571       105.182    
  44  0.667575     -0.404103     -0.566866E-01  0.566866E-01   104.724       104.781    
  45  0.725579     -0.320785     -0.449989E-01  0.449989E-01   104.538       104.583    
  46  0.555976     -0.587030     -0.823471E-01  0.823471E-01   102.726       102.808    
loop,thermsimp(1:2)       63  0.179133      0.708777E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    444        103.53         68.37          1.25         41.88          0.00          0.05        111.55
Just calling func    0   0        111.55


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    103.53
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       63
neval is:      443
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       63      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       64
neval is:      443


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      443     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.379008E-01  -3.27278     -0.459098      0.459098       100.829       101.288    
   2  0.772352     -0.258315     -0.362357E-01  0.362357E-01   101.344       101.380    
   3  0.802807     -0.219640     -0.308106E-01  0.308106E-01   102.289       102.320    
   4  0.514956     -0.663673     -0.930984E-01  0.930984E-01   102.207       102.300    
   5  0.554302     -0.590045     -0.827701E-01  0.827701E-01   102.232       102.315    
   6  0.503754     -0.685667     -0.961837E-01  0.961837E-01   102.533       102.629    
   7  0.400624     -0.914733     -0.128317      0.128317       102.439       102.568    
   8  0.912762     -0.912806E-01 -0.128046E-01  0.128046E-01   102.675       102.688    
   9  0.197841E-01  -3.92288     -0.550292      0.550292       102.593       103.143    
  10  0.657402E-02  -5.02463     -0.704843      0.704843       102.688       103.393    
  11  0.802861     -0.219574     -0.308014E-01  0.308014E-01   102.726       102.756    
  12  0.494750     -0.703703     -0.987137E-01  0.987137E-01   103.075       103.173    
  13  0.533728     -0.627869     -0.880759E-01  0.880759E-01   102.963       103.051    
  14  0.202886      -1.59511     -0.223758      0.223758       103.047       103.271    
  15  0.459498     -0.777620     -0.109083      0.109083       102.913       103.022    
  16  0.476385     -0.741530     -0.104020      0.104020       103.201       103.305    
  17  0.604782     -0.502887     -0.705438E-01  0.705438E-01   103.373       103.443    
  18  0.652452     -0.427018     -0.599011E-01  0.599011E-01   103.293       103.353    
  19  0.611862     -0.491249     -0.689112E-01  0.689112E-01   103.448       103.517    
  20  0.974982     -0.253365E-01 -0.355415E-02  0.355415E-02   103.589       103.592    
  21  0.950238E-01  -2.35363     -0.330161      0.330161       103.591       103.921    
  22  0.322848      -1.13057     -0.158594      0.158594       103.278       103.436    
  23  0.581382     -0.542348     -0.760793E-01  0.760793E-01   103.681       103.757    
  24  0.267652      -1.31807     -0.184895      0.184895       103.811       103.996    
  25  0.232641E-01  -3.76084     -0.527562      0.527562       103.852       104.380    
  26  0.515113E-01  -2.96595     -0.416057      0.416057       103.941       104.357    
  27  0.300440      -1.20251     -0.168685      0.168685       103.831       103.999    
  28  0.760936     -0.273206     -0.383246E-01  0.383246E-01   104.070       104.108    
  29  0.447102     -0.804968     -0.112919      0.112919       104.097       104.210    
  30  0.550831     -0.596328     -0.836514E-01  0.836514E-01   104.120       104.203    
  31  0.314273      -1.15749     -0.162370      0.162370       103.996       104.159    
  32  0.967020     -0.335365E-01 -0.470442E-02  0.470442E-02   103.904       103.909    
  33  0.505250     -0.682701     -0.957677E-01  0.957677E-01   104.251       104.347    
  34  0.416175     -0.876649     -0.122974      0.122974       104.294       104.417    
  35  0.450270     -0.797909     -0.111929      0.111929       104.151       104.263    
  36  0.521734     -0.650597     -0.912642E-01  0.912642E-01   104.298       104.390    
  37  0.135069      -2.00197     -0.280831      0.280831       104.389       104.670    
  38  0.186856      -1.67742     -0.235304      0.235304       104.296       104.531    
  39  0.965761     -0.348385E-01 -0.488706E-02  0.488706E-02   104.517       104.522    
  40  0.419580     -0.868501     -0.121831      0.121831       104.538       104.659    
  41  0.558190     -0.583056     -0.817896E-01  0.817896E-01   104.387       104.469    
  42  0.862407     -0.148028     -0.207649E-01  0.207649E-01   104.509       104.530    
  43  0.507376E-01  -2.98109     -0.418180      0.418180       104.724       105.142    
  44  0.568000     -0.565633     -0.793456E-01  0.793456E-01   104.316       104.396    
  45  0.750571     -0.286921     -0.402486E-01  0.402486E-01   104.627       104.667    
  46  0.873151     -0.135646     -0.190281E-01  0.190281E-01   103.530       103.549    
loop,thermsimp(1:2)       64  0.459098      0.362357E-01

 sort simplex so values of h (with thermal fluctuations) are increasing in index. sort g and h acordingly


 calculate pbar [the centroid fo the vertices of best np1 MINUS nprocs points]
 do i=1,np1-nprocs .... pbar = pbar + g(i,:)


 assign each processor one of the nprocs worst points
 myimax=np1-myrank
 for example: if numprocs is 2 so that myrank is 0 or 1, we will have myimax=np1 for myrank=0 and myimax=np1-1 for myrank=1. 
 then reflect the worst point [g(myimax,:) ] through pbar and call this pstar and get obj value at pstar and call it hstar 

iter,obj,time:    445        103.44         68.14          1.19         42.27          0.00          0.05        111.65
Just calling func    0   0        111.65


reflection --> reflecting MY worst point i.e. g( myimax,:) through PBAR to get the reflection point PSTAR. 
(R) PSTAR = a * (PBAR - g(imax,:)) + PBAR 
(RR) HSTAR=functn(PSTAR,HSTAR) 

now each processor follows different instructions based on their hstar  
and they return a point mypoint with value myval in appropriate index corresponding to which proccessor. 
record what happened in appropriate engry of mycase 

 share outcomes and figure out what the new simplex will look like
 First share outcomes MYCASE, MYPOINT and MYVAL
 right after mycase,mypoint,myval assignments: count number of function evaluations, print as appropriate
 nrounds is no of evals per processor (it can be >1 depending on mycase
 nevalp=nevalp+nrounds
 do 0 to nprocs and writes down what their mycase situation is (after broadcast)
 For case=1 where the reflection PSTAR gives a HSTAR lower than current min, we do  expansion to calculate a new PSTST through expanding and then compare that PSTST to PSTAR
 For case=2 where the reflection PSTAR gives a HSTAR higher than current min BUT lower than htherm(myimax-1), we do nothing (no new PSTST) 
 For case=3, where the reflection PSTAR gives a HSTAR higher than both the current min AND htherm(myimax-1)
 ............we do contraction to calculate a new PSTST by convx combo of pstar and pbar 
 ............then we compare PSTST to EITHER pstar OR the worst point of the original simplex (depending on which is better):  


  myrank  mycase     myval
       0       2    103.44
 mycase(ii+1)=2: hstar-thermstar(myrank+1) > htherm(1) BUT  hstar-thermstar(myrank+1)<htherm(np1-myrank-1) i.e hstar<htherm(np1-1) or (np1-2) ... (np1-myrank-1) .. etc
 mycase(ii+1)=2: hstar > hmi but lower than htherm(myimax-1) 
 nonparal: hstar is not <hmin. but lower than some point, replace p(imax) with pstar and hmax with hstar
 nonparal: note that in nonparallel version it's different, it doesn't sort the objvalue array and it compares hstar to aNY point other than imax
  ---> do nothing and just return the reflection point pstar i.e. mycase(..)=2,mypoint(myrank+1,:)=pstar,myval(myrank+1)=hstar.
  ---> Note that this is the only case in which the processor does not do an extra function call


  myrank  mycase     myval
       0    ****      0.00
 mycase(ii+1)=3 or 4: hstar-thermstar(myrank+1) > htherm(1) AND  hstar-thermstar(myrank+1)>htherm(np1-myrank-1)
 nonparal: hstar > all func values except possibly hmax.  
 nonparal: if hstar<=hmax, replace p(imax) with pstar/ hmax with hstar test whether it is < func value at some point other than p(imax)
 reflection did not do any good i.e. hstar not better than the best AND not better than MY worst point (after imax)
 ---> contract by getting the convex combo of pstar and pbar: PSTST= b * pstar + (one-b) * pbar
 ---> compare the contraction point to EITHER pstar OR the worst point of the original simplex (depending on which is better):  
 ---> IF (hstar-thermstar(myrank+1)<htherm(myimax)) THEN i.e. (pstar is better of the two)
 ----------------> IF (hstst<hstar) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ----------------> ELSE - return the better of pstar and the original point, which is here pstar
 ----------------------------> mycase(myrank+1)=4, mypoint..pstar, myval..hstar
 ---> ELSE  ther original point of the simplex is better than pstar 
 ----------------> IF (hstst-thermstst(myrank+1)<htherm(myimax)) THEN ! case 3 - return the contraction point
 ----------------------------> mycase(myrank+1)=3, mypoint..pstst, myval..hstst
 ---------------->ELSE ! case 4 - return the better of pstar and the original point of the simplex,here g(myimax,:)
 ----------------------------> mycase(myrank+1)=4, mypoint..g(myimax,:), myval..h(myimax)




 CHECK cases
 -----IF at least one proces did not have case 4, then replace worst points and restart loop
 -----IF all processes had case 4, then shrink
current SAtemp,tstepnext are:   0.140278               451
loop is:       64
neval is:      444
 ............
 ............
 ............
 ............
 At least one process did not have case 4 ---> replace the worst nprocs points of simplex with mypoint(1:nprocs) and restart loop
 -----> g(np1-nprocs+1:np1,:)=mypoint(1:nprocs,:)
 -----> h(np1-nprocs+1:np1)=myval(1:nprocs)
 -----> go to 250 (which starts main cycle if loop<nloop)
        loop,nloop are:       64      95
 right before GO TO 250



beginning of Main_loop, just augmented loop: loop=loop+1
T0,tstep,tfreq (these do not change):    35.9111      0.500000    
T0,tstep,tfreq (these do not change):             45
current SAtemp,tstepnext are:   0.140278               451
loop is:       65
neval is:      444


Should I lower temperature?
check: neval>tstepnext?
---if yes: lower temp and get the new temp as SAtemp=SAtemp*Tstep and new tstepnext as tstepnext=tstepnext+Tfreq : 
---if no:  leave SAtemp and tstepnext as they are  lower temp and get the new temp as SAtemp=SAtemp*Tstep: 


 After checking wtr I should lower temperature i.e. out of the neval>tstepnext if statement 
next time, will lower temprature when neval>tstepnext:      451
neval,tstepnext:      444     451

compute and add thermal fluctuations: thermsimp,thermstar,thermstst 


   i      SArandom   logSArandom    SAtemp*log     thermsimp      h       htherm=h+thermsimp
   1  0.483176     -0.727373     -0.102034      0.102034       100.829       100.931    
   2  0.880011     -0.127821     -0.179304E-01  0.179304E-01   101.344       101.362    
   3  0.163672      -1.80989     -0.253887      0.253887       102.207       102.461    
   4  0.548194     -0.601126     -0.843245E-01  0.843245E-01   102.232       102.316    
   5  0.774171     -0.255963     -0.359059E-01  0.359059E-01   102.289       102.325    
   6  0.815808     -0.203577     -0.285573E-01  0.285573E-01   102.439       102.468    
   7  0.901270     -0.103951     -0.145819E-01  0.145819E-01   102.533       102.548    
   8  0.604998     -0.502529     -0.704936E-01  0.704936E-01   102.675       102.746    
   9  0.583320     -0.539020     -0.756124E-01  0.756124E-01   102.726       102.801    
  10  0.776155     -0.253403     -0.355468E-01  0.355468E-01   102.913       102.948    
  11  0.414399     -0.880925     -0.123574      0.123574       102.963       103.087    
  12  0.321893      -1.13354     -0.159010      0.159010       102.593       102.752    
  13  0.882206     -0.125330     -0.175810E-01  0.175810E-01   103.075       103.092    
  14  0.176926      -1.73202     -0.242964      0.242964       103.047       103.290    
  15  0.143482      -1.94155     -0.272356      0.272356       103.201       103.474    
  16  0.669321     -0.401491     -0.563202E-01  0.563202E-01   103.293       103.349    
  17  0.862244     -0.148216     -0.207914E-01  0.207914E-01   102.688       102.709    
  18  0.897950     -0.107641     -0.150995E-01  0.150995E-01   103.278       103.293    
  19  0.788148     -0.238070     -0.333958E-01  0.333958E-01   103.373       103.406    
  20  0.801563     -0.221191     -0.310282E-01  0.310282E-01   103.448       103.479    
  21  0.284401      -1.25737     -0.176381      0.176381       103.530       103.706    
  22  0.782583     -0.245155     -0.343898E-01  0.343898E-01   103.589       103.623    
  23  0.813976     -0.205825     -0.288726E-01  0.288726E-01   103.681       103.710    
  24  0.528421     -0.637861     -0.894776E-01  0.894776E-01   103.904       103.994    
  25  0.871065     -0.138038     -0.193637E-01  0.193637E-01   103.591       103.610    
  26  0.139992      -1.96617     -0.275809      0.275809       103.811       104.087    
  27  0.549296     -0.599118     -0.840429E-01  0.840429E-01   103.831       103.915    
  28  0.990967     -0.907357E-02 -0.127282E-02  0.127282E-02   104.070       104.071    
  29  0.735762     -0.306848     -0.430440E-01  0.430440E-01   103.996       104.039    
  30  0.647880     -0.434050     -0.608875E-01  0.608875E-01   104.120       104.180    
  31  0.324740      -1.12473     -0.157774      0.157774       104.097       104.255    
  32  0.995457E-01  -2.30714     -0.323640      0.323640       104.151       104.475    
  33  0.953388     -0.477336E-01 -0.669596E-02  0.669596E-02   104.251       104.258    
  34  0.573564     -0.555886     -0.779784E-01  0.779784E-01   103.941       104.019    
  35  0.988045     -0.120272E-01 -0.168715E-02  0.168715E-02   103.852       103.854    
  36  0.499857     -0.693433     -0.972732E-01  0.972732E-01   104.298       104.396    
  37  0.687815E-01  -2.67682     -0.375498      0.375498       104.316       104.692    
  38  0.430407     -0.843024     -0.118257      0.118257       104.294       104.412    
  39  0.204975      -1.58487     -0.222322      0.222322       104.387       104.610    
  40  0.318612      -1.14378     -0.160447      0.160447       104.517       104.677    
  41  0.339792      -1.07942     -0.151419      0.151419       104.509       104.661    
  42  0.609830     -0.494575     -0.693778E-01  0.693778E-01   104.296       104.365    
  43  0.518092     -0.657603     -0.922469E-01  0.922469E-01   104.538       104.630    
  44  0.595099     -0.519028     -0.728080E-01  0.728080E-01   104.627       104.700    
  45  0.658024     -0.418513     -0.587080E-01  0.587080E-01   104.389       104.448    
