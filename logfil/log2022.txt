1_mumar3
ran with mumar 3 different mumars up until 15231 something but this did not give me any decrease in mar rates
so save this as the first iteration of today 
and run another one with higher mumar

2_mumar3


mig030722
same as 2_mumar3 but with skriv true at q0=q=18

check why you can't draw the status quo (q0=q=18) for example

check why you can't have q0=3 and q=1 for example 

q0=10 q=1 
This is interesting in how chk2 looks. look at it SAVED THESE AS chk2_q010q1

to migsol, added that bit about whether I can have q0=10 and w=5 and l=1
this is an if statement and it is marked by ahu030622

mumar   0.002   2    25
        20     15000 20000
dont get any decreasing marrates here
but saved it all as 2_mumar3 nevertheless (or did I? can't see this anywhere but it's ok)



030822_1q010q201
CHANGED MULTMAR TO 100000!!!
VERY IMPORTANT 
change this back change htis back change it back change it back 
and also remember the if statement you added to mig_sol
based on a quick run of that if statement I got that q should be 201 so changed it so that I write q0=10 and q=201 now
and running with 
mumar 0.002   0.5_dp     25
saved this as q010q1 because for some reason it still had q=1 instad of 201 in chk2 even though it shows in mig_sol that it is 201
butprogram.f90 was the file that seemed outdated
so strange 
but still keep in order to look at q010 and q=1 situation



030822_2mardecrease
changed multmar to 500000 this time!
because in the last run where mumar was 100K I was still ont going the decreasing mar rates even though way before that was the case 
now I DO get the decreasing mar (to too much though) from mar=122,459 (0.5) to mar=500000 (25)
and BIG increase in div rates from mar=124K to mar=500K

later I will also try with nonlabinc that is not 0 later 


030822_3
changed mig_yaz (added some more lines that hae to do with haveenoughtotransfer (check the places where !ahu030822) 
also added ia=50 to the yaz condition in mig_sol (it was ia 45 and 49 and 18 and 17 before. now it is also 50 so that I can see what is happening without the continuation value complicating things. 
in 030722 directory:
Now run with mumar=122,459 (0.5) first and look at chk2
in temp directory:
copy everything from 030722 and then just change mig_main pars(75) to 25 and then run with mumar=500,000 (25) first and look at chk2



cant catch a break
because even though age18 div rates for the larger mumr very high copared to smaller mumar, the decisions look the same when I compare age18 in chk2 for just q0=10 and q=201
as for the div rate differences for the later ages, I don't want to rely on those since in sim, there'll be a lot of stuff going on before the age (with all the mar and div decision differences, the pool of people will be hard to compare between teh two runs) 
so now save these as 
and run another one with more q and q0s

(q0<=15).and.(q>=190.and.q<=201)

Added some more yay
More specifically, added yazmax which writes file 201 where I just write the state variables, choices considered and max choices 
So we can see what is wrong with scarlet this way





MARCH 10 22 
see chk2_march1022_1 in m030722 an temp for the comparison between age 48 marriage decisions for the specific q0=4 and q=92 and x=19
 
SOME BIG CHANGES
marked with ahumarch1022

changed delta to 0    VERY IMPORTANT  
changed nepsmove to 2 VERY IMPORTANT 

Important insight: When delta is 0, the moments are exactly the same between mumar-122000 and 500000. mar rates div rates everything is the same. 
this means that the problem si that continuation value which is what I suspected



MARCH 11 22
changed nepsmove back to 13 to check something about the previous runs
also added to obsjf writemoments: added bshock writing and also added nepsmove to the momentsfile



mom031122_1
ran from a very small mumar to a very large one 
between mumar=1250 and 12497 things start looking different 
ie where div rates start changing in a different direction after this
so below I run another iteration with the end points 1250 and 1z497 and smaller bumps between these (like very small) 
see the 15 iteratiosn from 1250 to 12497


mom031122_2
ran from 1250 to 12497 
div rates start increasing around iterationg 13
run iterations 13 14 and 15 adn compare their chk2
the purpose is a situation where mumar decreasing and dv rates are starting to increase
the reason why the end points are 1250 and 12497 is because ofo the previous run marked mom031122_1



    !031122_1
    !pars(75)=0.00005_dp
    !call getpars(pars,realpars)
    !call objfunc(pars,qval) ; realpars=realpartemp      
    !pars(75)=0.0001_dp
    !call getpars(pars,realpars)
    !call objfunc(pars,qval) ; realpars=realpartemp      
    !pars(75)=0.0005_dp
    !call getpars(pars,realpars)
    !call objfunc(pars,qval) ; realpars=realpartemp      
    !pars(75)=0.001_dp
    !call getpars(pars,realpars)
    !call objfunc(pars,qval) ; realpars=realpartemp      
    !pars(75)=0.005_dp
    !call getpars(pars,realpars)
    !call objfunc(pars,qval) ; realpars=realpartemp      
    !pars(75)=0.01_dp
    !call getpars(pars,realpars)
    !call objfunc(pars,qval) ; realpars=realpartemp      
    !pars(75)=0.05_dp
    !call getpars(pars,realpars)
    !call objfunc(pars,qval) ; realpars=realpartemp      
    !pars(75)=0.1_dp
    !call getpars(pars,realpars)
    !call objfunc(pars,qval) ; realpars=realpartemp      
    !pars(75)=0.5_dp
    !call getpars(pars,realpars)
    !call objfunc(pars,qval) ; realpars=realpartemp      
    !pars(75)=1.0_dp
    !call getpars(pars,realpars)
    !call objfunc(pars,qval) ; realpars=realpartemp      
    !pars(75)=3.0_dp
    !call getpars(pars,realpars)
    !call objfunc(pars,qval) ; realpars=realpartemp      


	!031122_2
    pars(75)=0.005_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.006_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.007_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.008_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.009_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.01_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.012_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.015_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
   	pars(75)=0.02_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.025_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
   	pars(75)=0.03_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.035_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.04_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.045_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.05_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      

mu_mar            1250.00   1500.00   1749.99   1999.99   2249.98   2499.98   2999.96   3749.93   4999.83   6249.67   7499.44   8749.11   9998.67  11248.10  12497.40
in 031122_2: the change in terms of switching to increasing div rates start happening at iteration 13 ot 14 to 15
 1000    1. get div by ia   18             0.1604        0.0714        0.1193        0.0000           1060        56        0.0663
 1000    2. get div by ia   18             0.1555        0.0714        0.1066       -0.0127           1061        56        0.0663
 1000    3. get div by ia   18             0.0867        0.0714        0.0035       -0.1158           1061        56        0.0663
 1000    4. get div by ia   18             0.0857        0.0714        0.0031       -0.1162           1062        56        0.0663
 1000    5. get div by ia   18             0.0857        0.0714        0.0031       -0.1162           1062        56        0.0663
 1000    6. get div by ia   18             0.0847        0.0714        0.0026       -0.1166           1063        56        0.0663
 1000    7. get div by ia   18             0.0827        0.0714        0.0019       -0.1174           1064        56        0.0663
 1000    8. get div by ia   18             0.0818        0.0714        0.0016       -0.1177           1064        56        0.0663
 1000    9. get div by ia   18             0.0825        0.0714        0.0018       -0.1174           1067        56        0.0663
 1000   10. get div by ia   18             0.0802        0.0714        0.0012       -0.1181           1072        56        0.0663
 1000   11. get div by ia   18             0.0798        0.0714        0.0011       -0.1182           1078        56        0.0663
 1000   12. get div by ia   18             0.0798        0.0714        0.0011       -0.1182           1078        56        0.0663
 1000   13. get div by ia   18             0.0805        0.0714        0.0012       -0.1181           1081        56        0.0663
 1000   14. get div by ia   18             0.1099        0.0714        0.0223       -0.0970           1083        56        0.0663
 1000   15. get div by ia   18             0.1465        0.0714        0.0851       -0.0342           1085        56        0.0663
 1001    1. get div by ia   19             0.1399        0.0763        0.0575        0.0000           2416       118        0.0705
 1001    2. get div by ia   19             0.1357        0.0763        0.0502       -0.0073           2424       118        0.0705
 1001    3. get div by ia   19             0.0933        0.0763        0.0041       -0.0533           2497       118        0.0705
 1001    4. get div by ia   19             0.0928        0.0763        0.0039       -0.0536           2500       118        0.0705
 1001    5. get div by ia   19             0.0920        0.076


While htese were runnning I also ran in m030722 to compare age 47 chk2s and to see wy the div rates change so much between mumar small and mumar big.
but didnt' find anything tha tstood out. 


031122_3
Running in 031122 directory still but note that today was march 14 2022
Now going between iteration 13 and iteration 15 but in smaller steps 

	!031122_3
    pars(75)=0.04_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.041_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.042_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.043_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.044_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.45_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.046_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.047_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
   	pars(75)=0.048_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.049_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
   	pars(75)=0.05_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
	!mu_mar            9998.67  10248.56  10498.46  10748.34  10998.23 110639.23  11497.97  11747.84  11997.70  12247.55  12497.40
	!In the above run, where I was trying to figure out where the div rate starting to increase (instead of decrease) occurs between mumar values changing, I all of a sudden see the below horrific view where there is indeed an increse at sme point between mumar 99998 and mumar 12497 but it is not monotonic and there is a big huge jump when mumar changes from 10998 to 110639
Note that we have 0.45 for the 6th iteration instead of 0.045 so ignore that one 

1000    1. get div by ia   18             0.0805        0.0714        0.0012        0.0000           1081        56        0.0663
 1000    2. get div by ia   18             0.0804        0.0714        0.0012       -0.0000           1082        56        0.0663
 1000    3. get div by ia   18             0.0804        0.0714        0.0012       -0.0000           1082        56        0.0663
 1000    4. get div by ia   18             0.0803        0.0714        0.0012       -0.0000           1083        56        0.0663
 1000    5. get div by ia   18             0.0923        0.0714        0.0066        0.0054           1083        56        0.0663
 1000    6. get div by ia   18             0.1906        0.0714        0.2143        0.2130           1133        56        0.0663
 1000    7. get div by ia   18             0.1181        0.0714        0.0328        0.0316           1084        56        0.0663
 1000    8. get div by ia   18             0.1273        0.0714        0.0471        0.0458           1084        56        0.0663
 1000    9. get div by ia   18             0.1458        0.0714        0.0833        0.0821           1084        56        0.0663
 1000   10. get div by ia   18             0.1458        0.0714        0.0833        0.0821           1084        56        0.0663
 1000   11. get div by ia   18             0.1465        0.0714        0.0851        0.0838           1085        56        0.0663
 1001    1. get div by ia   19             0.0880        0.0763        0.0020        0.0000           2557       118        0.0705
 1001    2. get div by ia   19             0.0880        0.0763        0.0019       -0.0000           2558       118        0.0705
 1001    3. get div by ia   19             0.0879        0.0763        0.0019       -0.0000           2559       118        0.0705
 1001    4. get div by ia   19             0.0879        0.0763        0.0019       -0.0000           2560       118        0.0705
 1001    5. get div by ia   19             0.1009        0.0763        0.0086        0.0067           2547       118        0.0705
 1001    6. get div by ia   19             0.1574        0.0763        0.0935        0.0915           2490       118        0.0705
 1001    7. get div by ia   19             0.1238        0.0763        0.0320        0.0301           2521       118        0.0705
 1001    8. get div by ia   19             0.1226        0.0763        0.0305        0.0285           2512       118        0.0705
 1001    9. get div by ia   19             0.1264        0.0763        0.0356        0.0337           2493       118        0.0705
 1001   10. get div by ia   19             0.1295        0.0763        0.0402        0.0382           2495       118        0.0705
 1001   11. get div by ia   19             0.1299        0.0763        0.0408        0.0388           2495       118        0.0705
 1002    1. get div by ia   20             0.0899        0.1179        0.0076        0.0000           3994       195        0.1040
 1002    2. get div by ia   20             0.0899        0.1179        0.0076        0.0000           3995       195        0.1040
 1002    3. get div by ia   20             0.0898        0.1179        0.0076        0.0000           3996       195        0.1040
 1002    4. get div by ia   20             0.0896        0.1179        0.0077        0.0002           3997       195        0.1040
 1002    5. get div by ia   20             0.0949        0.1179        0.0051       -0.0024           3953       195        0.1040
 1002    6. get div by ia   20             0.1440        0.1179        0.0065       -0.0010           3736       195        0.1040
 1002    7. get div by ia   20             0.1147        0.1179        0.0001       -0.0075           3879       195        0.1040
 1002    8. get div by ia   20             0.1156        0.1179        0.0001       -0.0075           3875       195        0.1040
 1002    9. get div by ia   20             0.1183        0.1179        0.0000       -0.0076           3854       195        0.1040
 1002   10. get div by ia   20             0.1227        0.1179        0.0002       -0.0074           3847       195        0.1040
 1002   11. get div by ia   20             0.1224        0.1179        0.0002       -0.0074           3847       195        0.1040
 1003    1. get div by ia   21             0.0945        0.1111        0.0028        0.0000           5260       270        0.0988
 1003    2. get div by ia   21             0.0945        0.1111        0.0028        0.0000           5261       270        0.0988
 1003    3. get div by ia   21             0.0943        0.1111        0.0029        0.0001           5262       270        0.0988
 1003    4. get div by ia   21             0.0942        0.1111        0.0029        0.0001           5263       270        0.0988
 1003    5. get div by ia   21             0.1131        0.1111        0.0000       -0.0028           5208       270        0.0988
 1003    6. get div by ia   21             0.1517    



MARCH1522   031522     ------------------------ahu082222 note trying to catch up: CORNER SOLUTION ADDED ON OR AROUND THIS DATE. THE DIRECTORY M031522 HAS THE FIRST RUNS WITH CORNER SOLUTIONS
BIG CHANGES ON AND AROUND THIS DATE
THE GIST OF THE CHANGE IS THAT I ADDED CORNER SOLUTIONS
FIRST CHECK WHETHER NB IS WELL DEFINED 
SURPLUS>0 ( IS TEHRE ANYTHING THAT CAN MAKE THE TWO HAPPIER THAN ALONE?) 
C1 C2 >=0 ( IS THERE ANYTHING WITHIN THE FEASIBLE SET THAT CAN MEK THEM HAPPIR  
AFTER I CHECK THIS 
THEN I CHECK  THE INTERIOR OPT CONDITIONS WHICH HAVE TO DO WITH COMPARING 
WCSUM >= ABS(VDIF1-VDIF2)  --> INTERIOR 
WCSUM >= VDIF1-VDIF2   ----> CORER ALL GOES TO C1
WCSUM <= VDIF2-VDIF1   ---> CORNER ALL GOES TO C2
 
LOOK LATER. CORRECT LATER. CHECK LATER. check later. beware. 
CHECK the ocrner soolution additions
the previous version of sol should be kept 
Also make sure that you look through the changes to get rid of redundant calculations
as it si now, the way corner sols are added is quite inefficient and it wil increase run ime alot 
AND ALSO I THINK I GET THE EPS AND EPS2 STUFF NOW. SORT OF. 
WITH DP, IT IS DIFFICULT TO GET EXACT EQUALITIES AND DESIRED INEQUALITIES BETWEEN NUMBERS 
SO IT IS SAFER TO ADD EPS2 OR EPS INSTEAD OF NOTHING
AT SOME POINT, THE IF STATEMENTS (SEE COMMENTED OUT IF STATEMENTS IN SOL AND GETDEC_C AROUND WHERE WE ADDED THE CORNERSOL STUFF
YOU WILL SEE THAT THOSE IF STATEMENTS WHEN UNCOMMENTED OUT, THEY CAUSE PROBLEMS. THEY DO STOP THE PROGRAME.
WHY? METHINGS IT'S BECAUSE EVNE THOUGH THE NUMBERS ARE SUPPOSED TO BE RIGHT ALL TEH WAY SGICIENTIF PRECISION ND IT'S N

ALSO REALL THAT NEPSMOVE IS 2 NOW SO MAYBE CHANGE THAT BACK BECAUSE MOVE RATES ARE QUITE LOW?  
ALSO NONLABINC IS 0 NOW 
LOOK LATER. CORRECT LATER. CHECK LATER. BEWARE.

    !031522 MARCH1522 corner solution stuff added 
    pars(75)=0.035_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.04_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.045_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      
    pars(75)=0.05_dp
    call getpars(pars,realpars)
    call objfunc(pars,qval) ; realpars=realpartemp      

Now the div rates no longer look increasing with higher mumar's or high as before 
and the getmar rates falling with mumar is gon eas well 
But what seems to be ht eproblem now? 
BUT if you look at higher mumar values, then the div rates slightly decrease with an increase in mumar at some point again. 
Itis nowhere near what it used  be. but it  us vu
for example compare m031722_1 and m031722_2
will try now with mumar somewhere in between 1 and 2 



m031722_1   ------- ahu082222 THESE ARE THE FIRST RUNS WITH CORNER SOLUTION WHERE WE NO LONGER 



m031722_2
alf2t                8.67      8.67      8.67      8.67
cst                  0.00      0.00      0.00      0.00
mu_mar              12.50     25.00    250.00   2499.98




    ^M
    !m031722_1^M
    !pars(75)=0.035_dp^M
    !call getpars(pars,realpars)^M
    !call objfunc(pars,qval) ; realpars=realpartemp      ^M
    !pars(75)=0.04_dp^M
    !call getpars(pars,realpars)^M
    !call objfunc(pars,qval) ; realpars=realpartemp      ^M
    !pars(75)=0.045_dp^M
    !call getpars(pars,realpars)^M
    !call objfunc(pars,qval) ; realpars=realpartemp      ^M
    !pars(75)=0.05_dp^M
    !call getpars(pars,realpars)^M
    !call objfunc(pars,qval) ; realpars=realpartemp      ^M
^M
^M
    !m031722_2  ^M
    !pars(75)=0.00005_dp^M
    !call getpars(pars,realpars)^M
    !call objfunc(pars,qval) ; realpars=realpartemp      ^M
    !pars(75)=0.0001_dp^M
    !call getpars(pars,realpars)^M
    !call objfunc(pars,qval) ; realpars=realpartemp      ^M
    !pars(75)=0.001_dp^M
    !call getpars(pars,realpars)^M
    !call objfunc(pars,qval) ; realpars=realpartemp      ^M
    !pars(75)=0.01_dp^M
    !call getpars(pars,realpars)^M
    !call objfunc(pars,qval) ; realpars=realpartemp      ^M
^M



    !m031722_3^M
    !pars(75)=0.00005_dp^M
    !call getpars(pars,realpars)^M
    !call objfunc(pars,qval) ; realpars=realpartemp      ^M
    !pars(75)=0.0001_dp^M
    !call getpars(pars,realpars)^M
    !call objfunc(pars,qval) ; realpars=realpartemp      ^M
    !pars(75)=0.001_dp^M
    !call getpars(pars,realpars)^M
    !call objfunc(pars,qval) ; realpars=realpartemp      ^M
    !pars(75)=0.005_dp^M
    !call getpars(pars,realpars)^M
    !call objfunc(pars,qval) ; realpars=realpartemp       ^M
    !pars(75)=0.01_dp^M
    !call getpars(pars,realpars)^M
    !call objfunc(pars,qval) ; realpars=realpartemp      ^M
    !pars(75)=0.015_dp^M
    !call getpars(pars,realpars)^M
    !call objfunc(pars,qval) ; realpars=realpartemp      ^M
    !pars(75)=0.02_dp^M
    !call getpars(pars,realpars)^M
    !call objfunc(pars,qval) ; realpars=realpartemp      ^M
^M
^M
    !m031722_4^M
    pars(75)=0.001_dp^M
    call getpars(pars,realpars)^M
    call objfunc(pars,qval) ; realpars=realpartemp      ^M
    pars(75)=0.0015_dp^M
    call getpars(pars,realpars)^M
    call objfunc(pars,qval) ; realpars=realpartemp       ^M
    pars(75)=0.002_dp^M
    call getpars(pars,realpars)^M
    call objfunc(pars,qval) ; realpars=realpartemp      ^M
    pars(75)=0.0025_dp^M
    call getpars(pars,realpars)^M
    call objfunc(pars,qval) ; realpars=realpartemp      ^M
    pars(75)=0.003_dp^M
    call getpars(pars,realpars)^M
    call objfunc(pars,qval) ; realpars=realpartemp      ^M
    pars(75)=0.0035_dp^M
    call getpars(pars,realpars)^M
    call objfunc(pars,qval) ; realpars=realpartemp      ^M
    pars(75)=0.004_dp^M
    call getpars(pars,realpars)^M
    call objfunc(pars,qval) ; realpars=realpartemp      ^M
    pars(75)=0.0045_dp^M
    call getpars(pars,realpars)^M
    call objfunc(pars,qval) ; realpars=realpartemp      ^M
    pars(75)=0.005_dp^M
    call getpars(pars,realpars)^M
    call objfunc(pars,qval) ; realpars=realpartemp      ^M




MARCH 21 2022 032122

Changed a bunch of other things 
Need to catch up with the notes
Changed locch and loc0 - in order to save time 
Changed to vdif rather than writing vs-vmar all the time
Also changed the places where I was adding eps. I was adding eps to the wrong side sometimes. Check where I added this 
Look at mig_main and then also look at 031522 and 032122


Now the div rates no longer increasing or anything like that

There is a big decrease in div rate when we go from 250 to 1250 (i.e. 0.001 and 0.005) 
You can see that in m031722_3 (iteration 3 to 4 is the big decrease in div rate from 0.27 to around 0.07)
And then I ran m031722_4  where I did smaller incremembts between 250 and 1250 (i.e. 0.001 and 0.005)
In m031722_4 the big decrease seesm to happen between 250 and 375 (i.e. 0.001 and 0.0015)
So now doing m032122_5 to do smaller increasements between 0.001 and 0.0015 (like really small. i am doing 11 steps ebtween 0.001 and 0.0015)



march 22 2022 032222
 mom032122_5: 
This is the run from 0.001 and 0.0015
IT seems the big decrease in div rates happens from iteration 4 to 5 to 6
div rates go from 0.25 to 0.19 to 0.11
whereas in other places they only move by 3 percentage points at most 
In other words: 
wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww


mu_mar             250.00    262.50    275.00    287.50    300.00    312.50    325.00    337.50    350.00    362.50    375.00
               **************************************************************************************************************
               **************************************************************************************************************
               **************************************************************************************************************
               ************


1000    1. get div by ia   18             0.2772        0.0714        0.6386        0.0000           4646        56        0.0663
 1000    2. get div by ia   18             0.2773        0.0714        0.6392        0.0006           4648        56        0.0663
 1000    3. get div by ia   18             0.2779        0.0714        0.6430        0.0045           4652        56        0.0663
 1000    4. get div by ia   18             0.2586        0.0714        0.5282       -0.1104           4652        56        0.0663
 1000    5. get div by ia   18             0.1926        0.0714        0.2214       -0.4172           4652        56        0.0663
 1000    6. get div by ia   18             0.1107        0.0714        0.0233       -0.6153           4652        56        0.0663
 1000    7. get div by ia   18             0.0886        0.0714        0.0044       -0.6341           4652        56        0.0663
 1000    8. get div by ia   18             0.0812        0.0714        0.0015       -0.6371           4653        56        0.0663
 1000    9. get div by ia   18             0.0739        0.0714        0.0001       -0.6385           4654        56        0.0663
 1000   10. get div by ia   18             0.0730        0.0714        0.0000       -0.6385           4655        56        0.0663
 1000   11. get div by ia   18             0.0709        0.0714        0.0000       -0.6386           4655        56        0.0663
 1001    1. get div by ia   19             0.2342        0.0763        0.3541        0.0000           7173       118        0.0705
 1001    2. get div by ia   19             0.2338        0.0763        0.3521       -0.0020           7178       118        0.0705
 1001    3. get div by ia   19             0.2340        0.0763        0.3532       -0.0009           7179       118        0.0705
 1001    4. get div by ia   19             0.2178        0.0763        0.2842       -0.0699           7269       118        0.0705
 1001    5. get div by ia   19             0.1600        0.0763        0.0995       -0.2546           7576       118        0.0705
 1001    6. get div by ia   19             0.0884        0.0763        0.0021       -0.3520           7955       118        0.0705
 1001    7. get div by ia   19             0.0673        0.0763        0.0012       -0.3529           8058       118        0.0705
 1001    8. get div by ia   19             0.0584        0.0763        0.0045       -0.3496           8093       118        0.0705
 1001    9. get div by ia   19             0.0523        0.0763        0.0082       -0.3459           8128       118        0.0705
 1001   10. get div by ia   19             0.0513        0.0763        0.0089       -0.3452           8133       118        0.0705
 1001   11. get div by ia   19             0.0503        0.0763        0.0095       -0.3445           8144       118        0.0705
 1002    1. get div by ia   20             0.2022        0.1179        0.0683        0.0000           8752       195        0.1040
 1002    2. get div by ia   20             0.2024        0.1179        0.0686        0.0003           8759       195        0.1040
 1002    3. get div by ia   20             0.2021        0.1179        0.0681   







MARCH 23 2022  032322
NOW YESTERDAY I HAD SAID YES TO THE QUESTIN IT ALWAYS WAKS WHEN I OPEN A FILE IN VISUAL FORTRAN 
THIS WAS IN MIG_SOL 
SO THEN I SAVED THE ORIGINAL VERSION AS MIGSOL032222 FROM THE CLUSTER
BEWARE OF THIS 


Now looking at some time saving possibilities
Open a new directory called m032322 in the cluster
Transfer the file sin m030622 in the desktop to the cluster new irectory 
Use the original mig_sol

Renaming the migsol032222save file in the desktop 030622 directory as mig_sol 
and renaming the mig_sol as migsolcontaminated

scp -i key030322.pem ~/Dropbox/migit/m030622/mig_main.f90 ec2-user@ec2-23-20-1-216.compute-1.amazonaws.com:/home/ec2-user/m032122/
scp -i key030322.pem ec2-user@ec2-23-20-1-216.compute-1.amazonaws.com:/home/ec2-user/m032122/mig_sol.f90 ~/Dropbox/migit/m030622/migsol032222save.f90
scp -i key030322.pem ec2-user@ec2-23-20-1-216.compute-1.amazonaws.com:/home/ec2-user/m032122/mig_sol.f90 ~/Dropbox/migit/m030622/migsol032222save.f90
scp -i key030322.pem ec2-user@ec2-52-87-253-211.compute-1.amazonaws.com:/home/ec2-user/m032122/mig_sol.f90 ~/Dropbox/migit/m030622/migsol032222save.f90
scp -i key030322.pem ~/Dropbox/migit/m030622/*.f90 ec2-user@ec2-54-234-98-155.compute-1.amazonaws.com:/home/ec2-user/m032322/
scp -i key030322.pem ~/Dropbox/migit/m030622/mig_sol.f90 ec2-user@ec2-54-234-98-155.compute-1.amazonaws.com:/home/ec2-user/m032322_2/   
scp -i key030322.pem ~/Dropbox/migit/m030622/*.f90 ec2-user@ec2-54-234-98-155.compute-1.amazonaws.com:/home/ec2-user/m032322_2/
scp -i key030322.pem ec2-user@ec2-75-101-234-79.compute-1.amazonaws.com:/home/ec2-user/m032322_2/* ~/Dropbox/migit/m032322_2/                                                                                        



-----------------------


In directory m032322_2
This directory files were copied from m030622 as well as can be seen from above 


There were two files mig_sol.f90 and migsolcontaminated (see above for how they came from m030622)
The only difference between these two files is the placement of "  if ( maxval(qq2w(:,q0)) <= np1 ) then !state variable part of the q space i.e. w <= np1  " 


I think I tried to move this if statement from the x loop to right after the beginning of the q0 loop (probably in order to save time and also to check if anything changes?)
See below for the two possible places for this if statement

			if (onlysingles) then 	
				decm_s(:,:,:,:,ia,index)=decm0_s(:,:,:,:,ia,index)
				decf_s(:,:,:,:,ia,index)=decf0_s(:,:,:,:,ia,index)
				vmr=vm(:,:,:,:,ia,index)
				vfr=vf(:,:,:,:,ia,index)
			else 
				whereamI=1 ! for telling yaz about where we are
				vec=pen
				do q0=1,nq	
                    if ( maxval(qq2w(:,q0)) <= np1 ) then !state variable part of the q space i.e. w <= np1

					vm_c=pen ; vf_c=pen
					prob=0.0_dp
					do x=1,nx	
						do q=1,nq



---->

					do x0=1,nx
                       ! if ( maxval(qq2w(:,q0)) <= np1 ) then !state variable part of the q space i.e. w <= np1
						    !prob=matmul( reshape(ppcq(:,q0,x0),(/nq,1/)) , reshape(ppcx(:,q0,x0),(/1,nx/)) )
						    !emaxm_c(q0,x0,ia)=sum(prob*vm_c)
						    !emaxf_c(q0,x0,ia)=sum(prob*vf_c)                    
                            emaxm_c(q0,x0,ia)=0.0_dp
						    emaxf_c(q0,x0,ia)=0.0_dp
                            do q=1,nq
                                do x=1,nx
						            emaxm_c(q0,x0,ia)=emaxm_c(q0,x0,ia)+ppcq(q,q0,x0)*ppcx(x,q0,x0)*vm_c(q,x)
						            emaxf_c(q0,x0,ia)=emaxf_c(q0,x0,ia)+ppcq(q,q0,x0)*ppcx(x,q0,x0)*vf_c(q,x)
                                end do 
                            end do 
                        !end if !state variable part of the q space i.e. w <= np1
					end do	 !x0						




------

GETTING RID OF M032322_2 DIRECTORY
The files 
migsolcontaminated in m030622 
migsolcontaminated in m032322_2
mig_sol.f90 in m032322_2
are all the same EXCEPT for their difference in that xx2xs error AND where the following goes: if ( maxval(qq2w(:,q0)) <= np1 ) then !state variable part of the q space i.e. w <= np1
So delete the redundant files and just leave one mig_sol in m030622
See Things to check and decide to make a decision about that

The files 
mig_objf.f90 in m030622
mig_objf.f90 in m032322_2
as well as the other files since 032322_2 was copied from 030622
are all the same so get rid of the redundant ones

So Get rid of directory m032322_2
Delete all the redundant mig_sol files 
Rename migsol032322_2 and place it in m030622



GETTING RID OF M032322 DIRECTORY 
ECLP022:migit ahu$ diff ./m030622/mig_params.f90 ./m032322/mig_params.f90 
19c19
< 	integer(i4b), parameter :: numit=12 !ahumarch1122
---
> 	integer(i4b), parameter :: numit=2 !ahumarch1122
ECLP022:migit ahu$ 
ECLP022:migit ahu$ 
ECLP022:migit ahu$ diff ./m030622/mig_share.f90 ./m032322/mig_share.f90 
ECLP022:migit ahu$ diff ./m030622/mig_func.f90 ./m032322/mig_func.f90 
ECLP022:migit ahu$ diff ./m030622/mig_yaz.f90 ./m032322/mig_yaz.f90 
ECLP022:migit ahu$ 
ECLP022:migit ahu$ diff ./m030622/mig_main.f90 ./m032322/mig_main.f90 
900,933d899
<     nonlabinc=0.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp          
<     nonlabinc=0.5_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=5.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp  
<     nonlabinc=10.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=100.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=500.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=1000.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=2000.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=3000.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=4000.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=5000.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=6000.0_dp
935a902
>     
ECLP022:migit ahu$ diff ./m030622/mig_mom.f90 ./m032322/mig_mom.f90 
ECLP022:migit ahu$ 
ECLP022:migit ahu$ 

All files same except for migsol and migmain. Save those as 032322 and put them in m030622
params only difference is numit so leave that alone 
Delete all other files in m032322

ECLP022:m032322 ahu$ mv mig_sol.f90 migsol032322.f90
ECLP022:m032322 ahu$ mv mig_main.f90 migmain032322.f90
ECLP022:m032322 ahu$ mv mig_sol_extras1.f90 migsolextras1032322.f90

ECLP022:migit ahu$ mv ./m032322/migmain032322.f90 ./m030622/
ECLP022:migit ahu$ mv ./m032322/migsol032322.f90 ./m030622/
ECLP022:migit ahu$ mv ./m032322/migsolextras1032322.f90 ./m030622/



COMPARING m030622 vs. m032122. GETTING RID OF M032122 BECAUSE SOL IS 
THE SAME AS MIGSOL032322_2 IN M030622 (EXCEPT FOR END IF ON LINE 190 RELATED TO THAT Q SPACE IF STATEMENT THING)
AND MAIN AND PARAMS ONLY DIFFER IN TERMS OF NUMIT STUFF. KEEPING THE MOMENTS OUTPUT FILES THOUGH AND PLACING THEM IN M030622. 
ECLP022:migit ahu$ diff ./m030622/migsol032322_2.f90 ./m032122/migsol.f90
190c190
<                     end if 
---
> 
ECLP022:migit ahu$ diff ./m030622/mig_func.f90 ./m032122/mig_func.f90
ECLP022:migit ahu$ diff ./m030622/mig_share.f90 ./m032122/mig_share.f90
ECLP022:migit ahu$ diff ./m030622/mig_yaz.f90 ./m032122/mig_yaz.f90
ECLP022:migit ahu$ diff ./m030622/mig_objf.f90 ./m032122/mig_objf.f90
281c281
<         write(60,'(1a15,12f10.2)') parname(i),realpar_save(i,1:numit) !ahu030622
---
>         write(60,'(1a15,11f10.2)') parname(i),realpar_save(i,1:numit) !ahu030622
ECLP022:migit ahu$ 
ECLP022:migit ahu$ diff ./m030622/mig_params.f90 ./m032122/mig_params.f90
19c19
< 	integer(i4b), parameter :: numit=12 !ahumarch1122
---
> 	integer(i4b), parameter :: numit=11 !ahumarch1122
ECLP022:migit ahu$ 
ECLP022:migit ahu$ diff ./m030622/mig_mom.f90 ./m032122/mig_mom.f90
ECLP022:migit ahu$ 





COMPARING ./m030622/migsol032322_2.f90 ./m031522/migsol032122.f90 

ECLP022:migit ahu$ diff ./m030622/temp032322_2.f90 ./m031522/temp032122.f90 
190c190
<                     end if 
---
> 
Note that temp files are the /m030622/mig_sol032322_2 and /m031522/mig_sol032122.f90 files but until line 218
So teh above diff means that until line 218, the only difference is the end if statement on line 190. which needs to be commented or uncommented out. 

Then comparing the lines AfTER line 218, the following are the main differences: 
The following starts right after line 218 and goes until around line 238 (until the if surplus and haveneough statement)

m031522/migsol032122
LINE 219                                    !call checknb(dd,vec,welldef,vsum )  
                                        
                                            surplus = vec(5) + vec(3) - vec(1) + vec(4) - vec(2)  
                                            vdif(1)=vec(3)-vec(1)   !ahumarch1522 adding cornersol
                                            vdif(2)=vec(4)-vec(2)   !ahumarch1522 adding cornersol

                                            pc(1:2)	= ( vdif + eps >= 0.0_dp )	!pc(1:2)    = ( vec(3:4) - vec(1:2) >= 0.0_dp )						        
                                            pc_alt(1:2)=( vdif >= 0.0_dp )	
                                            asum = sum(  one(.not. pc)  *   abs( vdif )   ) 
                                            haveenoughtomakeindiff=(  vec(5) + eps - asum  >= 0.0_dp  )
                                            haveenoughtomakeindiff_alt=(  vec(5) - asum  >= 0.0_dp  )
                                            !In orer for NB to be well defined, we need: 1) surplus>=0 2) there exists some transfer such that transfer1>=0 and transfer2>=0
                                            !Condition 2 follows from the requirement that the utility transfer has to only come from current wsum and not the V's. In other words, 
                                            !w has to be such that it can cover any utility transfers that are needed o have the PC's hold. 
                                            !See notes in black notebook about why Condition 2 translates into that asum condition. 
                                            !Once we establish that NB is well defined, then we can go ahead and see if the optimum is interior or corner. 
                                            intsol(1)=( vec(5) + eps >= abs(vdif(1)-vdif(2)) )  !interior
                                            intsol(2)=( vec(5) + eps < vdif(1)-vdif(2)   )      !corner where c1=0 and c2=wsum
                                            intsol(3)=( vec(5) + eps < vdif(2)-vdif(1)   )      !corner where c1=wsum and c2=0
                                            if (surplus+eps>0.0_dp .and. haveenoughtomakeindiff ) then
                                            !ahumarch1522 Now check if the interior condition is really indeed satisfied but get rid of this later
                                            if ( intsol(1) ) then       !ahumarch1522 interiorcheck adding cornersol
                                                welldef=.TRUE.          !ahumarch1522
                                                transfers(1) = alf * surplus - ( vec(3)-vec(1) )                                                
                                                transfers(2) = (1.0_dp-alf) * (vec(5) + vec(3) - vec(1) ) - alf*( vec(4)-vec(2) )   
 LINE 244                                               vmarios(1:2)=vec(3:4)+transfers(1:2)
 





m030622/migsol032322_2
 LINE 219                                   !call checknb(dd,vec,welldef,vsum )  
                                            vdif(1)=vec(3)-vec(1)   !ahumarch1522 ahu031522 adding cornersol
                                            vdif(2)=vec(4)-vec(2)   !ahumarch1522 ahu031522 adding cornersol
                                            !ahumarch2122 ahu032122 replacing this with vdif for saving time surplus = vec(5) + vec(3) - vec(1) + vec(4) - vec(2)  
                                            surplus = vec(5) + sum(vdif(1:2))  !ahumarch2122 ahu032122 replacing with vdif for saving time
                                            pc(1:2)	= ( vdif + eps >= 0.0_dp )	!pc(1:2)    = ( vec(3:4) - vec(1:2) >= 0.0_dp )						        
                                            !ahu032122 ahumarch2122 commenting out to save time pc_alt(1:2)=( vdif >= 0.0_dp )	
                                            asum = sum(  one(.not. pc)  *   abs( vdif )   ) 
                                            haveenoughtomakeindiff=(  vec(5) + eps - asum  >= 0.0_dp  )
                                            !ahu032122 ahumarch2122 commenting out to save time haveenoughtomakeindiff_alt=(  vec(5) - asum  >= 0.0_dp  )
                                            !In orer for NB to be well defined, we need: 1) surplus>=0 2) there exists some transfer such that transfer1>=0 and transfer2>=0
                                            !Condition 2 follows from the requirement that the utility transfer has to only come from current wsum and not the V's. In other words, 
                                            !w has to be such that it can cover any utility transfers that are needed o have the PC's hold. 
                                            !See notes in black notebook about why Condition 2 translates into that asum condition. 
                                            !Once we establish that NB is well defined, then we can go ahead and see if the optimum is interior or corner. 
                                            intsol(1)=( vec(5) + eps >= abs(vdif(1)-vdif(2)) )  !interior
                                            !ahumarch2122 ahu032122 moving eps to the other side intsol(2)=( vec(5) + eps < vdif(1)-vdif(2)   )      !corner where c1=0 and c2=wsum
                                            !ahumarch2122 ahu032122 moving eps to the other side intsol(3)=( vec(5) + eps < vdif(2)-vdif(1)   )      !corner where c1=wsum and c2=0
                                            intsol(2)=( vec(5) <= vdif(1)-vdif(2) + eps  )      !corner where c1=0 and c2=wsum !ahumarch2122 ahu032122 moving eps to the other side
                                            intsol(3)=( vec(5) <= vdif(2)-vdif(1) + eps  )      !corner where c1=wsum and c2=0 !ahumarch2122 ahu032122 moving eps to the other side

                                            if (surplus+eps>0.0_dp .and. haveenoughtomakeindiff ) then
                                            !ahumarch1522 Now check if the interior condition is really indeed satisfied but get rid of this later
                                            if ( intsol(1) ) then       !ahumarch1522 interiorcheck adding cornersol                                            
                                                welldef=.TRUE.          !ahumarch1522
                                                !ahumarch2122 ahu032122 replacing with vdif to save time transfers(1) = alf * surplus - ( vec(3)-vec(1) )                                                
                                                !ahumarch2122 ahu032122 replacing with vdif to save time transfers(2) = (1.0_dp-alf) * (vec(5) + vec(3) - vec(1) ) - alf*( vec(4)-vec(2) )   
                                                transfers(1) = alf * surplus -  vdif(1)                     !ahumarch2122 ahu032122 replacing with vdif to save time                                           
                                                transfers(2) = (1.0_dp-alf) * (vec(5) + vdif(1) ) - alf*vdif(2) !ahumarch2122 ahu032122 replacing with vdif to save time   
                                                vmarios(1:2)=vec(3:4)+transfers(1:2)


So as can be seen the only differences are the way vdid's replace vec3-vec1 and vec4-vec2 to avoid recalculating the same thing 
the moving of eps to the other side
and the commenting out of some of those alt logical statement
and calculation of transfers (with vdif)





m031522/migsol032122

LINE 505    choice: do j=1,nc	
        i = ch(j,q,q0)	!alternative q
        if (i>0 ) then		
            locch=qq2l(1,i)     !ahumarch2022 ahu032022
            !if (qq2l(1,i).ne.qq2l(2,i)) then ; print*, 'something wrong in dec_c' ; stop; end if 
            !if (qq2l(1,q0).ne.qq2l(2,q0)) then ; print*, 'something wrong in dec_c' ; stop; end if 
            !ahumarch2022 ahu032022 vec(3) = vm0_c(i,x,ia,index)  + mg(z,trueindex) + one( qq2l(1,i) /= qq2l(1,q0)) * mcost(1) + one( qq2l(1,i) /= qq2l(1,q0)) * moveshock_m(iepsmove)  !fnmove(kid)     
            !ahumarch2022 ahu032022 vec(4) = vf0_c(i,x,ia,index)  + mg(z,trueindex) + one( qq2l(2,i) /= qq2l(2,q0)) * mcost(2) + one( qq2l(2,i) /= qq2l(2,q0)) * moveshock_f(iepsmove)  !fnmove(kid)     
            vec(3) = vm0_c(i,x,ia,index)  + mg(z,trueindex) + one( locch /= loc0 ) * (mcost(1) + moveshock_m(iepsmove) ) !ahumarch2022 ahu032022     
            vec(4) = vf0_c(i,x,ia,index)  + mg(z,trueindex) + one( locch /= loc0 ) * (mcost(2) + moveshock_f(iepsmove) ) !ahumarch2022 ahu032022
            !vec(5) = wc(1,i,x,trueindex) + wc(2,i,x,trueindex) + one( qq2w(1,q0)<=np )* ubc(1,i,x,trueindex) + one( qq2w(2,q0)<=np )* ubc(2,i,x,trueindex) + nonlabinc + nonlabinc 	 !ahu summer18 050318: added the ubc
            vec(5) = wc(1,i,x,trueindex) + wc(2,i,x,trueindex) + nonlabinc(ed(1)) + nonlabinc(ed(2)) 
            surplusj(j) = vec(5) + vec(3) - vec(1) + vec(4) - vec(2)  
            dd(8:9)=(/j,i/)
            !arson
            vdif(1)=vec(3)-vec(1)   !ahumarch1522 adding cornersol
            vdif(2)=vec(4)-vec(2)   !ahumarch1522 adding cornersol
		    !vdif = vec(3:4) - vec(1:2) 	
	        !surplus=vec(3)-vec(1)+vec(4)-vec(2)+vec(5)
            !ahu032122 ahumarch2122 commenting out cuz time pc(1:2)	= ( vdif + eps >= 0.0_dp )	!pc(1:2)    = ( vec(3:4) - vec(1:2) >= 0.0_dp )						        
            !ahu032122 ahumarch2122 commenting out cuz time pc_alt(1:2)=( vdif >= 0.0_dp )	
            asum = sum(  one(.not. pc)  *   abs( vdif )   ) 
            haveenoughtomakeindiff=(  vec(5) + eps - asum  >= 0.0_dp  )
            haveenoughtomakeindiff_alt=(  vec(5) - asum  >= 0.0_dp  )
            !In orer for NB to be well defined, we need: 1) surplus>=0 2) there exists some transfer such that transfer1>=0 and transfer2>=0
            !Condition 2 follows from the requirement that the utility transfer has to only come from current wsum and not the V's. In other words, 
            !w has to be such that it can cover any utility transfers that are needed o have the PC's hold. 
            !See notes in black notebook about why Condition 2 translates into that asum condition. 
            !Once we establish that NB is well defined, then we can go ahead and see if the optimum is interior or corner. 
            intsol(1)=( vec(5) + eps >= abs(vdif(1)-vdif(2)) )  !interior
            intsol(2)=( vec(5) + eps < vdif(1)-vdif(2)   )      !corner where c1=0 and c2=wsum
            intsol(3)=( vec(5) + eps < vdif(2)-vdif(1)   )      !corner where c1=wsum and c2=0
            if (surplusj(j)+eps>0.0_dp .and. haveenoughtomakeindiff ) then
                    !ahumarch1522 Now check if the interior condition is really indeed satisfied but get rid of this later
                    if ( intsol(1) ) then       !ahumarch1522 interiorcheck adding cornersol
                        defj(j)=.TRUE.          !ahumarch1522
                        transfers(1) = alf * surplusj(j) - ( vec(3)-vec(1) )                                                
                        transfers(2) = (1.0_dp-alf) * (vec(5) + vec(3) - vec(1) ) - alf*( vec(4)-vec(2) )   
 LINE 543                       vmario(1:2,j)=vec(3:4)+transfers(1:2)







m030622/migsol032322_2

 line 504   choice: do j=1,nc	
        i = ch(j,q,q0)	!alternative q
        if (i>0 ) then		
            locch=qq2l(1,i)     !ahumarch2122 ahu032122
            dd(8:9)=(/j,i/)     !ahumarch2122 ahu022122 moved this up
            !if (qq2l(1,i).ne.qq2l(2,i)) then ; print*, 'something wrong in dec_c' ; stop; end if 
            !if (qq2l(1,q0).ne.qq2l(2,q0)) then ; print*, 'something wrong in dec_c' ; stop; end if 
            !ahumarch2122 ahu032122 vec(3) = vm0_c(i,x,ia,index)  + mg(z,trueindex) + one( qq2l(1,i) /= qq2l(1,q0)) * mcost(1) + one( qq2l(1,i) /= qq2l(1,q0)) * moveshock_m(iepsmove)  !fnmove(kid)     
            !ahumarch2122 ahu032122 vec(4) = vf0_c(i,x,ia,index)  + mg(z,trueindex) + one( qq2l(2,i) /= qq2l(2,q0)) * mcost(2) + one( qq2l(2,i) /= qq2l(2,q0)) * moveshock_f(iepsmove)  !fnmove(kid)     
            vec(3) = vm0_c(i,x,ia,index)  + mg(z,trueindex) + one( locch /= loc0 ) * (mcost(1) + moveshock_m(iepsmove) ) !ahumarch2022 ahu032022     
            vec(4) = vf0_c(i,x,ia,index)  + mg(z,trueindex) + one( locch /= loc0 ) * (mcost(2) + moveshock_f(iepsmove) ) !ahumarch2022 ahu032022
            !vec(5) = wc(1,i,x,trueindex) + wc(2,i,x,trueindex) + one( qq2w(1,q0)<=np )* ubc(1,i,x,trueindex) + one( qq2w(2,q0)<=np )* ubc(2,i,x,trueindex) + nonlabinc + nonlabinc 	 !ahu summer18 050318: added the ubc
            vec(5) = wc(1,i,x,trueindex) + wc(2,i,x,trueindex) + nonlabinc(ed(1)) + nonlabinc(ed(2)) 
            vdif(1)=vec(3)-vec(1)   !ahumarch1522 ahu031522 adding cornersol
            vdif(2)=vec(4)-vec(2)   !ahumarch1522 ahu031522 adding cornersol
            !ahumarch2122 ahu032122 replacing this with vdif for saving time surplusj(j) = vec(5) + vec(3) - vec(1) + vec(4) - vec(2)  
            surplusj(j) = vec(5) + sum(vdif(1:2))  !ahumarch2122 ahu032122 replacing with vdif for saving time
	        !surplus=vec(3)-vec(1)+vec(4)-vec(2)+vec(5)
            pc(1:2)	= ( vdif + eps >= 0.0_dp )	!pc(1:2)    = ( vec(3:4) - vec(1:2) >= 0.0_dp )						        
            !ahu032122 ahumarch2122 commenting out to save time pc_alt(1:2)=( vdif >= 0.0_dp )	
            asum = sum(  one(.not. pc)  *   abs( vdif )   ) 
            haveenoughtomakeindiff=(  vec(5) + eps - asum  >= 0.0_dp  )
            !ahu032122 ahumarch2122 commenting out to save time haveenoughtomakeindiff_alt=(  vec(5) - asum  >= 0.0_dp  )
            !In orer for NB to be well defined, we need: 1) surplus>=0 2) there exists some transfer such that transfer1>=0 and transfer2>=0
            !Condition 2 follows from the requirement that the utility transfer has to only come from current wsum and not the V's. In other words, 
            !w has to be such that it can cover any utility transfers that are needed o have the PC's hold. 
            !See notes in black notebook about why Condition 2 translates into that asum condition. 
            !Once we establish that NB is well defined, then we can go ahead and see if the optimum is interior or corner. 
            intsol(1)=( vec(5) + eps >= abs(vdif(1)-vdif(2)) )  !interior
            !ahumarch2122 ahu032122 moving eps to the other side intsol(2)=( vec(5) + eps < vdif(1)-vdif(2)   )      !corner where c1=0 and c2=wsum
            !ahumarch2122 ahu032122 moving eps to the other side intsol(3)=( vec(5) + eps < vdif(2)-vdif(1)   )      !corner where c1=wsum and c2=0
            intsol(2)=( vec(5) <= vdif(1)-vdif(2) + eps  )      !corner where c1=0 and c2=wsum !ahumarch2122 ahu032122 moving eps to the other side
            intsol(3)=( vec(5) <= vdif(2)-vdif(1) + eps  )      !corner where c1=wsum and c2=0 !ahumarch2122 ahu032122 moving eps to the other side

            if (surplusj(j)+eps>0.0_dp .and. haveenoughtomakeindiff ) then
                    !ahumarch1522 Now check if the interior condition is really indeed satisfied but get rid of this later
                    if ( intsol(1) ) then       !ahumarch1522 interiorcheck adding cornersol
                        defj(j)=.TRUE.          !ahumarch1522
                        !ahumarch2122 ahu032122 replacing with vdif to save time transfers(1) = alf * surplusj(j) - ( vec(3)-vec(1) )                                                
                        !ahumarch2122 ahu032122 replacing with vdif to save time transfers(2) = (1.0_dp-alf) * (vec(5) + vec(3) - vec(1) ) - alf*( vec(4)-vec(2) )   
                        transfers(1) = alf * surplusj(j) -  vdif(1)                     !ahumarch2122 ahu032122 replacing with vdif to save time                                           
                        transfers(2) = (1.0_dp-alf) * (vec(5) + vdif(1) ) - alf*vdif(2) !ahumarch2122 ahu032122 replacing with vdif to save time   
 line 546                       vmario(1:2,j)=vec(3:4)+transfers(1:2)


So the above differences show that the only other difference between these two files are in these lines in getdec_c 
which are similar to the differences around lines 219



ECLP022:migit ahu$ diff ./m030622/tempbottom032322_2.f90 ./m031522/tempbottom032122.f90 
This shows that the lines after 543 or 546 are exactly the same between these two files. So the above are the only differences. (around line 219 and then in getdec_c)

For the differences between other files in these directories: 
ECLP022:migit ahu$ diff ./m030622/mig_func.f90 ./m031522/mig_func.f90 
ECLP022:migit ahu$ diff ./m030622/mig_share.f90 ./m031522/mig_share.f90 
ECLP022:migit ahu$ diff ./m030622/mig_yaz.f90 ./m031522/mig_yaz.f90 
ECLP022:migit ahu$ diff ./m030622/mig_mom.f90 ./m031522/mig_mom.f90 
ECLP022:migit ahu$ diff ./m030622/mig_main.f90 ./m031522/mig_main.f90 
821,839c821,824
<     !call getpars(pars,realpars)
<     !call objfunc(pars,qval) ; realpars=realpartemp      
<     !pars(75)=0.015_dp
<     !call getpars(pars,realpars)
<     !call objfunc(pars,qval) ; realpars=realpartemp      
<     !pars(75)=0.02_dp
<     !call getpars(pars,realpars)
<     !call objfunc(pars,qval) ; realpars=realpartemp      
< 
< 
<     !m031722_4
<  !   pars(75)=0.001_dp
<  !   call getpars(pars,realpars)
<  !   call objfunc(pars,qval) ; realpars=realpartemp      
<  !   pars(75)=0.0015_dp
<  !   call getpars(pars,realpars)
<  !   call objfunc(pars,qval) ; realpars=realpartemp       
<  !   pars(75)=0.002_dp
<  !   call getpars(pars,realpars)
---
> !    call getpars(pars,realpars)
> !    call objfunc(pars,qval) ; realpars=realpartemp      
> !    pars(75)=0.015_dp
> !    call getpars(pars,realpars)
841,856c826
<  !   pars(75)=0.0025_dp
<  !   call getpars(pars,realpars)
<  !   call objfunc(pars,qval) ; realpars=realpartemp      
<  !   pars(75)=0.003_dp
<  !   call getpars(pars,realpars)
<  !   call objfunc(pars,qval) ; realpars=realpartemp      
<  !   pars(75)=0.0035_dp
<  !   call getpars(pars,realpars)
<  !   call objfunc(pars,qval) ; realpars=realpartemp      
<  !   pars(75)=0.004_dp
<  !   call getpars(pars,realpars)
<  !   call objfunc(pars,qval) ; realpars=realpartemp      
<  !   pars(75)=0.0045_dp
<  !   call getpars(pars,realpars)
<  !   call objfunc(pars,qval) ; realpars=realpartemp      
<  !   pars(75)=0.005_dp
---
>  !   pars(75)=0.02_dp
860,910c830,857
<    
<     !!m031722_5
<     !pars(75)=0.001_dp
<     !call getpars(pars,realpars)
<     !call objfunc(pars,qval) ; realpars=realpartemp      
<     !pars(75)=0.00105_dp
<     !call getpars(pars,realpars)
<     !call objfunc(pars,qval) ; realpars=realpartemp       
<     !pars(75)=0.0011_dp
<     !call getpars(pars,realpars)
<     !call objfunc(pars,qval) ; realpars=realpartemp      
<     !pars(75)=0.00115_dp
<     !call getpars(pars,realpars)
<     !call objfunc(pars,qval) ; realpars=realpartemp      
<     !pars(75)=0.0012_dp
<     !call getpars(pars,realpars)
<     !call objfunc(pars,qval) ; realpars=realpartemp      
<     !pars(75)=0.00125_dp
<     !call getpars(pars,realpars)
<     !call objfunc(pars,qval) ; realpars=realpartemp      
<     !pars(75)=0.0013_dp
<     !call getpars(pars,realpars)
<     !call objfunc(pars,qval) ; realpars=realpartemp      
<     !pars(75)=0.00135_dp
<     !call getpars(pars,realpars)
<     !call objfunc(pars,qval) ; realpars=realpartemp      
<     !pars(75)=0.0014_dp
<     !call getpars(pars,realpars)
<     !call objfunc(pars,qval) ; realpars=realpartemp      
<     !pars(75)=0.00145_dp
<     !call getpars(pars,realpars)
<     !call objfunc(pars,qval) ; realpars=realpartemp      
<     !pars(75)=0.0015_dp
<     !call getpars(pars,realpars)
<     !call objfunc(pars,qval) ; realpars=realpartemp      
<     
<     
<     !march 23 2022
<     !M032322_1 
<     pars(75)=0.0015_dp
<     nonlabinc=0.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp          
<     nonlabinc=0.5_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=5.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp  
<     nonlabinc=10.0_dp
<     call getpars(pars,realpars)
---
> 
>     !m031722_4
>     pars(75)=0.001_dp
>     call getpars(pars,realpars)
>     call objfunc(pars,qval) ; realpars=realpartemp      
>     pars(75)=0.0015_dp
>     call getpars(pars,realpars)
>     call objfunc(pars,qval) ; realpars=realpartemp       
>     pars(75)=0.002_dp
>     call getpars(pars,realpars)
>     call objfunc(pars,qval) ; realpars=realpartemp      
>     pars(75)=0.0025_dp
>     call getpars(pars,realpars)
>     call objfunc(pars,qval) ; realpars=realpartemp      
>     pars(75)=0.003_dp
>     call getpars(pars,realpars)
>     call objfunc(pars,qval) ; realpars=realpartemp      
>     pars(75)=0.0035_dp
>     call getpars(pars,realpars)
>     call objfunc(pars,qval) ; realpars=realpartemp      
>     pars(75)=0.004_dp
>     call getpars(pars,realpars)
>     call objfunc(pars,qval) ; realpars=realpartemp      
>     pars(75)=0.0045_dp
>     call getpars(pars,realpars)
>     call objfunc(pars,qval) ; realpars=realpartemp      
>     pars(75)=0.005_dp
>     call getpars(pars,realpars)
912,935d858
<     nonlabinc=100.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=500.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=1000.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=2000.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=3000.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=4000.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=5000.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=6000.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
937a861
>    

ECLP022:migit ahu$ mv ./m031522/mig_main.f90 ./m031522/migmain032122.f90
ECLP022:migit ahu$ diff ./m030622/mig_params.f90 ./m031522/mig_params.f90 
19c19
< 	integer(i4b), parameter :: numit=12 !ahumarch1122
---
> 	integer(i4b), parameter :: numit=9 !ahumarch1122

WILL DELETE THE REST OF THE FILES IN M031522 (OTHER THAN MIGSOL AND MIGMAIN AND NO NEED FOR PARAMS) 
NOTE THAT I AM SAVING THE MIGMAIN IN M031522 AS MIGMAIN032122 TO BE CONSISTENT WITH THE MIGSOL THERE. 
WILL NOT DELETE DIRECTORY M031522 AND WILL KEEP ALL THESE FILES IN THERE (BUT DELETING THE SAME FIELS WHICH ARE MIG_FUNC , ETC.) 


COMPARING M030622 AND M032722CLUSTER DIRECTORIES
ECLP022:migit ahu$ diff ./m030622/getdecdec0-032322.f90 ./m032722cluster/getdecdec0-032722.f90 
ECLP022:migit ahu$ diff ./m030622/mig_share.f90 ./m032722cluster/mig_share.f90 
ECLP022:migit ahu$ diff ./m030622/mig_func.f90 ./m032722cluster/mig_func.f90 
ECLP022:migit ahu$ diff ./m030622/mig_yaz.f90 ./m032722cluster/mig_yaz.f90 
ECLP022:migit ahu$ diff ./m030622/mig_mom.f90 ./m032722cluster/mig_mom.f90 
ECLP022:migit ahu$ diff ./m030622/mig_objf.f90 ./m032722cluster/mig_objf.f90 
281c281
<         write(60,'(1a15,12f10.2)') parname(i),realpar_save(i,1:numit) !ahu030622
---
>         write(60,'(1a15,2f10.2)') parname(i),realpar_save(i,1:numit) !ahu030622
ECLP022:migit ahu$ 
ECLP022:migit ahu$ diff ./m030622/mig_params.f90 ./m032722cluster/mig_params.f90 
19c19
< 	integer(i4b), parameter :: numit=12 !ahumarch1122
---
> 	integer(i4b), parameter :: numit=2 !ahumarch1122
ECLP022:migit ahu$ diff ./m030622/gauher.f90 ./m032722cluster/gauher.f90 
ECLP022:migit ahu$ diff ./m030622/gauher_save.f90 ./m032722cluster/gauher_save.f90 
ECLP022:migit ahu$ diff ./m030622/indexx.f90 ./m032722cluster/indexx.f90 
ECLP022:migit ahu$ diff ./m030622/interpolate.f90 ./m032722cluster/interpolate.f90 
ECLP022:migit ahu$ diff ./m030622/getNB.f90 ./m032722cluster/getNB.f90 
ECLP022:migit ahu$ diff ./m030622/locate.f90 ./m032722cluster/locate.f90 
ECLP022:migit ahu$ diff ./m030622/read_data.f90 ./m032722cluster/read_data.f90 
ECLP022:migit ahu$ diff ./m030622/regression.f90 ./m032722cluster/regression.f90 
ECLP022:migit ahu$ diff ./m030622/SLgenlib.f90 ./m032722cluster/SLgenlib.f90 
ECLP022:migit ahu$ diff ./m030622/testran.f90 ./m032722cluster/testran.f90 
ECLP022:migit ahu$ diff ./m030622/sort2.f90 ./m032722cluster/sort2.f90 
ECLP022:migit ahu$ diff ./m030622/pNelder_mead_train.f90 ./m032722cluster/pNelder_mead_train.f90 
ECLP022:migit ahu$ diff ./m030622/pNelder_mead_hold.f90 ./m032722cluster/pNelder_mead_hold.f90 
ECLP022:migit ahu$ diff ./m030622/pNelder_mead_cluster040615.f90 ./m032722cluster/pNelder_mead_cluster040615.f90 
ECLP022:migit ahu$ diff ./m030622/alib.f90 ./m032722cluster/alib.f90 
ECLP022:migit ahu$ diff ./m030622/mig_xtramom.f90 ./m032722cluster/mig_xtramom.f90 
ECLP022:migit ahu$ diff ./m030622/mig_main.f90 ./m032722cluster/mig_main.f90 
900,933d899
<     nonlabinc=0.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp          
<     nonlabinc=0.5_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=5.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp  
<     nonlabinc=10.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=100.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=500.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=1000.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=2000.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=3000.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=4000.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=5000.0_dp
<     call getpars(pars,realpars)
<     call objfunc(pars,qval) ; realpars=realpartemp      
<     nonlabinc=6000.0_dp
935a902
>     
ECLP022:migit ahu$ diff ./m030622/mig_params_wait.f90 ./m032722cluster/mig_params_wait.f90 



DELETED THE ONES THAT ARE THE SAME




THINGS TO CHECK AND DECIDE: 

1add. REMEMBER TO CHECK NEPSMOVE AS WELL AS NONLABINC VALUES 

1. Where to put the if statement if ( maxval(qq2w(:,q0)) <= np1 ) then !state variable part of the q space i.e. w <= np1 (after the start of q0 loop or x0 loop?)
Need to check whether it makes a differences in runtime as well as in moments. 

2. ECLP022:migit ahu$ diff ./m030622/temp032322_2.f90 ./m031522/temp032122.f90 
190c190
<                     end if 
---
> 
Note that temp files are the /m030622/mig_sol032322_2 and /m031522/mig_sol032122.f90 files but until line 218
So teh above diff means that until line 218, the only difference is the end if statement on line 190. which needs to be commented or unc


3. The main differences between m030622/migsol032322_2.f90 and m031522/migsol032122.f90 are getdec_c (PLUS between lines 219 and 244 which are pretty much the same thing as the part in getdecc that is different but see above for more details) 
So I copied the getdec_c in the two files and saved them as getdec032322_2 and getdec032122. I will add them to one file later in order to test their outcome
But their main differences are simply the replacement of vdifs of the other longer calculations, moving of eps to the other side and commenting out of some logical alt statements and the calculation of transfers

4. Took out the getch_couple and get_dec and get_Dec0 of migsol032322 because those look different and later written. 
So I copied these and saved the new file as getchdecdec0032322.f90
The rest of that file (Line 1to467 and the lines after the end of get_dec0) do not look different to anything else that counts
You can check the rest later if you'd like a peace of mind. Everything is preserved under m030622/migsol032322.f90 
But for now we need to incorporate these getch_couple things as well as the difference getdec versions and choose one of them. 

So usually from the beginning of mig_Sol file until the end of the solve subroutine (end subroutine solve) usually the only difference between all these files is that part between line 219 and line 244. in migsol032322, there are also some differences that are due to writing of output when debugging around call get_dec0 in the solve subroutine but these can be ignored). 



5. The mig_sol in m030622 looks a little off. Not sure what date this corresponds to at all. But it's incomplete. The getdec_c starts in the middle fo the solve subroutine right after calling getdec_c. And inside getdec_c it seems all wrong, something that I tried that seems to eb wrong. 
But look at this getdec_c. Also look at the write statement that writes out something about the difference between testing etc. 

6. ECLP022:migit ahu$ diff ./m030622/getdecdec0-032322.f90 ./m032722cluster/getdecdec0-032722.f90 
There is no difference between the getdec subroutines in the migsol files named 032322 and 032722 (from the directories above) 
Most probably (since getdec getdec0 are the same) the rest of the migsol032322 adn mig_sol file in m032722cluster are also the same (other than the fact that migsol032322 also includes getch_couple but the other one does not). 
I won't bother checking this. 
Will copy getdecdec0-032722 onto m030622 directory in order to use it for incorporating all gender's in one file and choosing one of them. 


7. Using migsol032322.f90 as the base, I will now add all the different getdec and getch_couple subroutines to this file. 
in other words, I will copy and paste getdec032322_2.f90 
Not adding the others since getdecdec0-032722 is exactly the same as that in getdecdec0-032322 (which is from migsol032322)
and Not addingg getch_couple since that is also from migsol032322
Added also getdec_c from migsol032122 (as getdec032122) in directory m031522, which was the one that is close to getdec032322_2
which is why I am using that as base
NAme this file migsol082822.f90. In this file, rename getch_couple as getchcouple for now in order to prevent that subroutine being used for now. 
Replace call get_dec0 on line 161 with getdec032322_2 which is the original one (Sort of ). 

Now only work from this file (migsol082822). 
ALSO NEED TO LOOK AT MIG_SOL IN M030622. IT IS INCOMPLETE BUT IS THERE ANYTHING NEW OR DIFFERENT. GETCHCOUPLE OR GETDEC?


8. Need to incorporate getch_couple as well as choose one o the getdec subroutines 

Created m082822 directory in new cluster and copied the f90 files from m030622

ECLP022:migit ahu$ scp -i  ~/.ssh/zju64 ~/Dropbox/migit/m030622/*.f90   ahu@10.50.0.20:/home/ahu/m082822/
SLgenlib.f90                                                                                                                                       100%   53KB  58.0KB/s   00:00    
alib.f90                                                                                                                                           100%   25KB  74.2KB/s   00:00    
gauher.f90                                                                                                                                         100% 1331     4.3KB/s   00:00    
gauher_save.f90                                                                                                                                    100% 1331     4.3KB/s   00:00    
gauleg.f90                                                                                                                                         100% 1146     4.1KB/s   00:00    
getNB.f90                                                                                                                                          100% 3277    10.5KB/s   00:00    
getchcouple-032322.f90                                                                                                                             100% 8150    25.8KB/s   00:00    
getdec032322_2.f90                                                                                                                                 100%   12KB  40.2KB/s   00:00    
getdecdec0-032322.f90                                                                                                                              100%   17KB  51.0KB/s   00:00    
getdecdec0-032722.f90                                                                                                                              100%   17KB  63.0KB/s   00:00    
indexx.f90                                                                                                                                         100% 3466    11.1KB/s   00:00    
interpolate.f90                                                                                                                                    100% 7400    23.4KB/s   00:00    
locate.f90                                                                                                                                         100%  512     1.5KB/s   00:00    
mig_func.f90                                                                                                                                       100%   10KB  36.0KB/s   00:00    
mig_main.f90                                                                                                                                       100%   51KB 167.1KB/s   00:00    
mig_mom.f90                                                                                                                                        100%  117KB 379.8KB/s   00:00    
mig_objf.f90                                                                                                                                       100%   16KB  46.9KB/s   00:00    
mig_params.f90                                                                                                                                     100%   37KB 119.0KB/s   00:00    
mig_params_wait.f90                                                                                                                                100%   36KB 116.8KB/s   00:00    
mig_share.f90                                                                                                                                      100%   46KB 165.5KB/s   00:00    
mig_sol.f90                                                                                                                                        100%   47KB 155.9KB/s   00:00    
mig_xtramom.f90                                                                                                                                    100%   40KB 131.5KB/s   00:00    
mig_yaz.f90                                                                                                                                        100%   37KB 120.8KB/s   00:00    
migmain032322.f90                                                                                                                                  100%   50KB 164.3KB/s   00:00    
migsol032322.f90                                                                                                                                   100%   81KB 278.8KB/s   00:00    
migsol032322_2.f90                                                                                                                                 100%   64KB 226.7KB/s   00:00    
migsol082822.f90                                                                                                                                   100%  106KB 341.5KB/s   00:00    
migsolextras1032322.f90                                                                                                                            100%   10KB  30.1KB/s   00:00    
nr.f90                                                                                                                                             100%   84KB 270.9KB/s   00:00    
nrtype.f90                                                                                                                                         100% 1413     4.5KB/s   00:00    
nrutil.f90                                                                                                                                         100%   29KB  95.6KB/s   00:00    
pNelder_mead_cluster040615.f90                                                                                                                     100%   45KB 160.8KB/s   00:00    
pNelder_mead_hold.f90                                                                                                                              100%   42KB 151.7KB/s   00:00    
pNelder_mead_train.f90                                                                                                                             100%   36KB 108.6KB/s   00:00    
prog032122.f90                                                                                                                                     100%  559KB   1.0MB/s   00:00    
program.f90                                                                                                                                        100%  528KB   1.4MB/s   00:00    
read_data.f90                                                                                                                                      100%   11KB  38.0KB/s   00:00    
regression.f90                                                                                                                                     100%   10KB  34.3KB/s   00:00    
sort2.f90                                                                                                                                          100%  369     1.3KB/s   00:00    
temp032322_2.f90                                                                                                                                   100%   14KB  22.7KB/s   00:00    
temp1to467-m032322.f90                                                                                                                             100%   35KB  60.2KB/s   00:00    
tempbottom032322_2.f90                                                                                                                             100%   23KB  81.3KB/s   00:00    
testran.f90                                                                                                                                        100%  310     1.1KB/s   00:00    
ECLP022:migit ahu$ 
ECLP022:migit ahu$ scp -i  ~/.ssh/zju64 ~/Dropbox/migit/m030622/bp*.txt   ahu@10.50.0.20:/home/ahu/m082822/
bp040219_2.txt                                                                                                                                     100% 2511     8.3KB/s   00:00    
bp041019_3.txt                                     


ahu@zju64core:~$ cd m082822/
ahu@zju64core:~/m082822$ dir
alib.f90	 getchcouple-032322.f90  interpolate.f90    mig_objf.f90	 migsol082822.f90	  nrtype.f90			  program.f90	    temp1to467-m032322.f90
bp040219_2.txt	 getdec032322_2.f90	 locate.f90	    mig_params.f90	 migsolextras1032322.f90  nrutil.f90			  read_data.f90     tempbottom032322_2.f90
bp041019_3.txt	 getdecdec0-032322.f90	 mig_func.f90	    mig_params_wait.f90  mig_sol.f90		  pNelder_mead_cluster040615.f90  regression.f90    testran.f90
gauher.f90	 getdecdec0-032722.f90	 migmain032322.f90  mig_share.f90	 mig_xtramom.f90	  pNelder_mead_hold.f90		  SLgenlib.f90
gauher_save.f90  getNB.f90		 mig_main.f90	    migsol032322_2.f90	 mig_yaz.f90		  pNelder_mead_train.f90	  sort2.f90
gauleg.f90	 indexx.f90		 mig_mom.f90	    migsol032322.f90	 nr.f90			  prog032122.f90		  temp032322_2.f90
ahu@zju64core:~/m082822$ rm getch*.f90
ahu@zju64core:~/m082822$ rm getdec*.f90
ahu@zju64core:~/m082822$ rm migsolextras1032322.f90 
ahu@zju64core:~/m082822$ rm migsol032322*
ahu@zju64core:~/m082822$ rm mig_params_wait.f90 
ahu@zju64core:~/m082822$ rm migmain032322.f90 
ahu@zju64core:~/m082822$ rm prog*.f90
ahu@zju64core:~/m082822$ rm temp*.f90
ahu@zju64core:~/m082822$ dir
alib.f90	gauher_save.f90  interpolate.f90  mig_mom.f90	  migsol082822.f90  nr.f90			    pNelder_mead_hold.f90   SLgenlib.f90
bp040219_2.txt	gauleg.f90	 locate.f90	  mig_objf.f90	  mig_sol.f90	    nrtype.f90			    pNelder_mead_train.f90  sort2.f90
bp041019_3.txt	getNB.f90	 mig_func.f90	  mig_params.f90  mig_xtramom.f90   nrutil.f90			    read_data.f90	    testran.f90
gauher.f90	indexx.f90	 mig_main.f90	  mig_share.f90   mig_yaz.f90	    pNelder_mead_cluster040615.f90  regression.f90
ahu@zju64core:~/m082822$ 
ahu@zju64core:~/m082822$ rm gauher_save.f90 
ahu@zju64core:~/m082822$ cd .. 
ahu@zju64core:~$ cp /home/ahu/m030722c082322/compmig /home/ahu/m082822/
ahu@zju64core:~$ cp /home/ahu/m030722c082322/familymigpsid.txt /home/ahu/m082822/
ahu@zju64core:~$ 
ahu@zju64core:~$ 

WHEN TRIED TO COMPILE, GOT ERRORS I THINK RELATED TO GETCHCOUPLE IN MIGSOL082822. WILL REMOVE THAT SUBROUTINE FOR NOW. 
ADD THAT BACK ON LATER USING GETCHCOUPLE-032322.F90 

When that subroutine removed now everything is fine

Changed mig_main, objf, and params to have numit 2. 
Changed mig_params by commenting out print mumar(1)  marked by ahu082822 as well as august2022







082922  
migsol082822: In getdec_c0 added mg to the value functions. More specifically, when it was corner solutions, I was just adding transfers but not mar utility so now I corrected that
                vmarioj(1:2,j)=vecj(3:4,j)+transfers(1:2)  +  mg(z,trueindex)   !ag082922 agaugust2022            


Running migsol082822 with getdec032322_2: 



Running migsl082822 with detdec032122: 



The objective function value is slightly different. 
This must be mostly due to the fact that the main difference between these two versions is that I moved the eps to the other side of the inequality when calculating intsol in getdec (there are other differences such as using vdif in place of vec-vec in places etc. but eps must be the main thing that makes the difference. not the other things). 


Check if this is indeed the case

To check do the following in getdec032322_2:
                !temp intsol(1)=( vec(5) + eps >= abs(vdif(1)-vdif(2)) )  !interior
                !ahumarch2122 ahu032122 moving eps to the other side intsol(2)=( vec(5) + eps < vdif(1)-vdif(2)   )      !corner where c1=0 and c2=wsum
                !ahumarch2122 ahu032122 moving eps to the other side intsol(3)=( vec(5) + eps < vdif(2)-vdif(1)   )      !corner where c1=wsum and c2=0
                !temp intsol(2)=( vec(5) <= vdif(1)-vdif(2) + eps  )      !corner where c1=0 and c2=wsum !ahumarch2122 ahu032122 moving eps to the other side
                !temp intsol(3)=( vec(5) <= vdif(2)-vdif(1) + eps  )      !corner where c1=wsum and c2=0 !ahumarch2122 ahu032122 moving eps to the other side
                intsol(1)=( vec(5) + eps >= abs(vdif(1)-vdif(2)) )  !interior
                intsol(2)=( vec(5) + eps < vdif(1)-vdif(2)   )      !corner where c1=0 and c2=wsum
                intsol(3)=( vec(5) + eps < vdif(2)-vdif(1)   )      !corner where c1=wsum and c2=0


And call getec032322_2 in solve subroutine
To see if the objval will now be similar to when calling getdec032122
The output for this is out032322_2test mom032322_2test
The objval not the same as getdec032122 situation. Why?

Also note that I was compiling with bounds check until now so that's why the runtime has been longer


Adding the following to getdec032122 because it was omitted and there was no pc even though it was being used in the calculation of asum: 
pc(1:2)	= ( vdif + eps >= 0.0_dp ) !ag082922 agaugust2022 added back pc calculation. pc was being used in asum below but not being assigned any value due to the above commenting out!

asum = sum(  one(.not. pc)  *   abs( vdif )   ) 


CHECK. MAKE SURE PC ETC. ARE ALL CALCULATED IN THE NEW GETDEC. (GETDEC_C OR GETDEC_C0 ETC.) 

THINGS TO CHECK. THINGS TO CHECK. THINGS TO CHECK. 
WHICH SIDE SHOULD EPS GO ON. DOES IT MAKE A DIFFERENCE. 
DO WE NEED TO CHECK HAVEENOUGHTOMAKEINDIFF ETC. OR IS INTSOL ENOUGH OR SORT OF EQUIVALENT?
WHAT SHOULD BE THE VALUES FOR NONLABINC
WHAT SHOULD BE THE VALUE FOR NEPSMOVE. 
DONE - MAKE SURE GETDEC_C (WHICHEVER IS CHOSEN) AND THE MAR DECISIONS INSIDE SOLVE ARE CONSISTENT. 
MAKE SURE YOU CHANGE NZ FROM ONE TO SOMETHING HIGHER LATER.
MAKE SURE YOU CHECK GROUPS TRUE OR FALSE
GET RID OF SOME DECLARED VARIABLES THAT ARE NOT BEING USED ANYMORE IN SOL. 
MAKE SURE DD IS CONSISTENT ALL THROUGHOUT 
CHECK ALL THE YAZ'S TO MAKE SURE THEY ARE CONSISTENT WITH THE NEW DD SITUATIONS AND NEW CALLS
YAZ CHECKNB YAZ DECISION YAZMAX ETC 
Another check that needs to be done is to make sure that vmax=vec(3:4)+transfers(1:2) gives the same value as vmax=vec(1:2)+alf*surplus  


                                    !ag090122 agsept2022 turnining dd(7) to callfrom instead of gender since gender wasn't being used anyway 
                                    !ag090122 agsept2022 and using dd(8:11) for qm,qf,xm,xf
                                    !ag090122 agsept2022 dd = (/ ia,trueindex,q,x,z,q0,-1,-1,q,-1,-1 /) 	! (/ ia,index,q,x,z,q0,gender,jmax,qmax,relmax,iepsmove /)  	
                                                        ! g and q0 is just -1 here (/ ia,index,q,x,z,q0,gender,j,q,rel,iepsmove /) 
                                                        ! when in the marriage market, the index that corresponds 
                                                        ! to altq (i.e. i in yaz for example or dim 9 in dd) is just set to q since there is no altq in marriage market
                                    callfrom=10
                                    dd = (/ ia,trueindex,q,x,z,q0,callfrom,qm,qf,xm,xf /) 



CHECK THE FOLLOWING
m is well-defined meaning that there exists some allocation in the utility possibility set that is mutually beneficial
module sol
	use params
	use share
	use myaz
	implicit none
	real(sp) :: begintime,time(5)   
    real(dp), dimension(nqs,nxs) :: vm0_s,vf0_s
contains		
	subroutine solve
	real(dp) :: vec(5),vmax(2),val(2),vsum(2),vcheck(2)
	real(dp), dimension(nqs,nxs) :: vm_s,vf_s,prob_s


MAKE SURE CHEK THE FOLLOWING 
        qmax=ch(jmax,q,q0)
        relmax=1
        vmax(1:2)=vec(1:2)+0.5_dp*surplusj(jmax)
    else
        qmax=0
        relmax=0
        vmax(1:2)=vec(1:2)
    end if
    dd(8)=jmax
    dd(9)=qmax
    dd(10)=relmax 






ahu@zju64core:~/m082822$ vi out.txt 
ahu@zju64core:~/m082822$ vi out032322_2.txt 
ahu@zju64core:~/m082822$ vi out032322_2test.txt 
ahu@zju64core:~/m082822$ vi out032122.txt 


Now getdec032322_2 and getdec032122 give the same objval. As well as the test one 
where we ran with getdec032322_2 but with eps placed the same as getdec032122. 


Then ran with getdec_c0 which is the downhile one. 
Gives different objval and the same run time as others. So no time save. 


Changed in mig_params groups to false


090122 SEPT2022 
Tried to replace the calling of getdec_c in sol routine with checksit
but that seems to take slightly longer 
so went back to getdec_c
Moved checklist as well as everything that has to do with it to checksit.f90 (From migsol082822.f90)
Moved getdec032322_2 as well as getdec032122 all to checksit as well 
Created a subroutine called checkdecmar and moved some if statements for checking there (this is placed in migsol)

Note that in some of the new getdec, there are some redundancies, which I Will get rid of 

    !ii is the max of surplusj. 
    !check if that ii option is welldef and interior/corner
    !welldef ----> you have found your best ii and set jmax equal to that
    !not welldef ----> set surplusj(ii)=pen and update nn and go on to the next best ii 
    !
    jmax=-1 ; nn=0 !initiate jmax and the below do loop goes until this jmax is changed to a positive integer value
    if (maxval(surplusj)>0.0_dp) then 
    do while (jmax<0.and.nn<=nc+1.and.maxval(surplusj)>0.0_dp)
        !check if that max is well defined or not. if it is  then move on. if not then lookat the rest of the surplusj's. 
        !if (trueindex==1)   print*, "HEre it isat first",nn,jmax,surplusj(1:nc)

For example above, the maxval(surplus) statement is repeated twice. No need for this. 
And it's not clear if weldef is the appropriate term to use here for the surplus>0 condition


MAKE SURE DD IS CONSSITENT ALL THROUGHOUT
                                    !ag090122 agsept2022 turnining dd(7) to callfrom instead of gender since gender wasn't being used anyway 
                                    !ag090122 agsept2022 and using dd(8:11) for qm,qf,xm,xf
                                    !ag090122 agsept2022 dd = (/ ia,trueindex,q,x,z,q0,-1,-1,q,-1,-1 /) 	! (/ ia,index,q,x,z,q0,gender,jmax,qmax,relmax,iepsmove /)  	
                                                        ! g and q0 is just -1 here (/ ia,index,q,x,z,q0,gender,j,q,rel,iepsmove /) 
                                                        ! when in the marriage market, the index that corresponds 
                                                        ! to altq (i.e. i in yaz for example or dim 9 in dd) is just set to q since there is no altq in marriage market
                                    callfrom=10
                                    dd = (/ ia,trueindex,q,x,z,q0,callfrom,qm,qf,xm,xf /) 


090122 SEPT2022 CONTINUED 

1. IMPORTANT INSIGHT SITUATION TYPE DEAL
When creating getdec (which combines couples and singles decisions in sol routine), I had an error that basically shows that sometimes specifically
at age 50 (probably only at age 50) jmax=maxloc(surplusj,MASK=haveenough(:)) this jmax comes out to be 0 sometimes 
because there is basically no j such that have enough is TRUE. in other words, there are no options within marriage such that surplus is positive AND there 
is enough inctotales (w1+w2+nonlabinc1+nonlabinc2) to make enough transfers so that both parties at least indifferent to being married over single. 
This can happen if all surplusj elements are negative OR some are positive but there is not enough transfers to make marriage incentive combatible for both parties. 
See below for example. 
By the way, when a surplusj(j) is negative, note that this automatically also means that haveenoughj(j) is .FALSE. since in that case, we are not even talking about 
having enough transfers to give some of the surplus to either or both parties to make them at least indifferent to being married over single. In that case, there is just no surplus 
to be allocated period. So we don't even have to worry about whether we have the means to do any allocation (via transfers). 
See below for example. The was a situation where all surplusj's are negative (see the broken down elements for why) and therefore jmax turns out to be 0. 
If I just go onto using that jmax for array dimension (to get surplusj(jmax), vdifj(jmax) etc.) then I get an error. 

So then I corrected this by first assigning relmax according to where jmax>0 AND THEN I go onto calculating the transfers and max. 
For singles, we don't have to do any of this since there is no jmax to speak of in their case. 


 mysay,ia,trueindex            0          50           1
 jmax           0  -6492.1910269568198       -6492.1910269568198       -15923.981075689491       -19282.492720429891       -16843.506748661464       -7136.1139611717126       -16346.645609013422       -15711.631896078752       -11129.763059483987       -17858.243835633944       -6492.1910269568198       -6492.1910269568198       -1900.8680599622721       -1900.8680599622721       -99999999.000000000       -99999999.000000000       -99999999.000000000
 utilc,vm0_c
   3009.3035645586306        3009.3035645586306
 mg,movecosts
   374.99992968748063       -0.0000000000000000
 vecj3, vm0c+mg+movecosts
   3384.3034942461113        3384.3034942461113
 vec1
   6872.8776537644935
 vecj1,vecj3-vec1
  -3488.5741595183822       -3488.5741595183822
 utilc,vf0_c
   4898.2730824861446        4898.2730824861446
 mg,movecosts
   374.99992968748063       -0.0000000000000000
 vecj4, vf0c+mg+movecosts
   5273.2730121736249        5273.2730121736249
 vec2
   8276.8898796120629
 vecj2,vecj4-vec2
  -3003.6168674384380       -3003.6168674384380
 vecj5
   0.0000000000000000
 surplusj,vecj5+sum(vecj(1:2,1))
  -6492.1910269568198       -6492.1910269568198


2. Another check that needs to be done is to make sure that vmax=vec(3:4)+transfers(1:2) gives the same value as vmax=vec(1:2)+alf*surplus  


3. Changed mig_mom so that it calls getdec instead of getdec. marked by ag090122 and agsept2022

4. Changed nepsmove from 2 to 5 and nz from 1 to 5 . marked by  ag090122 and agsept2022

5. Also don't forget to decide on nonlabinc 
   Also don't forget to 


6. NOW TRYING WITH GROUPS=FALSE TO MAKE SURE WE GET THE SAME OBJVAL
   WAS GIVING AN ERROR BUT IT WENT AWAY AFTER I CHANGED IT SO THAT AT THE END OF MIGMAIN I CALL MPI FINALIZE EVEN IF NOT DOING GROUPS 

nohup mpirun -n 63 --use-hwthread-cpus /home/ahu/m032722c082222/mig.x > /home/ahu/m032722c082222/out.txt &

nohup mpirun -n 63 --use-hwthread-cpus /home/ahu/m090122/mig.x > /home/ahu/m090122/out.txt &

7. Changed something in mig_objf.f90 (commented out if groups in dividing moms by cntsim because i wasn't getting the right objval when groups FALSE even though 
the moments look the same as groups TRUE!
		!ag090122 agsept2022 when groups FALSE momsim's are not divided by cntsim so it gives weird objval so commenting this out 
		!ag090122 agsept2022 see above line for why commented out if (groups) then 
            if (calcvar(i)==0 .and. calcorr(i)==0 ) then
                if ( cntsim(i) > 0) then
				    momsim(i)=momsim(i)/cntsim(i)		!else ; simom(i)=0.0_dp  
                end if 
            else if (calcvar(i)==1) then 
                if ( cntsim(i) > 0) then
                    mutemp1=momsim(i)/cntsim(i)
                    mutemp2=momsim(i+1)/cntsim(i+1)
                    momsim(i)= mutemp1   
                    momsim(i+1)= mutemp2  - mutemp1**2
                end if 
            else if (calcorr(i)==1) then 
                if ( cntsim(i) > 0) then
                    mutemp1=momsim(i)/cntsim(i)
                    mutemp2=momsim(i+1)/cntsim(i+1)
                    mutemp3=momsim(i+2)/cntsim(i+2)
                    momsim(i)= mutemp1
                    momsim(i+1)= mutemp2                    
                    momsim(i+2)= mutemp3 - mutemp1 * mutemp2   
                end if
            end if
		!ag090122 agsept2022 end if 




8. 	IN MIG_MAIN: 
	!ag090122 agsept2022 if (groups) then 
	!ag090122 agsept2022 	call mpi_finalize(ierror)   
	!ag090122 agsept2022 end if 
    !ag090122 agsept2022 commenting out the aove groups if statment because 
    !I get mpi error when I run with groups FALSE saying some process couldnt finish because mpi finalze wasn't called etc.
    !since I invoke mpi regardless of groups, I have to call mpi finalize regardless of groups


9. 	
		!AG090122 AGSEPT2022
		!IF WANT TO COMPARE OBJVAL BETWEEN RUNS GROUPS=TRUE AND GROUPS=FALSE THEN 
		!NEED TO RUN GROUPS=TRUE WITH THE BELOW AND THEN GROUPS=FALSE WITH THE BELOW 
		!INSTEAD OF THE LATTER IF STATEMENT (RIGHT AFTER IT)
		!BECAUSE OTHERWISE WHEN GROUPS=FALSE, IT DOES NOT CALCULATE THE MOMENTS 
		!WITH CALCVAR=1 AND CALCORR=1 THE WAY THEY ARE CALCULATED WHEN GROUPS=TRUE 
		!(I.E. THE WAY THEY ARE CALCULATED WITHIN THE IF STATEMENT WITH MUTEMP'S)
		!BUT IF COMPARING IS NOT THE PURPOSE THEN WHEN GROUPS=TRUE, 
		!THE CALCVAR AND CALCORR MOMENTS NEED TO BE CALCULATED WIHT THOSE MUTEMP'S 
		!I AM NTO JUST GETTING RID OF THESE MOMENTS BECAUSE I NEED THEM (OR THINK SO)
		!if (groups) then 
        !        if ( cntsim(i) > 0) then
		!		    momsim(i)=momsim(i)/cntsim(i)		
        !        end if 
		!end if 
		if (groups) then 
            if (calcvar(i)==0 .and. calcorr(i)==0 ) then
                if ( cntsim(i) > 0) then
				    momsim(i)=momsim(i)/cntsim(i)		!else ; simom(i)=0.0_dp  
                end if 
            else if (calcvar(i)==1) then 
                if ( cntsim(i) > 0) then
                    mutemp1=momsim(i)/cntsim(i)
                    mutemp2=momsim(i+1)/cntsim(i+1)
                    momsim(i)= mutemp1   
                    momsim(i+1)= mutemp2  - mutemp1**2
					!ag090122 agsept2022 : 
					!IF THIS IS NOT COMMENTED OUT:
					!GROUPS TRUE AND FALSE They give the same moments so they should give same objval. 
					!But they don't give same objval mainly because of this calculation above. 
					!When groups false, the momsims dont need to be dividded by cntsims and all the momsims 
					!are already calculated the way they should be by getmom (when groups false).
					!So when groups false, we do not get in these calculations within the if (groups) statement above. 
					!In this if statement, some momsims are calculated with these mutemp's (when calcvar=1 and calcorr=1) (when groups true) 
					!so there is no way to this mutemp calculation when groups true. (for calcvar=1 and calcorr=1 cases)
					!so then instead of trying to figure out how to do the calcvar and calcorr calcuations for groups true
					!i just comment them out and compare objval to groups false. 
                end if 
            else if (calcorr(i)==1) then 
                if ( cntsim(i) > 0) then
                    mutemp1=momsim(i)/cntsim(i)
                    mutemp2=momsim(i+1)/cntsim(i+1)
                    mutemp3=momsim(i+2)/cntsim(i+2)
                    momsim(i)= mutemp1
                    momsim(i+1)= mutemp2                    
                    momsim(i+2)= mutemp3 - mutemp1 * mutemp2   
                end if 
            end if
		end if 


THE ABOVE IS SOMETHING YOU NEED TO WATCH OUT FOR. WHEN GROUPS TRUE, IT HAS THIS IF GROUPS STATEMENT AND AFTER THAT SOME MOMSIM'S ARE
CALCULATED BY DIVIDING BY CNTSIM AND SOME ARE CALCULATED DIFFERENTLY ACCORDINGLY TO CALCVAR AND CALCORR STUFF. 
WHEN GROUPS FALSE, THAT WHOLE CALCULATION DOES NOT TAKE PLACE BECAUSE OF THE IF GROUPS STATEMETN BEFORE IT. 
BUT THE SOLUTION IS NOT TO GET RID OF THE IF GROUPS STATEMENT BECAUSE WHEN GROUPS FALSE YOU DO NOT NEED TO 
DIVIDE MOMSIM BY CNTSIM BECAUSE THAT'S ALREADY DONE BEFORE AUTOMATICALLY IN GETMOM I THINK. 
 

10. TRIED WITH DIFFERENT NONLABINC AND MUMAR COMBO'S. DON'T SEEM TO MAKE MUCH DIFF. 

11. mar move rates are way too low. CHANGED NEPSMOVE TO 5

12. IN SHARE: BIG CHANGE 
	moveshock_m(:) = sqrt(2.0_dp) * sigo_m * abs3(:) + mu_o			! abscissas for marrige utility shock distribution
	moveshock_f(:) = sqrt(2.0_dp) * sigo_f * abs3(:) + mu_o			! abscissas for marrige utility shock distribution
    !if ((.not.chkstep).and.(.not.optimize) ) print*, "mg :", mg(:)
	!moveshock(:) = sqrt(2.0_dp) * sig_o * dble(abs3(:)) + mu_o			! abscissas for marrige utility shock distribution

 
    if (nepsmove==1) then 
        moveshock_m=0.0_dp
        moveshock_f=0.0_dp
    end if
    !ag090122 agsept2022 bshock_m=moveshock_m
    !ag090122 agsept2022 bshock_f=moveshock_f
	bshock_m=0.0_dp
	bshock_f=0.0_dp
    !moveshock_m=0.0_dp
    !moveshock_f=0.0_dp
    

    
13. WHEN I TRY TO WRITE SIGOM SIGOF IN MIG_PARAMS WHY IS IT WRITING OUT DIFFERENT VALUES EACH ROW IN OUT.TXT. DONE. COMMENTED OUT SOME REDUNDANT EXTRA GETPARS IN MAIN, 

14. WHY IS NEPSMOVE=5 GIVING DIFFERENT RESULTS COMPARED TO NEPSMOVE=2    DONE. NOT A PROBLEM. WAS NOT A PROBLEM IN THE FIRST PLACE .


15. NEED TO CHANGE GETCH COUPLE (MAYBE NOT) BUT LATER. 


16.     !ag090122 agsept2022 real(dp), parameter :: wtrans=50.0_dp,wwaged=50.0_dp,wdifww=50.0_dp,wrel=1.0_dp,wmove=10.0_dp,whour=1.0_dp,wwage=10.0_dp,wkid=1.0_dp,wmovemar=1.0_dp,wmovesin=1.0_dp,wwagebymove=1.0_dp		!ahu 121918 changed wmove to 10 from 1 and changed wmovemar from 10 to 100		! weights for moments for married couples. set in objfunc.
    !ag090122 agsept2022: increasing wmovemar to 100 because mar move rates are too low
    real(dp), parameter :: wtrans=50.0_dp,wwaged=50.0_dp,wdifww=50.0_dp,wrel=1.0_dp,wmove=10.0_dp,whour=1.0_dp,wwage=10.0_dp,wkid=1.0_dp,wmovemar=200.0_dp,wmovesin=1.0_dp,wwagebymove=1.0_dp		!ahu 121918 changed wmove to 10 from 1 and changed wmovemar from 10 to 100		! weights for moments for married couples. set in objfunc.


17 NEPSMOVE =3 NOW. SENT A OPT WITH THAT SITUATION. 

18. ALSO RUNNING SINGLES OPT WITH THE SAME EXACT SETUP.
ahu@zju64core:~$ cp /home/ahu/m090122/* /home/ahu/m090422/
ahu@zju64core:~$ cd m090422/
JUST CHANGED ONLYSINGLES TO TRUE IN MIG_PARAMS AND THE REST IS THE SAME AS 090122



ECLP022:m030622 ahu$ scp -i  ~/.ssh/zju64 ~/Dropbox/migit/m030622/mig_objf.f90   ahu@10.50.0.20:/home/ahu/m090522/
mig_objf.f90                                                                                                                                       100%   18KB  29.4KB/s   00:00    
ECLP022:m030622 ahu$ scp -i  ~/.ssh/zju64 ~/Dropbox/migit/m030622/migsol082822.f90   ahu@10.50.0.20:/home/ahu/m090122/
migsol082822.f90                                                                                                                                   100%   66KB  69.3KB/s   00:00    
ECLP022:m030622 ahu$ scp -i  ~/.ssh/zju64 ~/Dropbox/migit/m030622/mig_share.f90   ahu@10.50.0.20:/home/ahu/m090122/
mig_share.f90                                                                                                                                      100%   46KB  56.3KB/s   00:00    
ECLP022:m030622 ahu$ scp -i  ~/.ssh/zju64 ~/Dropbox/migit/m030622/mig_params.f90   ahu@10.50.0.20:/home/ahu/m090522/


090522
in mig_params: 
    integer(i4b), parameter :: nepsmove=2, nepskid=2 !ag090522 nepsmove 3 to 2 !ag090122 agsept2022 changed nepsmove frmo 2 to 5 !ahumarch1022 changed nepsmove to 2 from 13
AND
!ag090122 agsept2022 
    real(dp), parameter :: wtrans=50.0_dp,wwaged=50.0_dp,wdifww=50.0_dp,wrel=1.0_dp,wmove=10.0_dp,whour=1.0_dp,wwage=10.0_dp,wkid=1.0_dp,wmovemar=1.0_dp,wmovesin=1.0_dp,wwagebymove=1.0_dp		!ahu 121918 changed wmove to 10 from 1 and changed wmovemar from 10 to 100		! weights for moments for married couples. set in objfunc.
    !ag090122 agsept2022: increasing wmovemar to 100 because mar move rates are too low
    !ag090522 agsept2022 real(dp), parameter :: wtrans=50.0_dp,wwaged=50.0_dp,wdifww=50.0_dp,wrel=1.0_dp,wmove=10.0_dp,whour=1.0_dp,wwage=10.0_dp,wkid=1.0_dp,wmovemar=200.0_dp,wmovesin=1.0_dp,wwagebymove=1.0_dp		!ahu 121918 changed wmove to 10 from 1 and changed wmovemar from 10 to 100		! weights for moments for married couples. set in objfunc.
AND
Changed optimize to FALSE


in migsol082822:
in sol:
                                vsingtest(1:2)=valso(1:2) !ag090522 agsept2022

    real(dp) :: vsingtest(2) !ag090522 agsept2022
			print*, "mysay,ia,trueindex ",mysay,ia,trueindex !ahu 030622

			print*, "mysay,ia,trueindex ",iter,mysay,ia,trueindex !ahu 030622

in getdec:
            vec(1:2)=vsingtest(1:2) !vsing(1:2) ag090522 agsept2022



in mig_objf:
    print*, "iter,mysay,iwritegen",iter,mysay,iwritegen !ag090522 agsept2022



in mig_share:
moveshock(:) = sqrt(2.0_dp) * sig_o * dble(abs3(:)) + mu_o                     ! abscissas for marrige utility shock distribution
    if (nepsmove==1) then
        moveshock_m=0.0_dp
        moveshock_f=0.0_dp
    end if
    bshock_m=moveshock_m
    bshock_f=moveshock_f
    moveshock_m=0.0_dp
    moveshock_f=0.0_dp


    !moveshock(:) = sqrt(2.0_dp) * sig_o * dble(abs3(:)) + mu_o                     ! abscissas for marrige utility shock distribution^M
    if (nepsmove==1) then ^M
        moveshock_m=0.0_dp^M
        moveshock_f=0.0_dp^M
    end if^M
    !ag090122 agsept2022 bshock_m=moveshock_m^M
    !ag090122 agsept2022 bshock_f=moveshock_f^M
    bshock_m=0.0_dp^M
    bshock_f=0.0_dp^M
    !moveshock_m=0.0_dp^M
    !moveshock_f=0.0_dp^M



change it back to:
    if (nepsmove==1) then 
        moveshock_m=0.0_dp
        moveshock_f=0.0_dp
    end if
    !ag090122 agsept2022 bshock_m=moveshock_m
    !ag090122 agsept2022 bshock_f=moveshock_f
	bshock_m=0.0_dp
	bshock_f=0.0_dp
    !moveshock_m=0.0_dp
    !moveshock_f=0.0_dp



 in pNelder_mead
    g(irow,i) = p(i) + zero !ag090522 agsept2022 step(i)
among other things

MODULE pNelder_Mead
!ahu 010417: TOOK THIS FROM COHABITC/CLUSTER 040615. ONLY CHANGE FOR NOW WILL BE THE INCLUDE MPIF.H AND UNCOMMENTING OUT USE GLOBAL. 
!AND ALSO SOME CHANGED AT THE BEGINNING ABOUT HOW REALRANK IS OBTAINED (WAS EQUATING TO MYID BEFORE WHICH REQUIRED THE USE OF GLOBAL. 
!BUT NOW UNCOMMENTED OUT THE CALL MPI AT THE BEGINNING AND I OBTAIN REALRANK THAT WAY). 
use nrtype, only: dp
!use params !, only: mysay !use global  !, only: myid
!use mpi

IMPLICIT NONE
!INCLUDE 'mpif.h'
!ahu f14 putting this in the subroutine so that it does not clash with nrtype INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND(12, 60)
!PRIVATE
!PUBLIC :: pminim


in migmain:
    stepmin=0.0_dp !ag090522 agsept2022
    stepmin(1:30)=stepos(1:30) !ag090522 agept2022         



090622 SEPTEMBER 6 2022

 ~/.ssh/zju64 ~/Dropbox/migit/m030622/pNelder_mead_cluster040615.f90   ahu@10.50.0.20:/home/ahu/m090522/
 ~/.ssh/zju64  ahu@10.50.0.20:/home/ahu/m090122/*   ~/Dropbox/migit/m090622/ 


COPYING FILES FROM M090122 BECAUSE THOSE ARE ALL ORIGINAL FILES FROM M030622 (NO ALTERING WHEN DEBUGGIN IN THE FIRST WEEK OF SEPTEMBER)
ECLP022:migit ahu$ mkdir m090622
ECLP022:migit ahu$ scp -i  ~/.ssh/zju64  ahu@10.50.0.20:/home/ahu/m090122/*   ~/Dropbox/migit/m090622/ 
alib.f90                                                                                                                                           100%   25KB  45.9KB/s   00:00    
alib.mod                                                                                                                                           100%   40KB  64.1KB/s   00:00    
bestpar.txt                                                                                                                                        100% 2511     8.7KB/s   00:00    
bestval.txt                                                                                                                                        100% 4121    14.2KB/s   00:00    
bp040219_2.txt                                                                                                                                     100% 2511     8.7KB/s   00:00    
bp041019_3.txt                                                                                                                                     100% 2511     8.7KB/s   00:00    
chkobj.txt                                                                                                                                         100%   49KB 173.8KB/s   00:00    
compmig                                                                                                                                            100% 1273     3.2KB/s   00:00    
copumig                                                                                                                                            100%  193     0.7KB/s   00:00    
dursim1.txt                                                                                                                                        100% 3881KB 460.0KB/s   00:08    
familymigpsid.txt                                                                                                                                  100% 4587KB   1.5MB/s   00:02    
gauher.f90                                                                                                                                         100% 1331     4.6KB/s   00:00    
gauher_save.f90                                                                                                                                    100% 1331     4.6KB/s   00:00    
gauleg.f90                                                                                                                                         100% 1146     3.9KB/s   00:00    
getNB.f90                                                                                                                                          100% 3277    11.4KB/s   00:00    
hist                                                                                                                                               100%   29KB 100.4KB/s   00:00    
indexx.f90                                                                                                                                         100% 3466    12.2KB/s   00:00    
interpolate.f90                                                                                                                                    100% 7400    25.8KB/s   00:00    
locate.f90                                                                                                                                         100%  512     1.8KB/s   00:00    
mig_func.f90                                                                                                                                       100%   10KB  35.0KB/s   00:00    
mig_main.f90                                                                                                                                       100%   53KB 190.1KB/s   00:00    
migmom082822.f90                                                                                                                                   100%  117KB 318.4KB/s   00:00    
mig_mom.f90                                                                                                                                        100%  117KB 409.6KB/s   00:00    
mig_objf.f90                                                                                                                                       100%   18KB  47.3KB/s   00:00    
mig_params.f90                                                                                                                                     100%   37KB 132.8KB/s   00:00    
mig_params_wait.f90                                                                                                                                100%   36KB 126.5KB/s   00:00    
mig_share.f90                                                                                                                                      100%   46KB 163.2KB/s   00:00    
migsol082822.f90                                                                                                                                   100%   66KB 238.8KB/s   00:00    
migsol090122.f90                                                                                                                                   100%  104KB 366.3KB/s   00:00    
migsol090222.f90                                                                                                                                   100%   66KB 211.6KB/s   00:00    
mig_sol.f90                                                                                                                                        100%   47KB 162.6KB/s   00:00    
mig.x                                                                                                                                              100%  652KB   2.2MB/s   00:00    
mig_xtramom.f90                                                                                                                                    100%   40KB 118.8KB/s   00:00    
mig_yaz.f90                                                                                                                                        100%   37KB 130.1KB/s   00:00    
mom090522.txt                                                                                                                                      100%  365KB   1.2MB/s   00:00    
mom1.txt                                                                                                                                           100%  365KB   1.2MB/s   00:00    
momgrfalse.txt                                                                                                                                     100%  364KB   1.2MB/s   00:00    
momgroupsfalse.txt                                                                                                                                 100%  364KB   1.2MB/s   00:00    
momgroupstrue                                                                                                                                      100%  364KB   1.2MB/s   00:00    
momgrtrue.txt                                                                                                                                      100%  364KB   1.2MB/s   00:00    
mom.mod                                                                                                                                            100%   59KB 207.4KB/s   00:00    
momnonlabinc.txt                                                                                                                                   100% 1445KB   1.7MB/s   00:00    
mom.txt                                                                                                                                            100%  365KB   1.2MB/s   00:00    
myaz.mod                                                                                                                                           100%   58KB 201.6KB/s   00:00    
nodelist                                                                                                                                           100%   85     0.3KB/s   00:00    
nr.f90                                                                                                                                             100%   84KB 298.3KB/s   00:00    
nr.mod                                                                                                                                             100%   29KB 102.0KB/s   00:00    
nrtype.f90                                                                                                                                         100% 1413     4.9KB/s   00:00    
nrtype.mod                                                                                                                                         100% 1802     6.2KB/s   00:00    
nrutil.f90                                                                                                                                         100%   29KB 104.5KB/s   00:00    
nrutil.mod                                                                                                                                         100% 7802    26.6KB/s   00:00    
objf.mod                                                                                                                                           100%   59KB 208.4KB/s   00:00    
opt090522.txt                                                                                                                                      100%  581KB   1.9MB/s   00:00    
opt.txt                                                                                                                                            100% 4457KB   2.0MB/s   00:02    
out1.txt                                                                                                                                           100%   53KB 183.8KB/s   00:00    
outgrfalse.txt                                                                                                                                     100%  149KB 524.1KB/s   00:00    
outgroupsfalse.txt                                                                                                                                 100%  149KB 377.8KB/s   00:00    
outgroupstrue                                                                                                                                      100%   18KB  63.3KB/s   00:00    
outgrtrue.txt                                                                                                                                      100%   18KB  46.9KB/s   00:00    
outjmaxer.txt                                                                                                                                      100%   11KB  37.6KB/s   00:00    
outnonlabinc.txt                                                                                                                                   100% 1803     4.6KB/s   00:00    
out.txt                                                                                                                                            100% 3871    13.5KB/s   00:00    
outz5nepsmove5.txt                                                                                                                                 100%   18KB  63.0KB/s   00:00    
params.mod                                                                                                                                         100%   55KB 194.4KB/s   00:00    
pNelder_mead_cluster040615.f90                                                                                                                     100%   45KB 157.8KB/s   00:00    
pNelder_mead_hold.f90                                                                                                                              100%   42KB 122.0KB/s   00:00    
pnelder_mead.mod                                                                                                                                   100% 1872     6.5KB/s   00:00    
pNelder_mead_train.f90                                                                                                                             100%   36KB 116.1KB/s   00:00    
program.f90                                                                                                                                        100%  566KB   1.9MB/s   00:00    
read_data.f90                                                                                                                                      100%   11KB  38.7KB/s   00:00    
regression.f90                                                                                                                                     100%   10KB  37.4KB/s   00:00    
share.mod                                                                                                                                          100%   58KB 203.6KB/s   00:00    
SLgenlib.f90                                                                                                                                       100%   53KB 161.8KB/s   00:00    
sol.mod                                                                                                                                            100%   59KB 206.9KB/s   00:00    
sort2.f90                                                                                                                                          100%  369     1.3KB/s   00:00    
testran.f90                                                                                                                                        100%  310     1.1KB/s   00:00    
ECLP022:migit ahu$ rm *.mod
ECLP022:migit ahu$ rm mom*.txt
ECLP022:migit ahu$ rm chk*.txt
ECLP022:migit ahu$ rm out*.txt
ECLP022:migit ahu$ rm migsol09*
rm: migsol09*: No such file or directory
ECLP022:migit ahu$ cd m090622/
ECLP022:m090622 ahu$ rm *.mod
ECLP022:m090622 ahu$ rm mom*.txt
ECLP022:m090622 ahu$ rm chk*.txt
ECLP022:m090622 ahu$ rm out*.txt
ECLP022:m090622 ahu$ rm migsol09*
ECLP022:m090622 ahu$ dir
-bash: dir: command not found
ECLP022:m090622 ahu$ 
ECLP022:m090622 ahu$ ls -al
total 36128
drwxr-xr-x@  49 ahu  staff     1568 Sep  6 11:15 .
drwxr-xr-x@ 214 ahu  staff     6848 Sep  6 11:13 ..
-rwxr--r--@   1 ahu  staff    54745 Sep  6 11:13 SLgenlib.f90
-rwxr--r--@   1 ahu  staff    26056 Sep  6 11:12 alib.f90
-rw-r--r--@   1 ahu  staff     2511 Sep  6 11:12 bestpar.txt
-rw-r--r--@   1 ahu  staff     4121 Sep  6 11:12 bestval.txt
-rw-r--r--@   1 ahu  staff     2511 Sep  6 11:12 bp040219_2.txt
-rw-r--r--@   1 ahu  staff     2511 Sep  6 11:12 bp041019_3.txt
-rwxr--r--@   1 ahu  staff     1273 Sep  6 11:12 compmig
-rwxr--r--@   1 ahu  staff      193 Sep  6 11:12 copumig
-rw-r--r--@   1 ahu  staff  3974100 Sep  6 11:12 dursim1.txt
-rw-r--r--@   1 ahu  staff  4697484 Sep  6 11:12 familymigpsid.txt
-rwxr--r--@   1 ahu  staff     1331 Sep  6 11:12 gauher.f90
-rwxr--r--@   1 ahu  staff     1331 Sep  6 11:13 gauher_save.f90
-rwxr--r--@   1 ahu  staff     1146 Sep  6 11:13 gauleg.f90
-rwxr--r--@   1 ahu  staff     3277 Sep  6 11:13 getNB.f90
-rw-r--r--@   1 ahu  staff    29300 Sep  6 11:13 hist
-rwxr--r--@   1 ahu  staff     3466 Sep  6 11:13 indexx.f90
-rwxr--r--@   1 ahu  staff     7400 Sep  6 11:13 interpolate.f90
-rwxr--r--@   1 ahu  staff      512 Sep  6 11:13 locate.f90
-rwxr-xr-x@   1 ahu  staff   667696 Sep  6 11:13 mig.x
-rwxr--r--@   1 ahu  staff    10133 Sep  6 11:13 mig_func.f90
-rw-r--r--@   1 ahu  staff    54563 Sep  6 11:13 mig_main.f90
-rw-r--r--@   1 ahu  staff   119646 Sep  6 11:13 mig_mom.f90
-rw-r--r--@   1 ahu  staff    18414 Sep  6 11:13 mig_objf.f90
-rw-r--r--@   1 ahu  staff    38340 Sep  6 11:13 mig_params.f90
-rw-r--r--@   1 ahu  staff    36888 Sep  6 11:13 mig_params_wait.f90
-rwxr--r--@   1 ahu  staff    47440 Sep  6 11:13 mig_share.f90
-rw-r--r--@   1 ahu  staff    48477 Sep  6 11:13 mig_sol.f90
-rwxr--r--@   1 ahu  staff    41462 Sep  6 11:13 mig_xtramom.f90
-rwxr--r--@   1 ahu  staff    37922 Sep  6 11:13 mig_yaz.f90
-rw-r--r--@   1 ahu  staff   120121 Sep  6 11:13 migmom082822.f90
-rw-r--r--@   1 ahu  staff    67890 Sep  6 11:13 migsol082822.f90
-rw-r--r--@   1 ahu  staff   373190 Sep  6 11:13 momgroupstrue
-rw-r--r--@   1 ahu  staff       85 Sep  6 11:13 nodelist
-rwxr--r--@   1 ahu  staff    85678 Sep  6 11:13 nr.f90
-rwxr--r--@   1 ahu  staff     1413 Sep  6 11:13 nrtype.f90
-rwxr--r--@   1 ahu  staff    30176 Sep  6 11:13 nrutil.f90
-rw-r--r--@   1 ahu  staff  4563997 Sep  6 11:13 opt.txt
-rw-r--r--@   1 ahu  staff   594667 Sep  6 11:13 opt090522.txt
-rw-r--r--@   1 ahu  staff    18179 Sep  6 11:13 outgroupstrue
-rw-r--r--@   1 ahu  staff    46304 Sep  6 11:13 pNelder_mead_cluster040615.f90
-rwxr--r--@   1 ahu  staff    43094 Sep  6 11:13 pNelder_mead_hold.f90
-rw-r--r--@   1 ahu  staff    36590 Sep  6 11:13 pNelder_mead_train.f90
-rw-r--r--@   1 ahu  staff   579913 Sep  6 11:13 program.f90
-rwxr--r--@   1 ahu  staff    11273 Sep  6 11:13 read_data.f90
-rwxr--r--@   1 ahu  staff    10625 Sep  6 11:13 regression.f90
-rwxr--r--@   1 ahu  staff      369 Sep  6 11:13 sort2.f90
-rw-r--r--@   1 ahu  staff      310 Sep  6 11:13 testran.f90
ECLP022:m090622 ahu$ rm hist
ECLP022:m090622 ahu$ rm bestpar.txt 
ECLP022:m090622 ahu$ rm opt*
ECLP022:m090622 ahu$ rm outgroupstrue 
ECLP022:m090622 ahu$ rm momgroupstrue 
ECLP022:m090622 ahu$ rm pNelder_mead_*
ECLP022:m090622 ahu$ ls -al
total 23008
drwxr-xr-x@  40 ahu  staff     1280 Sep  6 11:16 .
drwxr-xr-x@ 214 ahu  staff     6848 Sep  6 11:13 ..
-rwxr--r--@   1 ahu  staff    54745 Sep  6 11:13 SLgenlib.f90
-rwxr--r--@   1 ahu  staff    26056 Sep  6 11:12 alib.f90
-rw-r--r--@   1 ahu  staff     4121 Sep  6 11:12 bestval.txt
-rw-r--r--@   1 ahu  staff     2511 Sep  6 11:12 bp040219_2.txt
-rw-r--r--@   1 ahu  staff     2511 Sep  6 11:12 bp041019_3.txt
-rwxr--r--@   1 ahu  staff     1273 Sep  6 11:12 compmig
-rwxr--r--@   1 ahu  staff      193 Sep  6 11:12 copumig
-rw-r--r--@   1 ahu  staff  3974100 Sep  6 11:12 dursim1.txt
-rw-r--r--@   1 ahu  staff  4697484 Sep  6 11:12 familymigpsid.txt
-rwxr--r--@   1 ahu  staff     1331 Sep  6 11:12 gauher.f90
-rwxr--r--@   1 ahu  staff     1331 Sep  6 11:13 gauher_save.f90
-rwxr--r--@   1 ahu  staff     1146 Sep  6 11:13 gauleg.f90
-rwxr--r--@   1 ahu  staff     3277 Sep  6 11:13 getNB.f90
-rwxr--r--@   1 ahu  staff     3466 Sep  6 11:13 indexx.f90
-rwxr--r--@   1 ahu  staff     7400 Sep  6 11:13 interpolate.f90
-rwxr--r--@   1 ahu  staff      512 Sep  6 11:13 locate.f90
-rwxr-xr-x@   1 ahu  staff   667696 Sep  6 11:13 mig.x
-rwxr--r--@   1 ahu  staff    10133 Sep  6 11:13 mig_func.f90
-rw-r--r--@   1 ahu  staff    54563 Sep  6 11:13 mig_main.f90
-rw-r--r--@   1 ahu  staff   119646 Sep  6 11:13 mig_mom.f90
-rw-r--r--@   1 ahu  staff    18414 Sep  6 11:13 mig_objf.f90
-rw-r--r--@   1 ahu  staff    38340 Sep  6 11:13 mig_params.f90
-rw-r--r--@   1 ahu  staff    36888 Sep  6 11:13 mig_params_wait.f90
-rwxr--r--@   1 ahu  staff    47440 Sep  6 11:13 mig_share.f90
-rw-r--r--@   1 ahu  staff    48477 Sep  6 11:13 mig_sol.f90
-rwxr--r--@   1 ahu  staff    41462 Sep  6 11:13 mig_xtramom.f90
-rwxr--r--@   1 ahu  staff    37922 Sep  6 11:13 mig_yaz.f90
-rw-r--r--@   1 ahu  staff   120121 Sep  6 11:13 migmom082822.f90
-rw-r--r--@   1 ahu  staff    67890 Sep  6 11:13 migsol082822.f90
-rw-r--r--@   1 ahu  staff       85 Sep  6 11:13 nodelist
-rwxr--r--@   1 ahu  staff    85678 Sep  6 11:13 nr.f90
-rwxr--r--@   1 ahu  staff     1413 Sep  6 11:13 nrtype.f90
-rwxr--r--@   1 ahu  staff    30176 Sep  6 11:13 nrutil.f90
-rw-r--r--@   1 ahu  staff   579913 Sep  6 11:13 program.f90
-rwxr--r--@   1 ahu  staff    11273 Sep  6 11:13 read_data.f90
-rwxr--r--@   1 ahu  staff    10625 Sep  6 11:13 regression.f90
-rwxr--r--@   1 ahu  staff      369 Sep  6 11:13 sort2.f90
-rw-r--r--@   1 ahu  staff      310 Sep  6 11:13 testran.f90
ECLP022:m090622 ahu$ rm bestval.txt 
ECLP022:m090622 ahu$ rm mig.x 
ECLP022:m090622 ahu$ rm dursim1.txt 
ECLP022:m090622 ahu$ rm gauher_save.f90 
ECLP022:m090622 ahu$ rm mig_params_wait.f90 
ECLP022:m090622 ahu$ rm mig_xtramom.f90 
ECLP022:m090622 ahu$ 



IN DIRECTORY M090622: 

1. In migobjf note that there was no "use share" before. I think that's because it uses sol which uses share already. 
check which one to do. 
for now just added use share to migobjf. 

2. with openmp, there is a line truncation problem so the modification of the files mostly have to do with making 
long lines shorter by splitting them up. 

3. check time variables 




090822 SEPTEMBER 8 2022

 ~/.ssh/zju64  ahu@10.50.0.20:/home/ahu/m090122/*   ~/Dropbox/migit/m090122/ 
In Dropbox/migit/m090122 deleted all the extra files (including extra f90s. if you need the older versions look at the older directories)

FROM NOW ON WILL USE DIRECTORY M090122 AS THE BASE. IF YOU NEED ANY OLD VERSIONS OF THINGS JUST LOOK AT THE DIRECTORY m090122 in the kg cluster


ECLP022:migit ahu$ cd m090122
ECLP022:m090122 ahu$ rm *
ECLP022:m090122 ahu$ cd .. 
ECLP022:migit ahu$ rmdir m090122

TOO CONFUSING


1. Tried with different wmovemar in m090122 iteration (wmovemar=200) because marriage move rates are too low
But this did not really help it seems 


2. Try with vsingtest 
declare vsingtest in module sol
put in mar market loop 
                                vsingtest(1:2)=valso(1:2) !ag090522 agsept2022

put in getdec market part 
            vec(1:2)=vsingtest(1:2) !vsing(1:2) ag090522 agsept2022


3. nepsmove and nz values 

4,     stepmin(1:30)=stepos(1:30) !ag090522 agept2022         



5. 
6735c6735
<     integer(i4b), parameter :: nepsmove=2, nepskid=2 !ag090522 nepsmove 3 to 2 !ag090122 agsept2022 changed nepsmove frmo 2 to 5 !ahumarch1022 changed nepsmove to 2 from 13
---
>     integer(i4b), parameter :: nepsmove=3, nepskid=2 !ag090122 agsept2022 changed nepsmove frmo 2 to 5 !ahumarch1022 changed nepsmove to 2 from 13
6766a6767
< 			print*, "mysay,ia,trueindex ",iter,mysay,ia,trueindex !ahu 030622
---
> 			!print*, "mysay,ia,trueindex ",mysay,ia,trueindex !ahu 030622
12719c12719
<     print*, "iter,mysay,iwritegen",iter,mysay,iwritegen !ag090522 agsept2022
---
>     
14087,14088c14087
<     stepmin=stepos !ahu 121118
<     stepmin(1:30)=stepos(1:30) !ag090522 agept2022         
---
>     stepmin=stepos !ahu 121118    



CHECKING THINGS IN DIRECTORY M030622C

There is still an optimization running in m090122.
kg cluster m090122 is as of today consistent with m030622 directory at dropbox. Checked this. 
ECLP022:migit ahu$ scp -i  ~/.ssh/zju64 ~/Dropbox/migit/m030622/*.f90   ahu@10.50.0.20:/home/ahu/m030622c/



senss timeline 
birkbeck city emails
annual rev upgrade 





TRYING VSINGTEST AGAIN
    real(dp) :: vsingtest(2) !ag090822 agsept2022
                                vsingtest(2)=valso(2) !ag090822


in migshare: 
    real(dp) :: vsingtest(2) !ag090822 agsept2022



090922 SEPT 9 2022

MIGSOLC in m030622c


opened directory m090922 in cluster
copied f90 files from m030622 from desktop
copied bp090122final from cluster m090122 iteration and directory 

in main: 
bp090122final.txt 

iwriteminim=30 from 1 IMPORTANT. DEL LATER. LOOK LATER. CHECK LATER. IMPORTANT. 

in params:
set ntypp=4 from 1 and first run an iteration with the original starting parameters 
and maybe compare to that with and without types and that with and without only singles
will do only singles

in objf:
    !print*, "iter,mysay,iwritegen",iter,mysay,iwritegen !ag090522 agsept2022





np=3
   66    1. wdif | stay                    0.0157        0.0281        0.0013        0.0000         502655     28890        0.1194
   66    2. wdif | stay                    0.0503        0.0281        0.0041        0.0029         502423     28890        0.1194
   67    1. wdif | move                    0.0757        0.0274        0.0118        0.0000            636       820        0.1972
   67    2. wdif | move                    0.1964        0.0274        0.1449        0.1331           2609       820        0.1972
   68    1. wdif | eue,s                   0.0157       -0.0924        0.0319        0.0000           1120       420        0.3666
   68    2. wdif | eue,s                   0.0785       -0.0924        0.0797        0.0478           1120       420        0.3666
   69    1. wdif | eue,m                   0.0499       -0.0782        0.0466        0.0000            106        21        0.3524
   69    2. wdif | eue,m                   0.0971       -0.0782        0.0872        0.0406            213        21        0.3524
   70    1. w|noed                         8.9665        9.7062        1.9918        0.0000         292990     15304        0.2747
   70    2. w|noed                         9.6328        9.7062        0.0196       -1.9722         293129     15304        0.2747
   71    1. wvar|noed                      0.0302        0.2747        0.0006        0.0000         292990     15304      101.0594
   71    2. wvar|noed                      0.2583        0.2747        0.0000       -0.0006         293129     15304      101.0594
   72    1. w|  ed                         9.3458       10.0473        1.4330        0.0000         241162     17497        0.3435
   72    2. w|  ed                         9.9927       10.0473        0.0087       -1.4244         241902     17497        0.3435
   73    1. wvar|ed                        0.0313        0.3435        0.0007        0.0000         241162     17497      137.4002
   73    2. wvar|ed                        0.2745        0.3435        0.0000       -0.0007         241902     17497      137.4002
   


   31    1. wdif | hmemve=0                0.3698        0.0364        0.0000        0.0000           9425       558        0.2041
   31    2. wdif | hmemve=0                0.3235        0.0364        0.0000        0.0000           6449       558        0.2041
   32    1. wdif | hmemve=1                0.0110        0.0082        0.0000        0.0000           1775       262        0.1821
   32    2. wdif | hmemve=1               -0.0165        0.0082        0.0000        0.0000           1419       262        0.1821
   33    1. wdif | stay                    0.0402        0.0281        0.0615        0.0000         446829     28890        0.1194
   33    2. wdif | stay                    0.0378        0.0281        0.0399       -0.0216         459917     28890        0.1194
   34    1. wdif2 | stay                   0.0115        0.1194        3.7640        0.0000         446829     28890        0.1547
   34    2. wdif2 | stay                   0.0096        0.1194        3.9002        0.1362         459917     28890        0.1547
   35    1. wdif | move                    0.3129        0.0274       20.6730        0.0000          11200       820        0.1972
   35    2. wdif | move                    0.2622        0.0274       13.9815       -6.6914           7868       820        0.1972
   36    1. wdif2 | move                   0.0873        0.1972        3.7933        0.0000          11200       820        0.1594
   36    2. wdif2 | move                   0.0785        0.1972        4.4187        0.6254           7868       820        0.1594
   37    1. wdif | eue,s                  -0.1838       -0.0924        1.1403        0.0000           8682       420        0.3666
   37    2. wdif | eue,s                  -0.1605       -0.0924        0.6328       -0.5074           7033       420        0.3666
   38    1. wdif2 | eue,s                  0.1201        0.3666        6.0709        0.0000           8682       420        0.5006
   38    2. wdif2 | eue,s                  0.0946        0.3666        7.3917        1.3207           7033       420        0.5006
   39    1. wdif | eue,m                  -0.1667       -0.0782        1.1104        0.0000           1094        21        0.3524
   39    2. wdif | eue,m                  -0.1349       -0.0782        0.4556       -0.6548            837        21        0.3524
   40    1. wdif2 | eue,m                  0.1433        0.3524        5.9153        0.0000           1094        21        0.3693
   40    2. wdif2 | eue,m                  0.1058        0.3524        8.2297        2.3144            837        21        0.3693
   41    1. w|noed                         9.6842        9.7062        0.0177        0.0000         274624     15304        0.2747
   41    2. w|noed                         9.6559        9.7062        0.0924        0.0






When nepsmove is 1 or sigo is 0, then the objval is very jumpy like to 1000's becasue then some people jsut don't go to some of the locations and then 
there is no emp or wage conditional on those locations



NOTE NOW I HAVE OJT BACK
NOTE NOT ITERATING ON: 
psih(2)
ECST 
KCST
ALPHAED BY ED 
ANYMORE 

!ahu jan19 012419: not iterating the below anymore 
psih(2)=0.0_dp
ECST=0.0_DP
kcst=0.0_dp
alphaed(:,2)=alphaed(:,1)



091122 September 11 2022
Stopped the singles iteration in m090922 (which was with ntypp=4) and saved output as opt090922 etc.
And sent another job which is the same as before except I Changed the below: 
    tstart=0.4_dp*qval !ag091122 agsept2022 changing thermsimp value !0.0_dp !*qval !10.0_dp !
    tstep=0.4_dp  !ag091122 agsept2022 changing tstep value !0.0_dp !0.7_dp !0.8_dp
    tfreq=2*COUNT(stepmin /= zero) !ag091122 agsept2022 changing tfreq value







091222 SEPTEMBER 12 2022

Cleaning the directories
ECLP022:m030622 ahu$ diff gauher.f90 gauher_save.f90 
ECLP022:m030622 ahu$ 
So delete all gauher_save in directories as well as other unused f90 files

Deleted all other extra files in m030622 (which was checked to be consistent and same as m090122 in kgcluster which has the last couples optimization with ntypp=1.
Moved them to a new directory named misc091222

Then created a new directory in /Dropbox/migrepo and started using Gitkraken





091322/091422 SEPTEMBER 13/14 2022 
Changed indices of vm0_c,vf0_c,wc for loop optimization inside sol 

------------
OPTIMIZAITON TIPS STAR INSIGHT STAR INSIGHT (all of the below can be found in m090122cc) 
-----------
The original runtime was 166.98/195.75

See the below loop that is inside sol within the q0 loop (after index and ia)
The innermost loop here is x0 but emax first dim is q0.

			do x0=1,nx
                        if ( maxval(qq2w(:,q0)) <= np1 ) then !state variable part of the q space i.e. w <= np1
				!prob=matmul( reshape(ppcq(:,q0,x0),(/nq,1/)) , reshape(ppcx(:,q0,x0),(/1,nx/)) )
				!emaxm_c(q0,x0,ia)=sum(prob*vm_c)
				!emaxf_c(q0,x0,ia)=sum(prob*vf_c)                    
	                         emaxm_c(q0,x0,ia)=0.0_dp
				emaxf_c(q0,x0,ia)=0.0_dp
                            do q=1,nq
                                do x=1,nx
				emaxm_c(q0,x0,ia)=emaxm_c(q0,x0,ia)+ppcq(q,q0,x0)*ppcx(x,q0,x0)*vm_c(q,x)
				emaxf_c(q0,x0,ia)=emaxf_c(q0,x0,ia)+ppcq(q,q0,x0)*ppcx(x,q0,x0)*vf_c(q,x)
                                end do 
                            end do 
                        end if !state variable part of the q space i.e. w <= np1
			end do	 !x0						

So I changed the emax dims to x0,q0 instead. So now that loop is:
                            do q=1,nq
                            do x=1,nx
                            do x0=1,nx
                                emaxm_c(x0,q0,ia)=emaxm_c(x0,q0,ia)+probmuq(x0,q,q0)*probmux(x0,x,q0)*vm_c(x,q)
				emaxf_c(x0,q0,ia)=emaxf_c(x0,q0,ia)+probmuq(x0,q,q0)*probmux(x0,x,q0)*vf_c(x,q)
                            end do 
                            end do 
                            end do	 				

and the new runtime became 155.50/180.64
------------------------------------------
Then I also did the following: 

After changing the emax dims, I also had to change the v0c and other dims. 
after doing this now in getdec, within the choice j loop we got
do j=1,nj
i=ch(j ...) ---> is the q counterpart of choice j
......
vecj(3,.)=vm0_c(x,i,ia,index) + mar + move etc. 
vecj(4,.)=vf0_c(x,i,ia,index) + mar + move etc. 
wc(1,x,i,trueindex) + wc(2,x,i,trueindex) + nonlabinc + nonlabinc 
.......
end do 
The dims are x,i rather than i,x because I had to change emax dims to i,x 
(and therefore also had to change dims of v0c's and the rest) 
This was for opt purposes within sol. 
But that was not very good for the above illustrated loop within getdec which goes
through j (i.e. q). 
So I declared new variables called
v0ctemp and wctemp and then assigning them 
the v0c and wc values within sol before the start of q0 loop in sol by the following: 
                !for loop opt 
                do q=1,nq
                    do x=1,nx
                        vm0ctemp(q,x,ia,index)=vm0_c(x,q,ia,index) ---> NOTE THAT V0CTEMP HAS TO HAVE INDEX AS DIM NOT FOR SOL BUT FOR SIMULATION (FOR WHEN GROUPS=TRUE) STAR INSIGHT 
                        vf0ctemp(q,x,ia,index)=vf0_c(x,q,ia,index) 
                        wmctemp(q,x,trueindex)=wc(1,x,q,trueindex)
                        wfctemp(q,x,trueindex)=wc(2,x,q,trueindex)
                    end do
		end do 
v0ctemp and wctemp have (i,x) dimensions rather than (x,i) and they are 
assigned the v0c and wc values by the above loop within sol before q0 loop
Then in getdec, they replace v0c and wc. 
do j=1,nj
i=ch(j ...) ---> is the q counterpart of choice j
......
vecj(3,.)=vm0ctemp(i,x,ia,index) + mar + move etc. 
vecj(4,.)=vf0ctemp(i,x,ia,index) + mar + move etc. 
wmctemp(i,x,...+wfctemp+nonlabinc+nonlabinc
.......
end do 
This did not save additional time. Now the runtime became 156.76/182.14 
--------------------------------------
BUT then I got rid of the ia,index dim in vm0ctemp. 
THIS DID save some time 
In other words, I replaced the loop within sol with: 
                do q=1,nq
                    do x=1,nx
                        vm0ctemp(q,x)=vm0_c(x,q,ia,index) 
                        vf0ctemp(q,x)=vf0_c(x,q,ia,index) 
                        wmctemp(q,x,trueindex)=wc(1,x,q,trueindex)
                        wfctemp(q,x,trueindex)=wc(2,x,q,trueindex)
                    end do 
		end do 
And the loop within getdec with: 
do j=1,nj
i=ch(j ...) ---> is the q counterpart of choice j
......
vecj(3,.)=vm0ctemp(i,x) + mar + move etc. 
vecj(4,.)=vf0ctemp(i,x) + mar + move etc. 
wmctemp(i,x,...+wfctemp+nonlabinc+nonlabinc
.......
end do 
Run time with 4 types and nepsmove=3 and nz=1 became 143.55/169.54
Not sure why exactly though. 
-----------------------------
To check whether and why ia,index makes such a difference I did a run with 
no emax dim change (i.e. emax(q,x ,ia) as before
just assigning v0ctemp(q,x) to v0c(q,x,ia,index) within sol and then using v0ctemp in getdec
So nothing about the x dim being at the first dim for any array 
and the only difference is literally just the assignment of v0ctemp(q,x) with no ia,index and using that within getdec instead of v0c(q,x,ia,index) 
The runtime of this (test0) was 159/183.62

     		do q=1,nq
                    do x=1,nx
                        vm0ctemp(q,x)=vm0_c(q,x,ia,index)
                        vf0ctemp(q,x)=vf0_c(q,x,ia,index)
                        !wmctemp(q,x,trueindex)=wc(1,q,x,trueindex)
                        !wfctemp(q,x,trueindex)=wc(2,q,x,trueindex)
                    end do
                end do


                 if (callfrom==40) then !calling from sol
                    vecj(3,j) = vm0ctemp(i,x)  + mg(z,trueindex) + one( locch /= loc0 ) * (mcost(1) + moveshock_m(iepsmove) ) !ahumarch2022 ahu032022     
                    vecj(4,j) = vf0ctemp(i,x)  + mg(z,trueindex) + one( locch /= loc0 ) * (mcost(2) + moveshock_f(iepsmove) ) !ahumarch2022 ahu032022
                    !vecj(5,j) = wmctemp(i,x,trueindex) + wc(2,i,x,trueindex) + nonlabinc(ed(1)) + nonlabinc(ed(2)) 
                    else if (callfrom==80) then !calling from simulation
                    vecj(3,j) = vm0_c(i,x,ia,index)  + mg(z,trueindex) + one( locch /= loc0 ) * (mcost(1) + moveshock_m(iepsmove) ) !ahumarch2022 ahu032022     
                    vecj(4,j) = vf0_c(i,x,ia,index)  + mg(z,trueindex) + one( locch /= loc0 ) * (mcost(2) + moveshock_f(iepsmove) ) !ahumarch2022 ahu032022
                    !vecj(5,j) = wc(1,i,x,trueindex) + wc(2,i,x,trueindex) + nonlabinc(ed(1)) + nonlabinc(ed(2)) 
                end if

(with or without wctemp doesn't make a difference)
So it is the emax dim change that saves time and then on top of that the getting rid of ia,index that saves time
They both save the same amount of time separately (around 10-15 seconds) and when combined (with x dims at the beginning)
they save 20-25 seconds. 
so that the runtime becomes (test3) 143.55/169.54
---------------------------
A summary of the above runtimes:


before emaxindexchange-start:    original
iter,obj:      1             2367.17        166.98          0.38         17.81
run time:         195.75


emaxindexchange-end: (this is also before the opt of v0ctemp,wctemp dims)     test1
iter,obj:      1             2367.17        155.50          0.36         18.08
run time:         180.64


v0wctempdimchange=end: (this is also before the opt of v0wctempnoianoindex )     test2
iter,obj:      1             2367.17        156.76          0.38         18.12
run time:         182.14


v0wctempnoianoindex-end     test3
iter,obj:      1             2367.17        143.55          0.37         17.58
run time:         169.54


v0ctempnoianoindex but no emax dim change and just wctemp in loop in sol (without putting it in getdec)    test0
I don't think wctemp stuff makes any difference at all anyway 
iter,obj:      1             2367.17        159.00          0.37         17.82
run time:         183.62

--------------------


091422 SEPTEMBER 14 2022
The version with saved time (emax dim change and v0ctemp with no ia/index) is commit 03727a (test3 above)



092022 SEPTEMBER 20 2022 

m090922 optimization processing
ran with singles ntypp=4 and no therm ----> bp090922
ran with singles ntypp=4 with therm as well ----> bp090922therm

Then made a moments file for singles as well as couples where I compare: 
bp041019_3
bp090922
bp090922therm

This comparison moments file is mcomp090922singles and mcomp090922couples
Ran this comparison in migrepo
If you compare the wdif move's they decreased a lot especially from bp041019_3 to bp090922
So then I tried to see what parameter change was most responsible for this
These runs are commit
It is sig_wge
sig_wge has decreased for both genders (not even that much) and that led to a decrease in wdif move




Looking at wage dif moment comparisons between the above parameters:
First one is bp041019_3 and then bp090922 and then bp090922therm 
mcomp090922singles MALES: 
   31    1. wdif | hmemve=0                0.3698        0.0364        0.0000        0.0000           9425       558        0.2041
   31    2. wdif | hmemve=0                0.2670        0.0364        0.0000        0.0000           6024       558        0.2041
   31    3. wdif | hmemve=0                0.3141        0.0364        0.0000        0.0000           6933       558        0.2041
   32    1. wdif | hmemve=1                0.0110        0.0082        0.0000        0.0000           1775       262        0.1821
   32    2. wdif | hmemve=1                0.0237        0.0082        0.0000        0.0000           1691       262        0.1821
   32    3. wdif | hmemve=1               -0.0457        0.0082        0.0000        0.0000           1649       262        0.1821
   33    1. wdif | stay                    0.0402        0.0281        0.0615        0.0000         446829     28890        0.1194
   33    2. wdif | stay                    0.0359        0.0281        0.0261       -0.0354         470814     28890        0.1194
   33    3. wdif | stay                    0.0367        0.0281        0.0312       -0.0303         456502     28890        0.1194
   34    1. wdif2 | stay                   0.0115        0.1194        3.7640        0.0000         446829     28890        0.1547
   34    2. wdif2 | stay                   0.0086        0.1194        3.9701        0.2061         470814     28890        0.1547
   34    3. wdif2 | stay                   0.0099        0.1194        3.8803        0.1163         456502     28890        0.1547
   35    1. wdif | move                    0.3129        0.0274       20.6730        0.0000          11200       820        0.1972
   35    2. wdif | move                    0.2137        0.0274        8.7995      -11.8734           7715       820        0.1972
   35    3. wdif | move                    0.2449        0.0274       11.9974       -8.6756           8582       820        0.1972
   36    1. wdif2 | move                   0.0873        0.1972        3.7933        0.0000          11200       820        0.1594
   36    2. wdif2 | move                   0.0749        0.1972        4.6930        0.8996           7715       820        0.1594
   36    3. wdif2 | move                   0.0800        0.1972        4.3139        0.5206           8582       820        0.1594
   37    1. wdif | eue,s                  -0.1838       -0.0924        1.1403        0.0000           8682       420        0.3666
   37    2. wdif | eue,s                  -0.1613       -0.0924        0.6482       -0.4921           4810       420        0.3666
   37    3. wdif | eue,s                  -0.1648       -0.0924        0.7147       -0.4255           7204       420        0.3666
   38    1. wdif2 | eue,s                  0.1201        0.3666        6.0709        0.0000           8682       420        0.5006
   38    2. wdif2 | eue,s                  0.0845        0.3666        7.9517        1.8807           4810       420        0.5006
   38    3. wdif2 | eue,s                  0.0940        0.3666        7.4221        1.3512           7204       420        0.5006
   39    1. wdif | eue,m                  -0.1667       -0.0782        1.1104        0.0000           1094        21        0.3524
   39    2. wdif | eue,m                  -0.1487       -0.0782        0.7048       -0.4056            605        21        0.3524
   39    3. wdif | eue,m                  -0.1442       -0.0782        0.6170       -0.4934            936        21        0.3524
   40    1. wdif2 | eue,m                  0.1433        0.3524        5.9153        0.0000           1094        21        0.3693
   40    2. wdif2 | eue,m                  0.1044        0.3524        8.3227        2.4074            605        21        0.3693
   40    3. wdif2 | eue,m                  0.1139        0.3524        7.7000        1.7847            936        21        0.3693


I tried changing different parameter values from bp041019_3 to bp090922 
All the others (including uloc or other wage parameters or psio or psih) did not give the above changes
But when I changed 66:69 one by one, then I got the whiff changes as above (slightly less but mostly)

Below, the first run is bo041019_3 
The second run is all the same parameters except sigwge(1) is lower 
The third run i all the same parameters except sigwge(2) is lower 
The fourth run is all the same parameters except sigom 
The fifth run is all the same parameters except sigof 


mcomp66t69
   31    1. wdif | hmemve=0                0.3698        0.0364        0.0000        0.0000           9425       558        0.2041
   31    2. wdif | hmemve=0                0.3064        0.0364        0.0000        0.0000           7065       558        0.2041
   31    3. wdif | hmemve=0                0.3678        0.0364        0.0000        0.0000           9480       558        0.2041
   31    4. wdif | hmemve=0                0.3698        0.0364        0.0000        0.0000           9425       558        0.2041
   31    5. wdif | hmemve=0                0.3698        0.0364        0.0000        0.0000           9425       558        0.2041
   32    1. wdif | hmemve=1                0.0110        0.0082        0.0000        0.0000           1775       262        0.1821
   32    2. wdif | hmemve=1               -0.0073        0.0082        0.0000        0.0000           1619       262        0.1821
   32    3. wdif | hmemve=1                0.0100        0.0082        0.0000        0.0000           1786       262        0.1821
   32    4. wdif | hmemve=1                0.0110        0.0082        0.0000        0.0000           1775       262        0.1821
   32    5. wdif | hmemve=1                0.0110        0.0082        0.0000        0.0000           1775       262        0.1821
   33    1. wdif | stay                    0.0402        0.0281        0.0615        0.0000         446829     28890        0.1194
   33    2. wdif | stay                    0.0379        0.0281        0.0404       -0.0211         448752     28890        0.1194
   33    3. wdif | stay                    0.0402        0.0281        0.0614       -0.0001         446770     28890        0.1194
   33    4. wdif | stay                    0.0402        0.0281        0.0615        0.0000         446829     28890        0.1194
   33    5. wdif | stay                    0.0402        0.0281        0.0615        0.0000         446829     28890        0.1194
   34    1. wdif2 | stay                   0.0115        0.1194        3.7640        0.0000         446829     28890        0.1547
   34    2. wdif2 | stay                   0.0093        0.1194        3.9239        0.1599         448752     28890        0.1547
   34    3. wdif2 | stay                   0.0115        0.1194        3.7640        0.0000         446770     28890        0.1547
   34    4. wdif2 | stay                   0.0115        0.1194        3.7640        0.0000         446829     28890        0.1547
   34    5. wdif2 | stay                   0.0115        0.1194        3.7640        0.0000         446829     28890        0.1547
   35    1. wdif | move                    0.3129        0.0274       20.6730        0.0000          11200       820        0.1972
   35    2. wdif | move                    0.2479        0.0274       12.3299       -8.3430           8684       820        0.1972
   35    3. wdif | move                    0.3111        0.0274       20.4003       -0.2727          11266       820        0.1972
   35    4. wdif | move                    0.3129        0.0274       20.6730        0.0000          11200       820        0.1972
   35    5. wdif | move                    0.3129        0.0274       20.6730        0.0000          11200       820        0.1972
   36    1. wdif2 | move                   0.0873        0.1972        3.7933        0.0000          11200       820        0.1594
   36    2. wdif2 | move                   0.0723        0.1972        4.8961        1.1028           8684       820        0.1594
   36    3. wdif2 | move                   0.0878        0.1972        3.7532       -0.0401          11266       820        0.1594
   36    4. wdif2 | move                   0.0873        0.1972        3.7933        0.0000          11200       820        0.1594
   36    5. wdif2 | move                   0.0873        0.1972        3.7933        0.0000          11200       820        0.1594
   37    1. wdif | eue,s                  -0.1838       -0.0924        1.1403        0.0000           8682       420        0.3666
   37    2. wdif | eue,s                  -0.1403       -0.0924        0.3129       -0.8274           8714       420        0.3666
   37    3. wdif | eue,s                  -0.1840       -0.0924        1.1453        0.0050           8680       420        0.3666
   37    4. wdif | eue,s                  -0.1838       -0.0924        1.1403        0.0000           8682       420        0.3666
   37    5. wdif | eue,s                  -0.1838       -0.0924        1.1403        0.0000           8682       420        0.3666
   38    1. wdif2 | eue,s                  0.1201        0.3666        6.0709        0.0000           8682       420        0.5006
   38    2. wdif2 | eue,s                  0.0848        0.3666        7.9324        1.8614           8714       420        0.5006
   38    3. wdif2 | eue,s                  0.1202        0.3666        6.0673       -0.0037           8680       420        0.5006
   38    4. wdif2 | eue,s                  0.1201        0.3666        6.0709        0.0000           8682       420        0.5006
   38    5. wdif2 | eue,s                  0.1201        0.3666        6.0709        0.0000           8682       420        0.5006
   39    1. wdif | eue,m                  -0.1667       -0.0782        1.1104        0.0000           1094        21        0.3524
   39    2. wdif | eue,m                  -0.1236       -0.0782        0.2914       -0.8191           1056        21        0.3524
   39    3. wdif | eue,m                  -0.1684       -0.0782        1.1531        0.0427           1111        21        0.3524
   39    4. wdif | eue,m                  -0.1667       -0.0782        1.1104        0.0000           1094        21        0.3524
   39    5. wdif | eue,m                  -0.1667       -0.0782        1.1104        0.0000           1094        21        0.3524
   40    1. wdif2 | eue,m                  0.1433        0.3524        5.9153        0.0000           1094        21        0.3693
   40    2. wdif2 | eue,m                  0.1031        0.3524        8.4132        2.4979           1056        21        0.3693
   40    3. wdif2 | eue,m                  0.1428        0.3524        5.9448        0.0294           1111        21        0.3693
   40    4. wdif2 | eue,m                  0.1433        0.3524        5.9153        0.0000           1094        21        0.3693
   40    5. wdif2 | eue,m                  0.1433        0.3524        5.9153        0.0000           1094        21        0.3693




September 22 2022


Issues: 
4 types and for each type, the parameters are:
ptypehs   0 for type1 
ptypecol  0 for type1
alf1t
alf2t
cst     0 for type1
mumar   should it be 0 for type1? 

Have been so far normalizing ptype for type 1 to 0. 1 minus thingie. 


Have been so far normalizing cst type1 to 0 but where? 
is it set to 0 in parameters file or params or main or where. Answer: It's 0 in parameters file see bp041019_3.txt
and why is its step not zero? Answer: For no good reason. 
It looks like I've been iterating on it even though its starting value is 0 (set somewhere to be figured out where)
The reason cost for type 1 needs to be normalized to 0 is because I have moveshocks and sigo can't be identified otherwise, right? 


Should we normalize mumar type 1 to 0? 
So far it's been fixed at 375 for all types and I haven't been iterating on it. 
One reason to normalize it would be if we have sigmar, then mumar for one of the types needs ot be normalized to 0, correct? 
But we don't have sigmar. 
AT least we either have sigmove OR sigmar. Right? No. I separated them. I have both nz loops AND nepsmove loop. 
But nz has been aways 1 lately. 
What happens if I increase nz? 


Still need to choose whether to pick bp090922 or bp090922therm. Not sure which one is better. 


was not iterating on ptypes before (for any type) and now will
was not iterating on mumar's before for any type (it was fixed at a nonzero value) and now will 

Why am I doing all this? 
Iterating on ptypes just because. no particular reason. still not sure whether that's the right thing to do or whether to keep them fixed at 0.25 
which is what I had started doing a long time ago


Iterating on mumar for all types just because. Can restrict mumar for type1 to be 0 but that might be too restrictive since already normalizing cst. 
(what's too much would be to keep BOTH cst and mumar for type 1 fixed at 0) 

A reason for iterating on mumar is to try to get the marmove rates higher (if I increase mumar for some types of couples (1,2,3,or 4) AND if I get them to have 
a cst parameter that is positive then married people do move much more.
But since it won't make sense to have ap positive cst, i will just try to rely on sig0. For example for type 3, if mumar is very high and cut is very low (in absolute value but still negative in real value), then maybe a high sign would get them to move sometimes when they get positive moveshocks? 



mom092322_cstpositive_formovemar
This run is with high positive cost values along with high mumar values for one of the types (type 3 in this case) 
The others are left at normal values
The move rates for single and married men can be found below: 

ptypehs              0.25      0.25      0.25      0.25      0.25
ptypecol             0.25      0.25      0.25      0.25      0.25
alf1t                9.58      9.58      9.58      9.58      9.58
alf2t                9.21      9.21      9.21      9.21      9.21
cst                 -1.73     -1.73     -1.73     -1.73     -1.73
mu_mar               0.30      0.30      0.30      0.30      0.30
ptypehs              0.25      0.25      0.25      0.25      0.25
ptypecol             0.25      0.25      0.25      0.25      0.25
alf1t                8.91      8.91      8.91      8.91      8.91
alf2t                8.65      8.65      8.65      8.65      8.65
cst                 -1.94     -1.94   5000.00  10000.00  20000.00
mu_mar               0.30   2000.00   2000.00   2000.00   2000.00
ptypehs              0.25      0.25      0.25      0.25      0.25
ptypecol             0.25      0.25      0.25      0.25      0.25
alf1t                9.56      9.56      9.56      9.56      9.56
alf2t                9.16      9.16      9.16      9.16      9.16
cst                 -1.81     -1.81     -1.81     -1.81     -1.81
mu_mar               0.30      0.30      0.30      0.30      0.30



single male
    2    1. move by age     17             0.0486        0.0000        0.0000        0.0000          13443         0        0.0000
    2    2. move by age     17             0.0450        0.0000        0.0000        0.0000          12908         0        0.0000
    2    3. move by age     17             0.0869        0.0000        0.0000        0.0000          12908         0        0.0000
    2    4. move by age     17             0.1558        0.0000        0.0000        0.0000          12908         0        0.0000
    2    5. move by age     17             0.2664        0.0000        0.0000        0.0000          12908         0        0.0000
    3    1. mv|ned by a     17             0.0486        0.0000        0.0000        0.0000          13443         0        0.0000
    3    2. mv|ned by a     17             0.0450        0.0000        0.0000        0.0000          12908         0        0.0000
    3    3. mv|ned by a     17             0.0869        0.0000        0.0000        0.0000          12908         0        0.0000
    3    4. mv|ned by a     17             0.1558        0.0000        0.0000        0.0000          12908         0        0.0000
    3    5. mv|ned by a     17             0.2664        0.0000        0.0000        0.0000          12908         0        0.0000
    4    1. move by age     18             0.0393        0.0252        0.0081        0.0000          12878       516        0.0246
    4    2. move by age     18             0.0347        0.0252        0.0037       -0.0044          11913       516        0.0246
    4    3. move by age     18             0.0717        0.0252        0.0880        0.0799          11913       516        0.0246
    4    4. move by age     18             0.1299        0.0252        0.4468        0.4387          11913       516        0.0246
    4    5. move by age     18             0.2385        0.0252        1.8523        1.8442          11913       516        0.0246
    5    1. move by age     23             0.0329        0.0691        0.0204        0.0000          21623       666        0.0643
    5    2. move by age     23             0.0360        0.0691        0.0170       -0.0034          18387       666        0.0643
    5    3. move by age     23             0.0474        0.0691        0.0073       -0.0131          18404       666        0.0643
    5    4. move by age     23             0.0811        0.0691        0.0022       -0.0181          18698       666        0.0643
    5    5. move by age     23             0.1705        0.0691        0.1600        0.1396          18464       666        0.0643
    6    1. move by age     28             0.0230        0.0479        0.0135        0.0000          17546       376        0.0456
    6    2. move by age     28             0.0272        0.0479        0.0094       -0.0042          13446       376        0.0456
    6    3. move by age     28             0.0295        0.0479        0.0074       -0.0061          13507       376        0.0456
    6    4. move by age     28             0.0489        0.0479        0.0000       -0.0135          14408       376        0.0456
    6    5. move by age     28             0.1014        0.0479        0.0628        0.0492          13635       376        0.0456
    7    1. move by age     33             0.0223        0.0319        0.0030        0.0000          14677       251        0.0309
    7    2. move by age     33             0.0243        0.0319        0.0019       -0.0011          10710       251        0.0309
    7    3. move by age     33             0.0256        0.0319        0.0013       -0.0017          10792       251        0.0309
    7    4. move by age     33             0.0426        0.0319        0.0037        0.0007          11815       251        0.0309
    7    5. move by age     33             0.0724        0.0319        0.0533        0.0504          11016       251        0.0309
    8    1. move by age     38             0.0203        0.0391        0.0094        0.0000          11942       179        0.0376
    8    2. move by age     38             0.0237        0.0391        0.0063       -0.0030           8530       179        0.0376
    8    3. move by age     38             0.0241        0.0391        0.0060       -0.0034           8613       179        0.0376
    8    4. move by age     38             0.0392        0.0391        0.0000       -0.0094           9581       179        0.0376
    8    5. move by age     38             0.0568        0.0391        0.0084       -0.0010           8813       179        0.0376

married males
  205    1. move by age     17             0.0000        0.0000        0.0000        0.0000              0         0        0.0000
  205    2. move by age     17             0.0000        0.0000        0.0000        0.0000              0         0        0.0000
  205    3. move by age     17             0.0000        0.0000        0.0000        0.0000              0         0        0.0000
  205    4. move by age     17             0.0000        0.0000        0.0000        0.0000              0         0        0.0000
  205    5. move by age     17             0.0000        0.0000        0.0000        0.0000              0         0        0.0000
  206    1. mv|ned by a     17             0.0000        0.0000        0.0000        0.0000              0         0        0.0000
  206    2. mv|ned by a     17             0.0000        0.0000        0.0000        0.0000              0         0        0.0000
  206    3. mv|ned by a     17             0.0000        0.0000        0.0000        0.0000              0         0        0.0000
  206    4. mv|ned by a     17             0.0000        0.0000        0.0000        0.0000              0         0        0.0000
  206    5. mv|ned by a     17             0.0000        0.0000        0.0000        0.0000              0         0        0.0000
  207    1. move by age     18             0.0016        0.0833       17.4979        0.0000            632        12        0.0764
  207    2. move by age     18             0.0034        0.0833       16.7144       -0.7835           1165        12        0.0764
  207    3. move by age     18             0.0739        0.0833        0.2307      -17.2672           1163        12        0.0764
  207    4. move by age     18             0.2527        0.0833       75.1008       57.6029           1112        12        0.0764
  207    5. move by age     18             0.5190        0.0833      496.9674      479.4694           1131        12        0.0764
  208    1. move by age     23             0.0044        0.0466        8.0160        0.0000           3410       279        0.0444
  208    2. move by age     23             0.0037        0.0466        8.2749        0.2589           6178       279        0.0444
  208    3. move by age     23             0.0213        0.0466        2.8717       -5.1443           6139       279        0.0444
  208    4. move by age     23             0.1604        0.0466       58.3504       50.3344           5541       279        0.0444
  208    5. move by age     23             0.5087        0.0466      961.3403      953.3243           6041       279        0.0444
  209    1. move by age     28             0.0004        0.0288        5.7642        0.0000           4825       590        0.0280
  209    2. move by age     28             0.0015        0.0288        5.3368       -0.4274           8739       590        0.0280
  209    3. move by age     28             0.0093        0.0288        2.7328       -3.0313           8640       590        0.0280
  209    4. move by age     28             0.0939        0.0288       30.3093       24.5451           7271       590        0.0280
  209    5. move by age     28             0.4977        0.0288     1571.2158     1565.4516           8419       590        0.0280
  210    1. move by age     33             0.0006        0.0151        2.8162        0.0000           4730       728        0.0149
  210    2. move by age     33             0.0010        0.0151        2.6586       -0.1576           8612       728        0.0149
  210    3. move by age     33             0.0057        0.0151        1.2024       -1.6137           8494       728        0.0149
  210    4. move by age     33             0.0723        0.0151       44.0270       41.2109           7008       728        0.0149
  210    5. move by age     33             0.4934        0.0151     3074.5912     3071.7750           8198       728        0.0149
  211    1. move by age     38             0.0015        0.0129        2.0436        0.0000           4055       699        0.0127
  211    2. move by age     38             0.0020        0.0129        1.8552       -0.1883           7435       699        0.0127
  211    3. move by age     38             0.0070        0.0129        0.5493       -1.4943           7320       699        0.0127
  211    4. move by age     38             0.0559        0.0129       29.1297       27.0861           5957       699        0.0127
  211    5. move by age     38             0.4940        0.0129     3642.8781     3640.8345           7024       699        0.0127

As you can see for cst=5000 the initial move rates at age 18 are indeed high enough (around 7 percent) 
but then at age 23 they are 2 percent adn then 28 they are 0.9 percent and 33 they are around 0.5 percent. 

for cst=10000 the initial move rates at age 18 are very high at 25 percent. But that's the only way to get 
some nonzero like looking move rates for the latter ages. 

Can try values between 5000 and 10000

And also need to play with mumar values (high mumar values for the high positive cst type so that the high positive cst people are the ones who marry)






************************************************************************************************************************************
092422 START
SEPTEMBER 24 2022 
starting from 092422 tag


SEE MOM092422_2 TAG
changed the setting of type parameters and their normalizations. see the
tried to put high and positive cst values for some types
later will also play with mumar so that the types with high mumar also have high positive cost value s
but for now just played with cst values for some types 
we do get finally high move rates for married people when we do this (for some types but overall as well 
You can see this in MOM092422_2 BUT beware that there are some weirded out w ned moments because of calcvar stuff
corrected that because it was just something that was due to me putting wdif moments at top, which come before w ned by type moments 
so the calcvar was messing up with their calculation but only whatever moment comes afterward

**********************
SEE BIG-GETMOM-CHGE 092422 TAG
made big get mom changes
basically got rid of some commented out extra things
put all of them in another file 

Here are some of the potentially useful comments from there
        !ahu summer18 041118: the below getmar by gender and ia was added just to figure out the eps2 problem (why marriage rates were so sensitive to eps2 and 
        !why they were so different by gender). I figured it out now (i.e. the gender disparity in marriage rates go away when I set fem's psio equal to male's
        !but when I was looking at these getmar rates I also noticed the following: 
        !if I am recording age17 rel as 0 and when they make their decision at age 18 I record the rel for age18 as potentiall ymarried
        !but that is not consistent with data is it?
        !ahu jan19 010219: so I am still writing the age 17 (mad) mar rate. age 17 mar rate does not exit in the data since we don't record age 17 rel there. 
        !so the weight on this moment is 0 but then it's wrel for age=mna and age=19
        !do ia=mnad,mnad
        !    call condmom(im,( dat(ia,:)%rel==0 .AND. dat(ia+1,:)%rel>=0   .AND. dat(ia,:)%sexr==1 ), d1*one(dat(ia+1,:)%rel==1),mom,cnt,var)
        !    write(name(im),'("getmarbyia,m  ",tr1,i4)') ia
        !    weights(im)=0.0_dp
        !    im=im+1
        !    call condmom(im,( dat(ia,:)%rel==0 .AND. dat(ia+1,:)%rel>=0   .AND. dat(ia,:)%sexr==2 ), d1*one(dat(ia+1,:)%rel==1),mom,cnt,var)
        !    write(name(im),'("getmarbyia,f  ",tr1,i4)') ia
        !    weights(im)=0.0_dp
        !    im=im+1
        !end do            
    
        !Note about conditioning on age:
        !The max endage in data is 47. 
        !The way sim is done, for those whose endage is 47, the last age where variables get recorded is ia-1=46. 
        !This is because dat(ia-1,.) is recorded for each ia. So for the last age 47, the variables for 46 gets written
        !But then there is nothing after age 46, despite the fact that we do have people whose endage is 46 (namely 47). 

        !call condmom(im,( coho(MNA:MXAD,:) .AND. dat(MNA:MXAD,:)%rel==1  .AND. dat(MNA+1:MXA,:)%rel>=0 .AND. move(MNA:MXAD,:)==0 ), d1*one(dat(MNA+1:MXA,:)%rel==0),mom,cnt,var)
        !write(name(im),'("getdiv | nomv",tr1,i4)') 
        !weights(im)=wrel

                                      

        !ahu jan19 010119: commenting out the below and not doing the nummove by rel moments 
        !this is because for example in data nummove-0 is 0.84 while both nummove_mar and _sin are 0.92 something. 
        !I think the norelchg requirement is the reason. With that requirement it is not clear what these moments mean and 
        !they might be hindering the matching of the move by age moments. For example, there are times when nummove=0 is understated by a whole lot in sim
        !whereas movey age is overstated 
        !call condmom(im,(  cohogen(:)==co ) ,   d1* one( nummove_mar(MXAI,:)==0 ) ,mom,cnt,var)	
        !write(name(im),'("nummove_mar=0 ",tr1)')  
        !weights(im)=wmove
        !im=im+1



  

        !ahu summer18: before the below moments were conditioned on cosexrel instead of just cosex. 
        !I remove the rel conditioning because sometimes these seem to have noone in the cells and they lead to jumpiness 
        !See notes for 042118. 
        !ia=MNAd
        !call condmom(im,( cosex(ia,:) .AND. dat(ia,:)%hhr==0 .AND. dat(ia+1,:)%hhr>=0 ),   d1*one( dat(ia+1,:)%hhr==1 ),mom,cnt,var)		
        !write(name(im),'("e|u by ia",tr5,i2)') ia
        !weights(im)=0.0_dp
        !im=im+1 
        !call condmom(im,( cosex(ia,:) .AND. dat(ia,:)%hhr==0 .AND. dat(ia+1,:)%hhr==1 .AND. dat(ia+1,:)%logwr>=0  ),   d1*dat(ia+1,:)%logwr ,mom,cnt,var)		
        !write(name(im),'("w|u by ia",tr5,i2)') ia
        !weights(im)=0.0_dp 
        !im=im+1 


        !headloc(ihead)=im; headstr(ihead)='Labor market hours by gender/rel/ia';ihead=ihead+1
        !ahu 061211: have to control for ia here because the two brs have different ia compositions
        !ahu 061211: br 2 has no hours/kids/cohmar simultaneously in the biannual years so if you condition on all that you will just get something until they are ia 28 or something (depending on what the br grouping is)
        !ahu 061211: and so if we don't control for ia, it looks as if br 2 females who are cohabiting have decreased their hours of work. but this is just a composition effect.
        !ahu 061211: excluding ia 20 because, something looks weird. br 2 works too few hours at ia 20 (for females,coh,nokid). so then when I include them, it looks as if br 2 coh females with no kids work less in the later br. 
        !do g=1,2
        !   do j=0,1
        !       CALL condmom(im,((dat%co==co).AND.(dat%sexr==g).AND.(dat%rel==j).AND.(dat%hhr>=0).AND.(iacat==1)),dat%hhr,mom,cnt,var)
        !       WRITE(name(im),'("hrs/gender/rel ",2I4)') g,j
        !       weights(im)=whour
        !       im=im+1 
        !   end do 
        !end do

***********************





092422 END 
************************************************************************************************************************************


FROM LOGSO: 







September 25 2022

m092522_3

as you can see from below, cost increases from type 1 to type 4.
in run 1 mumar is low
in run 2 mumar is high
in both the alf1t and alf2ts are 9 for all types

in both runs the mar rates are lower for the high cst types
in run 1 where mumar is low, the move rates for mar men are around 0 for almost all types despite the fact that the cst is high and positive for the higher types
		this is mainly because for higher cost types, the mar rates are nearly 0 so there is no married people for those higher cost types
		so the move rates conditional on mar does not mean much for those higher cost types
in run 2, where mumar is high, the move rates for mar men are indeed higher for higher cost types
so it seems you need a high enough mumar for this cost thing to work (to work for getting high enough move mar rates)


also note that for run1, the mar rates are lower for higher cost types (relative to the lower cost types) 
and for run2 as well, i.e. the mar rates are lower for higher cost types



sig_wge              0.20      0.20
sig_wge              0.20      0.20
sigo_m            3440.09   3440.09
sigo_f            2754.42   2754.42
ptypehs              0.25      0.25
ptypecol             0.25      0.25
alf1t                9.00      9.00
alf2t                9.00      9.00
cst                  0.00      0.00
mu_mar              37.50    375.00
ptypehs              0.25      0.25
ptypecol             0.25      0.25
alf1t                9.00      9.00
alf2t                9.00      9.00
cst               5000.00   5000.00
mu_mar              37.50    375.00
ptypehs              0.25      0.25
ptypecol             0.25      0.25
alf1t                9.00      9.00
alf2t                9.00      9.00
cst               8000.00   8000.00
mu_mar              37.50    375.00
ptypehs              0.25      0.25
ptypecol             0.25      0.25
alf1t                9.00      9.00
alf2t                9.00      9.00
cst              12000.00  12000.00
mu_mar              37.50    375.00
    1    1. mar                            0.2215        0.5890        0.5579        0.0000        1151870     62443        0.2421
    1    2. mar                            0.4880        0.5890        0.0421       -0.5158        1151870     62443        0.2421
    2    1. mar by typ       1             0.6526        0.0000        0.0000        0.0000         285224         0        0.0000
    2    2. mar by typ       1             0.7187        0.0000        0.0000        0.0000         285224         0        0.0000
    3    1. mar by typ       2             0.1593        0.0000        0.0000        0.0000         287849         0        0.0000
    3    2. mar by typ       2             0.5588        0.0000        0.0000        0.0000         287849         0        0.0000
    4    1. mar by typ       3             0.0789        0.0000        0.0000        0.0000         290231         0        0.0000
    4    2. mar by typ       3             0.4153        0.0000        0.0000        0.0000         290231         0        0.0000
    5    1. mar by typ       4             0.0007        0.0000        0.0000        0.0000         288566         0        0.0000
    5    2. mar by typ       4             0.2623        0.0000        0.0000        0.0000         288566         0        0.0000

married men I
   95    1. mv by typ    1                 0.0005        0.0000        0.0000        0.0000          85199         0        0.0000
   95    2. mv by typ    1                 0.0018        0.0000        0.0000        0.0000          94674         0        0.0000
   96    1. mv by typ    2                 0.0007        0.0000        0.0000        0.0000          24466         0        0.0000
   96    2. mv by typ    2                 0.0110        0.0000        0.0000        0.0000          77302         0        0.0000
   97    1. mv by typ    3                 0.0003        0.0000        0.0000        0.0000          13181         0        0.0000
   97    2. mv by typ    3                 0.0286        0.0000        0.0000        0.0000          60138         0        0.0000
   98    1. mv by typ    4                 0.0000        0.0000        0.0000        0.0000             78         0        0.0000
   98    2. mv by typ    4                 0.1461        0.0000        0.0000        0.0000          37473         0        0.0000
   99    1. wdif | hmemve=0                0.2318        0.0753        0.0000        0.0000             36       208        0.1848
   99    2. wdif | hmemve=0                0.0334        0.0753        0.0000        0.0000           2056       208        0.1848
  100    1. wdif | hmemve=1               -0.3642       -0.0608        0.0000        0.0000              1        89        0.1792
  100    2. wdif | hmemve=1                0.0018       -0.0608        0.0000        0.0000            792        89        0.1792
  101    1. wdif | stay                    0.0326        0.0197        0.0000        0.0000         112155     13809        0.1224
  101    2. wdif | stay                    0.0329        0.0197        0.0000        0.0000         239884     13809        0.1224

single men I
   80    1. mv by typ    1                 0.0310        0.0000        0.0000        0.0000          44533         0        0.0000
   80    2. mv by typ    1                 0.0222        0.0000        0.0000        0.0000          33774         0        0.0000
   81    1. mv by typ    2                 0.0693        0.0000        0.0000        0.0000         112785         0        0.0000
   81    2. mv by typ    2                 0.0880        0.0000        0.0000        0.0000          48679         0        0.0000
   82    1. mv by typ    3                 0.1393        0.0000        0.0000        0.0000         126973         0        0.0000
   82    2. mv by typ    3                 0.1646        0.0000        0.0000        0.0000          65211         0        0.0000
   83    1. mv by typ    4                 0.3214        0.0000        0.0000        0.0000         138275         0        0.0000
   83    2. mv by typ    4                 0.3446        0.0000        0.0000        0.0000          81493         0        0.0000
   84    1. wdif | hmemve=0                0.0655        0.0443        0.0000        0.0000          25282       165        0.2325
   84    2. wdif | hmemve=0                0.0594        0.0443        0.0000        0.0000          15550       165        0.2325
   85    1. wdif | hmemve=1                0.0070        0.0750        0.0000        0.0000           4627        70        0.1764
   85    2. wdif | hmemve=1               -0.0039        0.0750        0.0000        0.0000           2781        70        0.1764
   86    1. wdif | stay                    0.0387        0.0460        0.0000        0.0000         302642      5272        0.1430
   86    2. wdif | stay                    0.0435        0.0460        0.0000        0.0000         152591      5272        0.1430

now run a different one with all the same as m0925_3 but with higher mumar for run1: 
because in m092522_3, the mumar of run1 was too low and no one got married especially for the higher cost types so it was hard to tell their move rates conditional on marriage. 


m092522_4
sig_wge              0.20      0.20
sig_wge              0.20      0.20
sigo_m            3440.09   3440.09
sigo_f            2754.42   2754.42
ptypehs              0.25      0.25
ptypecol             0.25      0.25
alf1t                9.00      9.00
alf2t                9.00      9.00
cst                  0.00      0.00
mu_mar             150.00    375.00
ptypehs              0.25      0.25
ptypecol             0.25      0.25
alf1t                9.00      9.00
alf2t                9.00      9.00
cst               5000.00   5000.00
mu_mar             150.00    375.00
ptypehs              0.25      0.25
ptypecol             0.25      0.25
alf1t                9.00      9.00
alf2t                9.00      9.00
cst               8000.00   8000.00
mu_mar             150.00    375.00
ptypehs              0.25      0.25
ptypecol             0.25      0.25
alf1t                9.00      9.00
alf2t                9.00      9.00
cst              12000.00  12000.00
mu_mar             150.00    375.00

everyone
    1    2. mar                            0.4880        0.5890        0.0421       -0.0991        1151870     62443        0.2421
    2    1. mar by typ       1             0.7054        0.0000        0.0000        0.0000         285224         0        0.0000
    2    2. mar by typ       1             0.7187        0.0000        0.0000        0.0000         285224         0        0.0000
    3    1. mar by typ       2             0.4654        0.0000        0.0000        0.0000         287849         0        0.0000
    3    2. mar by typ       2             0.5588        0.0000        0.0000        0.0000         287849         0        0.0000
    4    1. mar by typ       3             0.3241        0.0000        0.0000        0.0000         290231         0        0.0000
    4    2. mar by typ       3             0.4153        0.0000        0.0000        0.0000         290231         0        0.0000
    5    1. mar by typ       4             0.1255        0.0000        0.0000        0.0000         288566         0        0.0000
    5    2. mar by typ       4             0.2623        0.0000        0.0000        0.0000         288566         0        0.0000

single men I                                                                                                            
   80    1. mv by typ    1                 0.0281        0.0000        0.0000        0.0000          35459         0        0.0000
   80    2. mv by typ    1                 0.0222        0.0000        0.0000        0.0000          33774         0        0.0000
   81    1. mv by typ    2                 0.1008        0.0000        0.0000        0.0000          58063         0        0.0000
   81    2. mv by typ    2                 0.0880        0.0000        0.0000        0.0000          48679         0        0.0000
   82    1. mv by typ    3                 0.1970        0.0000        0.0000        0.0000          78769         0        0.0000
   82    2. mv by typ    3                 0.1646        0.0000        0.0000        0.0000          65211         0        0.0000
   83    1. mv by typ    4                 0.3883        0.0000        0.0000        0.0000         110293         0        0.0000
   83    2. mv by typ    4                 0.3446        0.0000        0.0000        0.0000          81493         0        0.0000
   84    1. wdif | hmemve=0                0.0571        0.0443        0.0000        0.0000          22884       165        0.2325
   84    2. wdif | hmemve=0                0.0594        0.0443        0.0000        0.0000          15550       165        0.2325
   85    1. wdif | hmemve=1               -0.0027        0.0750        0.0000        0.0000           3784        70        0.1764
   85    2. wdif | hmemve=1               -0.0039        0.0750        0.0000        0.0000           2781        70        0.1764
   86    1. wdif | stay                    0.0437        0.0460        0.0000        0.0000         177835      5272        0.1430
   86    2. wdif | stay                    0.0435        0.0460        0.0000        0.0000         152591      5272        0.1430


married men I                                                                                                           
   95    1. mv by typ    1                 0.0013        0.0000        0.0000        0.0000          92735         0        0.0000
   95    2. mv by typ    1                 0.0018        0.0000        0.0000        0.0000          94674         0        0.0000
   96    1. mv by typ    2                 0.0051        0.0000        0.0000        0.0000          69125         0        0.0000
   96    2. mv by typ    2                 0.0110        0.0000        0.0000        0.0000          77302         0        0.0000
   97    1. mv by typ    3                 0.0073        0.0000        0.0000        0.0000          51277         0        0.0000
   97    2. mv by typ    3                 0.0286        0.0000        0.0000        0.0000          60138         0        0.0000
   98    1. mv by typ    4                 0.0119        0.0000        0.0000        0.0000          22109         0        0.0000
   98    2. mv by typ    4                 0.1461        0.0000        0.0000        0.0000          37473         0        0.0000
   99    1. wdif | hmemve=0                0.0601        0.0753        0.0000        0.0000            376       208        0.1848
   99    2. wdif | hmemve=0                0.0334        0.0753        0.0000        0.0000           2056       208        0.1848
  100    1. wdif | hmemve=1                0.0177       -0.0608        0.0000        0.0000            220        89        0.1792
  100    2. wdif | hmemve=1                0.0018       -0.0608        0.0000        0.0000            792        89        0.1792
  101    1. wdif | stay                    0.0319        0.0197        0.0000        0.0000         216648     13809        0.1224
  101    2. wdif | stay                    0.0329        0.0197        0.0000        0.0000         239884     13809        0.1224

in this run again the cst varies by type in the same way for both runs.
the only difference between run1 and run2 is mumar. mumar is low for run1 and higher for run2.
as you can see from the above, the mar rate falls with cst (across types the cst vary so the higher types have higher positive costs and they mar rate is lower 
for both runs the cst parameter by type is 0/5K/8K/12K
for run1 the mar rate by type is 70/46/32/12 percent
for run2 the mar rate by type is 71/55/41/26 percent
the interesting thing is: 
MAR RATE OF TYPE 1 IS 70 PERCENT FOR MUMAR=150 AND 71 PERCENT FOR MUMAR=375
ON THE OTHER HAND
MAR RATE OF TYPE 4 IS 12 PERCENT FOR MUMAR=150 AND 26 PERCENT FOR MUMAR=375
so the difference in mar rate between the mumar=150 run and mumar=375 run is higher for higher positive csts (I Wonder if that would be the case for higher negative costs too?)
and this makes a lot of sense because with high positive cost any move is more beneficial so they marry less since when they marry, they are not able to take 
advantage of that benefit as much since then they are not able to move as much. at least I guess thats why. 
STAR INSIGHT STAR INSIGHT STAR INSIGHT TWO STAR INSIGHTS HERE, ONE IS THE ONE ABOVE AND THE OTHER IS:
as you can see, the mv by typ is higher for the second run for each type which means you can get higher move rates for the same cst value if mumar is higher. 
which is better for me since a very high positive cst is hard to justify. but maybe I can still high move mar rates by just increasing mumar for some types. 

m092522_5

alf23                0.00      0.00
sig_wge              0.20      0.20
sig_wge              0.20      0.20
sigo_m            3440.09   3440.09
sigo_f            2754.42   2754.42
ptypehs              0.25      0.25
ptypecol             0.25      0.25
alf1t                9.00      9.00
alf2t                9.00      9.00
cst                  0.00      0.00
mu_mar            2499.98  24979.19
ptypehs              0.25      0.25
ptypecol             0.25      0.25
alf1t                9.00      9.00
alf2t                9.00      9.00
cst               1000.00   1000.00
mu_mar            2499.98  24979.19
ptypehs              0.25      0.25
ptypecol             0.25      0.25
alf1t                9.00      9.00
alf2t                9.00      9.00
cst               1000.00   1000.00
mu_mar            2499.98  24979.19
ptypehs              0.25      0.25
ptypecol             0.25      0.25
alf1t                9.00      9.00
alf2t                9.00      9.00
cst               1000.00   1000.00
mu_mar            2499.98  24979.19

everyone                                                                                                                
    1    1. mar                            0.7637        0.5890        0.1261        0.0000        1151870     62443        0.2421
    1    2. mar                            0.7737        0.5890        0.1410        0.0149        1151870     62443        0.2421
    2    1. mar by typ       1             0.7619        0.0000        0.0000        0.0000         285224         0        0.0000
    2    2. mar by typ       1             0.7717        0.0000        0.0000        0.0000         285224         0        0.0000
    3    1. mar by typ       2             0.7666        0.0000        0.0000        0.0000         287849         0        0.0000
    3    2. mar by typ       2             0.7766        0.0000        0.0000        0.0000         287849         0        0.0000
    4    1. mar by typ       3             0.7629        0.0000        0.0000        0.0000         290231         0        0.0000
    4    2. mar by typ       3             0.7728        0.0000        0.0000        0.0000         290231         0        0.0000
    5    1. mar by typ       4             0.7633        0.0000        0.0000        0.0000         288566         0        0.0000
    5    2. mar by typ       4             0.7739        0.0000        0.0000        0.0000         288566         0        0.0000

married men I                                                                                                           
   64    1. mv by typ    1                 0.0037        0.0000        0.0000        0.0000         102001         0        0.0000
   64    2. mv by typ    1                 0.0041        0.0000        0.0000        0.0000         103665         0        0.0000
   65    1. mv by typ    2                 0.0046        0.0000        0.0000        0.0000         104522         0        0.0000
   65    2. mv by typ    2                 0.0054        0.0000        0.0000        0.0000         106311         0        0.0000
   66    1. mv by typ    3                 0.0044        0.0000        0.0000        0.0000         105836         0        0.0000
   66    2. mv by typ    3                 0.0046        0.0000        0.0000        0.0000         107539         0        0.0000
   67    1. mv by typ    4                 0.0047        0.0000        0.0000        0.0000         103158         0        0.0000
   67    2. mv by typ    4                 0.0054        0.0000        0.0000        0.0000         105120         0        0.0000
   68    1. wdif | hmemve=0                0.1354        0.0753        0.0000        0.0000            768       208        0.1848
   68    2. wdif | hmemve=0                0.0654        0.0753        0.0000        0.0000            820       208        0.1848
   69    1. wdif | hmemve=1                0.0595       -0.0608        0.0000        0.0000            426        89        0.1792
   69    2. wdif | hmemve=1                0.0346       -0.0608        0.0000        0.0000            488        89        0.1792
   70    1. wdif | stay                    0.0328        0.0197        0.0000        0.0000         374488     13809        0.1224
   70    2. wdif | stay                    0.0328        0.0197        0.0000        0.0000         380166     13809        0.1224


single men I                                                                                                            
   94    1. mv by typ    1                 0.0178        0.0000        0.0000        0.0000          28560         0        0.0000
   94    2. mv by typ    1                 0.0173        0.0000        0.0000        0.0000          27438         0        0.0000
   95    1. mv by typ    2                 0.0208        0.0000        0.0000        0.0000          28788         0        0.0000
   95    2. mv by typ    2                 0.0198        0.0000        0.0000        0.0000          27594         0        0.0000
   96    1. mv by typ    3                 0.0198        0.0000        0.0000        0.0000          29263         0        0.0000
   96    2. mv by typ    3                 0.0192        0.0000        0.0000        0.0000          28178         0        0.0000
   97    1. mv by typ    4                 0.0197        0.0000        0.0000        0.0000          29004         0        0.0000
   97    2. mv by typ    4                 0.0190        0.0000        0.0000        0.0000          27676         0        0.0000
   98    1. wdif | hmemve=0                0.2339        0.0443        0.0000        0.0000            512       165        0.2325
   98    2. wdif | hmemve=0                0.2407        0.0443        0.0000        0.0000            449       165        0.2325
   99    1. wdif | hmemve=1                0.0608        0.0750        0.0000        0.0000            225        70        0.1764
   99    2. wdif | hmemve=1                0.0836        0.0750        0.0000        0.0000            188        70        0.1764
  100    1. wdif | stay                    0.0555        0.0460        0.0000        0.0000          79797      5272        0.1430
  100    2. wdif | stay                    0.0574        0.0460        0.0000        0.0000          75557      5272        0.1430


even very high mumar doesnt seem to cut it at least as far as getting high move mar rates goes
the only difference here between the two runs is mumar value 
was trying to see whether I can get away with just a higher mumar instead of a cst value very high (to get move mar right, that is)
although this might also very much depend on other parameters that are not being played around with here (such as alfts or sigwage or sigo etc.) 

nohup /usr/lib64/mpich/bin/mpiexec -np 72 -wdir /home/ec2-user/m092522 /home/ec2-user/m092522/mig.x > /home/ec2-user/m092522/out.txt &



now for the next run, I will change the alf1ts and see how things differ. 
trying both same high values for alts for all types as well as (in a later run) trying different alf2t-alf1t differences across types
for example do they move more when their wages are more similar? 
so make it so that for some types the difference between alf1t and alf2t is higher 


but first the next run is just having different alf1t/alf2t values across types (and between the two runs the values of alf1s are different)

m092522_6
sig_wge              0.20      0.20
sig_wge              0.20      0.20
sigo_m            3440.09   3440.09
sigo_f            2754.42   2754.42
ptypehs              0.25      0.25
ptypecol             0.25      0.25
alf1t                9.00      8.50
alf2t                9.00      8.50
cst                  0.00      0.00
mu_mar           24979.19  24979.19
ptypehs              0.25      0.25
ptypecol             0.25      0.25
alf1t                9.00      9.00
alf2t                9.00      9.00
cst               5000.00   5000.00
mu_mar           24979.19  24979.19
ptypehs              0.25      0.25
ptypecol             0.25      0.25
alf1t                9.00      9.40
alf2t                9.00      9.40
cst               5000.00   5000.00
mu_mar           24979.19  24979.19
ptypehs              0.25      0.25
ptypecol             0.25      0.25
alf1t                9.00      9.80
alf2t                9.00      9.80
cst               5000.00   5000.00
mu_mar           24979.19  24979.19

everyone                                                                                                                
    1    1. mar                            0.7737        0.5890        0.1410        0.0000        1151870     62443        0.2421
    1    2. mar                            0.7737        0.5890        0.1410       -0.0000        1151870     62443        0.2421
    2    1. mar by typ       1             0.7717        0.0000        0.0000        0.0000         285224         0        0.0000
    2    2. mar by typ       1             0.7717        0.0000        0.0000        0.0000         285224         0        0.0000
    3    1. mar by typ       2             0.7766        0.0000        0.0000        0.0000         287849         0        0.0000
    3    2. mar by typ       2             0.7766        0.0000        0.0000        0.0000         287849         0        0.0000
    4    1. mar by typ       3             0.7728        0.0000        0.0000        0.0000         290231         0        0.0000
    4    2. mar by typ       3             0.7728        0.0000        0.0000        0.0000         290231         0        0.0000
    5    1. mar by typ       4             0.7739        0.0000        0.0000        0.0000         288566         0        0.0000
    5    2. mar by typ       4             0.7738        0.0000        0.0000        0.0000         288566         0        0.0000

married men I                                                                                                           
   64    1. mv by typ    1                 0.0041        0.0000        0.0000        0.0000         103665         0        0.0000
   64    2. mv by typ    1                 0.0035        0.0000        0.0000        0.0000         103665         0        0.0000
   65    1. mv by typ    2                 0.0192        0.0000        0.0000        0.0000         106311         0        0.0000
   65    2. mv by typ    2                 0.0192        0.0000        0.0000        0.0000         106311         0        0.0000
   66    1. mv by typ    3                 0.0189        0.0000        0.0000        0.0000         107539         0        0.0000
   66    2. mv by typ    3                 0.0226        0.0000        0.0000        0.0000         107539         0        0.0000
   67    1. mv by typ    4                 0.0199        0.0000        0.0000        0.0000         105120         0        0.0000
   67    2. mv by typ    4                 0.0321        0.0000        0.0000        0.0000         105108         0        0.0000
   68    1. wdif | hmemve=0                0.0469        0.0753        0.0000        0.0000           1883       208        0.1848
   68    2. wdif | hmemve=0                0.0452        0.0753        0.0000        0.0000           3712       208        0.1848
   69    1. wdif | hmemve=1               -0.0174       -0.0608        0.0000        0.0000            998        89        0.1792
   69    2. wdif | hmemve=1               -0.0619       -0.0608        0.0000        0.0000           1284        89        0.1792
   70    1. wdif | stay                    0.0329        0.0197        0.0000        0.0000         376209     13809        0.1224
   70    2. wdif | stay                    0.0328        0.0197        0.0000        0.0000         375440     13809        0.1224
   71    1. w |ned by typ    1             9.4409        0.0000        0.0000        0.0000          52734         0        0.0000
   71    2. w |ned by typ    1             8.9352        0.0000        0.0000        0.0000          52658         0        0.0000
   72    1. w |ned by typ    2             9.4374        0.0000        0.0000        0.0000          54628         0        0.0000
   72    2. w |ned by typ    2             9.4374        0.0000        0.0000        0.0000          54628         0        0.0000
   73    1. w |ned by typ    3             9.4388        0.0000        0.0000        0.0000          55225         0        0.0000
   73    2. w |ned by typ    3             9.8448        0.0000        0.0000        0.0000          55441         0        0.0000
   74    1. w |ned by typ    4             9.4447        0.0000        0.0000        0.0000          53631         0        0.0000
   74    2. w |ned by typ    4            10.2593        0.0000        0.0000        0.0000          54194         0        0.0000
 
married fem I                                                                                                           
   79    1. mv by typ    1                 0.0042        0.0000        0.0000        0.0000         104562         0        0.0000
   79    2. mv by typ    1                 0.0028        0.0000        0.0000        0.0000         104562         0        0.0000
   80    1. mv by typ    2                 0.0303        0.0000        0.0000        0.0000         105214         0        0.0000
   80    2. mv by typ    2                 0.0303        0.0000        0.0000        0.0000         105214         0        0.0000
   81    1. mv by typ    3                 0.0323        0.0000        0.0000        0.0000         104658         0        0.0000
   81    2. mv by typ    3                 0.0277        0.0000        0.0000        0.0000         104658         0        0.0000
   82    1. mv by typ    4                 0.0313        0.0000        0.0000        0.0000         106221         0        0.0000
   82    2. mv by typ    4                 0.0343        0.0000        0.0000        0.0000         106220         0        0.0000
   83    1. wdif | hmemve=0                0.1805       -0.0200        0.0000        0.0000           1052        52        0.1587
   83    2. wdif | hmemve=0                0.2194       -0.0200        0.0000        0.0000           2190        52        0.1587
   84    1. wdif | hmemve=1                0.0374       -0.0348        0.0000        0.0000            806        35        0.1477
   84    2. wdif | hmemve=1               -0.0043       -0.0348        0.0000        0.0000            902        35        0.1477
   85    1. wdif | stay                    0.0357        0.0360        0.0000        0.0000         226633      7157        0.1088
   85    2. wdif | stay                    0.0352        0.0360        0.0000        0.0000         230135      7157        0.1088
   86    1. w |ned by typ    1             9.3631        0.0000        0.0000        0.0000          39540         0        0.0000
   86    2. w |ned by typ    1             8.8557        0.0000        0.0000        0.0000          39222         0        0.0000
   87    1. w |ned by typ    2             9.3520        0.0000        0.0000        0.0000          39596         0        0.0000
   87    2. w |ned by typ    2             9.3520        0.0000        0.0000        0.0000          39596         0        0.0000
   88    1. w |ned by typ    3             9.3627        0.0000        0.0000        0.0000          39230         0        0.0000
   88    2. w |ned by typ    3             9.7695        0.0000        0.0000        0.0000          40312         0        0.0000
   89    1. w |ned by typ    4             9.3446        0.0000        0.0000        0.0000          38755         0        0.0000
   89    2. w |ned by typ    4            10.1758        0.0000        0.0000        0.0000          40677         0        0.0000
  
single men I                                                                                                            
   94    1. mv by typ    1                 0.0173        0.0000        0.0000        0.0000          27438         0        0.0000
   94    2. mv by typ    1                 0.0204        0.0000        0.0000        0.0000          27438         0        0.0000
   95    1. mv by typ    2                 0.0794        0.0000        0.0000        0.0000          27594         0        0.0000
   95    2. mv by typ    2                 0.0794        0.0000        0.0000        0.0000          27594         0        0.0000
   96    1. mv by typ    3                 0.0824        0.0000        0.0000        0.0000          28178         0        0.0000
   96    2. mv by typ    3                 0.0738        0.0000        0.0000        0.0000          28178         0        0.0000
   97    1. mv by typ    4                 0.0775        0.0000        0.0000        0.0000          27676         0        0.0000
   97    2. mv by typ    4                 0.0738        0.0000        0.0000        0.0000          27685         0        0.0000
   98    1. wdif | hmemve=0                0.1731        0.0443        0.0000        0.0000           1060       165        0.2325
   98    2. wdif | hmemve=0                0.2140        0.0443        0.0000        0.0000           1758       165        0.2325
   99    1. wdif | hmemve=1                0.0271        0.0750        0.0000        0.0000            401        70        0.1764
   99    2. wdif | hmemve=1               -0.0133        0.0750        0.0000        0.0000            478        70        0.1764
  100    1. wdif | stay                    0.0575        0.0460        0.0000        0.0000          74320      5272        0.1430
  100    2. wdif | stay                    0.0572        0.0460        0.0000        0.0000          75017      5272        0.1430
  101    1. w |ned by typ    1             9.1421        0.0000        0.0000        0.0000           9875         0        0.0000
  101    2. w |ned by typ    1             8.6350        0.0000        0.0000        0.0000           9781         0        0.0000
  102    1. w |ned by typ    2             9.1276        0.0000        0.0000        0.0000          10441         0        0.0000
  102    2. w |ned by typ    2             9.1276        0.0000        0.0000        0.0000          10441         0        0.0000
  103    1. w |ned by typ    3             9.1331        0.0000        0.0000        0.0000          10392         0        0.0000
  103    2. w |ned by typ    3             9.5409        0.0000        0.0000        0.0000          10529         0        0.0000
  104    1. w |ned by typ    4             9.1333        0.0000        0.0000        0.0000          10097         0        0.0000
  104    2. w |ned by typ    4             9.9540        0.0000        0.0000        0.0000          10482         0        0.0000
 

m092522_7
sig_wge              0.20      0.20
sig_wge              0.20      0.20
sigo_m            3440.09   3440.09
sigo_f            2754.42   2754.42
ptypehs              0.25      0.25
ptypecol             0.25      0.25
alf1t                9.00      9.00
alf2t                9.00      9.00
cst                  0.00      0.00
mu_mar           24979.19  24979.19
ptypehs              0.25      0.25
ptypecol             0.25      0.25
alf1t                9.30      9.30
alf2t                9.30      9.30
cst               5000.00   8000.00
mu_mar           24979.19  24979.19
ptypehs              0.25      0.25
ptypecol             0.25      0.25
alf1t                9.30      9.30
alf2t                8.90      8.90
cst               5000.00   8000.00
mu_mar           24979.19  24979.19
ptypehs              0.25      0.25
ptypecol             0.25      0.25
alf1t                9.30      9.30
alf2t                8.50      8.50
cst               5000.00   8000.00
mu_mar           24979.19  24979.19

 everyone                                                                                                                
    1    1. mar                            0.7737        0.5890        0.1410        0.0000        1151870     62443        0.2421
    1    2. mar                            0.7737        0.5890        0.1410        0.0000        1151870     62443        0.2421
    2    1. mar by typ       1             0.7717        0.0000        0.0000        0.0000         285224         0        0.0000
    2    2. mar by typ       1             0.7717        0.0000        0.0000        0.0000         285224         0        0.0000
    3    1. mar by typ       2             0.7766        0.0000        0.0000        0.0000         287849         0        0.0000
    3    2. mar by typ       2             0.7766        0.0000        0.0000        0.0000         287849         0        0.0000
    4    1. mar by typ       3             0.7728        0.0000        0.0000        0.0000         290231         0        0.0000
    4    2. mar by typ       3             0.7728        0.0000        0.0000        0.0000         290231         0        0.0000
    5    1. mar by typ       4             0.7739        0.0000        0.0000        0.0000         288566         0        0.0000
    5    2. mar by typ       4             0.7739        0.0000        0.0000        0.0000         288566         0        0.0000

married men I                                                                                                           
   64    1. mv by typ    1                 0.0041        0.0000        0.0000        0.0000         103665         0        0.0000
   64    2. mv by typ    1                 0.0041        0.0000        0.0000        0.0000         103665         0        0.0000
   65    1. mv by typ    2                 0.0205        0.0000        0.0000        0.0000         106311         0        0.0000
   65    2. mv by typ    2                 0.0492        0.0000        0.0000        0.0000         106311         0        0.0000
   66    1. mv by typ    3                 0.0175        0.0000        0.0000        0.0000         107539         0        0.0000
   66    2. mv by typ    3                 0.0517        0.0000        0.0000        0.0000         107539         0        0.0000
   67    1. mv by typ    4                 0.0193        0.0000        0.0000        0.0000         105120         0        0.0000
   67    2. mv by typ    4                 0.0647        0.0000        0.0000        0.0000         105120         0        0.0000
   68    1. wdif | hmemve=0                0.0872        0.0753        0.0000        0.0000           2117       208        0.1848
   68    2. wdif | hmemve=0                0.0638        0.0753        0.0000        0.0000           4914       208        0.1848
   69    1. wdif | hmemve=1               -0.0339       -0.0608        0.0000        0.0000           1070        89        0.1792
   69    2. wdif | hmemve=1               -0.0475       -0.0608        0.0000        0.0000           1856        89        0.1792
   70    1. wdif | stay                    0.0327        0.0197        0.0000        0.0000         377049     13809        0.1224
   70    2. wdif | stay                    0.0329        0.0197        0.0000        0.0000         367961     13809        0.1224
   71    1. w |ned by typ    1             9.4409        0.0000        0.0000        0.0000          52734         0        0.0000
   71    2. w |ned by typ    1             9.4409        0.0000        0.0000        0.0000          52734         0        0.0000
   72    1. w |ned by typ    2             9.7404        0.0000        0.0000        0.0000          54868         0        0.0000
   72    2. w |ned by typ    2             9.7345        0.0000        0.0000        0.0000          54387         0        0.0000
   73    1. w |ned by typ    3             9.7444        0.0000        0.0000        0.0000          55419         0        0.0000
   73    2. w |ned by typ    3             9.7397        0.0000        0.0000        0.0000          54586         0        0.0000
   74    1. w |ned by typ    4             9.7505        0.0000        0.0000        0.0000          53948         0        0.0000
   74    2. w |ned by typ    4             9.7449        0.0000        0.0000        0.0000          52572         0        0.0000


single men I                                                                                                            
   94    1. mv by typ    1                 0.0173        0.0000        0.0000        0.0000          27438         0        0.0000
   94    2. mv by typ    1                 0.0173        0.0000        0.0000        0.0000          27438         0        0.0000
   95    1. mv by typ    2                 0.0722        0.0000        0.0000        0.0000          27594         0        0.0000
   95    2. mv by typ    2                 0.1363        0.0000        0.0000        0.0000          27594         0        0.0000
   96    1. mv by typ    3                 0.0798        0.0000        0.0000        0.0000          28178         0        0.0000
   96    2. mv by typ    3                 0.1428        0.0000        0.0000        0.0000          28178         0        0.0000
   97    1. mv by typ    4                 0.0742        0.0000        0.0000        0.0000          27676         0        0.0000
   97    2. mv by typ    4                 0.1338        0.0000        0.0000        0.0000          27676         0        0.0000
   98    1. wdif | hmemve=0                0.1850        0.0443        0.0000        0.0000           1402       165        0.2325
   98    2. wdif | hmemve=0                0.1513        0.0443        0.0000        0.0000           2667       165        0.2325
   99    1. wdif | hmemve=1               -0.0038        0.0750        0.0000        0.0000            471        70        0.1764
   99    2. wdif | hmemve=1               -0.0018        0.0750        0.0000        0.0000            718        70        0.1764
  100    1. wdif | stay                    0.0573        0.0460        0.0000        0.0000          75042      5272        0.1430
  100    2. wdif | stay                    0.0574        0.0460        0.0000        0.0000          73405      5272        0.1430
  101    1. w |ned by typ    1             9.1421        0.0000        0.0000        0.0000           9875         0        0.0000
  101    2. w |ned by typ    1             9.1421        0.0000        0.0000        0.0000           9875         0        0.0000
  102    1. w |ned by typ    2             9.4302        0.0000        0.0000        0.0000          10549         0        0.0000
  102    2. w |ned by typ    2             9.4304        0.0000        0.0000        0.0000          10601         0        0.0000
  103    1. w |ned by typ    3             9.4378        0.0000        0.0000        0.0000          10505         0        0.0000
  103    2. w |ned by typ    3             9.4351        0.0000        0.0000        0.0000          10539         0        0.0000
  104    1. w |ned by typ    4             9.4358        0.0000        0.0000        0.0000          10251         0        0.0000
  104    2. w |ned by typ    4             9.4358        0.0000        0.0000        0.0000          10234         0        0.0000

STAR INSIGHT: wdif is higher with higher alf1ts which makes sense 


starting an opt with onlysingles and some parameters with big steps. changed steps in getpars



*************************
SEPTEMBER 28 2022 (read together with the commit history for this day please. I didnt copy everything here)

See migrepo for the changes of the last couple of days 
But in summary 
I ran some onlysingles opt with pnmead as well as Neldermead0 from 2013. 


Ran Neldermead0 on both china and aws. China stopped. These can be found in optstp files. 
The Neldermead0 run on aws went for about 10 hours and it did change parameters quite a bit (though initially I thought they were not changing that much and so I went back to pnmead since that one has simulated annealing. But you can use both interchangeably and see how things look in comparison. 
> These runs you can find in neldermead0end tag

Note however that the aws objval is slightly different than the china objval 
And when I run pnmead on both, I get opt that looks quite different. I think this is because of the random seed situation but Im not sure. 

IMPORTANT CHECK LATER ISSUES FILE: need to check whether random seed gives very different sequence of random numbers on china vs. aws clusters. 

Note that the Neldermead0 run (in the commit with neldermead0end tag) that I did in the aws cluster was with a Neldermead0 file that is different than the 2013 original (I added something for dp as well as best1 and write best (fntnc2)). I tried adding more comments to it but didnt finish doing this. See branch. 

After the nedlermead0end tag, I started an attempt to add more comments to the neldermead0 file but this attempt is unfinished. 
After that I went back to adding comments to pnmead instead and added a lot of comments. 


Now running an opt in chi with pnmead (with the version that has a lot of comments added). > see tag pnmead-commentsadd-fin


opt issue: does random seed generate different sequences in chi relative to aws?
is that why the objval as well as the  opt files look so different (Especialy for simulated annealing)
writebest issue: this is not really an issue but: in pnmead's new output I checked out more closel
y whats' happening. first of all the therm stuff is too much. need to decrease tstep as well as ts
tstepnext otherwise it'll never get anywhere. because for example, mom.txt is written with an objv
al of 259 (starting value is 500 something, remember this is onlysingles). but when i looked at op
t in the current simplex, 259 is no longer there. Why? Probably becasue with the addition of therm
simp to it, that 259 became (due to random number additions) one of the worst points (even though it's the best so far) and then it got replaced. If you do too much therm addition then you'll get
situations like that. True eventually the algorithm will probably or hopefully find its way back t
here but it'll take a long long time.  
This also reveals taht there's a discrepancy between the mom.txt write whenever there's a best val
ue and the writing of the best values called from pnmead. The latter is an entirely different mons
ter. > See the changes I made to fnctn2 in pnmead and write best in obj and all the other necessary changes that come with those. 



tstart=qval
tstep=0.8
tfreq=2*count(step-in/=zero)
temperature setting issue: the above this is way too much 


Added more arguments to write best:
writebest is called from pnmead and it writes the minvalue of h and the parameters that correspond to it as well as neval,hmean,hstd. 
I also write the parameters (along with moments) that are best so far by calling from within obj. note that this is a different thing than the call of writebest from within pnmead. They should be consistent especially if the temp is low at that point (because sometimes if the temp is high then the good points might be discarded since then htherm will be quite different with respect to h)



pnmeadl close(lout)
this is because in the opt092822tempsmall run, I noticed that there was no output after convergence even though quad=1. i.e. no quadratic surface fitting adn second derivatives output. At this point I had already sent another opt job to chi. Then I realized that the 092822tempsmall job was actuall ystill running. I just didn't see it because there is close(lout) right before quadratic surface fitting starts. It does a lot of function calls at that point so it was still running and writing to fort.6. So then I stopped both jobs and now will send a new one. 

*************************************
SEPTEMBER 29 2022 
MB092822TEMPSMALL this is the onlysingles opt that converged because stopcr=100. copying the wages below to figure out how to change the next init parameters. see after the below. 
155    1. w|1819                         9.1388        9.2422        0.5134        0.0000          16491       410        0.2082
  155    2. w|1819                         9.2016        9.2422        0.0789       -0.4345          17009       410        0.2082
  156    1. wvar|1819                      0.0558        0.2082        0.0033        0.0000          16491       410       69.4327
  156    2. wvar|1819                      0.0690        0.2082        0.0028       -0.0006          17009       410       69.4327
  157    1. w|1819 l    1                  9.2661        9.4171        0.0000        0.0000            510         4        0.0610
  157    2. w|1819 l    1                  9.3493        9.4171        0.0000        0.0000            593         4        0.0610
  158    1. wvar|1819 l    1               0.0566        0.0610        0.0000        0.0000            510         4       22.2003
  158    2. wvar|1819 l    1               0.0626        0.0610        0.0000        0.0000            593         4       22.2003
  159    1. w|1819 l    2                  9.1600        9.1778        0.0131        0.0000           2378        44        0.2405
  159    2. w|1819 l    2                  9.2413        9.1778        0.1678        0.1547           2592        44        0.2405
  160    1. wvar|1819 l    2               0.0513        0.2405        0.0045        0.0000           2378        44       78.8113
  160    2. wvar|1819 l    2               0.0602        0.2405        0.0041       -0.0004           2592        44       78.8113
  161    1. w|1819 l    3                  9.2264        9.3213        0.5464        0.0000           3172        80        0.1649
  161    2. w|1819 l    3                  9.3009        9.3213        0.0251       -0.5213           3418        80        0.1649
  162    1. wvar|1819 l    3               0.0502        0.1649        0.0023        0.0000           3172        80       56.4196
  162    2. wvar|1819 l    3               0.0616        0.1649        0.0019       -0.0004           3418        80       56.4196
  163    1. w|1819 l    4                  9.0929        9.2662        1.5280        0.0000           1952        71        0.1966
  163    2. w|1819 l    4                  9.1651        9.2662        0.5196       -1.0084           2083        71        0.1966
  164    1. wvar|1819 l    4               0.0541        0.1966        0.0030        0.0000           1952        71       66.9712
  164    2. wvar|1819 l    4               0.0650        0.1966        0.0026       -0.0004           2083        71       66.9712
  165    1. w|1819 l    5                  9.0767        9.1424        0.2003        0.0000           3361        48        0.2153
  165    2. w|1819 l    5                  9.0768        9.1424        0.1999       -0.0004           2946        48        0.2153
  166    1. wvar|1819 l    5               0.0498        0.2153        0.0040        0.0000           3361        48       67.9881
  166    2. wvar|1819 l    5               0.0579        0.2153        0.0036       -0.0004           2946        48       67.9881
  167    1. w|1819 l    6                  9.1011        9.1679        0.2612        0.0000           1627        40        0.1708
  167    2. w|1819 l    6                  9.1588        9.1679        0.0049       -0.2563           1724        40        0.1708
  168    1. wvar|1819 l    6               0.0523        0.1708        0.0025        0.0000           1627        40       55.4654
  168    2. wvar|1819 l    6               0.0623        0.1708        0.0021       -0.0004           1724        40       55.4654
  169    1. w|1819 l    7                  9.0789        9.2756        1.7893        0.0000           1471        38        0.2162
  169    2. w|1819 l    7                  9.1376        9.2756        0.8808       -0.9085           1545        38        0.2162
  170    1. wvar|1819 l    7               0.0510        0.2162        0.0037        0.0000           1471        38       74.1590
  170    2. wvar|1819 l    7               0.0612        0.2162        0.0032       -0.0004           1545        38       74.1590
  171    1. w|1819 l    8                  9.0660        9.0982        0.0472        0.0000            751        30        0.2193
  171    2. w|1819 l    8                  9.1182        9.0982        0.0183       -0.0288            743        30        0.2193
  172    1. wvar|1819 l    8               0.0528        0.2193        0.0040        0.0000            751        30       69.2743
  172    2. wvar|1819 l    8               0.0650        0.2193        0.0034       -0.0006            743        30       69.2743
  173    1. w|1819 l    9                  9.2248        9.3315        0.4901        0.0000           1269        55        0.2323
  173    2. w|1819 l    9                  9.3109        9.3315        0.0184       -0.4717           1365        55        0.2323
  174    1. wvar|1819 l    9               0.0521        0.2323        0.0041        0.0000           1269        55       79.5147
  174    2. wvar|1819 l    9               0.0605        0.2323        0.0037       -0.0004           1365        55       79.5147
  

wvar 1819 (the 156 moment) is a good indicator of whether there is enough variation in the loc specific intercepts of alf. 
Need to change those in order to get that right because the vars are too low. 
The vars are also too low within each location at age 1819. This means that sigwge is too low as well. sigwge for males is now 0.2 and it didnt change much in the optimization. 
Because when it increases, then the wdifs increase too much. I think sigwge needs to be lower to get a low wdif. And we instead get wage increase by increasing the experience coefficient. At least thats what I remember. 

BUT why does wdif increase when I increase alft. Shouldnt that cancel out since these are log wage differences?  or DOES wdif increase when I increase alft? NEED TO CHECK THIS. PARAM TRY. 





objval issue
    print*, "mysay etc.", mysay,momwgt(1:10)   !,sum(momwgt(11:50))/nmom,sum(momwgt(51:200))/nmom

	qcont=momwgt*msm_wgt*(momdat-momsim)**2
	objval=sum(qcont) 
	timing(8)=secnds(timing(7))
	timing(9)=secnds(0.0)
	print*, "mysay etc.", mysay,mycos(mysay),mytyps(mysay),myhomes(mysay),sum(momsim)/nmom,objval
    !if (iter==1) print*, 'my name is ',mysay,' and iwritegen is ',iwritegen
	if (iwritegen==1) then ; write(*,'("iter,obj,time: ",i6,f20.2,4f14.2)') iter,objval,timing(2),timing(4),timing(6),timing(8) ; end if  
	!ahu 0317 write(*,'("iter,obj: ",3i6,f20.2,3f14.2)') mygroup,mysay,iter,q,timing(2),timing(4),timing(6)  


	print*, "mysay,momsim,qval", mysay,momsim(50:54),objval

    
    !ag092922 sept2022: note that I got rid of all the if stateements following weights(im) i.e. if(onlysingles and j==1) weights(im)=0.0_dp
    !got rid of them because I don't need them if I have maxrel0 since maxrel0 is set to 1 if onlysingles in the above if statement before the co do loop starts. 
    !this if (onlysingles and j==1) was leading to bugs i.e. different processors would have different momwgt (all else same tho at least)
    !because I wasn't assigning j in the loops for just co or cosex (j is for rel) and when I moved around the moments do loops I forgot that j there 
    !so it was being assigned something different for each processor and they were each gibing different momwgt because of that. 
    !but just get rid of onlysingles if statements after weights(im) since you don't need that anyway (due tot he presence of maxrel)
	cohort: do co=1,nco



STAR INSIGHT
wnedvar for 18 or 18:19 or for all ages within each loc is too low 
wnedvar for 18 or earlier ages comes mostly from sigwge and type > it is too low 
wnedvar for later ages comes mostly from sigwge and type and experience > it is too low
wdif move is not very very high but its also not low enough > so cant increase sigwge
w by age is increasing fine > cant increase experience coefficient
so then need to increase alft variance across types 
thats the only way to increase those wvars without messing up wdif move etc. (type intercepts dont affect wdif move. at least it shouldnt!)
need to nacres ealft variance across types but by how much? and which? 

did some wage ident tries 

see m092922_wageident1 and 2
the wage intercepts 
the issue is what to normalize 
now type 3 alfloc in the wage intercept is normalized to 0 
that gives me the type intercepts 
because otherwise they are not separately ident, right? 
it makes sense? maybe. 
according to a little exercise I Did it looks that way 

consider the following 
4 + 5/5.4 + 2/2.3/2.6  the second term is types and the third term is loc intercepts, say 
now consider 
4 + 3/3.4  + 4/4.3/4/6 
the above are the same exact sums and the var across types is the same between the scenario 1 and scenario 2 so the var within location would not identify these separately I think.

if you normalize one of the locs to 0 that will sort of give an idea about hte mean and var of the type intercepts so it will be a start

in m092922_wageident1 I tried  some different alf1t combos along with also decreasing all the alf10s (even loc 3) and decreasing all alf10s (keeping loc 3 at 0) 
need to look at this run to process. 

and in m092922_wageident2, I tried various alf1ts. they had the following values:
9.6   9.1   9.2   9.3  (alll the 4 runs had these values but which type has which value differed and thats it)
the above are type 1, 2, 3, 4 respectively 
It ddoesnt seem to make a difference where I put the high alf i.e. the 9.6

but the above variance just as is is around 0.2. but when I do the run, the vars within locs are around 0.1
So one way to increase that loc var is to increase the variance across types 
and this can also be seen from thew deciles
right now there are 0 percent people in the high wage deciles 

in m092922_wageident3 I did another run with 9.8 instead of 9.6 (all else same)

now the vars are higher but still not high enough 
the mean wage (nodes) conditional on loc are about right 
wdif move is too high 
wdif stay I dont know 
wdeciles about right

so the one way to increase the var cord on loc is to increase one of the alf1ts even more but that would be too high (higher than 9.8 too high since deciles look ok) 
the other way is to increase sigwge but that will increase wdif moves too much 

wdif moves are too high even wdif home moves 
so then maybe one thing to do is to increase uloc differences across locations (to get wdif moves down? but I am not sure if I ever tried this) and increase sigwage (to increase var conditional on loc) 
or how about sigo?

m092922_wgeident4 
was with 9.8 alts 
and then second run very high sigwge 
and third run very high sigwge (to increase wvar with sigwge) but with high sigo
since a high sigwge gives a high wdif move I tried to balance that out by increasing sigo a lot but it didnt work 
wdif move way too high (it does go down with sigo higher but not enough) and wdif eue,s way too high negative

m092922_wgeident5
was with 9.8 alts 
and then second run very high sigwge 
and third run very high sigwge (to increase wvar with sigwge) but with high loc differentials
since a high sigwge gives a high wdif move I tried to balance that out by increasing uloc differentials a lot but it didnt work 
wdif move way too high and eue,s way too high negative 

m092922_wgeident6
run2 is good. that is with higher alft values for some types adn lower alft for others (and ptype changed so that it has less weight in intermediate values). 
run3 is all of above but with higher sigwge
run2 is with more extreme values for alf1t and ptype's also different (ptype for the intermediate alft value lowered. ptypehs that is). sigwge increasing is just not going to work because it increases wdif move too much. in run2 wdif's look ok AND wvar's are ok too. mean wages seem a bit high though.
run3 was with all of above but with higher sigwge and it didn't work out because it increases wdif a lot. 

*************************************************************************
SEPTEMBER 30 2022 

An opt ran in chi but stopped at naval 370 something 
The objval did improve and things look ok 
The starting point was with ptypes and alf1ts adjusted to get good mean wages, vars and waifs (See the discussion above. al the wgeident runs 
were to find a good initial point for this run). 
The opt for this run is labeled m093022 

Ran the best parameters (so far but stopped) from this run for couples 
see m093022_mar for those moments
The objval is much higher for bp093022 relative to the starting point
For example single men emp transition rates ee move seems to be way too low here. even though in the singles run they are fine. 
I think this is because the marriage rates are way too high (because mummars for all types were very high) and the ee move single men moment is picking up 
the fact that ee move is different by age (or whatever it is, it is about the marriage rates causing these moments to not look good). 
STAR INSIGHT STAR INSIGHT (its what I just said, the star insight is, that is). 


so now try with lower mumar's for some of the types (especially type 1-3 but not 4 since thats the one with high positive cst for move)
this is m093022_mar2:
it worked! the mar rates are lower (though not low enough at all) and the single men emp trans rates are back up! so my hypo was correct! 


by the way for fem wages: 
forgot to normalize one of the location intercept 
normalize loc 3 intercept to 0 (which is fine because that param is 0.09 now and the loc 3 mean wage moment look too high now) 
and her loc 5 alf20 needs to increase by like 0.15 or so (wned at age 18:19 is too low) 
and also for fems the wvar moments too low so play around with alf2t or sigwge or intercepts or something 


fro mm093022 (onlysingles):
as you can see below ,
wvar noed (200) is too low 
wvarned|1819 (76)  is too low as well 
wvarned|18:19 by loc9 (86)  is too low as well     
wvarned|20:25 by loc9  (88) is too low as well 
(note  80    1. wvarned|18:19 by loc   1   is low but its low in the data too but that doesnt mean anything because its only 11 people in data)
so increasing loc intercept variance (alf20) will not help 
one thing to do would be to increase the experience coefficient but fem wages by age already increase too much (see by age moments) 
the only thing to do seems to be to increase the alf2t variance across types 
put a higher alf2t for one of the types since that will also help with getting some women in the higher deciles (see wdecile for fem)
increasing sigwge will hep with these variance moments but then that will increase wdif move for her a lot and its already too high 
STAR INSIGHT STAR INSGIHT 
note that wdif move for fem is too high BUT its actually low for age 18  and wdif move only increases way too much for all later ages (look at wdif by ia). 
why? 
also note that in first run wdif move age 18 was also high and the opt brought it down but could not bring it down for later ages 
why? 
this is probably because those age 18 moves are home moves. and the opt increased her homemove utility so the wdif when she moves home is much lower now 
but this doesnt help the wdif for the later moves 
how do I bring wdif for later moves down? the same problem is also there for single men but in the model moments they dont change as 
drastically as they do for fem model moments wdif move by ia. in single men case they are just consistently high for all ages (whereas in data they are negative!) 
The only way to get around that problem has to be the uloc differentials but I am not sure. I tried this before and it didnt really work. 
maybe look at prop of moves to and from by loc and see which ones you can adjust 



single fem wages                                                                                                        
  199    1. w|noed                                          9.3503        9.3127        0.0579        0.0000         193735     10134        0.2442
  199    2. w|noed                                          9.3338        9.3127        0.0182       -0.0396         196472     10134        0.2442
  200    1. wvar|noed                                       0.1277        0.2442        0.0016        0.0000         193735     10134       83.2196
  200    2. wvar|noed                                       0.1247        0.2442        0.0017        0.0001         196472     10134       83.2196
  203    1. wdif | hmemve=0                                 0.3409        0.0040       26.4022        0.0000           4019       234        0.2150
  203    2. wdif | hmemve=0                                 0.2658        0.0040       15.9377      -10.4645           1816       234        0.2150
  204    1. wdif | hmemve=1                                 0.0169        0.0844        1.3635        0.0000           1033       123        0.1673
  204    2. wdif | hmemve=1                                -0.1625        0.0844       18.2222       16.8587            503       123        0.1673
  205    1. wdif | stay                                     0.0367        0.0395        0.0037        0.0000         271721     16724        0.1044
  205    2. wdif | stay                                     0.0384        0.0395        0.0006       -0.0031         276239     16724        0.1044
  206    1. wdif2 | stay                                    0.0105        0.1044        4.3076        0.0000         271721     16724        0.1024
  206    2. wdif2 | stay                                    0.0110        0.1044        4.2609       -0.0467         276239     16724        0.1024
  207    1. wdif | move                                     0.2747        0.0317       14.7575        0.0000           5052       357        0.2000
  207    2. wdif | move                                     0.1729        0.0317        4.9829       -9.7746           2319       357        0.2000
  208    1. wdif2 | move                                    0.1302        0.2000        1.2086        0.0000           5052       357        0.2018
  208    2. wdif2 | move                                    0.1493        0.2000        0.6364       -0.5722           2319       357        0.2018
  209    1. wdif | eue,s                                   -0.1024       -0.0127        1.3676        0.0000           3264       694        0.2944
  209    2. wdif | eue,s                                   -0.0916       -0.0127        1.0586       -0.3090           3533       694        0.2944
  210    1. wdif2 | eue,s                                   0.1391        0.2944        4.3135        0.0000           3264       694        0.2793
  210    2. wdif2 | eue,s                                   0.1348        0.2944        4.5604        0.2469           3533       694        0.2793
  211    1. wdif | eue,m                                   -0.1036       -0.1054        0.0005        0.0000            338        25        0.3062
  211    2. wdif | eue,m                                   -0.0497       -0.1054        0.5070        0.5065            206        25        0.3062
  212    1. wdif2 | eue,m                                   0.1679        0.3062        3.9413        0.0000            338        25        0.2427
  212    2. wdif2 | eue,m                                   0.1447        0.3062        5.3744        1.4331            206        25        0.2427
  213    1. wdif | stay ia       18                         0.0552        0.0365        0.0866        0.0000           1899        88        0.2016
  213    2. wdif | stay ia       18                         0.0604        0.0365        0.1409        0.0543           1967        88        0.2016
  214    1. wdif | stay ia       28                         0.0447        0.0656        0.2027        0.0000          11715       626        0.1080
  214    2. wdif | stay ia       28                         0.0464        0.0656        0.1699       -0.0328          11844       626        0.1080
  215    1. wdif | stay ia       38                         0.0290        0.0149        0.0899        0.0000           9639       584        0.1107
  215    2. wdif | stay ia       38                         0.0309        0.0149        0.1153        0.0254           9768       584        0.1107
  216    1. wdif | stay ia       48                         0.0214        0.0167        0.0147        0.0000           5880       496        0.0729
  216    2. wdif | stay ia       48                         0.0222        0.0167        0.0208        0.0061           5937       496        0.0729
  217    1. wdif | move ia       18                         0.3168       -0.4444        0.0000        0.0000             24         3        0.4831
  217    2. wdif | move ia       18                         0.0267       -0.4444        0.0000        0.0000             12         3        0.4831
  218    1. wdif | move ia       28                         0.2502        0.0108       22.8264        0.0000            222        14        0.1256
  218    2. wdif | move ia       28                         0.1225        0.0108        4.9719      -17.8545            104        14        0.1256
  219    1. wdif | move ia       38                         0.3021        0.0183        0.0000        0.0000            175         6        0.0837
  219    2. wdif | move ia       38                         0.2248        0.0183        0.0000        0.0000             82         6        0.0837
  220    1. wdif | move ia       48                         0.1977        0.1178        0.0000        0.0000            158         3        0.0132
  220    2. wdif | move ia       48                         0.1926        0.1178        0.0000        0.0000            116         3        0.0132

all fem w and wvar at 18 and 18:19 .. for ident                                                                         
   73    1. wnned|18 small samp size!                       9.0263        9.0049        0.0000        0.0000           2131       129        0.2125
   73    2. wnned|18 small samp size!                       9.0071        9.0049        0.0000        0.0000           2202       129        0.2125
   74    1. wvarned|18 small samp size!                     0.0910        0.2125        0.0000        0.0000           2131       129       70.0171
   74    2. wvarned|18 small samp size!                     0.0898        0.2125        0.0000        0.0000           2202       129       70.0171
   75    1. wnned|1819                                      9.0432        9.0268        0.0136        0.0000           5925       326        0.1984
   75    2. wnned|1819                                      9.0229        9.0268        0.0008       -0.0128           6072       326        0.1984
   76    1. wvarned|1819                                    0.0915        0.1984        0.0018        0.0000           5925       326       64.0170
   76    2. wvarned|1819                                    0.0894        0.1984        0.0019        0.0001           6072       326       64.0170
   77    1. wned|18 by loc small!   1                       9.2122        9.1617        0.0000        0.0000             89         5        0.1478
   77    2. wned|18 by loc small!   1                       9.1796        9.1617        0.0000        0.0000             91         5        0.1478
   78    1. wvarned|18 by loc small!   1                    0.1056        0.1478        0.0000        0.0000             89         5       48.5446
   78    2. wvarned|18 by loc small!   1                    0.1031        0.1478        0.0000        0.0000             91         5       48.5446
   79    1. wned|18:19 by loc   1                           9.2286        9.1938        0.1377        0.0000            214        11        0.0880
   79    2. wned|18:19 by loc   1                           9.1864        9.1938        0.0063       -0.1314            224        11        0.0880
   80    1. wvarned|18:19 by loc   1                        0.1141        0.0880        0.0002        0.0000            214        11       29.0151
   80    2. wvarned|18:19 by loc   1                        0.1073        0.0880        0.0001       -0.0001            224        11       29.0151
   81    1. wned|20:25 by loc   1                           9.3551        9.3409        0.0154        0.0000           1189        54        0.1307
   81    2. wned|20:25 by loc   1                           9.3089        9.3409        0.0785        0.0631           1505        54        0.1307
   82    1. wvarned|20:25 by loc   1                        0.1084        0.1307        0.0001        0.0000           1189        54       43.0319
   82    2. wvarned|20:25 by loc   1                        0.0936        0.1307        0.0003        0.0002           1505        54       43.0319
   83    1. wned|18 by loc small!   9                       9.1000        9.0139        0.0000        0.0000            194        18        0.1960
   83    2. wned|18 by loc small!   9                       9.0702        9.0139        0.0000        0.0000            202        18        0.1960
   84    1. wvarned|18 by loc small!   9                    0.1002        0.1960        0.0000        0.0000            194        18       65.0524
   84    2. wvarned|18 by loc small!   9                    0.0940        0.1960        0.0000        0.0000            202        18       65.0524
   85    1. wned|18:19 by loc   9                           9.1211        9.0439        0.2930        0.0000            504        41        0.2035
   85    2. wned|18:19 by loc   9                           9.0895        9.0439        0.1022       -0.1907            535        41        0.2035
   86    1. wvarned|18:19 by loc   9                        0.0988        0.2035        0.0016        0.0000            504        41       66.9540
   86    2. wvarned|18:19 by loc   9                        0.0883        0.2035        0.0020        0.0003            535        41       66.9540
   87    1. wned|20:25 by loc   9                           9.2271        9.2945        0.2203        0.0000           3098       227        0.2061
   87    2. wned|20:25 by loc   9                           9.2114        9.2945        0.3356        0.1153           3335       227        0.2061
   88    1. wvarned|20:25 by loc   9                        0.1000        0.2061        0.0016        0.0000           3098       227       69.6596
   88    2. wvarned|20:25 by loc   9                        0.0998        0.2061        0.0016        0.0000           3335       227       69.6596
   89    1. wdif | stay                                     0.0367        0.0395        0.0037        0.0000         271721     16724        0.1044
   89    2. wdif | stay                                     0.0384        0.0395        0.0006       -0.0031         276239     16724        0.1044
   90    1. wdif | move                                     0.2747        0.0317       14.7575        0.0000           5052       357        0.2000
   90    2. wdif | move                                     0.1729        0.0317        4.9829       -9.7746           2319       357        0.2000
   91    1. wdif | eue,s                                   -0.1024       -0.0127        1.3676        0.0000           3264       694        0.2944
   91    2. wdif | eue,s                                   -0.0916       -0.0127        1.0586       -0.3090           3533       694        0.2944
   92    1. wdif | eue,m                                   -0.1036       -0.1054        0.0005        0.0000            338        25        0.3062
   92    2. wdif | eue,m                                   -0.0497       -0.1054        0.5070        0.5065            206        25        0.3062
   93    1. wned|18:19 by loc   1                           9.2286        9.1938        0.1377        0.0000            214        11        0.0880
   93    2. wned|18:19 by loc   1                           9.1864        9.1938        0.0063       -0.1314            224        11        0.0880
   94    1. wned|18:19 by loc   2                           9.0543        9.0588        0.0010        0.0000            930        32        0.2168
   94    2. wned|18:19 by loc   2                           9.0548        9.0588        0.0007       -0.0002           1012        32        0.2168
   95    1. wned|18:19 by loc   3                           9.1134        9.0276        0.3083        0.0000           1079        70        0.2391
   95    2. wned|18:19 by loc   3                           9.0934        9.0276        0.1811       -0.1272           1151        70        0.2391
   96    1. wned|18:19 by loc   4                           8.9976        8.9704        0.0408        0.0000            641        36        0.1809
   96    2. wned|18:19 by loc   4                           8.9780        8.9704        0.0031       -0.0376            693        36        0.1809
   97    1. wned|18:19 by loc   5                           8.9918        9.1336        0.8965        0.0000           1147        46        0.2244
   97    2. wned|18:19 by loc   5                           8.9550        9.1336        1.4218        0.5252            958        46        0.2244
   98    1. wned|18:19 by loc   6                           9.0240        9.0132        0.0207        0.0000            648        33        0.0567
   98    2. wned|18:19 by loc   6                           9.0026        9.0132        0.0200       -0.0006            700        33        0.0567
   99    1. wned|18:19 by loc   7                           8.9491        8.8501        0.4045        0.0000            576        30        0.2423
   99    2. wned|18:19 by loc   7                           8.9291        8.8501        0.2579       -0.1466            619        30        0.2423
  100    1. wned|18:19 by loc   8                           8.9885        9.0054        0.0199        0.0000            186        26        0.1440
  100    2. wned|18:19 by loc   8                           8.9282        9.0054        0.4137        0.3938            180        26        0.1440
  101    1. wned|18:19 by loc   9                           9.1211        9.0439        0.2930        0.0000            504        41        0.2035
  101    2. wned|18:19 by loc   9                           9.0895        9.0439        0.1022       -0.1907            535        41        0.2035


m093022_magic:
OMG IT WORKED!
BASED ON THE ABOVE DISCUSSION, AFTER THE LAST RUN (M093022_MAR2) I INCREASED SIGO FOR BOTH MALES AND FEMALES BY A LOT. TO 200K. AND IT WORKED! 
look at tag m093022_mar2 and m093022_magic to see the difference (note that the other difference is also that I normalized fem loc3 alf20 to 0 in get pars but this is nothing)
IT WORKED!       STAR INSIGHT STAR INSIGHT 
WHAT WORKED 
WDIF MOVE ACTUALLY WENT DOWN A LOT 
IT 
WENT 
DOWN 

FOR EXAMPLE FOR SINGLE MALES WDIF MOVE BY IA IS ACTUALLY NEGATIVE NOW JUST LIKE IN THE DATA. 
FOR MARRIED MEN WDIF MVE BY IA IS NOT NEGATIVE BUT IT WENT DOWN A LOT FOR EACH AGE. PLUS THEIR OVERALL WDIF MOVE LOOKS JUST RIGHT. CAN IGNORE THE IA THING BUT MAYBE NOT. 

BUT NOW THE MOVE RATES ARE UP BY A LOT. AND EE MVOE AND EU MOVE ARE TOO LOW. 
MAYBE TRY INCREASING COST OF MOVE AND SEE WHAT THAT DOES. SINCE THATS A ONE TIME THING MAYBE IT WONT AFFECT THINGS THAT MUCH. 

ALSO THE OVERALL MAR RATE WENT DOWN TO 50 STH PERCENT. BUT THE GETMAR BY IA RATES ARE WAY TOO HIGH AND GETDIV RATES ARE TOO HIGH. 
GET MAR RATES WERE HIGH BEFORE AS WELL. 
BUT GETDIV RATES INCREASED WITH THE INCREASE OF SIGO > THIS MAKES SENSE! > STAR INSIGHT! 

BY THE WAY, SOME OF THE WAGE AND EMP MOMENTS (CONDITIONAL ON RELSTAT) MIGHT BE OFF BECAUSE THESE GETMAR AND GETDIV RATES ARE NOT RIGHT -> STAR INSIGHT

NOW THE QUESTION IS WHAT HAPPENS WHEN I INCREASE CST FOR SOME TYPES? 



m093022_magic2
did sigo 100K (lower than 200K of the prev run but still very high) 
and high costs (in absval) for all types (including type 4). 
in the second run, the cost was even higher in absval 
between first and second run, 
move rates did go down 
wdif move rates did not go back up 
mar rates changed too, they increased from run1 to run2 (which makes sense 


m093022_magic3
less high sigo and even higher cst in absval (all typ)
this seems better but need to take care of the getmar rates to see what's actually happenign with other moments conditional on relstat
div rates are ok now (in the second run where cst is higher) 
get mar rates too high (so overall mar rates too high as well) 

decrease pmeet? 












---------------


Week 1 - ENROLLMENT WEEK 
Week 2 - September 27 - Klaus
Week 3 - October 4 - Klaus
Week 4 - October 11 - Klaus
Week 5 - October 18 - Klaus
Week 6 - October 25 - Klaus
Week 7 - READING WEEK
Week 8 - November 8 - Ahu 
Week 9 - November 15 - Ahu 
Week 10 - November 22 - Ahu 
Week 11 - November 29 - Ahu 
Week 12 - December 6 - Ahu 
-------


